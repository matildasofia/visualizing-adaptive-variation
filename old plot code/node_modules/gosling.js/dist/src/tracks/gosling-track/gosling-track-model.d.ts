import type { ChannelDeep, ChannelTypes, SingleTrack } from '@gosling-lang/gosling-schema';
import { type ScaleLinear, type ScaleOrdinal, type ScaleBand, type ScaleSequential } from 'd3-scale';
import type { PIXIVisualProperty } from '../../core/visual-property.schema';
import { type CompleteThemeDeep } from '../../core/utils/theme';
import { MouseEventModel } from '../gosling-track/gosling-mouse-event';
export type ScaleType = ScaleLinear<any, any> | ScaleOrdinal<any, any> | ScaleBand<any> | ScaleSequential<any> | (() => string | number);
export declare class GoslingTrackModel {
    private id;
    private theme;
    private specOriginal;
    private specComplete;
    private dataOriginal;
    private dataAggregated;
    private channelScales;
    private mouseEventModel;
    constructor(spec: SingleTrack, data: {
        [k: string]: number | string;
    }[], theme: Required<CompleteThemeDeep>);
    getId(): string;
    originalSpec(): SingleTrack;
    spec(): SingleTrack;
    data(): {
        [k: string]: number | string;
    }[];
    getMouseEventModel(): MouseEventModel;
    /**
     * Fill the missing options with default values or with the values calculated based on the data.
     */
    private generateCompleteSpec;
    /**
     * TODO: This is experimental. For bar charts, for example, additional care should be taken to correctly flip the visual marks.
     * Flip the y scales when `flip` options is used.
     */
    private flipRanges;
    /**
     * Find an axis channel that is encoded with genomic coordinate and return the key (e.g., 'x').
     * `undefined` if not found.
     */
    getGenomicChannelKey(): 'x' | 'xe' | 'y' | 'ye' | 'x1' | 'x1e' | 'y1' | 'y1e' | undefined;
    /**
     * Find a genomic field from the track specification.
     * `undefined` if not found.
     */
    getGenomicChannel(): ChannelDeep | undefined;
    /**
     * Replace a domain with a new one in the complete spec(s) if the original spec does not define the domain.
     * A domain is replaced only when the channel is bound with data (i.e., `ChannelDeep`).
     */
    setChannelDomain(channelKey: keyof typeof ChannelTypes, domain: string[] | number[], force?: boolean): void;
    /**
     * Update default constant values by looking up other channels' scales.
     */
    updateChannelValue(): void;
    /**
     * Get the encoded value using the scales already constructed.
     */
    encodedValue(channelKey: keyof typeof ChannelTypes, value?: number | string): any;
    trackVisibility(currentStage: {
        zoomLevel?: number;
    }): boolean;
    /**
     * Check whether the visual mark should be visible or not.
     * Return 0 (invisible) only when the predefined condition is correct.
     */
    markVisibility(datum: {
        [k: string]: string | number;
    }, metrics?: any): number;
    /**
     *
     */
    visualPropertyByChannel(channelKey: keyof typeof ChannelTypes, datum?: {
        [k: string]: string | number;
    }): any;
    /**
     * Retrieve an encoded visual property of a visual mark.
     */
    encodedPIXIProperty(propertyKey: PIXIVisualProperty, datum?: {
        [k: string]: string | number;
    }, additionalInfo?: any): any;
    /**
     * Set missing `range`, `domain`, and/or `value` of each channel by looking into data.
     */
    addScaleMaterials(spec: SingleTrack): void;
    /**
     * Store the scale of individual visual channels based on the `complete` spec.
     */
    generateScales(): void;
    /**
     * Return the scale of a visual channel.
     * `undefined` if we do not have the scale.
     */
    getChannelScale(channelKey: keyof typeof ChannelTypes): ScaleType;
    /**
     * Set a new scale for a certain channel. Usually called to replace the scale of a genomic axis with the one that is generated by the HiGlass data fetcher.
     */
    setChannelScale(channelKey: keyof typeof ChannelTypes, scale: ScaleType): void;
    /**
     * Return whether to show y-axis.
     */
    isShowYAxis(): boolean;
    /**
     * Return the domain of a visual channel.
     * `undefined` if we do not have domain in array.
     */
    getChannelDomainArray(channelKey: keyof typeof ChannelTypes): string[] | number[] | undefined;
    /**
     * Return the range of a visual channel.
     * `undefined` if we do not have domain in array.
     */
    getChannelRangeArray(channelKey: keyof typeof ChannelTypes): string[] | number[] | undefined;
    /**
     * Validate the original spec.
     */
    validateSpec(): {
        valid: boolean;
        errorMessages: string[];
    };
}
//# sourceMappingURL=gosling-track-model.d.ts.map