var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _dataPromise, _chromSizes, _parsedData, _assembly, _filter, _file, _fetchCsv, fetchCsv_fn, _processCsvRow, processCsvRow_fn, _calcCumulativePos, calcCumulativePos_fn, _generateTilesetInfo, generateTilesetInfo_fn, _tile, tile_fn, _generateChomSizeInfo, generateChomSizeInfo_fn, _table;
import * as PIXI from "pixi.js";
import { color } from "d3-color";
import { group, max, min, bisector, sum } from "d3-array";
import { Bezier } from "bezier-js";
import { scaleLinear, scaleSequential, scaleOrdinal, scaleBand } from "d3-scale";
import { isUndefined, sampleSize, isEqual, uniqBy, cloneDeepWith } from "lodash-es";
import { interpolateViridis, interpolateGreys, interpolateWarm, interpolateSpectral, interpolateCividis, interpolateBuPu, interpolateRdBu, interpolateYlOrBr, interpolateRdPu } from "d3-scale-chromatic";
import higlassRegister from "higlass-register";
import { TextTrack } from "higlass-text";
import RBush from "rbush";
import { arc } from "d3-shape";
import { createNanoEvents } from "nanoevents";
import { spawn } from "threads";
import { Buffer as Buffer2 } from "buffer";
import QuickLRU from "quick-lru";
import { RemoteFile as RemoteFile$1, LocalFile } from "generic-filehandle";
import { dsvFormat } from "d3-dsv";
import * as gt from "gosling-theme";
import { getTheme as getTheme$1 } from "gosling-theme";
import PubSub$1 from "pubsub-js";
import React, { forwardRef, useState, useEffect, useMemo, useRef, useImperativeHandle, useCallback } from "react";
import require$$0 from "react-dom";
import { HiGlassComponent } from "higlass";
import { ResizeSensor } from "css-element-queries";
const name = "gosling.js";
const version = "0.12.0";
const DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM = 6;
const DEFAULT_TRACK_HEIGHT_LINEAR = 130;
const DEFAULT_TRACK_WIDTH_LINEAR = 600;
const DEFAULT_TRACK_SIZE_2D = 600;
const DEFAULT_VIEW_SPACING = 10;
const DEFAULT_INNER_RADIUS_PROP = 0.3;
const DEFAULT_CIRCULAR_VIEW_PADDING = 0;
const DEFAULT_BACKUP_COLOR = "gray";
const colorToHex = (colorStr) => {
  let c = color(colorStr);
  if (!c) {
    c = color(DEFAULT_BACKUP_COLOR);
  }
  const hex = PIXI.utils.rgb2hex([c.rgb().r / 255, c.rgb().g / 255, c.rgb().b / 255]);
  return hex;
};
const RADIAN_GAP = 0;
function valueToRadian(v, max2, sa, ea, g) {
  const safeVal = Math.max(Math.min(max2, v), 0);
  const gap = g != null ? g : RADIAN_GAP;
  const radExtent = (ea - sa) / 360 * Math.PI * 2 - gap * 2;
  const radStart = sa / 360 * Math.PI * 2;
  return -(radStart + safeVal / max2 * radExtent) - Math.PI / 2 - gap;
}
function cartesianToPolar(x, max2, r, cx, cy, sa, ea) {
  return {
    x: cx + r * Math.cos(valueToRadian(x, max2, sa, ea)),
    y: cy + r * Math.sin(valueToRadian(x, max2, sa, ea))
  };
}
function positionToRadian(x, y, cx, cy) {
  if (cx <= x) {
    return Math.atan((y - cy) / (x - cx));
  } else {
    return Math.atan((y - cy) / (x - cx)) - Math.PI;
  }
}
function pointsToDegree(x, y, cx, cy) {
  return (Math.atan2(-(y - cy), x - cx) / Math.PI * 180 + 270) % 360;
}
function drawPoint(track, g, model) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      const cx = model.encodedPIXIProperty("x-center", d);
      const cy = model.encodedPIXIProperty("y-center", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const radius = model.encodedPIXIProperty("p-size", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      const alphaTransition = model.markVisibility(d, { width: radius, zoomLevel });
      const actualOpacity = Math.min(alphaTransition, opacity);
      if (radius <= 0.1 || actualOpacity === 0 || cx + radius < 0 || cx - radius > trackWidth) {
        return;
      }
      g.lineStyle(
        strokeWidth,
        colorToHex(stroke),
        actualOpacity,
        // alpha
        1
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      if (circular) {
        const r = trackOuterRadius - (rowPosition + rowHeight - cy) / trackHeight * trackRingSize;
        const pos = cartesianToPolar(cx, trackWidth, r, tcx, tcy, startAngle, endAngle);
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawCircle(pos.x, pos.y, radius);
        model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, radius]);
      } else {
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawCircle(cx, rowPosition + rowHeight - cy, radius);
        model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - cy, radius]);
      }
    });
  });
}
function pointProperty(model, propertyKey, datum) {
  const xe = model.visualPropertyByChannel("xe", datum);
  const x = model.visualPropertyByChannel("x", datum);
  const size = model.visualPropertyByChannel("size", datum);
  switch (propertyKey) {
    case "x-center":
      return xe ? (xe + x) / 2 : x;
    case "y-center": {
      const ye = model.visualPropertyByChannel("ye", datum);
      const y = model.visualPropertyByChannel("y", datum);
      return ye ? (ye + y) / 2 : y;
    }
    case "p-size":
      return xe && model.spec().stretch ? (xe - x) / 2 : size;
    default:
      return void 0;
  }
}
function drawLine(g, model, trackWidth, trackHeight) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const trackCenterX = trackWidth / 2;
  const trackCenterY = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const colorCategories = (_f = model.getChannelDomainArray("color")) != null ? _f : ["___SINGLE_COLOR___"];
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    colorCategories.forEach((colorCategory) => {
      data2.filter(
        (d) => (!getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory) && (!getValueUsingChannel(d, spec.color) || getValueUsingChannel(d, spec.color) === colorCategory)
      ).sort(
        (d1, d2) => (
          // draw from the left to right
          getValueUsingChannel(d1, spec.x) - getValueUsingChannel(d2, spec.x)
        )
      ).forEach((d, i) => {
        const cx = model.encodedPIXIProperty("x", d);
        const y = model.encodedPIXIProperty("y", d);
        const size = model.encodedPIXIProperty("size", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        g.lineStyle(
          size,
          colorToHex(color2),
          opacity,
          0.5
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        if (circular) {
          const r = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const pos = cartesianToPolar(
            cx,
            trackWidth,
            r,
            trackCenterX,
            trackCenterY,
            startAngle,
            endAngle
          );
          if (i === 0) {
            g.moveTo(pos.x, pos.y);
          } else {
            g.lineTo(pos.x, pos.y);
          }
          model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, 1]);
        } else {
          if (i === 0) {
            g.moveTo(cx, rowPosition + rowHeight - y);
          } else {
            g.lineTo(cx, rowPosition + rowHeight - y);
          }
          model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - y, 1]);
        }
      });
    });
  });
}
function drawBar(track, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const tileSize = track.tilesetInfo.tile_size;
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const xScale = model.getChannelScale("x");
  let tileUnitWidth;
  if (tile.tileData.tilePos) {
    const { tileX, tileWidth } = track.getTilePosAndDimensions(
      tile.tileData.zoomLevel,
      tile.tileData.tilePos,
      tileSize
    );
    tileUnitWidth = xScale(tileX + tileWidth / tileSize) - xScale(tileX);
  }
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const clipRow = !IsChannelDeep(spec.row) || IsChannelDeep(spec.row) && typeof spec.row.clip === "undefined" || spec.row.clip;
  const baselineValue = IsChannelDeep(spec.y) ? (_f = spec.y) == null ? void 0 : _f.baseline : void 0;
  const staticBaseY = (_g = model.encodedValue("y", baselineValue)) != null ? _g : 0;
  const g = tile.graphics;
  if (IsStackedMark(spec)) {
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const xKeys = [...pivotedData.keys()];
    xKeys.forEach((k) => {
      var _a2;
      let prevYEnd = 0;
      (_a2 = pivotedData.get(k)) == null ? void 0 : _a2.forEach((d) => {
        const color2 = model.encodedPIXIProperty("color", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        const y = model.encodedPIXIProperty("y", d);
        const barWidth = model.encodedPIXIProperty("width", d, { tileUnitWidth });
        const xs = model.encodedPIXIProperty("x-start", d, { markWidth: barWidth });
        const xe = xs + barWidth;
        const alphaTransition = model.markVisibility(d, { width: barWidth, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (actualOpacity === 0 || barWidth <= 0 || y <= 0) {
          return;
        }
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          actualOpacity,
          0
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        let polygonForMouseEvents = [];
        if (circular) {
          const farR = trackOuterRadius - (rowHeight - prevYEnd) / trackHeight * trackRingSize;
          const nearR = trackOuterRadius - (rowHeight - y - prevYEnd) / trackHeight * trackRingSize;
          const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xs + barWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          polygonForMouseEvents = Array.from(g.currentPath.points);
          g.closePath();
        } else {
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.drawRect(xs, rowHeight - y - prevYEnd, barWidth, y);
          const ys = rowHeight - y - prevYEnd;
          const ye = ys + y;
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
        prevYEnd += y;
      });
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowPosition = model.encodedValue("row", rowCategory);
      data2.filter((d) => {
        const rowValue = getValueUsingChannel(d, spec.row);
        return !rowValue || rowValue === rowCategory;
      }).forEach((d) => {
        const color2 = model.encodedPIXIProperty("color", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity");
        let y = model.encodedPIXIProperty("y", d);
        let ye = model.encodedPIXIProperty("ye", d);
        if (typeof ye !== "undefined" && y > ye) {
          [y, ye] = [ye, y];
        }
        const barWidth = model.encodedPIXIProperty("width", d, { tileUnitWidth });
        const xs = model.encodedPIXIProperty("x-start", d, { markWidth: barWidth });
        const xe = xs + barWidth;
        let ys;
        if (typeof ye === "undefined") {
          ys = rowPosition + rowHeight - staticBaseY - y;
          ye = rowPosition + rowHeight - staticBaseY;
          if (IsChannelDeep(spec.y) && spec.y.flip || spec.flipY) {
            ye = ys;
            ys = rowPosition;
          }
        } else {
          ys = rowPosition + rowHeight - ye;
          ye = rowPosition + rowHeight - y;
        }
        if (clipRow) {
          ys = Math.max(rowPosition, ys);
          ys = Math.min(ys, rowPosition + rowHeight);
          ye = Math.max(rowPosition, ye);
          ye = Math.min(ye, rowPosition + rowHeight);
        }
        const alphaTransition = model.markVisibility(d, { width: barWidth, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (actualOpacity === 0 || barWidth === 0 || ye - ys === 0) {
          return;
        }
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          actualOpacity,
          0
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        let polygonForMouseEvents = [];
        if (circular) {
          const farR = trackOuterRadius - ys / trackHeight * trackRingSize;
          const nearR = trackOuterRadius - ye / trackHeight * trackRingSize;
          const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xs + barWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          polygonForMouseEvents = Array.from(g.currentPath.points);
          g.closePath();
        } else {
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.drawRect(xs, ys, barWidth, ye - ys);
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
      });
    });
  }
}
function barProperty(gm, propertyKey, datum, additionalInfo) {
  const x = gm.visualPropertyByChannel("x", datum);
  const xe = gm.visualPropertyByChannel("xe", datum);
  const size = gm.visualPropertyByChannel("size", datum);
  switch (propertyKey) {
    case "width":
      return size != null ? size : xe ? xe - x : additionalInfo == null ? void 0 : additionalInfo.tileUnitWidth;
    case "x-start":
      if (!(additionalInfo == null ? void 0 : additionalInfo.markWidth)) {
        return void 0;
      }
      return xe ? (x + xe - (additionalInfo == null ? void 0 : additionalInfo.markWidth)) / 2 : x - (additionalInfo == null ? void 0 : additionalInfo.markWidth) / 2;
    default:
      return void 0;
  }
}
function drawArea(HGC, track, tile, model) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const trackCenterX = trackWidth / 2;
  const trackCenterY = trackHeight / 2;
  const xScale = track._xScale;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const colorCategories = (_f = model.getChannelDomainArray("color")) != null ? _f : ["___SINGLE_COLOR___"];
  const constantOpacity = model.encodedPIXIProperty("opacity");
  const constantStrokeWidth = model.encodedPIXIProperty("strokeWidth");
  const constantStroke = model.encodedPIXIProperty("stroke");
  const graphics = tile.graphics;
  if (IsStackedMark(spec)) {
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const genomicPosCategories = [...pivotedData.keys()];
    graphics.lineStyle(
      constantStrokeWidth,
      colorToHex(constantStroke),
      constantOpacity,
      1
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    const prevYEndByGPos = {};
    colorCategories.forEach((colorCategory) => {
      const areaPointsTop = [];
      const areaPointsBottom = [];
      genomicPosCategories.forEach((genomicPosCategory, i, array) => {
        var _a2, _b2;
        (_b2 = (_a2 = pivotedData.get(genomicPosCategory)) == null ? void 0 : _a2.filter((d) => getValueUsingChannel(d, spec.color) === colorCategory)) == null ? void 0 : _b2.forEach((d) => {
          const xValue = +genomicPosCategory;
          const cx = xScale(xValue);
          const cy = max([model.encodedPIXIProperty("y", d), 0]);
          if (typeof prevYEndByGPos[genomicPosCategory] === "undefined") {
            prevYEndByGPos[genomicPosCategory] = 0;
          }
          const ys = rowHeight - cy - prevYEndByGPos[genomicPosCategory];
          const ye = rowHeight - prevYEndByGPos[genomicPosCategory];
          if (circular) {
            if (i === 0) {
              const r = trackOuterRadius - rowHeight / trackHeight * trackRingSize;
              const pos = cartesianToPolar(
                cx,
                trackWidth,
                r,
                trackCenterX,
                trackCenterY,
                startAngle,
                endAngle
              );
              areaPointsTop.push([pos.x, pos.y]);
              areaPointsBottom.push([pos.x, pos.y]);
            }
            const rTop = trackOuterRadius - ys / trackHeight * trackRingSize;
            const posTop = cartesianToPolar(
              cx,
              trackWidth,
              rTop,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            areaPointsTop.push([posTop.x, posTop.y]);
            const rBot = trackOuterRadius - ye / trackHeight * trackRingSize;
            const posBot = cartesianToPolar(
              cx,
              trackWidth,
              rBot,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            areaPointsBottom.push([posBot.x, posBot.y]);
            if (i === array.length - 1) {
              const r = trackOuterRadius - rowHeight / trackHeight * trackRingSize;
              const pos = cartesianToPolar(
                cx,
                trackWidth,
                r,
                trackCenterX,
                trackCenterY,
                startAngle,
                endAngle
              );
              areaPointsTop.push([pos.x, pos.y]);
              areaPointsBottom.push([pos.x, pos.y]);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [posBot.x, posBot.y, 1]);
          } else {
            if (i === 0) {
              areaPointsTop.push([cx, rowHeight]);
              areaPointsBottom.push([cx, rowHeight]);
            }
            areaPointsTop.push([cx, ys]);
            areaPointsBottom.push([cx, ye]);
            if (i === array.length - 1) {
              areaPointsTop.push([cx, rowHeight]);
              areaPointsBottom.push([cx, rowHeight]);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [cx, ys, 1]);
          }
          prevYEndByGPos[genomicPosCategory] += cy;
        });
      });
      const color2 = model.encodedValue("color", colorCategory);
      graphics.beginFill(colorToHex(color2), constantOpacity);
      graphics.drawPolygon([
        ...areaPointsTop.reduce((a, b) => a.concat(b)),
        ...areaPointsBottom.reverse().reduce((a, b) => a.concat(b))
      ]);
      graphics.endFill();
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowPosition = model.encodedValue("row", rowCategory);
      graphics.lineStyle(
        constantStrokeWidth,
        colorToHex(constantStroke),
        constantOpacity,
        0
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      colorCategories.forEach((colorCategory) => {
        const baselinePoints = [];
        const areaPoints = [];
        const baselineR = trackOuterRadius - (rowPosition + rowHeight) / trackHeight * trackRingSize;
        let startX = 0;
        data2.filter(
          (d) => (typeof getValueUsingChannel(d, spec.row) === "undefined" || getValueUsingChannel(d, spec.row) === rowCategory) && (typeof getValueUsingChannel(d, spec.color) === "undefined" || getValueUsingChannel(d, spec.color) === colorCategory)
        ).sort(
          // should sort properly before visualizing it so that the path is correctly drawn
          (a, b) => model.encodedPIXIProperty("x", a) - model.encodedPIXIProperty("x", b)
        ).forEach((d, i, array) => {
          const cy = min([max([model.encodedPIXIProperty("y", d), 0]), rowHeight]);
          const cx = model.encodedPIXIProperty("x", d);
          if (circular) {
            const baselinePos = cartesianToPolar(
              cx,
              trackWidth,
              baselineR,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            baselinePoints.push([baselinePos.x, baselinePos.y]);
            if (i === 0) {
              areaPoints.push(baselinePos.x, baselinePos.y);
            }
            const r = trackOuterRadius - (rowPosition + rowHeight - cy) / trackHeight * trackRingSize;
            const pos = cartesianToPolar(
              cx,
              trackWidth,
              r,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            areaPoints.push(pos.x, pos.y);
            if (i === array.length - 1) {
              const startR = trackOuterRadius - (rowPosition + rowHeight) / trackHeight * trackRingSize;
              const curPos = cartesianToPolar(
                cx,
                trackWidth,
                startR,
                trackCenterX,
                trackCenterY,
                startAngle,
                endAngle
              );
              areaPoints.push(curPos.x, curPos.y);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, 1]);
          } else {
            if (i === 0) {
              areaPoints.push(cx, rowPosition + rowHeight);
              startX = cx;
            }
            areaPoints.push(cx, rowPosition + rowHeight - cy);
            if (i === array.length - 1) {
              areaPoints.push(cx, rowPosition + rowHeight);
              areaPoints.push(startX, rowPosition + rowHeight);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - cy, 1]);
          }
        });
        if (circular && baselinePoints.length !== 0) {
          areaPoints.push(...baselinePoints.reverse().reduce((a, b) => a.concat(b)));
        }
        const color2 = model.encodedValue("color", colorCategory);
        graphics.beginFill(colorToHex(color2), constantOpacity);
        graphics.drawPolygon(areaPoints);
        graphics.endFill();
      });
    });
  }
}
function drawRect(HGC, track, tile, model) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const xScale = track._xScale;
  let tileUnitWidth;
  if (tile.tileData.tilePos) {
    const tileSize = track.tilesetInfo.tile_size;
    const { tileX, tileWidth } = track.getTilePosAndDimensions(
      tile.tileData.zoomLevel,
      tile.tileData.tilePos,
      // TODO: required parameter. Typing out `track` should address this issue.
      tileSize
    );
    tileUnitWidth = xScale(tileX + tileWidth / tileSize) - xScale(tileX);
  }
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const RPAD = IsChannelDeep(spec.row) && spec.row.padding ? spec.row.padding : 0;
  const yCategories = (_f = model.getChannelDomainArray("y")) != null ? _f : ["___SINGLE_Y_POSITION___"];
  const cellHeight = rowHeight / yCategories.length - RPAD * 2;
  const g = tile.graphics;
  data2.forEach((d) => {
    var _a2;
    const rowPosition = model.encodedPIXIProperty("row", d) + RPAD;
    const x = model.encodedPIXIProperty("x", d);
    const color2 = model.encodedPIXIProperty("color", d);
    const stroke = model.encodedPIXIProperty("stroke", d);
    const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
    const opacity = model.encodedPIXIProperty("opacity", d);
    const rectWidth = model.encodedPIXIProperty("width", d, { markWidth: tileUnitWidth });
    const rectHeight = model.encodedPIXIProperty("height", d, { markHeight: cellHeight });
    const y = model.encodedPIXIProperty("y", d);
    const alphaTransition = model.markVisibility(d, {
      width: rectWidth,
      zoomLevel: track._xScale.invert(trackWidth) - track._xScale.invert(0)
    });
    const actualOpacity = Math.min(alphaTransition, opacity);
    if (actualOpacity === 0 || rectHeight === 0 || rectWidth <= 1e-4) {
      return;
    }
    const [xs, xe, ys, ye] = [
      x,
      x + rectWidth,
      rowPosition + rowHeight - y - rectHeight / 2,
      rowPosition + rowHeight - y + rectHeight / 2
    ];
    const absoluteHeight = (_a2 = model.visualPropertyByChannel("size", d)) != null ? _a2 : void 0;
    g.lineStyle(
      strokeWidth,
      colorToHex(stroke),
      actualOpacity,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    let polygonForMouseEvent = [];
    if (circular) {
      if (xe < 0 || trackWidth < xs) {
        return;
      }
      let farR = trackOuterRadius - ys / trackHeight * trackRingSize;
      let nearR = trackOuterRadius - ye / trackHeight * trackRingSize;
      if (absoluteHeight) {
        const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
        farR = midR - absoluteHeight / 2;
        nearR = midR + absoluteHeight / 2;
      }
      const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
      const endRad = valueToRadian(xe, trackWidth, startAngle, endAngle);
      g.beginFill(colorToHex(color2 === "none" ? "white" : color2), color2 === "none" ? 0 : actualOpacity);
      g.moveTo(sPos.x, sPos.y);
      g.arc(cx, cy, nearR, startRad, endRad, true);
      g.arc(cx, cy, farR, endRad, startRad, false);
      polygonForMouseEvent = Array.from(g.currentPath.points);
      g.closePath();
    } else {
      g.beginFill(colorToHex(color2 === "none" ? "white" : color2), color2 === "none" ? 0 : actualOpacity);
      g.drawRect(xs, ys, xe - xs, ye - ys);
      polygonForMouseEvent = [xs, ys, xs, ye, xe, ye, xe, ys];
    }
    model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvent);
  });
}
function rectProperty(gm, propertyKey, datum, additionalInfo) {
  var _a;
  switch (propertyKey) {
    case "width":
      const width = (
        // (1) size
        gm.visualPropertyByChannel("xe", datum) ? gm.visualPropertyByChannel("xe", datum) - gm.visualPropertyByChannel("x", datum) : (
          // (2) unit mark height
          additionalInfo == null ? void 0 : additionalInfo.markWidth
        )
      );
      return width === 0 ? 0.1 : width;
    case "height":
      return (
        // (1) size
        (_a = gm.visualPropertyByChannel("size", datum)) != null ? _a : (
          // (2) unit mark height
          additionalInfo == null ? void 0 : additionalInfo.markHeight
        )
      );
    default:
      return void 0;
  }
}
function drawTriangle(g, model, trackWidth, trackHeight) {
  var _a, _b, _c, _d, _e, _f, _g;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const yCategories = (_f = model.getChannelDomainArray("y")) != null ? _f : ["___SINGLE_Y___"];
  const triHeight = (_g = model.encodedValue("size")) != null ? _g : circular ? trackRingSize / rowCategories.length / yCategories.length : rowHeight / yCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      var _a2, _b2, _c2;
      const x = model.encodedPIXIProperty("x", d);
      const xe = model.encodedPIXIProperty("xe", d);
      const markWidth = (_a2 = model.encodedPIXIProperty("size", d)) != null ? _a2 : xe === void 0 ? triHeight : xe - x;
      const y = model.encodedPIXIProperty("y", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      let polygon = [];
      if (circular) {
        let x0 = x ? x : xe - markWidth;
        let x1 = xe ? xe : x + markWidth;
        let xm = (x0 + x1) / 2;
        const rm = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
        const r0 = rm - triHeight / 2;
        const r1 = rm + triHeight / 2;
        if (((_b2 = spec.style) == null ? void 0 : _b2.align) === "right" && !xe) {
          x0 -= markWidth;
          x1 -= markWidth;
          xm -= markWidth;
        }
        if (spec.mark === "triangleLeft") {
          const p0 = cartesianToPolar(x1, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x0, trackWidth, rm, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(x1, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x1, trackWidth, r0, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        } else if (spec.mark === "triangleRight") {
          const p0 = cartesianToPolar(x0, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x1, trackWidth, rm, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x0, trackWidth, r0, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        } else if (spec.mark === "triangleBottom") {
          x0 = xm - markWidth / 2;
          x1 = xm + markWidth / 2;
          const p0 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x1, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(xm, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        }
        const alphaTransition = model.markVisibility(d, { width: x1 - x0, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          // too narrow triangle's stroke is becoming too sharp
          x1 - x0 > 2 ? actualOpacity : 0,
          // alpha
          0
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawPolygon(polygon);
        g.endFill();
      } else {
        let x0 = x ? x : xe - markWidth;
        let x1 = xe ? xe : x + markWidth;
        let xm = x0 + (x1 - x0) / 2;
        const ym = rowPosition + rowHeight - y;
        const y0 = rowPosition + rowHeight - y - triHeight / 2;
        const y1 = rowPosition + rowHeight - y + triHeight / 2;
        if (((_c2 = spec.style) == null ? void 0 : _c2.align) === "right" && !xe) {
          x0 -= markWidth;
          x1 -= markWidth;
          xm -= markWidth;
        }
        polygon = {
          triangleLeft: [x1, y0, x0, ym, x1, y1, x1, y0],
          triangleRight: [x0, y0, x1, ym, x0, y1, x0, y0],
          triangleBottom: [x0, y0, x1, y0, xm, y1, x0, y0]
        }[spec.mark];
        const alphaTransition = model.markVisibility(d, { width: x1 - x0, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          // too narrow triangle's stroke is becoming too sharp
          x1 - x0 > 2 ? actualOpacity : 0,
          // alpha
          0.5
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawPolygon(polygon);
        g.endFill();
      }
      model.getMouseEventModel().addPolygonBasedEvent(d, polygon);
    });
  });
}
const TEXT_STYLE_GLOBAL = {
  fontSize: "12px",
  fontFamily: "sans-serif",
  // 'Arial',
  fontWeight: "normal",
  fill: "black",
  background: "white",
  lineJoin: "round",
  stroke: "#ffffff",
  strokeThickness: 0
};
function drawText(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const dx = (_g = (_f = spec.style) == null ? void 0 : _f.dx) != null ? _g : 0;
  const dy = (_i = (_h = spec.style) == null ? void 0 : _h.dy) != null ? _i : 0;
  const textAnchor = !((_j = spec.style) == null ? void 0 : _j.textAnchor) ? "middle" : spec.style.textAnchor;
  if (IsStackedMark(spec)) {
    if (circular) {
      return;
    }
    const rowGraphics = tile.graphics;
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const xKeys = [...pivotedData.keys()];
    xKeys.forEach((k) => {
      var _a2;
      let prevYEnd = 0;
      (_a2 = pivotedData.get(k)) == null ? void 0 : _a2.forEach((d) => {
        var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const text = model.encodedPIXIProperty("text", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const x = model.encodedPIXIProperty("x", d) + dx;
        const xe = model.encodedPIXIProperty("xe", d) + dx;
        const cx = model.encodedPIXIProperty("x-center", d) + dx;
        const y = model.encodedPIXIProperty("y", d) + dy;
        const size = model.encodedPIXIProperty("size", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        if (cx < 0 || cx > trackWidth) {
          return;
        }
        if (trackInfo.textsBeingUsed > 1e3) {
          return;
        }
        const localTextStyle = {
          ...TEXT_STYLE_GLOBAL,
          fontSize: size != null ? size : ((_a3 = spec.style) == null ? void 0 : _a3.textFontSize) ? `${(_b2 = spec.style) == null ? void 0 : _b2.textFontSize}px` : TEXT_STYLE_GLOBAL.fontSize,
          stroke: (_d2 = stroke != null ? stroke : (_c2 = spec.style) == null ? void 0 : _c2.textStroke) != null ? _d2 : TEXT_STYLE_GLOBAL.stroke,
          strokeThickness: (_f2 = strokeWidth != null ? strokeWidth : (_e2 = spec.style) == null ? void 0 : _e2.textStrokeWidth) != null ? _f2 : TEXT_STYLE_GLOBAL.strokeThickness,
          fontWeight: (_h2 = (_g2 = spec.style) == null ? void 0 : _g2.textFontWeight) != null ? _h2 : TEXT_STYLE_GLOBAL.fontWeight
        };
        const textStyleObj = new HGC.libraries.PIXI.TextStyle(localTextStyle);
        let textGraphic;
        if (trackInfo.textGraphics.length > trackInfo.textsBeingUsed) {
          textGraphic = trackInfo.textGraphics[trackInfo.textsBeingUsed];
          textGraphic.style.fill = color2;
          textGraphic.visible = true;
          textGraphic.text = text;
          textGraphic.alpha = 1;
        } else {
          textGraphic = new HGC.libraries.PIXI.Text(text, {
            ...localTextStyle,
            fill: color2
          });
          trackInfo.textGraphics.push(textGraphic);
        }
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, textStyleObj);
        trackInfo.textsBeingUsed++;
        const alphaTransition = model.markVisibility(d, {
          ...metric,
          zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
        });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (!text || actualOpacity === 0) {
          trackInfo.textsBeingUsed--;
          textGraphic.visible = false;
          return;
        }
        textGraphic.alpha = actualOpacity;
        textGraphic.resolution = 8;
        textGraphic.updateText();
        textGraphic.texture.baseTexture.scaleMode = HGC.libraries.PIXI.SCALE_MODES.LINEAR;
        const sprite = new HGC.libraries.PIXI.Sprite(textGraphic.texture);
        sprite.x = x;
        sprite.y = rowHeight - y - prevYEnd;
        sprite.width = xe - x;
        sprite.height = y;
        rowGraphics.addChild(sprite);
        prevYEnd += y;
      });
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowGraphics = tile.graphics;
      const rowPosition = model.encodedValue("row", rowCategory);
      data2.filter(
        (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
      ).forEach((d) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const text = model.encodedPIXIProperty("text", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const cx = model.encodedPIXIProperty("x-center", d) + dx;
        const y = model.encodedPIXIProperty("y", d) + dy;
        const size = model.encodedPIXIProperty("size", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        if (cx < 0 || cx > trackWidth) {
          return;
        }
        if (trackInfo.textsBeingUsed > 1e3) {
          return;
        }
        const localTextStyle = {
          ...TEXT_STYLE_GLOBAL,
          fontSize: size != null ? size : ((_a2 = spec.style) == null ? void 0 : _a2.textFontSize) ? `${(_b2 = spec.style) == null ? void 0 : _b2.textFontSize}px` : TEXT_STYLE_GLOBAL.fontSize,
          stroke: (_d2 = stroke != null ? stroke : (_c2 = spec.style) == null ? void 0 : _c2.textStroke) != null ? _d2 : TEXT_STYLE_GLOBAL.stroke,
          strokeThickness: (_f2 = strokeWidth != null ? strokeWidth : (_e2 = spec.style) == null ? void 0 : _e2.textStrokeWidth) != null ? _f2 : TEXT_STYLE_GLOBAL.strokeThickness,
          fontWeight: (_h2 = (_g2 = spec.style) == null ? void 0 : _g2.textFontWeight) != null ? _h2 : TEXT_STYLE_GLOBAL.fontWeight
        };
        const textStyleObj = new HGC.libraries.PIXI.TextStyle(localTextStyle);
        let textGraphic;
        if (trackInfo.textGraphics.length > trackInfo.textsBeingUsed) {
          textGraphic = trackInfo.textGraphics[trackInfo.textsBeingUsed];
          textGraphic.style.fill = color2;
          textGraphic.visible = true;
          textGraphic.text = text;
          textGraphic.alpha = 1;
        } else {
          textGraphic = new HGC.libraries.PIXI.Text(text, {
            ...localTextStyle,
            fill: color2
          });
          trackInfo.textGraphics.push(textGraphic);
        }
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, textStyleObj);
        trackInfo.textsBeingUsed++;
        const alphaTransition = model.markVisibility(d, {
          ...metric,
          zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
        });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (!text || actualOpacity === 0) {
          trackInfo.textsBeingUsed--;
          textGraphic.visible = false;
          return;
        }
        textGraphic.alpha = actualOpacity;
        textGraphic.anchor.y = 0.5;
        textGraphic.anchor.x = textAnchor === "middle" ? 0.5 : textAnchor === "start" ? 0 : 1;
        let polygonForMouseEvents = [];
        if (circular) {
          const r = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const centerPos = cartesianToPolar(cx, trackWidth, r, tcx, tcy, startAngle, endAngle);
          textGraphic.x = centerPos.x;
          textGraphic.y = centerPos.y;
          textGraphic.resolution = 4;
          const tw = metric.width / (2 * r * Math.PI) * trackWidth;
          let [minX, maxX] = [cx - tw / 2, cx + tw / 2];
          if (minX < 0) {
            const gap = -minX;
            minX = 0;
            maxX += gap;
          } else if (maxX > trackWidth) {
            const gap = maxX - trackWidth;
            maxX = trackWidth;
            minX -= gap;
          }
          const ropePoints = [];
          const eventPointsFar = [];
          const eventPointsNear = [];
          for (let i = maxX; i >= minX; i -= tw / 10) {
            const p = cartesianToPolar(i, trackWidth, r, tcx, tcy, startAngle, endAngle);
            ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
            const pFar = cartesianToPolar(
              i,
              trackWidth,
              r + metric.height / 2,
              tcx,
              tcy,
              startAngle,
              endAngle
            );
            const pNear = cartesianToPolar(
              i,
              trackWidth,
              r - metric.height / 2,
              tcx,
              tcy,
              startAngle,
              endAngle
            );
            eventPointsFar.push(pFar.x, pFar.y);
            if (i === maxX) {
              eventPointsNear.push(pFar.y, pFar.x);
            }
            eventPointsNear.push(pNear.y, pNear.x);
          }
          textGraphic.updateText();
          const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
          rope.alpha = actualOpacity;
          rowGraphics.addChild(rope);
          eventPointsNear.reverse();
          polygonForMouseEvents = eventPointsFar.concat(eventPointsNear);
        } else {
          textGraphic.position.x = cx;
          textGraphic.position.y = rowPosition + rowHeight - y;
          rowGraphics.addChild(textGraphic);
          const { height: h, width: w } = metric;
          const ys = textGraphic.position.y - h / 2;
          const ye = ys + h;
          let xs = 0;
          let xe = 0;
          if (textAnchor === "start") {
            xs = cx;
            xe = cx + w;
          } else if (textAnchor === "middle") {
            xs = cx - w / 2;
            xe = cx + w / 2;
          } else {
            xs = cx - w;
            xe = cx;
          }
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
      });
    });
  }
}
function drawRule(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const dashed = (_f = spec.style) == null ? void 0 : _f.dashed;
  const linePattern = (_g = spec.style) == null ? void 0 : _g.linePattern;
  const curved = (_h = spec.style) == null ? void 0 : _h.curve;
  const g = tile.graphics;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      const x = model.encodedPIXIProperty("x", d);
      const xe = model.encodedPIXIProperty("xe", d);
      const y = model.encodedPIXIProperty("y", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      const alphaTransition = model.markVisibility(d, {
        width: xe - x,
        zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
      });
      const actualOpacity = Math.min(alphaTransition, opacity);
      g.lineStyle(
        strokeWidth,
        colorToHex(color2),
        actualOpacity,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      if (!xe && (!spec.y || !("field" in spec.y))) {
        if (circular) {
          return;
        } else {
          if (dashed) {
            const [dashSize, gapSize] = dashed;
            let curPos = 0;
            do {
              g.moveTo(x, curPos);
              g.lineTo(x, curPos + dashSize);
              curPos += dashSize + gapSize;
            } while (curPos < trackHeight);
          } else {
            g.moveTo(x, 0);
            g.lineTo(x, trackHeight);
          }
        }
      } else if (!xe && y) {
        if (circular) {
          g.lineStyle(
            strokeWidth,
            colorToHex(color2),
            0,
            // alpha
            0.5
            // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
          );
          const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
          const farR = midR + strokeWidth / 2;
          const nearR = midR - strokeWidth / 2;
          const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          g.closePath();
        } else {
          if (dashed) {
            const [dashSize, gapSize] = dashed;
            let curPos = 0;
            do {
              g.moveTo(curPos, rowPosition + rowHeight - y);
              g.lineTo(curPos + dashSize, rowPosition + rowHeight - y);
              curPos += dashSize + gapSize;
            } while (curPos < trackWidth);
          } else {
            g.moveTo(0, rowPosition + rowHeight - y);
            g.lineTo(trackWidth, rowPosition + rowHeight - y);
          }
        }
      } else {
        if (circular) {
          if (strokeWidth === 0) {
            return;
          }
          g.lineStyle(
            strokeWidth,
            colorToHex(color2),
            0,
            // alpha
            0.5
            // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
          );
          const midR = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const farR = midR + strokeWidth / 2;
          const nearR = midR - strokeWidth / 2;
          const sPos = cartesianToPolar(x, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(x, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xe, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          g.closePath();
        } else if (dashed) {
          const [dashSize, gapSize] = dashed;
          let curPos = x;
          do {
            g.moveTo(curPos, rowPosition + rowHeight - y);
            g.lineTo(curPos + dashSize, rowPosition + rowHeight - y);
            curPos += dashSize + gapSize;
          } while (curPos < xe);
        } else {
          if (curved === void 0) {
            g.moveTo(x, rowPosition + rowHeight - y);
            g.lineTo(xe, rowPosition + rowHeight - y);
          } else if (curved === "top") {
            const CURVE_HEIGHT = 2;
            const xm = x + (xe - x) / 2;
            g.moveTo(x, rowPosition + rowHeight - y + CURVE_HEIGHT / 2);
            g.lineTo(xm, rowPosition + rowHeight - y - CURVE_HEIGHT / 2);
            g.moveTo(xm, rowPosition + rowHeight - y - CURVE_HEIGHT / 2);
            g.lineTo(xe, rowPosition + rowHeight - y + CURVE_HEIGHT / 2);
          }
        }
        if (linePattern && curved === void 0 && !circular) {
          const { type: pType, size: pSize } = linePattern;
          let curPos = Math.max(x, 0);
          g.lineStyle(0);
          const PATTERN_GAP_SIZE = pSize * 2;
          let count = 0;
          while (curPos < Math.min(xe, trackWidth) && count < 100) {
            const x0 = curPos;
            const x1 = curPos + pSize;
            const ym = rowPosition + rowHeight - y;
            const y0 = ym - pSize / 2;
            const y1 = ym + pSize / 2;
            g.beginFill(colorToHex(color2), actualOpacity);
            g.drawPolygon(
              pType === "triangleLeft" ? [x1, y0, x0, ym, x1, y1, x1, y0] : [x0, y0, x1, ym, x0, y1, x0, y0]
            );
            g.endFill();
            curPos += pSize + PATTERN_GAP_SIZE;
            count++;
          }
        }
      }
    });
  });
}
function drawWithinLink(g, trackInfo, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const MIN_HEIGHT = (_g = (_f = spec.style) == null ? void 0 : _f.linkMinHeight) != null ? _g : 0.5;
  const NUM_STEPS = ((_h = spec.experimental) == null ? void 0 : _h.performanceMode) ? 10 : 50;
  const showVerticalLines = (_j = (_i = spec.style) == null ? void 0 : _i.withinLinkVerticalLines) != null ? _j : false;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      var _a2, _b2, _c2, _d2, _e2;
      let x = model.encodedPIXIProperty("x", d);
      let xe = model.encodedPIXIProperty("xe", d);
      let x1 = model.encodedPIXIProperty("x1", d);
      let x1e = model.encodedPIXIProperty("x1e", d);
      const y = model.encodedPIXIProperty("y", d);
      const ye = model.encodedPIXIProperty("ye", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      if (typeof xe !== "undefined") {
        [x, xe] = [x, xe].sort((a, b) => a - b);
      }
      if (typeof x1 !== "undefined" && typeof x1e !== "undefined") {
        [x1, x1e] = [x1, x1e].sort((a, b) => a - b);
      }
      const isRibbon = typeof xe !== "undefined" && typeof x1 !== "undefined" && typeof x1e !== "undefined" && // This means the strokeWidth of a band is too small, so we just need to draw a line instead
      Math.abs(x - xe) > 0.1 && Math.abs(x1 - x1e) > 0.1;
      if (!isRibbon && xe === void 0 && !Is2DTrack(spec)) {
        if (x1 === void 0 && x1e === void 0) {
          return;
        }
        xe = x1 !== void 0 ? x1 : x1e;
      }
      if (!isRibbon && Math.abs(x - xe) <= 0.1 && Math.abs(x1 - x1e) <= 0.1) {
        x = (x + xe) / 2;
        xe = (x1 + x1e) / 2;
      }
      g.lineStyle(
        strokeWidth,
        colorToHex(stroke),
        opacity,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      const flipY = IsChannelDeep(spec.y) && spec.y.flip || spec.flipY;
      const baseY = (_a2 = spec.baselineY) != null ? _a2 : rowPosition + (flipY ? 0 : rowHeight);
      let pathForMouseEvent = [];
      if (isRibbon) {
        g.beginFill(color2 === "none" ? colorToHex("white") : colorToHex(color2), color2 === "none" ? 0 : opacity);
        let [_x1, _x2, _x3, _x4] = [x, xe, x1, x1e];
        [_x1, _x2, _x3, _x4] = [_x1, _x2, _x3, _x4].sort((a, b) => a - b);
        if (_x1 > trackWidth || _x4 < 0 || Math.abs(_x4 - _x1) < 0.5) {
          return;
        }
        if (circular) {
          if (_x1 < 0 || _x4 > trackWidth) {
            return;
          }
          const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
          const posX = cartesianToPolar(_x1, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posXE = cartesianToPolar(_x2, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1 = cartesianToPolar(_x3, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1E = cartesianToPolar(_x4, trackWidth, r, tcx, tcy, startAngle, endAngle);
          g.moveTo(posX.x, posX.y);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posX1E.x, posX1E.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posX1E.x, posX1E.y, tcx, tcy),
            positionToRadian(posX1.x, posX1.y, tcx, tcy),
            false
          );
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posXE.x, posXE.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posXE.x, posXE.y, tcx, tcy),
            positionToRadian(posX.x, posX.y, tcx, tcy),
            false
          );
          pathForMouseEvent = Array.from(g.currentPath.points);
          g.endFill();
        } else {
          g.moveTo(_x1, baseY);
          if (!((_b2 = spec.style) == null ? void 0 : _b2.linkStyle) || ((_c2 = spec.style) == null ? void 0 : _c2.linkStyle) === "circular") {
            g.arc(
              (_x1 + _x4) / 2,
              // cx
              baseY,
              // cy
              (_x4 - _x1) / 2,
              // radius
              -Math.PI,
              // start angle
              Math.PI,
              // end angle
              false
            );
            g.arc((_x2 + _x3) / 2, baseY, (_x3 - _x2) / 2, Math.PI, -Math.PI, true);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.closePath();
          } else {
            g.lineTo(_x3, rowPosition + rowHeight);
            g.bezierCurveTo(
              _x3 + (_x2 - _x3) / 3,
              // rowPosition + (x1 - x),
              rowPosition + rowHeight - (_x2 - _x3) / 2,
              //Math.min(rowHeight - (x1 - x), (xe - x1) / 2.0),
              _x3 + (_x2 - _x3) / 3 * 2,
              // rowPosition + (x1 - x),
              rowPosition + rowHeight - (_x2 - _x3) / 2,
              //Math.min(rowHeight - (x1 - x), (xe - x1) / 2.0),
              _x2,
              rowPosition + rowHeight
            );
            g.lineTo(_x4, rowPosition + rowHeight);
            g.bezierCurveTo(
              _x1 + (_x4 - _x1) / 3 * 2,
              // rowPosition,
              rowPosition + rowHeight - (_x4 - _x1) / 2,
              //Math.min(rowHeight, (x1e - x) / 2.0),
              _x1 + (_x4 - _x1) / 3,
              // rowPosition,
              rowPosition + rowHeight - (_x4 - _x1) / 2,
              //Math.min(rowHeight, (x1e - x) / 2.0),
              _x1,
              rowPosition + rowHeight
            );
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.endFill();
          }
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, pathForMouseEvent);
      } else {
        const midX = (x + xe) / 2;
        g.beginFill(colorToHex("white"), 0);
        if (circular) {
          if (x < 0 || xe > trackWidth) {
            return;
          }
          if (((_d2 = spec.style) == null ? void 0 : _d2.linkStyle) === "straight") {
            const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
            const posS = cartesianToPolar(x, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const posE = cartesianToPolar(xe, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const x12 = posS.x;
            const y1 = posS.y;
            const x4 = posE.x;
            const y4 = posE.y;
            g.moveTo(x12, y1);
            g.lineTo(x4, y4);
            const length = 100;
            const eventPoints = Array.from({ length }, (d2, i) => {
              return {
                x: (x4 - x12) / (length - 1) * i + x12,
                y: (y4 - y1) / (length - 1) * i + y1
              };
            });
            pathForMouseEvent = eventPoints.flatMap((d2) => [d2.x, d2.y]);
          } else {
            const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
            const posS = cartesianToPolar(x, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const posE = cartesianToPolar(xe, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const x12 = posS.x;
            const y1 = posS.y;
            const x2 = posS.x;
            const y2 = posS.y;
            const x3 = trackWidth / 2;
            const y3 = trackHeight / 2;
            const x4 = posE.x;
            const y4 = posE.y;
            g.moveTo(x12, y1);
            const bezier = new Bezier(x12, y1, x2, y2, x3, y3, x4, y4);
            const points = bezier.getLUT(14);
            points.forEach((d2) => g.lineTo(d2.x, d2.y));
            const morePoints = bezier.getLUT(1e3);
            pathForMouseEvent = morePoints.flatMap((d2) => [d2.x, d2.y]);
          }
        } else {
          if (((_e2 = spec.style) == null ? void 0 : _e2.linkStyle) === "elliptical") {
            if (!(0 <= x && x <= trackWidth) && !(0 <= xe && xe <= trackWidth)) {
              return;
            }
            const points = [];
            const isYSpecified = IsChannelDeep(spec.y);
            for (let step = 0; step <= NUM_STEPS; step++) {
              const theta = Math.PI * (step / NUM_STEPS);
              const mx = (xe - x) / 2 * Math.cos(theta) + (x + xe) / 2;
              let my = baseY - y * Math.sin(theta) * (isYSpecified ? 1 : Math.min(xe - x + trackWidth * MIN_HEIGHT, trackWidth) / trackWidth) * (flipY ? -1 : 1);
              if (typeof y !== "undefined" && typeof ye !== "undefined") {
                const linkHeight = Math.abs(ye - y);
                const flipShape = ye > y;
                my = y - linkHeight * Math.sin(theta) * (flipShape ? -1 : 1);
              }
              if (step === 0) {
                if (showVerticalLines) {
                  const _y = flipY ? baseY - trackHeight : baseY;
                  g.moveTo(mx, _y);
                  points.push({ x: mx, y: _y });
                  g.lineTo(mx, my);
                } else {
                  g.moveTo(mx, my);
                }
              } else {
                g.lineTo(mx, my);
              }
              points.push({ x: mx, y: my });
              if (step === NUM_STEPS && showVerticalLines) {
                const _y = flipY ? baseY - trackHeight : baseY;
                g.lineTo(mx, _y);
                points.push({ x: mx, y: _y });
              }
            }
            pathForMouseEvent = points.flatMap((d2) => [d2.x, d2.y]);
          } else {
            if (xe < 0 || x > trackWidth) {
              return;
            }
            g.arc(midX, baseY, (xe - x) / 2, -Math.PI, Math.PI);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.closePath();
          }
        }
        model.getMouseEventModel().addLineBasedEvent(d, pathForMouseEvent);
      }
    });
  });
}
function insertItemToArray(array, index, item) {
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function flatArrayToPairArray(array) {
  const output = [];
  for (let i = 0; i < array.length; i += 2) {
    output.push([array[i], array[i + 1]]);
  }
  return output;
}
function isEvery(array, is) {
  return array.every(is);
}
function isNumberArray(array) {
  return isEvery(array, (x) => typeof x === "number");
}
function isStringArray(array) {
  return isEvery(array, (x) => typeof x === "string");
}
function drawGrid(trackInfo, tm, theme) {
  drawYGridQuantitative(trackInfo, tm, theme);
  drawRowGrid(trackInfo, tm, theme);
}
function drawRowGrid(trackInfo, tm, theme) {
  var _a, _b, _c, _d;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.row) || spec.row.grid !== true) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = tm.spec().layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = tm.getChannelDomainArray("row");
  if (!rowCategories) {
    return;
  }
  const rowHeight = trackHeight / rowCategories.length;
  if (circular && trackRingSize <= 20 || !circular && rowHeight <= 20) {
    return;
  }
  const graphics = trackInfo.pBackground;
  const strokeWidth = theme.axis.gridStrokeWidth;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = tm.encodedValue("row", rowCategory);
    if (!circular) {
      graphics.lineStyle(
        strokeWidth,
        colorToHex(theme.axis.gridColor),
        1,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      const y = trackY + rowPosition + rowHeight / 2;
      graphics.moveTo(trackX, y);
      graphics.lineTo(trackX + trackWidth, y);
    } else {
      const y = rowPosition + rowHeight / 2;
      const midR = trackOuterRadius - y / trackHeight * trackRingSize;
      const farR = midR + strokeWidth / 2;
      const nearR = midR - strokeWidth / 2;
      const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
      const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
      graphics.lineStyle(
        strokeWidth,
        colorToHex("black"),
        0,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      graphics.beginFill(colorToHex(theme.axis.gridColor), 1);
      graphics.moveTo(trackX + sPos.x, trackY + sPos.y);
      graphics.arc(trackX + cx, trackY + cy, nearR, startRad, endRad, true);
      graphics.arc(trackX + cx, trackY + cy, farR, endRad, startRad, false);
      graphics.closePath();
    }
  });
}
function drawYGridQuantitative(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.y) || spec.y.grid !== true) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const startX = trackX;
  const endX = trackX + trackWidth;
  const circular = tm.spec().layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = tm.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  if (!isStringArray(rowCategories)) {
    return;
  }
  const scale = tm.getChannelScale("y");
  const domain = tm.getChannelDomainArray("y");
  if (!scale || !domain || !isNumberArray(domain)) {
    return;
  }
  if (circular && rowHeight / trackHeight * trackRingSize <= 20 || !circular && rowHeight <= 20) {
    return;
  }
  const graphics = trackInfo.pBackground;
  const strokeWidth = theme.axis.gridStrokeWidth;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = tm.encodedValue("row", rowCategory);
    const assignedHeight = circular ? rowHeight / trackHeight * trackRingSize : rowHeight;
    const tickCount = Math.max(Math.ceil(assignedHeight / 40), 1);
    let ticks = scale.ticks(tickCount).filter((v) => domain[0] <= v && v <= domain[1]);
    if (ticks.length === 1) {
      ticks = scale.ticks(tickCount + 1).filter((v) => domain[0] <= v && v <= domain[1]);
    }
    if (!circular) {
      graphics.lineStyle(
        strokeWidth,
        colorToHex(theme.axis.gridColor),
        1,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      ticks.forEach((value) => {
        var _a2;
        const y = trackY + rowPosition + rowHeight - scale(value);
        if (theme.axis.gridStrokeType === "solid") {
          graphics.moveTo(startX, y);
          graphics.lineTo(endX, y);
        } else if (theme.axis.gridStrokeType === "dashed") {
          const [line, gap] = (_a2 = theme.axis.gridStrokeDash) != null ? _a2 : [1, 1];
          for (let i = startX; i < endX; i += line + gap) {
            graphics.moveTo(i, y);
            graphics.lineTo(i + line, y);
          }
        }
      });
    } else {
      ticks.forEach((value) => {
        const y = scale(value);
        const midR = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
        const farR = midR + strokeWidth / 2;
        const nearR = midR - strokeWidth / 2;
        const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
        const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
        const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
        graphics.lineStyle(
          strokeWidth,
          colorToHex("black"),
          0,
          // alpha
          0.5
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        graphics.beginFill(colorToHex(theme.axis.gridColor), 1);
        graphics.moveTo(trackX + sPos.x, trackY + sPos.y);
        graphics.arc(trackX + cx, trackY + cy, nearR, startRad, endRad, true);
        graphics.arc(trackX + cx, trackY + cy, farR, endRad, startRad, false);
        graphics.closePath();
      });
    }
  });
}
const DEFAULT_TEXT_STYLE = {
  color: "black",
  size: 10,
  fontFamily: "Arial",
  fontWeight: "normal",
  stroke: "#ffffff",
  strokeThickness: 0
};
function getTextStyle(style = {}) {
  const merged = { ...DEFAULT_TEXT_STYLE, ...style };
  const pixiTextStyle = {
    fontSize: `${merged.size}px`,
    fontFamily: merged.fontFamily,
    fontWeight: merged.fontWeight === "light" ? "lighter" : merged.fontWeight,
    fill: merged.color,
    lineJoin: "round",
    stroke: merged.stroke,
    strokeThickness: merged.strokeThickness
  };
  return pixiTextStyle;
}
function drawCircularTitle(HGC, trackInfo, tile, model, theme) {
  var _a, _b, _c;
  const spec = model.spec();
  const { title: title2 } = spec;
  if (spec.layout !== "circular") {
    return;
  }
  if (!title2) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const trackOuterRadius = (_a = spec.outerRadius) != null ? _a : 300;
  const startAngle = (_b = spec.startAngle) != null ? _b : 0;
  const endAngle = (_c = spec.endAngle) != null ? _c : 360;
  const cx = tw / 2;
  const cy = th / 2;
  const g = tile.graphics;
  const titleR = trackOuterRadius - 1;
  const padding = 1;
  const pos = cartesianToPolar(padding, tw, titleR, cx, cy, startAngle, endAngle);
  const styleConfig = getTextStyle({
    color: theme.track.titleColor,
    size: 12,
    // `theme.track.titleFontSize` seems to use much larger fonts
    fontFamily: theme.axis.labelFontFamily,
    // TODO: support
    fontWeight: theme.axis.labelFontWeight
    // TODO: support
  });
  const textGraphic = new HGC.libraries.PIXI.Text(title2, styleConfig);
  textGraphic.anchor.x = 1;
  textGraphic.anchor.y = 0.5;
  textGraphic.position.x = pos.x;
  textGraphic.position.y = pos.y;
  textGraphic.resolution = 4;
  const txtStyle = new HGC.libraries.PIXI.TextStyle(styleConfig);
  const metric = HGC.libraries.PIXI.TextMetrics.measureText(textGraphic.text, txtStyle);
  const txtWidth = metric.width / (2 * titleR * Math.PI) * tw * 360 / (endAngle - startAngle);
  const scaledStartX = padding;
  const scaledEndX = padding + txtWidth;
  const ropePoints = [];
  for (let i = scaledEndX; i >= scaledStartX; i -= txtWidth / 10) {
    const p = cartesianToPolar(i, tw, titleR - metric.height / 2, cx, cy, startAngle, endAngle);
    ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
  }
  const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
  const endRad = valueToRadian(scaledEndX + padding, tw, startAngle, endAngle);
  g.lineStyle(1, colorToHex("red"), 0, 0.5);
  g.beginFill(colorToHex(theme.track.titleBackground), 0.5);
  g.moveTo(pos.x, pos.y);
  g.arc(cx, cy, titleR - metric.height, startRad, endRad, true);
  g.arc(cx, cy, titleR, endRad, startRad, false);
  g.closePath();
  textGraphic.updateText();
  const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
  g.addChild(rope);
}
function drawChartOutlines(trackInfo, tm, theme) {
  var _a, _b, _c, _d;
  const g = trackInfo.pBorder;
  const [l, t] = trackInfo.position;
  const [w, h] = trackInfo.dimensions;
  g.lineStyle(
    (_b = (_a = tm.spec().style) == null ? void 0 : _a.outlineWidth) != null ? _b : 1,
    // TODO: outline not working
    colorToHex((_d = (_c = tm.spec().style) == null ? void 0 : _c.outline) != null ? _d : theme.track.outline),
    1,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  g.beginFill(colorToHex("white"), 0);
  g.drawRect(l, t, w, h);
  const x = tm.spec().x;
  g.lineStyle(
    1,
    colorToHex(theme.axis.baselineColor),
    1,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  if (IsChannelDeep(x) && x.axis === "top") {
    g.moveTo(l, t);
    g.lineTo(l + w, t);
  } else if (IsChannelDeep(x) && x.axis === "bottom") {
    g.moveTo(l, t + h);
    g.lineTo(l + w, t + h);
  }
}
function drawColorLegend(HGC, trackInfo, _tile2, model, theme) {
  if (!trackInfo.gLegend) {
    return;
  }
  trackInfo.gLegend.selectAll(".brush").remove();
  const spec = model.spec();
  const offset = { offsetRight: 0 };
  if (IsChannelDeep(spec.color) && spec.color.legend) {
    switch (spec.color.type) {
      case "nominal":
        drawColorLegendCategories(HGC, trackInfo, _tile2, model, theme);
        break;
      case "quantitative":
        drawColorLegendQuantitative(HGC, trackInfo, _tile2, model, theme, "color", offset);
        break;
    }
  }
  if (IsChannelDeep(spec.stroke) && spec.stroke.legend) {
    switch (spec.stroke.type) {
      case "quantitative":
        drawColorLegendQuantitative(HGC, trackInfo, _tile2, model, theme, "stroke", offset);
        break;
    }
  }
}
function drawColorLegendQuantitative(HGC, trackInfo, _tile2, model, theme, channelKey, offset) {
  const spec = model.spec();
  const channel = spec[channelKey];
  if (!IsChannelDeep(channel) || channel.type !== "quantitative" || !channel.legend) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const legendWidth = 80;
  const legendHeight = trackHeight - 2 > 110 ? 110 : Math.max(trackHeight - 2, 40 - 2);
  const colorBarDim = {
    top: 10,
    left: 55,
    width: 20,
    height: legendHeight - 20
  };
  const legendX = trackX + trackWidth - legendWidth - 1 - offset.offsetRight;
  const legendY = trackY + 1;
  const colorScale = model.getChannelScale(channelKey);
  const colorDomain = model.getChannelDomainArray(channelKey);
  if (!colorScale || !colorDomain) {
    return;
  }
  const graphics = trackInfo.pBorder;
  graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
  graphics.lineStyle(
    1,
    colorToHex(theme.legend.backgroundStroke),
    theme.legend.backgroundOpacity,
    // alpha
    0
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  graphics.drawRect(legendX, legendY, legendWidth, legendHeight);
  if (channel.title) {
    const titleStr = channel.title;
    const labelTextStyle2 = getTextStyle({
      color: theme.legend.labelColor,
      size: theme.legend.labelFontSize,
      fontWeight: theme.legend.labelFontWeight,
      fontFamily: theme.legend.labelFontFamily
    });
    const textGraphic = new HGC.libraries.PIXI.Text(titleStr, {
      ...labelTextStyle2,
      fontWeight: "bold"
    });
    textGraphic.anchor.x = 0;
    textGraphic.anchor.y = 0;
    textGraphic.position.x = legendX + 10;
    textGraphic.position.y = legendY + 10;
    const textStyleObj = new HGC.libraries.PIXI.TextStyle({ ...labelTextStyle2, fontWeight: "bold" });
    const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(titleStr, textStyleObj);
    graphics.addChild(textGraphic);
    colorBarDim.top += textMetrics.height + 4;
    colorBarDim.height -= textMetrics.height + 4;
  }
  const [startValue, endValue] = colorDomain;
  const extent = endValue - startValue;
  const scaleOffset = IsChannelDeep(channel) && channel.scaleOffset ? channel.scaleOffset : [0, 1];
  [...Array(colorBarDim.height).keys()].forEach((y) => {
    let value;
    const scaleOffsetSorted = Array.from(scaleOffset).sort();
    if (y / colorBarDim.height >= scaleOffsetSorted[1]) {
      value = endValue;
    } else if (y / colorBarDim.height <= scaleOffsetSorted[0]) {
      value = startValue;
    } else {
      const s1 = scaleLinear().domain([colorBarDim.height * scaleOffsetSorted[0], colorBarDim.height * scaleOffsetSorted[1]]).range([0, colorBarDim.height]);
      const s2 = scaleLinear().domain([0, colorBarDim.height]).range([startValue, endValue]);
      value = s2(s1(y));
    }
    graphics.beginFill(
      colorToHex(colorScale(value)),
      1
      // alpha
    );
    graphics.lineStyle(
      1,
      colorToHex(theme.legend.backgroundStroke),
      0,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.drawRect(
      legendX + colorBarDim.left,
      legendY + colorBarDim.top + colorBarDim.height - y,
      colorBarDim.width,
      1
    );
  });
  const BRUSH_HEIGHT = 4;
  trackInfo.colorBrushes = trackInfo.gLegend.append("g").attr("class", channelKey).selectAll(`.brush`).data(
    scaleOffset.map((d, i) => {
      return { y: d, id: i };
    })
  ).enter().append("rect").attr("class", `brush`).attr("pointer-events", "all").attr("cursor", "ns-resize").attr(
    "transform",
    (d) => `translate(${legendX + colorBarDim.left}, ${legendY + colorBarDim.top - BRUSH_HEIGHT / 2 + colorBarDim.height - colorBarDim.height * d.y})`
  ).attr("width", `${colorBarDim.width}px`).attr("height", `${BRUSH_HEIGHT}px`).attr("fill", "lightgrey").attr("stroke", "black").attr("stroke-width", "0.5px").call(
    HGC.libraries.d3Drag.drag().on("start", (event) => {
      trackInfo.startEvent = event.sourceEvent;
    }).on("drag", (event, d) => {
      if (channel && channel.scaleOffset) {
        const endEvent = event.sourceEvent;
        const diffY = trackInfo.startEvent.clientY - endEvent.clientY;
        const newScaleOffset = [channel.scaleOffset[0], channel.scaleOffset[1]];
        if (d.id === 0) {
          newScaleOffset[0] += diffY / colorBarDim.height;
        } else {
          newScaleOffset[1] += diffY / colorBarDim.height;
        }
        newScaleOffset[0] = Math.min(1, Math.max(0, newScaleOffset[0]));
        newScaleOffset[1] = Math.min(1, Math.max(0, newScaleOffset[1]));
        trackInfo.updateScaleOffsetFromOriginalSpec(spec._renderingId, newScaleOffset, channelKey);
        trackInfo.shareScaleOffsetAcrossTracksAndTiles(newScaleOffset, channelKey);
        trackInfo.draw();
        trackInfo.startEvent = event.sourceEvent;
      }
    })
  );
  const tickCount = Math.max(Math.ceil(colorBarDim.height / 30), 2);
  let ticks = colorScale.ticks(tickCount).filter((v) => colorDomain[0] <= v && v <= colorDomain[1]);
  if (ticks.length === 1) {
    ticks = colorScale.ticks(tickCount + 1).filter((v) => colorDomain[0] <= v && v <= colorDomain[1]);
  }
  const TICK_STROKE_SIZE = 1;
  graphics.lineStyle(
    TICK_STROKE_SIZE,
    colorToHex(theme.legend.tickColor),
    1,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  const tickEnd = legendX + colorBarDim.left;
  ticks.forEach((value) => {
    let y = legendY + colorBarDim.top + colorBarDim.height - (value - startValue) / extent * colorBarDim.height;
    if (y === legendY + colorBarDim.top) {
      y += TICK_STROKE_SIZE / 2;
    } else if (y === legendY + colorBarDim.top + colorBarDim.height) {
      y -= TICK_STROKE_SIZE / 2;
    }
    graphics.moveTo(tickEnd - 3, y);
    graphics.lineTo(tickEnd, y);
    const textGraphic = new HGC.libraries.PIXI.Text(value, labelTextStyle);
    textGraphic.anchor.x = 1;
    textGraphic.anchor.y = 0.5;
    textGraphic.position.x = tickEnd - 6;
    textGraphic.position.y = y;
    graphics.addChild(textGraphic);
  });
  offset.offsetRight = trackWidth - legendX;
}
function drawColorLegendCategories(HGC, track, _tile2, tm, theme) {
  var _a, _b, _c, _d, _e;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.color) || spec.color.type !== "nominal" || !spec.color.legend) {
    return;
  }
  const colorCategories = (_a = tm.getChannelDomainArray("color")) != null ? _a : ["___SINGLE_COLOR___"];
  if (colorCategories.length === 0) {
    return;
  }
  const domain = spec.color.domain;
  const range = spec.color.range;
  const existingLegends = track.displayedLegends;
  const toStr = (_) => {
    return typeof _ === "string" ? _ : _.join();
  };
  if (existingLegends.find((d) => toStr(d.domain) === toStr(domain) && toStr(d.range) === toStr(range))) {
    return;
  } else {
    existingLegends.push({ domain, range });
  }
  const graphics = track.pBorder;
  const paddingX = 10;
  const paddingY = 4;
  let cumY = paddingY;
  let maxWidth = 0;
  const recipe = [];
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  if ((_b = spec.style) == null ? void 0 : _b.inlineLegend) {
    colorCategories.map((d) => d).reverse().forEach((category) => {
      if (maxWidth > track.dimensions[0]) {
        return;
      }
      const color2 = tm.encodedValue("color", category);
      const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = track.position[0] + track.dimensions[0] - maxWidth - paddingX;
      textGraphic.position.y = track.position[1] + paddingY;
      graphics.addChild(textGraphic);
      const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
      if (cumY < textMetrics.height + paddingY * 3) {
        cumY = textMetrics.height + paddingY * 3;
      }
      recipe.push({
        x: track.position[0] + track.dimensions[0] - textMetrics.width - maxWidth - paddingX * 2,
        y: track.position[1] + paddingY + textMetrics.height / 2,
        color: color2
      });
      maxWidth += textMetrics.width + paddingX * 3;
    });
  } else {
    if ((_c = spec.style) == null ? void 0 : _c.legendTitle) {
      const textGraphic = new HGC.libraries.PIXI.Text((_d = spec.style) == null ? void 0 : _d.legendTitle, {
        ...labelTextStyle,
        fontWeight: "bold"
      });
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = track.position[0] + track.dimensions[0] - paddingX;
      textGraphic.position.y = track.position[1] + cumY;
      const textStyleObj = new HGC.libraries.PIXI.TextStyle({ ...labelTextStyle, fontWeight: "bold" });
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText((_e = spec.style) == null ? void 0 : _e.legendTitle, textStyleObj);
      graphics.addChild(textGraphic);
      cumY += textMetrics.height + paddingY * 2;
    }
    colorCategories.forEach((category) => {
      if (cumY > track.dimensions[1]) {
        return;
      }
      const color2 = tm.encodedValue("color", category);
      const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = track.position[0] + track.dimensions[0] - paddingX;
      textGraphic.position.y = track.position[1] + cumY;
      graphics.addChild(textGraphic);
      const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
      if (maxWidth < textMetrics.width + paddingX * 3) {
        maxWidth = textMetrics.width + paddingX * 3;
      }
      recipe.push({
        x: track.position[0] + track.dimensions[0] - textMetrics.width - paddingX * 2,
        y: track.position[1] + cumY + textMetrics.height / 2,
        color: color2
      });
      cumY += textMetrics.height + paddingY * 2;
    });
  }
  graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
  graphics.lineStyle(
    1,
    colorToHex(theme.legend.backgroundStroke),
    theme.legend.backgroundOpacity,
    // alpha
    0
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  graphics.drawRect(
    track.position[0] + track.dimensions[0] - maxWidth - 1,
    track.position[1] + 1,
    maxWidth,
    cumY - paddingY
  );
  recipe.forEach((r) => {
    graphics.lineStyle(
      1,
      colorToHex("black"),
      0,
      // alpha
      0
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.beginFill(colorToHex(r.color), 1);
    graphics.drawCircle(r.x, r.y, 4);
  });
}
function drawRowLegend(HGC, trackInfo, _tile2, tm, theme) {
  var _a;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.row) || spec.row.type !== "nominal" || !spec.row.legend) {
    return;
  }
  const rowCategories = (_a = tm.getChannelDomainArray("row")) != null ? _a : ["___SINGLE_ROW___"];
  if (rowCategories.length === 0) {
    return;
  }
  const graphics = trackInfo.pBorder;
  const paddingX = 4;
  const paddingY = 2;
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  rowCategories.forEach((category) => {
    const rowPosition = tm.encodedValue("row", category);
    const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
    textGraphic.anchor.x = 0;
    textGraphic.anchor.y = 0;
    textGraphic.position.x = trackInfo.position[0] + paddingX;
    textGraphic.position.y = trackInfo.position[1] + rowPosition + paddingY;
    graphics.addChild(textGraphic);
    const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
    const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
    graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
    graphics.lineStyle(
      1,
      colorToHex(theme.legend.backgroundStroke),
      0,
      // alpha
      0
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.drawRect(
      trackInfo.position[0] + 1,
      trackInfo.position[1] + rowPosition + 1,
      textMetrics.width + paddingX * 2,
      textMetrics.height + paddingY * 2
    );
  });
}
const EXTENT_TICK_SIZE = 8;
const TICK_SIZE = 6;
function drawLinearYAxis(HGC, trackInfo, _tile2, model, theme) {
  var _a;
  const spec = model.spec();
  const CIRCULAR = spec.layout === "circular";
  const yDomain = model.getChannelDomainArray("y");
  const yRange = model.getChannelRangeArray("y");
  if (CIRCULAR) {
    return;
  }
  if (!model.isShowYAxis() || !yDomain || !yRange) {
    return;
  }
  if (!isNumberArray(yDomain)) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const [tx, ty] = trackInfo.position;
  const rowCategories = (_a = model.getChannelDomainArray("row")) != null ? _a : ["___SINGLE_ROW___"];
  if (!isStringArray(rowCategories)) {
    return;
  }
  const rowHeight = th / rowCategories.length;
  if (rowHeight <= 20) {
    return;
  }
  const yChannel = model.spec().y;
  const isLeft = IsChannelDeep(yChannel) && "axis" in yChannel && yChannel.axis === "right" ? false : true;
  const yScale = scaleLinear().domain(yDomain).range(yRange);
  const graphics = trackInfo.pBorder;
  rowCategories.forEach((category) => {
    const rowPosition = model.encodedValue("row", category);
    const dx = isLeft ? tx : tx + tw;
    const dy = ty + rowPosition;
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.baselineColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.moveTo(dx, dy);
    graphics.lineTo(dx, dy + rowHeight);
    const tickCount = Math.max(Math.ceil(rowHeight / 40), 1);
    let ticks = yScale.ticks(tickCount).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    if (ticks.length === 1) {
      ticks = yScale.ticks(tickCount + 1).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    }
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.tickColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    let tickEnd = isLeft ? dx + TICK_SIZE : dx - TICK_SIZE;
    ticks.forEach((t) => {
      const y = yScale(t);
      graphics.moveTo(dx, dy + rowHeight - y);
      graphics.lineTo(tickEnd, dy + rowHeight - y);
    });
    tickEnd = isLeft ? dx + EXTENT_TICK_SIZE : dx - EXTENT_TICK_SIZE;
    graphics.moveTo(dx, dy);
    graphics.lineTo(tickEnd, dy);
    graphics.moveTo(dx, dy + rowHeight);
    graphics.lineTo(tickEnd, dy + rowHeight);
    const styleConfig = getTextStyle({
      color: theme.axis.labelColor,
      size: theme.axis.labelFontSize,
      fontFamily: theme.axis.labelFontFamily,
      fontWeight: theme.axis.labelFontWeight
    });
    ticks.forEach((t) => {
      const y = yScale(t);
      tickEnd = isLeft ? dx + TICK_SIZE * 2 : dx - TICK_SIZE * 2;
      const textGraphic = new HGC.libraries.PIXI.Text(t, styleConfig);
      textGraphic.anchor.x = isLeft ? 0 : 1;
      textGraphic.anchor.y = y === 0 ? 0.9 : 0.5;
      textGraphic.position.x = tickEnd;
      textGraphic.position.y = dy + rowHeight - y;
      if (spec.orientation === "vertical") {
        textGraphic.anchor.x = isLeft ? 1 : 0;
        textGraphic.scale.x *= -1;
      }
      graphics.addChild(textGraphic);
    });
  });
}
function drawCircularYAxis(HGC, trackInfo, tile, model, theme) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  const CIRCULAR = spec.layout === "circular";
  const yDomain = model.getChannelDomainArray("y");
  const yRange = model.getChannelRangeArray("y");
  if (!CIRCULAR) {
    return;
  }
  if (!model.isShowYAxis() || !yDomain || !yRange) {
    return;
  }
  if (!isNumberArray(yDomain)) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const cx = tw / 2;
  const cy = th / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = th / rowCategories.length;
  if (rowHeight / th * trackRingSize <= 20) {
    return;
  }
  const yChannel = model.spec().y;
  const isLeft = IsChannelDeep(yChannel) && "axis" in yChannel && yChannel.axis === "right" ? false : true;
  const yScale = scaleLinear().domain(yDomain).range(yRange);
  const graphics = tile.graphics;
  rowCategories.forEach((category) => {
    const rowPosition = model.encodedValue("row", category);
    const innerR = trackOuterRadius - (rowPosition + rowHeight) / th * trackRingSize;
    const outerR = trackOuterRadius - rowPosition / th * trackRingSize;
    const innerPos = cartesianToPolar(isLeft ? 0 : tw, tw, innerR, cx, cy, startAngle, endAngle);
    const outerPos = cartesianToPolar(isLeft ? 0 : tw, tw, outerR, cx, cy, startAngle, endAngle);
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.baselineColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.moveTo(innerPos.x, innerPos.y);
    graphics.lineTo(outerPos.x, outerPos.y);
    const SCALED_TICK_SIZE = (r) => TICK_SIZE * tw / 2 / Math.PI / r;
    const SCALED_EXTENT_TICK_SIZE = (r) => EXTENT_TICK_SIZE * tw / 2 / Math.PI / r;
    const axisHeight = rowHeight / th * trackRingSize;
    const tickCount = Math.max(Math.ceil(axisHeight / 40), 1);
    let ticks = yScale.ticks(tickCount).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    if (ticks.length === 1) {
      ticks = yScale.ticks(tickCount + 1).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    }
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.tickColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    ticks.forEach((t) => {
      const y = yScale(t);
      const currentR = trackOuterRadius - (rowPosition + rowHeight - y) / th * trackRingSize;
      const scaledStartX = isLeft ? 0 : tw - SCALED_TICK_SIZE(currentR);
      const scaledEndX = isLeft ? SCALED_TICK_SIZE(currentR) : tw;
      const pos = cartesianToPolar(scaledStartX, tw, currentR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(pos.x, pos.y);
      graphics.arc(cx, cy, currentR, startRad, endRad, true);
      graphics.arc(cx, cy, currentR, endRad, startRad, false);
      graphics.closePath();
    });
    {
      const scaledStartX = isLeft ? 0 : tw - SCALED_EXTENT_TICK_SIZE(trackInnerRadius);
      const scaledEndX = isLeft ? SCALED_EXTENT_TICK_SIZE(trackInnerRadius) : tw;
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(innerPos.x, innerPos.y);
      graphics.arc(cx, cy, trackInnerRadius, startRad, endRad, true);
      graphics.arc(cx, cy, trackInnerRadius, endRad, startRad, false);
      graphics.closePath();
    }
    {
      const scaledStartX = isLeft ? 0 : tw - SCALED_EXTENT_TICK_SIZE(trackOuterRadius);
      const scaledEndX = isLeft ? SCALED_EXTENT_TICK_SIZE(trackOuterRadius) : tw;
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(outerPos.x, outerPos.y);
      graphics.arc(cx, cy, trackOuterRadius, startRad, endRad, true);
      graphics.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
      graphics.closePath();
    }
    ticks.forEach((t) => {
      const y = yScale(t);
      const currentR = trackOuterRadius - (rowPosition + rowHeight - y) / th * trackRingSize;
      const pos = cartesianToPolar(SCALED_TICK_SIZE(currentR) * 2, tw, currentR, cx, cy, startAngle, endAngle);
      const styleConfig = getTextStyle({
        color: theme.axis.labelColor,
        size: theme.axis.labelFontSize,
        fontFamily: theme.axis.labelFontFamily,
        fontWeight: theme.axis.labelFontWeight
      });
      const textGraphic = new HGC.libraries.PIXI.Text(t, styleConfig);
      textGraphic.anchor.x = isLeft ? 1 : 0;
      textGraphic.anchor.y = 0.5;
      textGraphic.position.x = pos.x;
      textGraphic.position.y = pos.y;
      textGraphic.resolution = 4;
      const txtStyle = new HGC.libraries.PIXI.TextStyle(styleConfig);
      const metric = HGC.libraries.PIXI.TextMetrics.measureText(textGraphic.text, txtStyle);
      const txtWidth = metric.width / (2 * currentR * Math.PI) * tw * 360 / (endAngle - startAngle);
      const scaledStartX = isLeft ? SCALED_TICK_SIZE(currentR) * 2 : tw - SCALED_TICK_SIZE(currentR) * 2 - txtWidth;
      const scaledEndX = isLeft ? SCALED_TICK_SIZE(currentR) * 2 + txtWidth : tw - SCALED_TICK_SIZE(currentR) * 2;
      const ropePoints = [];
      for (let i = scaledEndX; i >= scaledStartX; i -= txtWidth / 10) {
        const p = cartesianToPolar(i, tw, currentR, cx, cy, startAngle, endAngle);
        ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
      }
      textGraphic.updateText();
      const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
      graphics.addChild(rope);
    });
  });
}
function drawCircularOutlines(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const spec = tm.spec();
  const [l, t] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const cx = l + trackWidth / 2;
  const cy = t + trackHeight / 2;
  const posStartInner = cartesianToPolar(0, trackWidth, trackInnerRadius, cx, cy, startAngle, endAngle);
  const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
  const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
  const g = trackInfo.pBackground;
  if (!(spec.layout === "circular" && spec.mark === "withinLink")) {
    g.lineStyle(
      ((_e = spec.style) == null ? void 0 : _e.outlineWidth) ? ((_f = spec.style) == null ? void 0 : _f.outlineWidth) / 2.5 : 0,
      colorToHex((_h = (_g = spec.style) == null ? void 0 : _g.outline) != null ? _h : "#DBDBDB"),
      1,
      // 0.4, // alpha
      1
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(
      colorToHex((_j = (_i = tm.spec().style) == null ? void 0 : _i.background) != null ? _j : theme.track.background),
      (_l = (_k = tm.spec().style) == null ? void 0 : _k.backgroundOpacity) != null ? _l : !theme.track.background || theme.track.background === "transparent" ? 0 : 1
    );
    g.moveTo(posStartInner.x, posStartInner.y);
    g.arc(cx, cy, trackInnerRadius, startRad, endRad, true);
    g.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
    g.closePath();
  }
  if (IsChannelDeep(spec.x) && spec.x.axis === "top") {
    g.lineStyle(
      0.5,
      colorToHex("black"),
      0,
      // 1, // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(colorToHex("white"), 0);
    g.moveTo(posStartInner.x, posStartInner.y);
    g.arc(cx, cy, trackOuterRadius - 0.5, startRad, endRad, true);
    g.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
    g.closePath();
  }
  g.lineStyle(
    0.5,
    colorToHex("black"),
    0,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  g.beginFill(colorToHex("white"), 0);
  g.moveTo(cx, cy);
  g.arc(cx, cy, trackOuterRadius + 3, startRad, endRad, false);
  g.closePath();
  g.lineStyle(
    1,
    colorToHex("#DBDBDB"),
    0,
    // alpha
    0
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  g.beginFill(colorToHex("white"), 0);
  g.drawCircle(cx, cy, trackInnerRadius - 1);
}
function drawBackground(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e, _f;
  const [l, t] = trackInfo.position;
  const [w, h] = trackInfo.dimensions;
  const g = trackInfo.pBackground;
  if (((_a = tm.spec().style) == null ? void 0 : _a.background) || theme.track.background && theme.track.background !== "transparent") {
    g.clear();
    const bg = (_c = (_b = tm.spec().style) == null ? void 0 : _b.background) != null ? _c : theme.track.background;
    const alpha = isUndefined((_d = tm.spec().style) == null ? void 0 : _d.backgroundOpacity) ? 1 : (_e = tm.spec().style) == null ? void 0 : _e.backgroundOpacity;
    g.lineStyle(
      1,
      colorToHex("white"),
      0,
      // alpha
      0
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(colorToHex(bg), alpha);
    g.drawRect(l, t, w, h);
  }
  if (theme.track.alternatingBackground && theme.track.alternatingBackground !== "transparent") {
    const spec = tm.spec();
    if (!IsChannelDeep(spec.row) || spec.row.type !== "nominal") {
      return;
    }
    const rowCategories = (_f = tm.getChannelDomainArray("row")) != null ? _f : ["___SINGLE_ROW___"];
    if (rowCategories.length === 0) {
      return;
    }
    rowCategories.forEach((category, i) => {
      var _a2, _b2, _c2, _d2;
      if (i % 2 === 0) {
        return;
      }
      const rowPosition = tm.encodedValue("row", category);
      const bg = (_b2 = (_a2 = tm.spec().style) == null ? void 0 : _a2.background) != null ? _b2 : theme.track.alternatingBackground;
      const alpha = isUndefined((_c2 = tm.spec().style) == null ? void 0 : _c2.backgroundOpacity) ? 1 : (_d2 = tm.spec().style) == null ? void 0 : _d2.backgroundOpacity;
      g.lineStyle(
        1,
        colorToHex("white"),
        0,
        // alpha
        0
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      g.beginFill(colorToHex(bg), alpha);
      g.drawRect(trackInfo.position[0], trackInfo.position[1] + rowPosition, w, h / rowCategories.length);
    });
  }
}
function drawBetweenLink(g, trackInfo, model) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      var _a2, _b2;
      let x = model.encodedPIXIProperty("x", d);
      let xe = model.encodedPIXIProperty("xe", d);
      let x1 = model.encodedPIXIProperty("x1", d);
      let x1e = model.encodedPIXIProperty("x1e", d);
      const y = model.encodedPIXIProperty("y", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      if (typeof xe !== "undefined") {
        [x, xe] = [x, xe].sort((a, b) => a - b);
      }
      if (typeof x1 !== "undefined" && typeof x1e !== "undefined") {
        [x1, x1e] = [x1, x1e].sort((a, b) => a - b);
      }
      const isRibon = typeof xe !== "undefined" && typeof x1 !== "undefined" && typeof x1e !== "undefined" && // This means the strokeWidth of a band is too small, so we just need to draw a line instead
      Math.abs(x - xe) > 0.1 && Math.abs(x1 - x1e) > 0.1;
      if (!isRibon && xe === void 0 && !Is2DTrack(spec)) {
        if (x1 === void 0 && x1e === void 0) {
          return;
        }
        xe = x1 !== void 0 ? x1 : x1e;
      }
      if (!isRibon && Math.abs(x - xe) <= 0.1 && Math.abs(x1 - x1e) <= 0.1) {
        x = (x + xe) / 2;
        xe = (x1 + x1e) / 2;
      }
      g.lineStyle(
        strokeWidth,
        colorToHex(stroke),
        opacity,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      if (isRibon) {
        g.beginFill(color2 === "none" ? colorToHex("white") : colorToHex(color2), color2 === "none" ? 0 : opacity);
        let [_x1, _x2, _x3, _x4] = [x, xe, x1, x1e];
        [_x1, _x2] = [_x1, _x2].sort((a, b) => a - b);
        [_x3, _x4] = [_x3, _x4].sort((a, b) => a - b);
        if (_x1 > trackWidth || _x4 < 0 || Math.abs(_x4 - _x1) < 0.5) {
          return;
        }
        if (circular) {
          if (_x1 < 0 || _x4 > trackWidth) {
            return;
          }
          const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
          const posX = cartesianToPolar(_x1, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posXE = cartesianToPolar(_x2, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1 = cartesianToPolar(_x3, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1E = cartesianToPolar(_x4, trackWidth, r, tcx, tcy, startAngle, endAngle);
          g.moveTo(posX.x, posX.y);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posX1E.x, posX1E.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posX1E.x, posX1E.y, tcx, tcy),
            positionToRadian(posX1.x, posX1.y, tcx, tcy),
            false
          );
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posXE.x, posXE.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posXE.x, posXE.y, tcx, tcy),
            positionToRadian(posX.x, posX.y, tcx, tcy),
            false
          );
          g.endFill();
        } else {
          g.moveTo(_x1, rowPosition);
          g.lineTo(_x2, rowPosition);
          g.lineTo(_x4, rowPosition + rowHeight);
          g.lineTo(_x3, rowPosition + rowHeight);
          g.lineTo(_x1, rowPosition);
          g.closePath();
        }
      } else {
        if (Is2DTrack(spec)) {
          if (((_a2 = spec.style) == null ? void 0 : _a2.linkConnectionType) === "curve") {
            g.moveTo(x, 0);
            g.bezierCurveTo(
              x / 5 * 4,
              (rowPosition + rowHeight - y) / 2,
              x / 2,
              (rowPosition + rowHeight - y) / 5 * 4,
              0,
              rowPosition + rowHeight - y
            );
          } else if (((_b2 = spec.style) == null ? void 0 : _b2.linkConnectionType) === "straight") {
            g.moveTo(x, 0);
            g.lineTo(0, rowPosition + rowHeight - y);
          } else {
            g.moveTo(x, 0);
            g.lineTo(x, rowPosition + rowHeight - y);
            g.lineTo(0, rowPosition + rowHeight - y);
          }
          return;
        }
        if (circular) {
          let prevX, prevY;
          for (let t = 0; t <= 1; t += 0.02) {
            const logodds = (t2) => Math.log(t2 / (1 - t2));
            const movingRadius = (t2) => trackOuterRadius - 1 / (1 + Math.exp(logodds(t2))) * trackRingSize + 3;
            const getRadian = (t2, s, e) => ((e - s) * t2 + s) / trackWidth;
            const _x = tcx + movingRadius(t) * Math.cos(-getRadian(t, x, xe) * 2 * Math.PI - Math.PI / 2);
            const _y = tcy + movingRadius(t) * Math.sin(-getRadian(t, x, xe) * 2 * Math.PI - Math.PI / 2);
            if (prevX && prevY) {
              g.lineStyle(
                strokeWidth,
                colorToHex(stroke),
                opacity,
                // alpha
                0.5
                // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
              );
              g.moveTo(prevX, prevY);
              g.lineTo(_x, _y);
            }
            prevX = _x;
            prevY = _y;
          }
          return;
        }
        g.moveTo(xe, rowPosition + rowHeight);
        g.lineTo(x, rowPosition);
      }
    });
  });
}
const SUPPORTED_CHANNELS = [
  "x",
  "xe",
  "x1",
  "x1e",
  "y",
  "ye",
  "y1",
  "y1e",
  "color",
  "size",
  "row",
  "stroke",
  "strokeWidth",
  "opacity",
  "text"
  // ...
];
function drawMark(HGC, trackInfo, tile, model) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  if (Is2DTrack(model.spec()) || IsVerticalRule(model.spec())) {
    const yScale = trackInfo._yScale.copy();
    yScale.range([yScale.range()[1], yScale.range()[0]]);
    ["y", "y1", "y1e", "ye"].forEach((d) => {
      model.setChannelScale(d, yScale);
    });
  }
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  switch (model.spec().mark) {
    case "point":
      drawPoint(trackInfo, tile.graphics, model);
      break;
    case "bar":
      drawBar(trackInfo, tile, model);
      break;
    case "line":
      drawLine(tile.graphics, model, trackWidth, trackHeight);
      break;
    case "area":
      drawArea(HGC, trackInfo, tile, model);
      break;
    case "rect":
      drawRect(HGC, trackInfo, tile, model);
      break;
    case "triangleLeft":
    case "triangleRight":
    case "triangleBottom":
      drawTriangle(tile.graphics, model, trackWidth, trackHeight);
      break;
    case "text":
      drawText(HGC, trackInfo, tile, model);
      break;
    case "rule":
      drawRule(HGC, trackInfo, tile, model);
      break;
    case "betweenLink":
      drawBetweenLink(tile.graphics, trackInfo, model);
      break;
    case "withinLink":
      drawWithinLink(tile.graphics, trackInfo, model);
      break;
    default:
      console.warn("Unsupported mark type");
      break;
  }
}
function drawPreEmbellishment(HGC, trackInfo, tile, model, theme) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  const isCircular = model.spec().layout === "circular";
  if (isCircular) {
    drawCircularOutlines(trackInfo, model, theme);
  } else {
    drawBackground(trackInfo, model, theme);
    drawChartOutlines(trackInfo, model, theme);
  }
  drawGrid(trackInfo, model, theme);
}
function drawPostEmbellishment(HGC, trackInfo, tile, model, theme) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  const isCircular = model.spec().layout === "circular";
  if (isCircular) {
    drawCircularYAxis(HGC, trackInfo, tile, model, theme);
    drawCircularTitle(HGC, trackInfo, tile, model, theme);
  } else {
    drawLinearYAxis(HGC, trackInfo, tile, model, theme);
    drawRowLegend(HGC, trackInfo, tile, model, theme);
  }
  drawColorLegend(HGC, trackInfo, tile, model, theme);
}
function resolveSuperposedTracks(track) {
  if (IsDataTrack(track) || IsDummyTrack(track)) {
    return [];
  }
  if (!IsOverlaidTrack(track)) {
    return [track];
  }
  if (track._overlay.length === 0) {
    return [{ ...track, superpose: void 0 }];
  }
  const base = JSON.parse(JSON.stringify(track));
  delete base._overlay;
  const resolved = [];
  track._overlay.forEach((subSpec, i) => {
    const spec = Object.assign(JSON.parse(JSON.stringify(base)), subSpec);
    if (spec.title && i !== 0) {
      delete spec.title;
    }
    resolved.push(spec);
  });
  let xAxisPosition = void 0;
  resolved.forEach((d) => {
    if (IsChannelDeep(d.x) && d.x.axis && !xAxisPosition) {
      xAxisPosition = d.x.axis;
    }
  });
  const corrected = resolved.map((d) => {
    return {
      ...d,
      x: { ...d.x, axis: xAxisPosition }
    };
  });
  return corrected;
}
function spreadTracksByData(tracks) {
  return [].concat(
    ...tracks.map((t) => {
      if (IsDataTrack(t) || !IsOverlaidTrack(t) || t._overlay.length <= 1) {
        return [t];
      }
      if (t._overlay.filter((s) => s.data).length === 0) {
        return [t];
      }
      if (isIdenticalDataSpec([t.data, ...t._overlay.map((s) => s.data)])) {
        return [t];
      }
      const base = { ...t, id: void 0, _overlay: void 0 };
      const spread = [];
      const original = JSON.parse(JSON.stringify(base));
      original._overlay = [];
      t._overlay.forEach((subSpec) => {
        if (!original.data) {
          original.data = subSpec.data;
        }
        if (!original.id) {
          original.id = subSpec.id;
        }
        if (!subSpec.data || isIdenticalDataSpec([original.data, subSpec.data])) {
          original._overlay.push(subSpec);
          return;
        }
        const spec = Object.assign(JSON.parse(JSON.stringify(base)), subSpec);
        spread.push(spec);
      });
      const output = original._overlay.length > 0 ? [original, ...spread] : spread;
      return output.map((track, i, arr) => {
        const overlayOnPreviousTrack = i !== 0;
        const y = IsSingleTrack(track) && IsChannelDeep(track.y) && !track.y.axis && overlayOnPreviousTrack ? { ...track.y, axis: i === 1 ? "right" : "none" } : IsSingleTrack(track) ? track.y : void 0;
        if (track.title && i !== arr.length - 1 && arr.length !== 1) {
          delete track.title;
        }
        return { ...track, overlayOnPreviousTrack, y };
      });
    })
  );
}
function isIdenticalDataSpec(specs) {
  if (specs.length === 0) {
    return false;
  }
  const definedSpecs = specs.filter((d) => d);
  if (definedSpecs.length !== specs.length) {
    return false;
  }
  const keys = Object.keys(definedSpecs[0]).sort();
  let isIdentical = true;
  keys.forEach((k) => {
    const uniqueProperties = Array.from(new Set(definedSpecs.map((d) => JSON.stringify(d[k]))));
    if (uniqueProperties.length !== 1) {
      isIdentical = false;
      return;
    }
  });
  return isIdentical;
}
const PREDEFINED_COLOR_STR_MAP = {
  viridis: interpolateViridis,
  grey: interpolateGreys,
  warm: interpolateWarm,
  spectral: interpolateSpectral,
  cividis: interpolateCividis,
  bupu: interpolateBuPu,
  rdbu: interpolateRdBu,
  hot: interpolateYlOrBr,
  pink: interpolateRdPu
};
function isObject(x) {
  return typeof x === "object" && x !== null;
}
function isTabularDataFetcher(dataFetcher) {
  return isObject(dataFetcher) && "getTabularData" in dataFetcher;
}
function hasDataTransform(spec, type2) {
  var _a;
  return ((_a = spec.dataTransform) != null ? _a : []).some((d) => d.type === type2);
}
function getHiGlassColorRange(colorStr = "viridis", step = 100) {
  var _a;
  const interpolate = (_a = PREDEFINED_COLOR_STR_MAP[colorStr]) != null ? _a : PREDEFINED_COLOR_STR_MAP["viridis"];
  return [...Array(step)].map((_, i) => interpolate(1 / step * i));
}
function IsFlatTracks(_) {
  return !("alignment" in _) && !_.tracks.find((d) => d.alignment === "overlay" || "tracks" in d);
}
function IsOverlaidTracks(_) {
  return "alignment" in _ && _.alignment === "overlay";
}
function IsStackedTracks(_) {
  return !IsFlatTracks(_) && !IsOverlaidTracks(_);
}
function IsDataTrack(_) {
  return !IsOverlaidTrack(_) && "data" in _ && !("mark" in _);
}
function IsDummyTrack(_) {
  return "type" in _ && _.type == "dummy-track";
}
function IsDataTemplate(_) {
  return !!("data" in _ && "overrideTemplate" in _ && _.overrideTemplate);
}
function IsDataDeep(data2) {
  return typeof data2 === "object";
}
function IsDomainChr(domain) {
  return "chromosome" in domain && !("interval" in domain);
}
function IsDomainInterval(domain) {
  return !("chromosome" in domain) && "interval" in domain;
}
function IsDomainChrInterval(domain) {
  return "chromosome" in domain && "interval" in domain;
}
function IsSingleTrack(track) {
  return !("_overlay" in track);
}
function IsOverlaidTrack(track) {
  return "_overlay" in track;
}
function IsTemplateTrack(track) {
  return "template" in track;
}
function IsVerticalRule(track) {
  return IsSingleTrack(track) && !IsChannelDeep(track.x) && IsChannelDeep(track.y) && track.y.type === "genomic";
}
function Is2DTrack(track) {
  const t = IsSingleTrack(track) ? track : resolveSuperposedTracks(track)[0];
  return IsChannelDeep(t.x) && t.x.type === "genomic" && IsChannelDeep(t.y) && t.y.type === "genomic";
}
function IsHiGlassMatrix(track) {
  return Is2DTrack(track) && track.data.type === "matrix" && (track.mark === "bar" || track.mark === "rect") && track.xe && track.ye;
}
function IsChannelValue(channel) {
  return channel !== null && typeof channel === "object" && "value" in channel;
}
function IsDataDeepTileset(_) {
  return _ !== void 0 && (_.type === "vector" || _.type === "beddb" || _.type === "multivec" || _.type === "bigwig" || _.type === "matrix" || _.type === "bam" || _.type === "vcf" || _.type === "gff" || _.type === "bed");
}
function IsChannelDeep(channel) {
  return isObject(channel) && !("value" in channel);
}
function IsOneOfFilter(_) {
  return "oneOf" in _;
}
function IsRangeFilter(_) {
  return "inRange" in _;
}
function IsIncludeFilter(_) {
  return "include" in _;
}
function IsDomainArray(domain) {
  return Array.isArray(domain);
}
function IsRangeArray(range) {
  return Array.isArray(range);
}
function IsStackedMark(track) {
  return (track.mark === "bar" || track.mark === "area" || track.mark === "text") && IsChannelDeep(track.color) && track.color.type === "nominal" && (!track.row || IsChannelValue(track.row)) && // TODO: determine whether to use stacked bar for nominal fields or not
  IsChannelDeep(track.y) && track.y.type === "quantitative" && !IsChannelDeep(track.ye);
}
function IsStackedChannel(track, channelKey) {
  const channel = track[channelKey];
  return IsStackedMark(track) && // only x or y channel can be stacked
  (channelKey === "x" || channelKey === "y") && // only quantitative channel can be stacked
  IsChannelDeep(channel) && channel.type === "quantitative";
}
function getValueUsingChannel(datum, channel) {
  if (IsChannelDeep(channel) && channel.field) {
    return datum[channel == null ? void 0 : channel.field];
  }
  return void 0;
}
function getChannelKeysByAggregateFnc(spec) {
  const keys = [];
  SUPPORTED_CHANNELS.forEach((k) => {
    const c = spec[k];
    if (IsChannelDeep(c) && "aggregate" in c) {
      keys.push(k);
    }
  });
  return keys;
}
function getChannelKeysByType(spec, t) {
  const keys = [];
  SUPPORTED_CHANNELS.forEach((k) => {
    const c = spec[k];
    if (IsChannelDeep(c) && c.type === t) {
      keys.push(k);
    }
  });
  return keys;
}
function IsXAxis(_) {
  if ((IsSingleTrack(_) || IsOverlaidTrack(_)) && IsChannelDeep(_.x) && _.x.axis && _.x.axis !== "none") {
    return true;
  } else if (IsOverlaidTrack(_)) {
    let isFound = false;
    _._overlay.forEach((t) => {
      if (isFound)
        return;
      if (IsChannelDeep(t.x) && t.x.axis && t.x.axis !== "none") {
        isFound = true;
      }
    });
    return isFound;
  }
  return false;
}
function IsYAxis(_) {
  if ((IsSingleTrack(_) || IsOverlaidTrack(_)) && IsChannelDeep(_.y) && _.y.axis && _.y.axis !== "none") {
    return true;
  } else if (IsOverlaidTrack(_)) {
    let isFound = false;
    _._overlay.forEach((t) => {
      if (isFound)
        return;
      if (IsChannelDeep(t.y) && t.y.axis && t.y.axis !== "none") {
        isFound = true;
      }
    });
    return isFound;
  }
  return false;
}
function IsMouseEventsDeep(_) {
  return typeof _ === "object";
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory2) {
    factory2(exports);
  })(commonjsGlobal, function(exports2) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray2(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign2(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err2) {
          _d = true;
          _e = err2;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (
          var w = 1, k = base;
          ;
          /* no condition */
          k += base
        ) {
          if (index >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err2) {
        _didIteratorError = true;
        _iteratorError = err2;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m2 = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m2) {
              m2 = currentValue;
            }
          }
        } catch (err2) {
          _didIteratorError2 = true;
          _iteratorError2 = err2;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (
                var k = base;
                ;
                /* no condition */
                k += base
              ) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                var qMinusT = q - t;
                var baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err2) {
          _didIteratorError3 = true;
          _iteratorError3 = err2;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign2({ scheme: "null" }, options);
      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse(uri2, options), options);
      } else if (typeOf(uri2) === "object") {
        uri2 = parse(serialize(uri2, options), options);
      }
      return uri2;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse2(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse2(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path && path !== "/" ? path : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray2(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name2 in headers) {
          if (headers[name2] !== O[name2]) {
            fields.push(name2.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name2].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID2 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse2(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID2))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
var uri_allExports = uri_all.exports;
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var ucs2length$1 = function ucs2length(str) {
  var length = 0, len = str.length, pos = 0, value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) == 56320)
        pos++;
    }
  }
  return length;
};
var util$5 = {
  copy,
  checkDataType,
  checkDataTypes,
  coerceToTypes,
  toHash: toHash$1,
  getProperty,
  escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length$1,
  varOccurences,
  varReplace,
  schemaHasRules,
  schemaHasRulesExcept,
  schemaUnknownRules,
  toQuotedString,
  getPathExpr,
  getPath,
  getData,
  unescapeFragment,
  unescapeJsonPointer,
  escapeFragment,
  escapeJsonPointer
};
function copy(o, to) {
  to = to || {};
  for (var key in o)
    to[key] = o[key];
  return to;
}
function checkDataType(dataType, data2, strictNumbers, negate) {
  var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
  switch (dataType) {
    case "null":
      return data2 + EQUAL + "null";
    case "array":
      return OK + "Array.isArray(" + data2 + ")";
    case "object":
      return "(" + OK + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
    case "integer":
      return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
    case "number":
      return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
    default:
      return "typeof " + data2 + EQUAL + '"' + dataType + '"';
  }
}
function checkDataTypes(dataTypes, data2, strictNumbers) {
  switch (dataTypes.length) {
    case 1:
      return checkDataType(dataTypes[0], data2, strictNumbers, true);
    default:
      var code = "";
      var types = toHash$1(dataTypes);
      if (types.array && types.object) {
        code = types.null ? "(" : "(!" + data2 + " || ";
        code += "typeof " + data2 + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number)
        delete types.integer;
      for (var t in types)
        code += (code ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
      return code;
  }
}
var COERCE_TO_TYPES = toHash$1(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i = 0; i < dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t])
        types[types.length] = t;
      else if (optionCoerceTypes === "array" && t === "array")
        types[types.length] = t;
    }
    if (types.length)
      return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === "array" && dataTypes === "array") {
    return ["array"];
  }
}
function toHash$1(arr) {
  var hash = {};
  for (var i = 0; i < arr.length; i++)
    hash[arr[i]] = true;
  return hash;
}
var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == "number" ? "[" + key + "]" : IDENTIFIER$1.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
}
function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function varOccurences(str, dataVar) {
  dataVar += "[^0-9]";
  var matches = str.match(new RegExp(dataVar, "g"));
  return matches ? matches.length : 0;
}
function varReplace(str, dataVar, expr) {
  dataVar += "([^0-9])";
  expr = expr.replace(/\$/g, "$$$$");
  return str.replace(new RegExp(dataVar, "g"), expr + "$1");
}
function schemaHasRules(schema, rules3) {
  if (typeof schema == "boolean")
    return !schema;
  for (var key in schema)
    if (rules3[key])
      return true;
}
function schemaHasRulesExcept(schema, rules3, exceptKeyword) {
  if (typeof schema == "boolean")
    return !schema && exceptKeyword != "not";
  for (var key in schema)
    if (key != exceptKeyword && rules3[key])
      return true;
}
function schemaUnknownRules(schema, rules3) {
  if (typeof schema == "boolean")
    return;
  for (var key in schema)
    if (!rules3[key])
      return key;
}
function toQuotedString(str) {
  return "'" + escapeQuotes(str) + "'";
}
function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
  return joinPaths(currentPath, path);
}
function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}
var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data2, matches;
  if ($data === "")
    return "rootData";
  if ($data[0] == "/") {
    if (!JSON_POINTER$1.test($data))
      throw new Error("Invalid JSON-pointer: " + $data);
    jsonPointer = $data;
    data2 = "rootData";
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER$1);
    if (!matches)
      throw new Error("Invalid JSON-pointer: " + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == "#") {
      if (up >= lvl)
        throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
      return paths[lvl - up];
    }
    if (up > lvl)
      throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
    data2 = "data" + (lvl - up || "");
    if (!jsonPointer)
      return data2;
  }
  var expr = data2;
  var segments = jsonPointer.split("/");
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data2 += getProperty(unescapeJsonPointer(segment));
      expr += " && " + data2;
    }
  }
  return expr;
}
function joinPaths(a, b) {
  if (a == '""')
    return b;
  return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
}
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
function escapeJsonPointer(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
var util$4 = util$5;
var schema_obj = SchemaObject$2;
function SchemaObject$2(obj) {
  util$4.copy(obj, this);
}
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
var URI$1 = uri_allExports, equal$1 = fastDeepEqual, util$3 = util$5, SchemaObject$1 = schema_obj, traverse = jsonSchemaTraverseExports;
var resolve_1 = resolve$3;
resolve$3.normalizeId = normalizeId;
resolve$3.fullPath = getFullPath;
resolve$3.url = resolveUrl;
resolve$3.ids = resolveIds;
resolve$3.inlineRef = inlineRef;
resolve$3.schema = resolveSchema;
function resolve$3(compile2, root, ref2) {
  var refVal = this._refs[ref2];
  if (typeof refVal == "string") {
    if (this._refs[refVal])
      refVal = this._refs[refVal];
    else
      return resolve$3.call(this, compile2, root, refVal);
  }
  refVal = refVal || this._schemas[ref2];
  if (refVal instanceof SchemaObject$1) {
    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
  }
  var res = resolveSchema.call(this, root, ref2);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }
  if (schema instanceof SchemaObject$1) {
    v = schema.validate || compile2.call(this, schema.schema, root, void 0, baseId);
  } else if (schema !== void 0) {
    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile2.call(this, schema, root, void 0, baseId);
  }
  return v;
}
function resolveSchema(root, ref2) {
  var p = URI$1.parse(ref2), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == "string") {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject$1) {
      if (!refVal.validate)
        this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject$1) {
        if (!refVal.validate)
          this._compile(refVal);
        if (id == normalizeId(ref2))
          return { schema: refVal, root, baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema)
      return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}
function resolveRecursive(root, ref2, parsedRef) {
  var res = resolveSchema.call(this, root, ref2);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id)
      baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}
var PREVENT_SCOPE_CHANGE = util$3.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
function getJsonPointer(parsedRef, baseId, schema, root) {
  parsedRef.fragment = parsedRef.fragment || "";
  if (parsedRef.fragment.slice(0, 1) != "/")
    return;
  var parts = parsedRef.fragment.split("/");
  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util$3.unescapeFragment(part);
      schema = schema[part];
      if (schema === void 0)
        break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref2 = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref2);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== void 0 && schema !== root.schema)
    return { schema, root, baseId };
}
var SIMPLE_INLINED = util$3.toHash([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum"
]);
function inlineRef(schema, limit) {
  if (limit === false)
    return false;
  if (limit === void 0 || limit === true)
    return checkNoRef(schema);
  else if (limit)
    return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == "object" && !checkNoRef(item))
        return false;
    }
  } else {
    for (var key in schema) {
      if (key == "$ref")
        return false;
      item = schema[key];
      if (typeof item == "object" && !checkNoRef(item))
        return false;
    }
  }
  return true;
}
function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == "object")
        count += countKeys(item);
      if (count == Infinity)
        return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == "$ref")
        return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == "object")
          count += countKeys(item) + 1;
        if (count == Infinity)
          return Infinity;
      }
    }
  }
  return count;
}
function getFullPath(id, normalize) {
  if (normalize !== false)
    id = normalizeId(id);
  var p = URI$1.parse(id);
  return _getFullPath(p);
}
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI$1.resolve(baseId, id);
}
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = { "": schemaId };
  var fullPaths = { "": getFullPath(schemaId, false) };
  var localRefs = {};
  var self2 = this;
  traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === "")
      return;
    var id = self2._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
    if (keyIndex !== void 0)
      fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util$3.escapeFragment(keyIndex));
    if (typeof id == "string") {
      id = baseId = normalizeId(baseId ? URI$1.resolve(baseId, id) : id);
      var refVal = self2._refs[id];
      if (typeof refVal == "string")
        refVal = self2._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal$1(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == "#") {
          if (localRefs[id] && !equal$1(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self2._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });
  return localRefs;
}
var resolve$2 = resolve_1;
var error_classes = {
  Validation: errorSubclass(ValidationError$1),
  MissingRef: errorSubclass(MissingRefError$1)
};
function ValidationError$1(errors) {
  this.message = "validation failed";
  this.errors = errors;
  this.ajv = this.validation = true;
}
MissingRefError$1.message = function(baseId, ref2) {
  return "can't resolve reference " + ref2 + " from id " + baseId;
};
function MissingRefError$1(baseId, ref2, message) {
  this.message = message || MissingRefError$1.message(baseId, ref2);
  this.missingRef = resolve$2.url(baseId, ref2);
  this.missingSchema = resolve$2.normalizeId(resolve$2.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}
var fastJsonStableStringify = function(data2, opts) {
  if (!opts)
    opts = {};
  if (typeof opts === "function")
    opts = { cmp: opts };
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var cmp = opts.cmp && function(f) {
    return function(node) {
      return function(a, b) {
        var aobj = { key: a, value: node[a] };
        var bobj = { key: b, value: node[b] };
        return f(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen = [];
  return function stringify(node) {
    if (node && node.toJSON && typeof node.toJSON === "function") {
      node = node.toJSON();
    }
    if (node === void 0)
      return;
    if (typeof node == "number")
      return isFinite(node) ? "" + node : "null";
    if (typeof node !== "object")
      return JSON.stringify(node);
    var i, out;
    if (Array.isArray(node)) {
      out = "[";
      for (i = 0; i < node.length; i++) {
        if (i)
          out += ",";
        out += stringify(node[i]) || "null";
      }
      return out + "]";
    }
    if (node === null)
      return "null";
    if (seen.indexOf(node) !== -1) {
      if (cycles)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    var seenIndex = seen.push(node) - 1;
    var keys = Object.keys(node).sort(cmp && cmp(node));
    out = "";
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = stringify(node[key]);
      if (!value)
        continue;
      if (out)
        out += ",";
      out += JSON.stringify(key) + ":" + value;
    }
    seen.splice(seenIndex, 1);
    return "{" + out + "}";
  }(data2);
};
var validate$1 = function generate_validate(it, $keyword, $ruleType) {
  var out = "";
  var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id2 = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = "unknown keyword: " + $unknownKwd;
      if (it.opts.strictKeywords === "log")
        it.logger.warn($keywordsMsg);
      else
        throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += " var validate = ";
    if ($async) {
      it.async = true;
      out += "async ";
    }
    out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
    if ($id2 && (it.opts.sourceCode || it.opts.processCode)) {
      out += " " + ("/*# sourceURL=" + $id2 + " */") + " ";
    }
  }
  if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
    var $keyword = "false schema";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += " var " + $valid + " = false; ";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'boolean schema is false' ";
        }
        if (it.opts.verbose) {
          out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += " return data; ";
        } else {
          out += " validate.errors = null; return true; ";
        }
      } else {
        out += " var " + $valid + " = true; ";
      }
    }
    if (it.isTop) {
      out += " }; return validate; ";
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];
    if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = "default is ignored in the schema root";
      if (it.opts.strictDefaults === "log")
        it.logger.warn($defaultMsg);
      else
        throw new Error($defaultMsg);
    }
    out += " var vErrors = null; ";
    out += " var errors = 0;     ";
    out += " if (rootData === undefined) rootData = data; ";
  } else {
    var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
    if ($id2)
      it.baseId = it.resolve.url(it.baseId, $id2);
    if ($async && !it.async)
      throw new Error("async schema in sync schema");
    out += " var errs_" + $lvl + " = errors;";
  }
  var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
  var $errorKeyword;
  var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf("null") == -1)
        $typeSchema = $typeSchema.concat("null");
    } else if ($typeSchema != "null") {
      $typeSchema = [$typeSchema, "null"];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == "fail") {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += " " + it.RULES.all.$comment.code(it, "$comment");
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
      var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
      var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
      out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
      if ($coerceToTypes) {
        var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
        out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
        if (it.opts.coerceTypes == "array") {
          out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
        }
        out += " if (" + $coerced + " !== undefined) ; ";
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($type == "string") {
              out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
            } else if ($type == "number" || $type == "integer") {
              out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
              if ($type == "integer") {
                out += " && !(" + $data + " % 1)";
              }
              out += ")) " + $coerced + " = +" + $data + "; ";
            } else if ($type == "boolean") {
              out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
            } else if ($type == "null") {
              out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
            } else if (it.opts.coerceTypes == "array" && $type == "array") {
              out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
            }
          }
        }
        out += " else {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
          if ($typeIsArray) {
            out += "" + $typeSchema.join(",");
          } else {
            out += "" + $typeSchema;
          }
          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } if (" + $coerced + " !== undefined) {  ";
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " " + $data + " = " + $coerced + "; ";
        if (!$dataLvl) {
          out += "if (" + $parentData + " !== undefined)";
        }
        out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
          if ($typeIsArray) {
            out += "" + $typeSchema.join(",");
          } else {
            out += "" + $typeSchema;
          }
          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      }
      out += " } ";
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
    if ($breakOnError) {
      out += " } if (errors === ";
      if ($top) {
        out += "0";
      } else {
        out += "errs_" + $lvl;
      }
      out += ") { ";
      $closingBraces2 += "}";
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == "object" && it.schema.properties) {
              var $schema2 = it.schema.properties, $schemaKeys = Object.keys($schema2);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema2[$propertyKey];
                  if ($sch.default !== void 0) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = "default is ignored for: " + $passData;
                        if (it.opts.strictDefaults === "log")
                          it.logger.warn($defaultMsg);
                        else
                          throw new Error($defaultMsg);
                      }
                    } else {
                      out += " if (" + $passData + " === undefined ";
                      if (it.opts.useDefaults == "empty") {
                        out += " || " + $passData + " === null || " + $passData + " === '' ";
                      }
                      out += " ) " + $passData + " = ";
                      if (it.opts.useDefaults == "shared") {
                        out += " " + it.useDefault($sch.default) + " ";
                      } else {
                        out += " " + JSON.stringify($sch.default) + " ";
                      }
                      out += "; ";
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1, l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== void 0) {
                    var $passData = $data + "[" + $i + "]";
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = "default is ignored for: " + $passData;
                        if (it.opts.strictDefaults === "log")
                          it.logger.warn($defaultMsg);
                        else
                          throw new Error($defaultMsg);
                      }
                    } else {
                      out += " if (" + $passData + " === undefined ";
                      if (it.opts.useDefaults == "empty") {
                        out += " || " + $passData + " === null || " + $passData + " === '' ";
                      }
                      out += " ) " + $passData + " = ";
                      if (it.opts.useDefaults == "shared") {
                        out += " " + it.useDefault($sch.default) + " ";
                      } else {
                        out += " " + JSON.stringify($sch.default) + " ";
                      }
                      out += "; ";
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1, l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += " " + $code + " ";
                  if ($breakOnError) {
                    $closingBraces1 += "}";
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += " " + $closingBraces1 + " ";
            $closingBraces1 = "";
          }
          if ($rulesGroup.type) {
            out += " } ";
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += " else { ";
              var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } ";
            }
          }
          if ($breakOnError) {
            out += " if (errors === ";
            if ($top) {
              out += "0";
            } else {
              out += "errs_" + $lvl;
            }
            out += ") { ";
            $closingBraces2 += "}";
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += " " + $closingBraces2 + " ";
  }
  if ($top) {
    if ($async) {
      out += " if (errors === 0) return data;           ";
      out += " else throw new ValidationError(vErrors); ";
    } else {
      out += " validate.errors = vErrors; ";
      out += " return errors === 0;       ";
    }
    out += " }; return validate;";
  } else {
    out += " var " + $valid + " = errors === errs_" + $lvl + ";";
  }
  function $shouldUseGroup($rulesGroup2) {
    var rules3 = $rulesGroup2.rules;
    for (var i = 0; i < rules3.length; i++)
      if ($shouldUseRule(rules3[i]))
        return true;
  }
  function $shouldUseRule($rule2) {
    return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
  }
  function $ruleImplementsSomeKeyword($rule2) {
    var impl = $rule2.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== void 0)
        return true;
  }
  return out;
};
var resolve$1 = resolve_1, util$2 = util$5, errorClasses$1 = error_classes, stableStringify$1 = fastJsonStableStringify;
var validateGenerator = validate$1;
var ucs2length2 = util$2.ucs2length;
var equal2 = fastDeepEqual;
var ValidationError = errorClasses$1.Validation;
var compile_1 = compile$2;
function compile$2(schema, root, localRefs, baseId) {
  var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
  root = root || { schema, refVal, refs };
  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling)
    return compilation.callValidate = callValidate;
  var formats2 = this._formats;
  var RULES = this.RULES;
  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode)
        cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }
  function callValidate() {
    var validate2 = compilation.validate;
    var result = validate2.apply(this, arguments);
    callValidate.errors = validate2.errors;
    return result;
  }
  function localCompile(_schema, _root, localRefs2, baseId2) {
    var isRoot = !_root || _root && _root.schema == _schema;
    if (_root.schema != root.schema)
      return compile$2.call(self2, _schema, _root, localRefs2, baseId2);
    var $async = _schema.$async === true;
    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot,
      baseId: baseId2,
      root: _root,
      schemaPath: "",
      errSchemaPath: "#",
      errorPath: '""',
      MissingRefError: errorClasses$1.MissingRef,
      RULES,
      validate: validateGenerator,
      util: util$2,
      resolve: resolve$1,
      resolveRef,
      usePattern,
      useDefault,
      useCustomRule,
      opts,
      formats: formats2,
      logger: self2.logger,
      self: self2
    });
    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode$1) + sourceCode;
    if (opts.processCode)
      sourceCode = opts.processCode(sourceCode, _schema);
    var validate2;
    try {
      var makeValidate = new Function(
        "self",
        "RULES",
        "formats",
        "root",
        "refVal",
        "defaults",
        "customRules",
        "equal",
        "ucs2length",
        "ValidationError",
        sourceCode
      );
      validate2 = makeValidate(
        self2,
        RULES,
        formats2,
        root,
        refVal,
        defaults,
        customRules,
        equal2,
        ucs2length2,
        ValidationError
      );
      refVal[0] = validate2;
    } catch (e) {
      self2.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    }
    validate2.schema = _schema;
    validate2.errors = null;
    validate2.refs = refs;
    validate2.refVal = refVal;
    validate2.root = isRoot ? validate2 : _root;
    if ($async)
      validate2.$async = true;
    if (opts.sourceCode === true) {
      validate2.source = {
        code: sourceCode,
        patterns,
        defaults
      };
    }
    return validate2;
  }
  function resolveRef(baseId2, ref2, isRoot) {
    ref2 = resolve$1.url(baseId2, ref2);
    var refIndex = refs[ref2];
    var _refVal, refCode;
    if (refIndex !== void 0) {
      _refVal = refVal[refIndex];
      refCode = "refVal[" + refIndex + "]";
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref2];
      if (rootRefId !== void 0) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref2, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }
    refCode = addLocalRef(ref2);
    var v2 = resolve$1.call(self2, localCompile, root, ref2);
    if (v2 === void 0) {
      var localSchema = localRefs && localRefs[ref2];
      if (localSchema) {
        v2 = resolve$1.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile$2.call(self2, localSchema, root, localRefs, baseId2);
      }
    }
    if (v2 === void 0) {
      removeLocalRef(ref2);
    } else {
      replaceLocalRef(ref2, v2);
      return resolvedRef(v2, refCode);
    }
  }
  function addLocalRef(ref2, v2) {
    var refId = refVal.length;
    refVal[refId] = v2;
    refs[ref2] = refId;
    return "refVal" + refId;
  }
  function removeLocalRef(ref2) {
    delete refs[ref2];
  }
  function replaceLocalRef(ref2, v2) {
    var refId = refs[ref2];
    refVal[refId] = v2;
  }
  function resolvedRef(refVal2, code) {
    return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
  }
  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === void 0) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return "pattern" + index;
  }
  function useDefault(value) {
    switch (typeof value) {
      case "boolean":
      case "number":
        return "" + value;
      case "string":
        return util$2.toQuotedString(value);
      case "object":
        if (value === null)
          return "null";
        var valueStr = stableStringify$1(value);
        var index = defaultsHash[valueStr];
        if (index === void 0) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return "default" + index;
    }
  }
  function useCustomRule(rule, schema2, parentSchema, it) {
    if (self2._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword2) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword2);
      }))
        throw new Error("parent schema must have all required keywords: " + deps.join(","));
      var validateSchema2 = rule.definition.validateSchema;
      if (validateSchema2) {
        var valid = validateSchema2(schema2);
        if (!valid) {
          var message = "keyword schema is invalid: " + self2.errorsText(validateSchema2.errors);
          if (self2._opts.validateSchema == "log")
            self2.logger.error(message);
          else
            throw new Error(message);
        }
      }
    }
    var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
    var validate2;
    if (compile2) {
      validate2 = compile2.call(self2, schema2, parentSchema, it);
    } else if (macro) {
      validate2 = macro.call(self2, schema2, parentSchema, it);
      if (opts.validateSchema !== false)
        self2.validateSchema(validate2, true);
    } else if (inline) {
      validate2 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
    } else {
      validate2 = rule.definition.validate;
      if (!validate2)
        return;
    }
    if (validate2 === void 0)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
    var index = customRules.length;
    customRules[index] = validate2;
    return {
      code: "customRule" + index,
      validate: validate2
    };
  }
}
function checkCompiling(schema, root, baseId) {
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0)
    return { index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema,
    root,
    baseId
  };
  return { index, compiling: false };
}
function endCompiling(schema, root, baseId) {
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0)
    this._compilations.splice(i, 1);
}
function compIndex(schema, root, baseId) {
  for (var i = 0; i < this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId)
      return i;
  }
  return -1;
}
function patternCode(i, patterns) {
  return "var pattern" + i + " = new RegExp(" + util$2.toQuotedString(patterns[i]) + ");";
}
function defaultCode(i) {
  return "var default" + i + " = defaults[" + i + "];";
}
function refValCode(i, refVal) {
  return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
}
function customRuleCode$1(i) {
  return "var customRule" + i + " = customRules[" + i + "];";
}
function vars(arr, statement) {
  if (!arr.length)
    return "";
  var code = "";
  for (var i = 0; i < arr.length; i++)
    code += statement(i, arr);
  return code;
}
var cache = { exports: {} };
var Cache$1 = cache.exports = function Cache() {
  this._cache = {};
};
Cache$1.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};
Cache$1.prototype.get = function Cache_get(key) {
  return this._cache[key];
};
Cache$1.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};
Cache$1.prototype.clear = function Cache_clear() {
  this._cache = {};
};
var cacheExports = cache.exports;
var util$1 = util$5;
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME$1 = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL$1 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var formats_1 = formats$1;
function formats$1(mode) {
  mode = mode == "full" ? "full" : "fast";
  return util$1.copy(formats$1[mode]);
}
formats$1.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  "uri-template": URITEMPLATE,
  url: URL$1,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  "json-pointer": JSON_POINTER,
  "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  "relative-json-pointer": RELATIVE_JSON_POINTER
};
formats$1.full = {
  date,
  time,
  "date-time": date_time,
  uri,
  "uri-reference": URIREF,
  "uri-template": URITEMPLATE,
  url: URL$1,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex,
  uuid: UUID,
  "json-pointer": JSON_POINTER,
  "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
  "relative-json-pointer": RELATIVE_JSON_POINTER
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
  var matches = str.match(DATE);
  if (!matches)
    return false;
  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(str, full) {
  var matches = str.match(TIME$1);
  if (!matches)
    return false;
  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}
var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $async, $refCode;
  if ($schema2 == "#" || $schema2 == "#/") {
    if (it.isRoot) {
      $async = it.async;
      $refCode = "validate";
    } else {
      $async = it.root.schema.$async === true;
      $refCode = "root.refVal[0]";
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema2, it.isRoot);
    if ($refVal === void 0) {
      var $message = it.MissingRefError.message(it.baseId, $schema2);
      if (it.opts.missingRefs == "fail") {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema2) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema2) + "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: " + it.util.toQuotedString($schema2) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        if ($breakOnError) {
          out += " if (false) { ";
        }
      } else if (it.opts.missingRefs == "ignore") {
        it.logger.warn($message);
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema2, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = "";
      $it.errSchemaPath = $schema2;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += " " + $code + " ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
      }
    } else {
      $async = $refVal.$async === true || it.async && $refVal.$async !== false;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.opts.passContext) {
      out += " " + $refCode + ".call(this, ";
    } else {
      out += " " + $refCode + "( ";
    }
    out += " " + $data + ", (dataPath || '')";
    if (it.errorPath != '""') {
      out += " + " + it.errorPath;
    }
    var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
    out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async)
        throw new Error("async schema referenced by sync schema");
      if ($breakOnError) {
        out += " var " + $valid + "; ";
      }
      out += " try { await " + __callValidate + "; ";
      if ($breakOnError) {
        out += " " + $valid + " = true; ";
      }
      out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
      if ($breakOnError) {
        out += " " + $valid + " = false; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " if (" + $valid + ") { ";
      }
    } else {
      out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
  }
  return out;
};
var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = " ";
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
  var arr1 = $schema2;
  if (arr1) {
    var $sch, $i = -1, l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += " if (true) { ";
    } else {
      out += " " + $closingBraces.slice(0, -1) + " ";
    }
  }
  return out;
};
var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $noEmptySchema = $schema2.every(function($sch2) {
    return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
        $closingBraces += "}";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match some schema in anyOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) {
      out += " } ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = " ";
  var $schema2 = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema2);
  if (it.opts.$comment === true) {
    out += " console.log(" + $comment + ");";
  } else if (typeof it.opts.$comment == "function") {
    out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
  }
  return out;
};
var _const = function generate_const(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  if (!$isData) {
    out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
  }
  out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be equal to constant' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " }";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all);
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + "[" + $idx + "]";
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    out += " if (" + $nextValid + ") break; }  ";
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $closingBraces + " if (!" + $nextValid + ") {";
  } else {
    out += " if (" + $data + ".length == 0) {";
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
    if (it.opts.messages !== false) {
      out += " , message: 'should contain a valid item' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } else { ";
  if ($nonEmptySchema) {
    out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
  }
  if (it.opts.allErrors) {
    out += " } ";
  }
  return out;
};
var dependencies = function generate_dependencies(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
  for ($property in $schema2) {
    if ($property == "__proto__")
      continue;
    var $sch = $schema2[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += "var " + $errs + " = errors;";
  var $currentErrorPath = it.errorPath;
  out += "var missing" + $lvl + ";";
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
      if ($ownProperties) {
        out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
      }
      if ($breakOnError) {
        out += " && ( ";
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += " || ";
            }
            var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
            out += " ( ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
          }
        }
        out += ")) {  ";
        var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should have ";
            if ($deps.length == 1) {
              out += "property " + it.util.escapeQuotes($deps[0]);
            } else {
              out += "properties " + it.util.escapeQuotes($deps.join(", "));
            }
            out += " when property " + it.util.escapeQuotes($property) + " is present' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        out += " ) { ";
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += " if ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
        }
      }
      out += " }   ";
      if ($breakOnError) {
        $closingBraces += "}";
        out += " else { ";
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
      out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
      if ($ownProperties) {
        out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
      }
      out += ") { ";
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
  }
  if ($breakOnError) {
    out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
  if (!$isData) {
    out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
  }
  out += "var " + $valid + ";";
  if ($isData) {
    out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
  }
  out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
  if ($isData) {
    out += "  }  ";
  }
  out += " if (!" + $valid + ") {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be equal to one of the allowed values' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " }";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var format$1 = function generate_format(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += " if (true) { ";
    }
    return out;
  }
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
    out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
    if (it.async) {
      out += " var async" + $lvl + " = " + $format + ".async; ";
    }
    out += " " + $format + " = " + $format + ".validate; } if (  ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " (";
    if ($unknownFormats != "ignore") {
      out += " (" + $schemaValue + " && !" + $format + " ";
      if ($allowUnknown) {
        out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
      }
      out += ") || ";
    }
    out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
    if (it.async) {
      out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
    } else {
      out += " " + $format + "(" + $data + ") ";
    }
    out += " : " + $format + ".test(" + $data + "))))) {";
  } else {
    var $format = it.formats[$schema2];
    if (!$format) {
      if ($unknownFormats == "ignore") {
        it.logger.warn('unknown format "' + $schema2 + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema2) >= 0) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema2 + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || "string";
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    if ($async) {
      if (!it.async)
        throw new Error("async format in sync schema");
      var $formatRef = "formats" + it.util.getProperty($schema2) + ".validate";
      out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
    } else {
      out += " if (! ";
      var $formatRef = "formats" + it.util.getProperty($schema2);
      if ($isObject)
        $formatRef += ".validate";
      if (typeof $format == "function") {
        out += " " + $formatRef + "(" + $data + ") ";
      } else {
        out += " " + $formatRef + ".test(" + $data + ") ";
      }
      out += ") { ";
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
    if ($isData) {
      out += "" + $schemaValue;
    } else {
      out += "" + it.util.toQuotedString($schema2);
    }
    out += "  } ";
    if (it.opts.messages !== false) {
      out += ` , message: 'should match format "`;
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + it.util.escapeQuotes($schema2);
      }
      out += `"' `;
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _if = function generate_if(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += "  " + it.validate($it) + " ";
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += " if (" + $nextValid + ") {  ";
      $it.schema = it.schema["then"];
      $it.schemaPath = it.schemaPath + ".then";
      $it.errSchemaPath = it.errSchemaPath + "/then";
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " " + $valid + " = " + $nextValid + "; ";
      if ($thenPresent && $elsePresent) {
        $ifClause = "ifClause" + $lvl;
        out += " var " + $ifClause + " = 'then'; ";
      } else {
        $ifClause = "'then'";
      }
      out += " } ";
      if ($elsePresent) {
        out += " else { ";
      }
    } else {
      out += " if (!" + $nextValid + ") { ";
    }
    if ($elsePresent) {
      $it.schema = it.schema["else"];
      $it.schemaPath = it.schemaPath + ".else";
      $it.errSchemaPath = it.errSchemaPath + "/else";
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " " + $valid + " = " + $nextValid + "; ";
      if ($thenPresent && $elsePresent) {
        $ifClause = "ifClause" + $lvl;
        out += " var " + $ifClause + " = 'else'; ";
      } else {
        $ifClause = "'else'";
      }
      out += " } ";
    }
    out += " if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += " }   ";
    if ($breakOnError) {
      out += " else { ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var items = function generate_items(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if (Array.isArray($schema2)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += " " + $valid + " = " + $data + ".length <= " + $schema2.length + "; ";
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + "/additionalItems";
      out += "  if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema2.length + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have more than " + $schema2.length + " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += "}";
        out += " else { ";
      }
    }
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
          var $passData = $data + "[" + $i + "]";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + ".additionalItems";
      $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
      out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema2.length + ") {  for (var " + $idx + " = " + $schema2.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " } }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
  } else if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + "[" + $idx + "]";
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    if ($breakOnError) {
      out += " if (!" + $nextValid + ") break; ";
    }
    out += " }";
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
  if (!($isData || typeof $schema2 == "number" || $schema2 === void 0)) {
    throw new Error($keyword + " must be number");
  }
  if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
    throw new Error($exclusiveKeyword + " must be number or boolean");
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
    out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
    $schemaValueExcl = "schemaExcl" + $lvl;
    out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
    if ($schema2 === void 0) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = "'" + $opStr + "'";
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
    } else {
      if ($exclIsNumber && $schema2 === void 0) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += "=";
      } else {
        if ($exclIsNumber)
          $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema2);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $notOp += "=";
        } else {
          $exclusive = false;
          $opStr += "=";
        }
      }
      var $opExpr = "'" + $opStr + "'";
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be " + $opStr + " ";
      if ($isData) {
        out += "' + " + $schemaValue;
      } else {
        out += "" + $schemaValue + "'";
      }
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxItems" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      if ($keyword == "maxItems") {
        out += "more";
      } else {
        out += "fewer";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " items' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxLength" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  if (it.opts.unicode === false) {
    out += " " + $data + ".length ";
  } else {
    out += " ucs2length(" + $data + ") ";
  }
  out += " " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT be ";
      if ($keyword == "maxLength") {
        out += "longer";
      } else {
        out += "shorter";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " characters' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxProperties" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      if ($keyword == "maxProperties") {
        out += "more";
      } else {
        out += "fewer";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " properties' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  out += "var division" + $lvl + ";if (";
  if ($isData) {
    out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
  }
  out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
  if (it.opts.multipleOfPrecision) {
    out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
  } else {
    out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
  }
  out += " ) ";
  if ($isData) {
    out += "  )  ";
  }
  out += " ) {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be multiple of ";
      if ($isData) {
        out += "' + " + $schemaValue;
      } else {
        out += "" + $schemaValue + "'";
      }
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var not = function generate_not(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = "valid" + $it.level;
  if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $errs + " = errors;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += " " + it.validate($it) + " ";
    $it.createErrors = true;
    if ($allErrorsOption)
      $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " if (" + $nextValid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be valid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) {
      out += " } ";
    }
  } else {
    out += "  var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be valid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if ($breakOnError) {
      out += " if (false) { ";
    }
  }
  return out;
};
var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
  out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema2;
  if (arr1) {
    var $sch, $i = -1, l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
      } else {
        out += " var " + $nextValid + " = true; ";
      }
      if ($i) {
        out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
        $closingBraces += "}";
      }
      out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
  if (it.createErrors !== false) {
    out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should match exactly one schema in oneOf' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError(vErrors); ";
    } else {
      out += " validate.errors = vErrors; return false; ";
    }
  }
  out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
  if (it.opts.allErrors) {
    out += " } ";
  }
  return out;
};
var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema2);
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
  }
  out += " !" + $regexp + ".test(" + $data + ") ) {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
    if ($isData) {
      out += "" + $schemaValue;
    } else {
      out += "" + it.util.toQuotedString($schema2);
    }
    out += "  } ";
    if (it.opts.messages !== false) {
      out += ` , message: 'should match pattern "`;
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + it.util.escapeQuotes($schema2);
      }
      out += `"' `;
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var properties$2 = function generate_properties(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
  var $schemaKeys = Object.keys($schema2 || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }
  function notProto(p) {
    return p !== "__proto__";
  }
  out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
  if ($ownProperties) {
    out += " var " + $dataProperties + " = undefined;";
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
    } else {
      out += " for (var " + $key + " in " + $data + ") { ";
    }
    if ($someProperties) {
      out += " var isAdditional" + $lvl + " = !(false ";
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1, l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
          }
        }
      }
      out += " ); if (isAdditional" + $lvl + ") { ";
    }
    if ($removeAdditional == "all") {
      out += " delete " + $data + "[" + $key + "]; ";
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = "' + " + $key + " + '";
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          out += " " + $nextValid + " = false; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalProperties";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is an invalid additional property";
              } else {
                out += "should NOT have additional properties";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += " break; ";
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == "failing") {
          out += " var " + $errs + " = errors;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + ".additionalProperties";
          $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + ".additionalProperties";
          $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += " } ";
    }
    out += " }  ";
    if ($breakOnError) {
      out += " if (" + $nextValid + ") { ";
      $closingBraces += "}";
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1, l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema2[$propertyKey];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += " var " + $nextData + " = " + $passData + "; ";
          }
          if ($hasDefault) {
            out += " " + $code + " ";
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") { " + $nextValid + " = false; ";
              var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + "/required";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += " } else { ";
            } else {
              if ($breakOnError) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = true; } else { ";
              } else {
                out += " if (" + $useData + " !== undefined ";
                if ($ownProperties) {
                  out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += " ) { ";
              }
            }
            out += " " + $code + " } ";
          }
        }
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1, l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " else " + $nextValid + " = true; ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  out += "var " + $errs + " = errors;";
  if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined; ";
    }
    if ($ownProperties) {
      out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
    } else {
      out += " for (var " + $key + " in " + $data + ") { ";
    }
    out += " var startErrs" + $lvl + " = errors; ";
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
      if (it.opts.messages !== false) {
        out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    if ($breakOnError) {
      out += " break; ";
    }
    out += " } }";
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var required$1 = function generate_required(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  var $vSchema = "schema" + $lvl;
  if (!$isData) {
    if ($schema2.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema2;
      if (arr1) {
        var $property, i1 = -1, l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema2;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += " var missing" + $lvl + "; ";
      if ($loopRequired) {
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
        }
        var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += " var " + $valid + " = true; ";
        if ($isData) {
          out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
        }
        out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
        if ($ownProperties) {
          out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
        }
        out += "; if (!" + $valid + ") break; } ";
        if ($isData) {
          out += "  }  ";
        }
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
      } else {
        out += " if ( ";
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1, l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += " || ";
            }
            var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
            out += " ( ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
          }
        }
        out += ") {  ";
        var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
        }
        var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
        }
        out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
        if ($ownProperties) {
          out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
        }
        out += ") {  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
        if ($isData) {
          out += "  }  ";
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += " if ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += " if (true) {";
  }
  return out;
};
var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (($schema2 || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
    }
    out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
    var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
      out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
    } else {
      out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
      var $method = "checkDataType" + ($typeIsArray ? "s" : "");
      out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
      if ($typeIsArray) {
        out += ` if (typeof item == 'string') item = '"' + item; `;
      }
      out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
    }
    out += " } ";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var dotjs = {
  "$ref": ref,
  allOf,
  anyOf,
  "$comment": comment,
  const: _const,
  contains,
  dependencies,
  "enum": _enum,
  format: format$1,
  "if": _if,
  items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf,
  not,
  oneOf,
  pattern,
  properties: properties$2,
  propertyNames,
  required: required$1,
  uniqueItems,
  validate: validate$1
};
var ruleModules = dotjs, toHash = util$5.toHash;
var rules$1 = function rules() {
  var RULES = [
    {
      type: "number",
      rules: [
        { "maximum": ["exclusiveMaximum"] },
        { "minimum": ["exclusiveMinimum"] },
        "multipleOf",
        "format"
      ]
    },
    {
      type: "string",
      rules: ["maxLength", "minLength", "pattern", "format"]
    },
    {
      type: "array",
      rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
    },
    {
      type: "object",
      rules: [
        "maxProperties",
        "minProperties",
        "required",
        "dependencies",
        "propertyNames",
        { "properties": ["additionalProperties", "patternProperties"] }
      ]
    },
    { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
  ];
  var ALL = ["type", "$comment"];
  var KEYWORDS2 = [
    "$schema",
    "$id",
    "id",
    "$data",
    "$async",
    "title",
    "description",
    "default",
    "definitions",
    "examples",
    "readOnly",
    "writeOnly",
    "contentMediaType",
    "contentEncoding",
    "additionalItems",
    "then",
    "else"
  ];
  var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);
  RULES.forEach(function(group2) {
    group2.rules = group2.rules.map(function(keyword2) {
      var implKeywords;
      if (typeof keyword2 == "object") {
        var key = Object.keys(keyword2)[0];
        implKeywords = keyword2[key];
        keyword2 = key;
        implKeywords.forEach(function(k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword2);
      var rule = RULES.all[keyword2] = {
        keyword: keyword2,
        code: ruleModules[keyword2],
        implements: implKeywords
      };
      return rule;
    });
    RULES.all.$comment = {
      keyword: "$comment",
      code: ruleModules.$comment
    };
    if (group2.type)
      RULES.types[group2.type] = group2;
  });
  RULES.keywords = toHash(ALL.concat(KEYWORDS2));
  RULES.custom = {};
  return RULES;
};
var KEYWORDS = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "additionalProperties",
  "enum",
  "format",
  "const"
];
var data = function(metaSchema2, keywordsJsonPointers) {
  for (var i = 0; i < keywordsJsonPointers.length; i++) {
    metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
    var segments = keywordsJsonPointers[i].split("/");
    var keywords = metaSchema2;
    var j;
    for (j = 1; j < segments.length; j++)
      keywords = keywords[segments[j]];
    for (j = 0; j < KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        };
      }
    }
  }
  return metaSchema2;
};
var MissingRefError = error_classes.MissingRef;
var async = compileAsync;
function compileAsync(schema, meta, callback) {
  var self2 = this;
  if (typeof this._opts.loadSchema != "function")
    throw new Error("options.loadSchema should be a function");
  if (typeof meta == "function") {
    callback = meta;
    meta = void 0;
  }
  var p = loadMetaSchemaOf(schema).then(function() {
    var schemaObj = self2._addSchema(schema, void 0, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });
  if (callback) {
    p.then(
      function(v) {
        callback(null, v);
      },
      callback
    );
  }
  return p;
  function loadMetaSchemaOf(sch) {
    var $schema2 = sch.$schema;
    return $schema2 && !self2.getSchema($schema2) ? compileAsync.call(self2, { $ref: $schema2 }, true) : Promise.resolve();
  }
  function _compileAsync(schemaObj) {
    try {
      return self2._compile(schemaObj);
    } catch (e) {
      if (e instanceof MissingRefError)
        return loadMissingSchema(e);
      throw e;
    }
    function loadMissingSchema(e) {
      var ref2 = e.missingSchema;
      if (added(ref2))
        throw new Error("Schema " + ref2 + " is loaded but " + e.missingRef + " cannot be resolved");
      var schemaPromise = self2._loadingSchemas[ref2];
      if (!schemaPromise) {
        schemaPromise = self2._loadingSchemas[ref2] = self2._opts.loadSchema(ref2);
        schemaPromise.then(removePromise, removePromise);
      }
      return schemaPromise.then(function(sch) {
        if (!added(ref2)) {
          return loadMetaSchemaOf(sch).then(function() {
            if (!added(ref2))
              self2.addSchema(sch, ref2, void 0, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });
      function removePromise() {
        delete self2._loadingSchemas[ref2];
      }
      function added(ref3) {
        return self2._refs[ref3] || self2._schemas[ref3];
      }
    }
  }
}
var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = "keywordValidate" + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema2, it.schema, it);
    if (!$ruleValidate)
      return;
    $schemaValue = "validate.schema" + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async)
    throw new Error("async keyword in sync schema");
  if (!($inline || $macro)) {
    out += "" + $ruleErrs + " = null;";
  }
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if ($isData && $rDef.$data) {
    $closingBraces += "}";
    out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
    if ($validateSchema) {
      $closingBraces += "}";
      out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += " " + $ruleValidate.validate + " ";
    } else {
      out += " " + $valid + " = " + $ruleValidate.validate + "; ";
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = "";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $code;
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    out += "  " + $validateCode + ".call( ";
    if (it.opts.passContext) {
      out += "this";
    } else {
      out += "self";
    }
    if ($compile || $rDef.schema === false) {
      out += " , " + $data + " ";
    } else {
      out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
    }
    out += " , (dataPath || '')";
    if (it.errorPath != '""') {
      out += " + " + it.errorPath;
    }
    var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
    out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += " " + $valid + " = ";
      if ($asyncKeyword) {
        out += "await ";
      }
      out += "" + def_callRuleValidate + "; ";
    } else {
      if ($asyncKeyword) {
        $ruleErrs = "customErrors" + $lvl;
        out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
      } else {
        out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
      }
    }
  }
  if ($rDef.modifying) {
    out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
  }
  out += "" + $closingBraces;
  if ($rDef.valid) {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  } else {
    out += " if ( ";
    if ($rDef.valid === void 0) {
      out += " !";
      if ($macro) {
        out += "" + $nextValid;
      } else {
        out += "" + $valid;
      }
    } else {
      out += " " + !$rDef.valid + " ";
    }
    out += ") { ";
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != "full") {
          out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } ";
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } ";
        }
      }
    } else if ($macro) {
      out += "   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += " " + def_customError + " ";
      } else {
        out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
        if (it.opts.verbose) {
          out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
        }
        out += " } } else { " + def_customError + " } ";
      }
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
  }
  return out;
};
const $schema$4 = "http://json-schema.org/draft-07/schema#";
const $id$1 = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions$3 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$1 = [
  "object",
  "boolean"
];
const properties$1 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$13 = {
  $schema: $schema$4,
  $id: $id$1,
  title,
  definitions: definitions$3,
  type: type$1,
  properties: properties$1,
  "default": true
};
var metaSchema = require$$13;
var definition_schema = {
  $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: "object",
  dependencies: {
    schema: ["validate"],
    $data: ["validate"],
    statements: ["inline"],
    valid: { not: { required: ["macro"] } }
  },
  properties: {
    type: metaSchema.properties.type,
    schema: { type: "boolean" },
    statements: { type: "boolean" },
    dependencies: {
      type: "array",
      items: { type: "string" }
    },
    metaSchema: { type: "object" },
    modifying: { type: "boolean" },
    valid: { type: "boolean" },
    $data: { type: "boolean" },
    async: { type: "boolean" },
    errors: {
      anyOf: [
        { type: "boolean" },
        { const: "full" }
      ]
    }
  }
};
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = custom;
var definitionSchema = definition_schema;
var keyword = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};
function addKeyword(keyword2, definition) {
  var RULES = this.RULES;
  if (RULES.keywords[keyword2])
    throw new Error("Keyword " + keyword2 + " is already defined");
  if (!IDENTIFIER.test(keyword2))
    throw new Error("Keyword " + keyword2 + " is not a valid identifier");
  if (definition) {
    this.validateKeyword(definition, true);
    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i = 0; i < dataType.length; i++)
        _addRule(keyword2, dataType[i], definition);
    } else {
      _addRule(keyword2, dataType, definition);
    }
    var metaSchema2 = definition.metaSchema;
    if (metaSchema2) {
      if (definition.$data && this._opts.$data) {
        metaSchema2 = {
          anyOf: [
            metaSchema2,
            { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema2, true);
    }
  }
  RULES.keywords[keyword2] = RULES.all[keyword2] = true;
  function _addRule(keyword3, dataType2, definition2) {
    var ruleGroup;
    for (var i2 = 0; i2 < RULES.length; i2++) {
      var rg = RULES[i2];
      if (rg.type == dataType2) {
        ruleGroup = rg;
        break;
      }
    }
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.push(ruleGroup);
    }
    var rule = {
      keyword: keyword3,
      definition: definition2,
      custom: true,
      code: customRuleCode,
      implements: definition2.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword3] = rule;
  }
  return this;
}
function getKeyword(keyword2) {
  var rule = this.RULES.custom[keyword2];
  return rule ? rule.definition : this.RULES.keywords[keyword2] || false;
}
function removeKeyword(keyword2) {
  var RULES = this.RULES;
  delete RULES.keywords[keyword2];
  delete RULES.all[keyword2];
  delete RULES.custom[keyword2];
  for (var i = 0; i < RULES.length; i++) {
    var rules3 = RULES[i].rules;
    for (var j = 0; j < rules3.length; j++) {
      if (rules3[j].keyword == keyword2) {
        rules3.splice(j, 1);
        break;
      }
    }
  }
  return this;
}
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
  if (v(definition))
    return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
  else
    return false;
}
const $schema$3 = "http://json-schema.org/draft-07/schema#";
const $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON Schema extension proposal)";
const type = "object";
const required = [
  "$data"
];
const properties = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties = false;
const require$$12 = {
  $schema: $schema$3,
  $id,
  description,
  type,
  required,
  properties,
  additionalProperties
};
var compileSchema = compile_1, resolve = resolve_1, Cache2 = cacheExports, SchemaObject = schema_obj, stableStringify = fastJsonStableStringify, formats = formats_1, rules2 = rules$1, $dataMetaSchema = data, util = util$5;
var ajv = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile$1;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = async;
var customKeyword = keyword;
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;
var errorClasses = error_classes;
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
var META_SUPPORT_DATA = ["/properties"];
function Ajv(opts) {
  if (!(this instanceof Ajv))
    return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache2();
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules2();
  this._getId = chooseGetId(opts);
  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == "property")
    opts._errorDataPathProperty = true;
  if (opts.serialize === void 0)
    opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);
  if (opts.formats)
    addInitialFormats(this);
  if (opts.keywords)
    addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == "object")
    this.addMetaSchema(opts.meta);
  if (opts.nullable)
    this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
  addInitialSchemas(this);
}
function validate(schemaKeyRef, data2) {
  var v;
  if (typeof schemaKeyRef == "string") {
    v = this.getSchema(schemaKeyRef);
    if (!v)
      throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }
  var valid = v(data2);
  if (v.$async !== true)
    this.errors = v.errors;
  return valid;
}
function compile$1(schema, _meta) {
  var schemaObj = this._addSchema(schema, void 0, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++)
      this.addSchema(schema[i], void 0, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== void 0 && typeof id != "string")
    throw new Error("schema id must be string");
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}
function validateSchema(schema, throwOrLogError) {
  var $schema2 = schema.$schema;
  if ($schema2 !== void 0 && typeof $schema2 != "string")
    throw new Error("$schema must be a string");
  $schema2 = $schema2 || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema2) {
    this.logger.warn("meta-schema not available");
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema2, schema);
  if (!valid && throwOrLogError) {
    var message = "schema is invalid: " + this.errorsText();
    if (this._opts.validateSchema == "log")
      this.logger.error(message);
    else
      throw new Error(message);
  }
  return valid;
}
function defaultMeta(self2) {
  var meta = self2._opts.meta;
  self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
  return self2._opts.defaultMeta;
}
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case "object":
      return schemaObj.validate || this._compile(schemaObj);
    case "string":
      return this.getSchema(schemaObj);
    case "undefined":
      return _getSchemaFragment(this, keyRef);
  }
}
function _getSchemaFragment(self2, ref2) {
  var res = resolve.schema.call(self2, { schema: {} }, ref2);
  if (res) {
    var schema = res.schema, root = res.root, baseId = res.baseId;
    var v = compileSchema.call(self2, schema, root, void 0, baseId);
    self2._fragments[ref2] = new SchemaObject({
      ref: ref2,
      fragment: true,
      schema,
      root,
      baseId,
      validate: v
    });
    return v;
  }
}
function _getSchemaObj(self2, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
}
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case "undefined":
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case "string":
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj)
        this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case "object":
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}
function _removeAllSchemas(self2, schemas, regex2) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex2 || regex2.test(keyRef))) {
      self2._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != "object" && typeof schema != "boolean")
    throw new Error("schema should be object or boolean");
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached)
    return cached;
  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema)
    checkUnique(this, id);
  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);
  var localRefs = resolve.ids.call(this, schema);
  var schemaObj = new SchemaObject({
    id,
    schema,
    localRefs,
    cacheKey,
    meta
  });
  if (id[0] != "#" && shouldAddSchema)
    this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);
  if (willValidate && recursiveMeta)
    this.validateSchema(schema, true);
  return schemaObj;
}
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;
  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }
  var v;
  try {
    v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
  } catch (e) {
    delete schemaObj.validate;
    throw e;
  } finally {
    schemaObj.compiling = false;
    if (schemaObj.meta)
      this._opts = currentOpts;
  }
  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;
  function callValidate() {
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}
function chooseGetId(opts) {
  switch (opts.schemaId) {
    case "auto":
      return _get$IdOrId;
    case "id":
      return _getId;
    default:
      return _get$Id;
  }
}
function _getId(schema) {
  if (schema.$id)
    this.logger.warn("schema $id ignored", schema.$id);
  return schema.id;
}
function _get$Id(schema) {
  if (schema.id)
    this.logger.warn("schema id ignored", schema.id);
  return schema.$id;
}
function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error("schema $id is different from id");
  return schema.$id || schema.id;
}
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors)
    return "No errors";
  options = options || {};
  var separator = options.separator === void 0 ? ", " : options.separator;
  var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
  var text = "";
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    if (e)
      text += dataVar + e.dataPath + " " + e.message + separator;
  }
  return text.slice(0, -separator.length);
}
function addFormat(name2, format2) {
  if (typeof format2 == "string")
    format2 = new RegExp(format2);
  this._formats[name2] = format2;
  return this;
}
function addDefaultMetaSchema(self2) {
  var $dataSchema;
  if (self2._opts.$data) {
    $dataSchema = require$$12;
    self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self2._opts.meta === false)
    return;
  var metaSchema2 = require$$13;
  if (self2._opts.$data)
    metaSchema2 = $dataMetaSchema(metaSchema2, META_SUPPORT_DATA);
  self2.addMetaSchema(metaSchema2, META_SCHEMA_ID, true);
  self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
}
function addInitialSchemas(self2) {
  var optsSchemas = self2._opts.schemas;
  if (!optsSchemas)
    return;
  if (Array.isArray(optsSchemas))
    self2.addSchema(optsSchemas);
  else
    for (var key in optsSchemas)
      self2.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self2) {
  for (var name2 in self2._opts.formats) {
    var format2 = self2._opts.formats[name2];
    self2.addFormat(name2, format2);
  }
}
function addInitialKeywords(self2) {
  for (var name2 in self2._opts.keywords) {
    var keyword2 = self2._opts.keywords[name2];
    self2.addKeyword(name2, keyword2);
  }
}
function checkUnique(self2, id) {
  if (self2._schemas[id] || self2._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}
function getMetaSchemaOptions(self2) {
  var metaOpts = util.copy(self2._opts);
  for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}
function setLogger(self2) {
  var logger = self2._opts.logger;
  if (logger === false) {
    self2.logger = { log: noop$1, warn: noop$1, error: noop$1 };
  } else {
    if (logger === void 0)
      logger = console;
    if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
      throw new Error("logger must implement log, warn and error methods");
    self2.logger = logger;
  }
}
function noop$1() {
}
const Ajv$1 = /* @__PURE__ */ getDefaultExportFromCjs(ajv);
const $ref$2 = "#/definitions/GoslingSpec";
const $schema$2 = "http://json-schema.org/draft-07/schema#";
const definitions$2 = {
  Aggregate: {
    "enum": [
      "max",
      "min",
      "mean",
      "bin",
      "count"
    ],
    type: "string"
  },
  Assembly: {
    anyOf: [
      {
        "const": "hg38",
        type: "string"
      },
      {
        "const": "hg19",
        type: "string"
      },
      {
        "const": "hg18",
        type: "string"
      },
      {
        "const": "hg17",
        type: "string"
      },
      {
        "const": "hg16",
        type: "string"
      },
      {
        "const": "mm10",
        type: "string"
      },
      {
        "const": "mm9",
        type: "string"
      },
      {
        "const": "unknown",
        type: "string"
      },
      {
        $ref: "#/definitions/ChromSizes"
      }
    ]
  },
  AxisPosition: {
    "enum": [
      "none",
      "top",
      "bottom",
      "left",
      "right"
    ],
    type: "string"
  },
  BamData: {
    additionalProperties: false,
    description: "Binary Alignment Map (BAM) is the comprehensive raw data of genome sequencing; it consists of the lossless, compressed binary representation of the Sequence Alignment Map-files.",
    properties: {
      extractJunction: {
        description: "Determine whether to extract exon-to-exon junctions. __Default__: `false`",
        type: "boolean"
      },
      indexUrl: {
        description: "URL link to the index file of the BAM file",
        type: "string"
      },
      junctionMinCoverage: {
        description: "Determine the threshold of coverage when extracting exon-to-exon junctions. __Default__: `1`",
        type: "number"
      },
      loadMates: {
        description: "Load mates that are located in the same chromosome. __Default__: `false`",
        type: "boolean"
      },
      maxInsertSize: {
        description: "Determines the threshold of insert sizes for determining the structural variants. __Default__: `5000`",
        type: "number"
      },
      type: {
        "const": "bam",
        type: "string"
      },
      url: {
        description: "URL link to the BAM data file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  BedData: {
    additionalProperties: false,
    description: "BED file format",
    properties: {
      customFields: {
        description: "An array of strings, where each string is the name of a non-standard field in the BED file. If there are `n` custom fields, we assume that the last `n` columns of the BED file correspond to the custom fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      indexUrl: {
        description: "Specify the URL address of the data file index.",
        type: "string"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "bed",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  BeddbData: {
    additionalProperties: false,
    description: "Regular BED or similar files can be pre-aggregated for the scalable data exploration. Find our more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bed-files).",
    properties: {
      exonIntervalFields: {
        description: "experimental",
        items: [
          {
            additionalProperties: false,
            properties: {
              index: {
                type: "number"
              },
              name: {
                type: "string"
              }
            },
            required: [
              "index",
              "name"
            ],
            type: "object"
          },
          {
            additionalProperties: false,
            properties: {
              index: {
                type: "number"
              },
              name: {
                type: "string"
              }
            },
            required: [
              "index",
              "name"
            ],
            type: "object"
          }
        ],
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          additionalProperties: false,
          properties: {
            index: {
              type: "number"
            },
            name: {
              type: "string"
            }
          },
          required: [
            "index",
            "name"
          ],
          type: "object"
        },
        type: "array"
      },
      type: {
        "const": "beddb",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      valueFields: {
        description: "Specify the column indexes, field names, and field types.",
        items: {
          additionalProperties: false,
          properties: {
            index: {
              type: "number"
            },
            name: {
              type: "string"
            },
            type: {
              "enum": [
                "nominal",
                "quantitative"
              ],
              type: "string"
            }
          },
          required: [
            "index",
            "name",
            "type"
          ],
          type: "object"
        },
        type: "array"
      }
    },
    required: [
      "type",
      "url",
      "genomicFields"
    ],
    type: "object"
  },
  BigWigData: {
    additionalProperties: false,
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "bigwig",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  BinAggregate: {
    "enum": [
      "mean",
      "sum"
    ],
    type: "string"
  },
  Channel: {
    anyOf: [
      {
        $ref: "#/definitions/ChannelDeep"
      },
      {
        $ref: "#/definitions/ChannelValue"
      }
    ]
  },
  ChannelDeep: {
    anyOf: [
      {
        $ref: "#/definitions/X"
      },
      {
        $ref: "#/definitions/Y"
      },
      {
        $ref: "#/definitions/Row"
      },
      {
        $ref: "#/definitions/Color"
      },
      {
        $ref: "#/definitions/Size"
      },
      {
        $ref: "#/definitions/Stroke"
      },
      {
        $ref: "#/definitions/StrokeWidth"
      },
      {
        $ref: "#/definitions/Opacity"
      },
      {
        $ref: "#/definitions/Text"
      }
    ]
  },
  ChannelValue: {
    additionalProperties: false,
    properties: {
      value: {
        description: "Assign a constant value for a visual channel.",
        type: [
          "number",
          "string"
        ]
      }
    },
    required: [
      "value"
    ],
    type: "object"
  },
  ChromSizes: {
    description: 'Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]]',
    items: {
      items: [
        {
          type: "string"
        },
        {
          type: "number"
        }
      ],
      maxItems: 2,
      minItems: 2,
      type: "array"
    },
    type: "array"
  },
  Color: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/Range",
        description: "Determine the colors that should be bound to data value. Default properties are determined considering the field type."
      },
      scale: {
        "enum": [
          "linear",
          "log"
        ],
        type: "string"
      },
      scaleOffset: {
        description: "Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]`",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      title: {
        description: "Title of the legend. __Default__: `undefined`",
        type: "string"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  CoverageTransform: {
    additionalProperties: false,
    description: "Aggregate rows and calculate coverage",
    properties: {
      endField: {
        type: "string"
      },
      groupField: {
        description: "The name of a nominal field to group rows by in prior to piling-up",
        type: "string"
      },
      newField: {
        type: "string"
      },
      startField: {
        type: "string"
      },
      type: {
        "const": "coverage",
        type: "string"
      }
    },
    required: [
      "type",
      "startField",
      "endField"
    ],
    type: "object"
  },
  CsvData: {
    additionalProperties: false,
    description: 'Any small enough tabular data files, such as tsv, csv, BED, BEDPE, and GFF, can be loaded using "csv" data specification.',
    properties: {
      chromosomeField: {
        description: "Specify the name of chromosome data fields.",
        type: "string"
      },
      chromosomePrefix: {
        description: 'Specify the chromosome prefix if chromosomes are denoted using a prefix besides "chr" or a number',
        type: "string"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      genomicFieldsToConvert: {
        description: "experimental",
        items: {
          additionalProperties: false,
          properties: {
            chromosomeField: {
              type: "string"
            },
            genomicFields: {
              items: {
                type: "string"
              },
              type: "array"
            }
          },
          required: [
            "chromosomeField",
            "genomicFields"
          ],
          type: "object"
        },
        type: "array"
      },
      headerNames: {
        description: "Specify the names of data fields if a CSV file does not contain a header.",
        items: {
          type: "string"
        },
        type: "array"
      },
      longToWideId: {
        description: "experimental",
        type: "string"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      separator: {
        description: "Specify file separator, __Default:__ ','",
        type: "string"
      },
      type: {
        "const": "csv",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  DataDeep: {
    anyOf: [
      {
        $ref: "#/definitions/JsonData"
      },
      {
        $ref: "#/definitions/CsvData"
      },
      {
        $ref: "#/definitions/BedData"
      },
      {
        $ref: "#/definitions/BigWigData"
      },
      {
        $ref: "#/definitions/MultivecData"
      },
      {
        $ref: "#/definitions/BeddbData"
      },
      {
        $ref: "#/definitions/VectorData"
      },
      {
        $ref: "#/definitions/MatrixData"
      },
      {
        $ref: "#/definitions/BamData"
      },
      {
        $ref: "#/definitions/VcfData"
      },
      {
        $ref: "#/definitions/GffData"
      }
    ]
  },
  DataTrack: {
    additionalProperties: false,
    description: "Partial specification of `BasicSingleTrack` to use default visual encoding predefined by data type.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "data"
    ],
    type: "object"
  },
  DataTransform: {
    anyOf: [
      {
        $ref: "#/definitions/FilterTransform"
      },
      {
        $ref: "#/definitions/StrConcatTransform"
      },
      {
        $ref: "#/definitions/StrReplaceTransform"
      },
      {
        $ref: "#/definitions/LogTransform"
      },
      {
        $ref: "#/definitions/DisplaceTransform"
      },
      {
        $ref: "#/definitions/ExonSplitTransform"
      },
      {
        $ref: "#/definitions/GenomicLengthTransform"
      },
      {
        $ref: "#/definitions/SvTypeTransform"
      },
      {
        $ref: "#/definitions/CoverageTransform"
      },
      {
        $ref: "#/definitions/JsonParseTransform"
      }
    ]
  },
  Datum: {
    additionalProperties: {
      type: [
        "number",
        "string"
      ]
    },
    description: "Values in the form of JSON.",
    type: "object"
  },
  DisplaceTransform: {
    additionalProperties: false,
    properties: {
      boundingBox: {
        additionalProperties: false,
        properties: {
          endField: {
            description: "The name of a quantitative field that represents the end position.",
            type: "string"
          },
          groupField: {
            description: "The name of a nominal field to group rows by in prior to piling-up.",
            type: "string"
          },
          isPaddingBP: {
            description: "Whether to consider `padding` as the bp length.",
            type: "boolean"
          },
          padding: {
            description: "The padding around visual lements. Either px or bp",
            type: "number"
          },
          startField: {
            description: "The name of a quantitative field that represents the start position.",
            type: "string"
          }
        },
        required: [
          "startField",
          "endField"
        ],
        type: "object"
      },
      maxRows: {
        description: "Specify maximum rows to be generated (default has no limit).",
        type: "number"
      },
      method: {
        $ref: "#/definitions/DisplacementType",
        description: "A string that specifies the type of displacement."
      },
      newField: {
        type: "string"
      },
      type: {
        "const": "displace",
        type: "string"
      }
    },
    required: [
      "type",
      "boundingBox",
      "method",
      "newField"
    ],
    type: "object"
  },
  Displacement: {
    additionalProperties: false,
    properties: {
      padding: {
        type: "number"
      },
      type: {
        $ref: "#/definitions/DisplacementType"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  DisplacementType: {
    "enum": [
      "pile",
      "spread"
    ],
    type: "string"
  },
  DomainChr: {
    additionalProperties: false,
    properties: {
      chromosome: {
        type: "string"
      }
    },
    required: [
      "chromosome"
    ],
    type: "object"
  },
  DomainChrInterval: {
    additionalProperties: false,
    properties: {
      chromosome: {
        description: "If specified, only showing a certain interval in a chromosome.",
        type: "string"
      },
      interval: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "chromosome",
      "interval"
    ],
    type: "object"
  },
  DomainInterval: {
    additionalProperties: false,
    properties: {
      interval: {
        description: "Show a certain interval within entire chromosome",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "interval"
    ],
    type: "object"
  },
  DummyTrack: {
    additionalProperties: false,
    description: "A placeholder track. In contrast to other tracks, this track does not display any data. Instead it provides empty space for third party tools to display their data on top of.",
    properties: {
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      assembly: {
        "const": "unknown",
        description: "No assemblies can be associated with a dummy track",
        type: "string"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      layout: {
        "const": "linear",
        description: "Only linear layout are supported at this time",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      "static": {
        "const": true,
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/DummyTrackStyle",
        description: "Defines how the track is styled"
      },
      title: {
        description: "Text that gets shown on the DummyTrack",
        type: "string"
      },
      type: {
        "const": "dummy-track",
        description: "Used to specify the dummy track",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      zoomLimits: {
        description: "Unused property for DummyTrack",
        items: {
          type: "null"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  DummyTrackStyle: {
    additionalProperties: false,
    properties: {
      background: {
        description: "Background color of the track",
        type: "string"
      },
      outline: {
        description: "Color of the outline of the track",
        type: "string"
      },
      textFontSize: {
        description: "Specify the font size of the title",
        type: "number"
      },
      textFontWeight: {
        description: "Specify the font weight of the title.",
        "enum": [
          "bold",
          "normal"
        ],
        type: "string"
      },
      textStroke: {
        description: "Specify the stroke color of title.",
        type: "string"
      },
      textStrokeWidth: {
        description: "Specify the stroke width of the title.",
        type: "number"
      }
    },
    type: "object"
  },
  EventStyle: {
    additionalProperties: false,
    description: "The styles defined here will be applied to the target marks of mouse events, such as a point mark after the user clicks on it.",
    properties: {
      arrange: {
        description: "Show event effects behind or in front of marks.",
        "enum": [
          "behind",
          "front"
        ],
        type: "string"
      },
      color: {
        description: "color of the marks when mouse events are triggered",
        type: "string"
      },
      opacity: {
        description: "opacity of the marks when mouse events are triggered",
        type: "number"
      },
      stroke: {
        description: "stroke color of the marks when mouse events are triggered",
        type: "string"
      },
      strokeOpacity: {
        type: "number"
      },
      strokeWidth: {
        description: "stroke width of the marks when mouse events are triggered",
        type: "number"
      }
    },
    type: "object"
  },
  ExonSplitTransform: {
    additionalProperties: false,
    properties: {
      fields: {
        items: {
          additionalProperties: false,
          properties: {
            chrField: {
              type: "string"
            },
            field: {
              type: "string"
            },
            newField: {
              type: "string"
            },
            type: {
              $ref: "#/definitions/FieldType"
            }
          },
          required: [
            "field",
            "type",
            "newField",
            "chrField"
          ],
          type: "object"
        },
        type: "array"
      },
      flag: {
        additionalProperties: false,
        properties: {
          field: {
            type: "string"
          },
          value: {
            type: [
              "number",
              "string"
            ]
          }
        },
        required: [
          "field",
          "value"
        ],
        type: "object"
      },
      separator: {
        type: "string"
      },
      type: {
        "const": "exonSplit",
        type: "string"
      }
    },
    required: [
      "type",
      "separator",
      "flag",
      "fields"
    ],
    type: "object"
  },
  FieldType: {
    "enum": [
      "genomic",
      "nominal",
      "quantitative"
    ],
    type: "string"
  },
  FilterTransform: {
    anyOf: [
      {
        $ref: "#/definitions/OneOfFilter"
      },
      {
        $ref: "#/definitions/RangeFilter"
      },
      {
        $ref: "#/definitions/IncludeFilter"
      }
    ]
  },
  GenomicDomain: {
    anyOf: [
      {
        $ref: "#/definitions/DomainInterval"
      },
      {
        $ref: "#/definitions/DomainChrInterval"
      },
      {
        $ref: "#/definitions/DomainChr"
      }
    ]
  },
  GenomicLengthTransform: {
    additionalProperties: false,
    description: "Calculate genomic length using two genomic fields",
    properties: {
      endField: {
        type: "string"
      },
      newField: {
        type: "string"
      },
      startField: {
        type: "string"
      },
      type: {
        "const": "genomicLength",
        type: "string"
      }
    },
    required: [
      "type",
      "startField",
      "endField",
      "newField"
    ],
    type: "object"
  },
  GffData: {
    additionalProperties: false,
    description: "Generic Feature Format Version 3 (GFF3) format data. It parses files that follow the [GFF3 specification](https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md).",
    properties: {
      attributesToFields: {
        description: 'Specifies which attributes to include as a fields. GFF files have an "attributes" column which contains a list of attributes which are each tag-value pairs (`tag=value`). This option allows for specific attributes to be accessible as a field. For example, if you have an attribute called "gene_name" and you want label features on your track using those values, you can use this option so that you can use `"field": "gene_name"` in the schema.\n\nIf there is a single `value` corresponding to the `tag`, Gosling will parse that value as a string. If there are multiple `value`s corresponding to a `tag`, Gosling will parse it as a comma-separated list string. If a feature does not have a particular attribute, then the attribute value will be set to the `defaultValue`.',
        items: {
          additionalProperties: false,
          properties: {
            attribute: {
              type: "string"
            },
            defaultValue: {
              type: "string"
            }
          },
          required: [
            "attribute",
            "defaultValue"
          ],
          type: "object"
        },
        type: "array"
      },
      indexUrl: {
        description: "URL link to the tabix index file",
        type: "string"
      },
      sampleLength: {
        description: "The maximum number of samples to be shown on the track. Samples are uniformly randomly selected so that this threshold is not exceeded. __Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "gff",
        type: "string"
      },
      url: {
        description: "URL link to the GFF file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  GoslingSpec: {
    anyOf: [
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "overlay",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          description: {
            type: "string"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              $ref: "#/definitions/PartialTrack"
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "alignment",
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "stack",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          description: {
            type: "string"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/PartialTrack"
                },
                {
                  $ref: "#/definitions/OverlaidTracks"
                }
              ]
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          description: {
            type: "string"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          title: {
            type: "string"
          },
          tracks: {
            items: {
              $ref: "#/definitions/Track"
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          arrangement: {
            description: "Specify how multiple views are arranged.",
            "enum": [
              "parallel",
              "serial",
              "horizontal",
              "vertical"
            ],
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          description: {
            type: "string"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    arrangement: {
                      description: "Specify how multiple views are arranged.",
                      "enum": [
                        "parallel",
                        "serial",
                        "horizontal",
                        "vertical"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    views: {
                      description: "An array of view specifications",
                      items: {
                        anyOf: [
                          {
                            $ref: "#/definitions/SingleView"
                          },
                          {
                            $ref: "#/definitions/MultipleViews"
                          }
                        ]
                      },
                      type: "array"
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          title: {
            type: "string"
          },
          views: {
            description: "An array of view specifications",
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/SingleView"
                },
                {
                  $ref: "#/definitions/MultipleViews"
                }
              ]
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "views"
        ],
        type: "object"
      }
    ]
  },
  IncludeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      include: {
        description: "Check whether the value includes a substring.",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "include",
      "type"
    ],
    type: "object"
  },
  JsonData: {
    additionalProperties: false,
    description: "The JSON data format allows users to include data directly in the Gosling's JSON specification.",
    properties: {
      chromosomeField: {
        description: "Specify the name of chromosome data fields.",
        type: "string"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      genomicFieldsToConvert: {
        description: "experimental",
        items: {
          additionalProperties: false,
          properties: {
            chromosomeField: {
              type: "string"
            },
            genomicFields: {
              items: {
                type: "string"
              },
              type: "array"
            }
          },
          required: [
            "chromosomeField",
            "genomicFields"
          ],
          type: "object"
        },
        type: "array"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "json",
        description: "Define data type.",
        type: "string"
      },
      values: {
        description: "Values in the form of JSON.",
        items: {
          $ref: "#/definitions/Datum"
        },
        type: "array"
      }
    },
    required: [
      "type",
      "values"
    ],
    type: "object"
  },
  JsonParseTransform: {
    additionalProperties: false,
    description: "Parse JSON Object Array and append vertically",
    properties: {
      baseGenomicField: {
        description: "Base genomic position when parsing relative position.",
        type: "string"
      },
      field: {
        description: "The field that contains the JSON object array.",
        type: "string"
      },
      genomicField: {
        description: "Relative genomic position to parse.",
        type: "string"
      },
      genomicLengthField: {
        description: "Length of genomic interval.",
        type: "string"
      },
      type: {
        "const": "subjson",
        type: "string"
      }
    },
    required: [
      "type",
      "field",
      "baseGenomicField",
      "genomicField",
      "genomicLengthField"
    ],
    type: "object"
  },
  Layout: {
    "enum": [
      "linear",
      "circular"
    ],
    type: "string"
  },
  LogBase: {
    anyOf: [
      {
        type: "number"
      },
      {
        "const": "e",
        type: "string"
      }
    ]
  },
  LogTransform: {
    additionalProperties: false,
    properties: {
      base: {
        $ref: "#/definitions/LogBase",
        description: "If not specified, 10 is used."
      },
      field: {
        type: "string"
      },
      newField: {
        description: "If specified, store transformed values in a new field.",
        type: "string"
      },
      type: {
        "const": "log",
        type: "string"
      }
    },
    required: [
      "type",
      "field"
    ],
    type: "object"
  },
  LogicalOperation: {
    "enum": [
      "less-than",
      "lt",
      "LT",
      "greater-than",
      "gt",
      "GT",
      "less-than-or-equal-to",
      "ltet",
      "LTET",
      "greater-than-or-equal-to",
      "gtet",
      "GTET"
    ],
    type: "string"
  },
  Mark: {
    "enum": [
      "point",
      "line",
      "area",
      "bar",
      "rect",
      "text",
      "withinLink",
      "betweenLink",
      "rule",
      "triangleLeft",
      "triangleRight",
      "triangleBottom",
      "brush",
      "header"
    ],
    type: "string"
  },
  MatrixData: {
    additionalProperties: false,
    properties: {
      binSize: {
        description: "Determine the number of nearby cells to aggregate. __Default__: `1`",
        type: "number"
      },
      column: {
        description: "The name of the first genomic field. __Default__: `x`",
        type: "string"
      },
      row: {
        description: "The name of the first genomic field. __Default__: `y`",
        type: "string"
      },
      type: {
        "const": "matrix",
        type: "string"
      },
      url: {
        description: "URL link to the matrix data file",
        type: "string"
      },
      value: {
        description: "The name of the value field. __Default__: `value`",
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  MouseEventsDeep: {
    additionalProperties: false,
    description: "Options for determining mouse events in detail, e.g., turning on specific events only",
    properties: {
      click: {
        description: "Whether to enable click events.",
        type: "boolean"
      },
      enableMouseOverOnMultipleMarks: {
        description: "Determine whether all marks underneath the mouse point should be affected by mouse over. __Default__: `false`",
        type: "boolean"
      },
      groupMarksByField: {
        description: "Group marks using keys in a data field. This affects how a set of marks are highlighted/selected by interaction. __Default__: `undefined`",
        type: "string"
      },
      mouseOver: {
        description: "Whether to enable mouseover events.",
        type: "boolean"
      },
      rangeSelect: {
        description: "Whether to send range selection events.",
        type: "boolean"
      }
    },
    type: "object"
  },
  MultipleViews: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      arrangement: {
        description: "Specify how multiple views are arranged.",
        "enum": [
          "parallel",
          "serial",
          "horizontal",
          "vertical"
        ],
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      id: {
        description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
        type: "string"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      views: {
        description: "An array of view specifications",
        items: {
          anyOf: [
            {
              $ref: "#/definitions/SingleView"
            },
            {
              $ref: "#/definitions/MultipleViews"
            }
          ]
        },
        type: "array"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "views"
    ],
    type: "object"
  },
  MultivecData: {
    additionalProperties: false,
    description: 'Two-dimensional quantitative values, one axis for genomic coordinate and the other for different samples, can be converted into HiGlass\' `"multivec"` data. For example, multiple BigWig files can be converted into a single multivec file. You can also convert sequence data (FASTA) into this format where rows will be different nucleotide bases (e.g., A, T, G, C) and quantitative values represent the frequency. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#multivec-files).',
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      categories: {
        description: "assign names of individual samples.",
        items: {
          type: "string"
        },
        type: "array"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      row: {
        description: 'Assign a field name of samples. __Default__: `"category"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "multivec",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  OneOfFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      oneOf: {
        description: "Check whether the value is an element in the provided list.",
        items: {
          type: [
            "string",
            "number",
            "null"
          ]
        },
        type: "array"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "oneOf",
      "type"
    ],
    type: "object"
  },
  Opacity: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Orientation: {
    "enum": [
      "horizontal",
      "vertical"
    ],
    type: "string"
  },
  OverlaidTrack: {
    additionalProperties: false,
    description: "Superposing multiple tracks.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _overlay: {
        items: {
          additionalProperties: false,
          properties: {
            _assignedHeight: {
              type: "number"
            },
            _assignedWidth: {
              description: "Internal: Used for responsive spec",
              type: "number"
            },
            _invalidTrack: {
              description: "internal",
              type: "boolean"
            },
            _renderingId: {
              description: "internal",
              type: "string"
            },
            assembly: {
              $ref: "#/definitions/Assembly",
              description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
            },
            baselineY: {
              type: "number"
            },
            centerRadius: {
              description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
              type: "number"
            },
            color: {
              anyOf: [
                {
                  $ref: "#/definitions/Color"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            data: {
              $ref: "#/definitions/DataDeep"
            },
            dataTransform: {
              items: {
                $ref: "#/definitions/DataTransform"
              },
              type: "array"
            },
            displacement: {
              $ref: "#/definitions/Displacement"
            },
            endAngle: {
              description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            experimental: {
              additionalProperties: false,
              properties: {
                mouseEvents: {
                  anyOf: [
                    {
                      type: "boolean"
                    },
                    {
                      $ref: "#/definitions/MouseEventsDeep"
                    }
                  ]
                },
                performanceMode: {
                  "default": false,
                  description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                  type: "boolean"
                }
              },
              type: "object"
            },
            flipY: {
              type: "boolean"
            },
            id: {
              description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
              type: "string"
            },
            innerRadius: {
              description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
              type: "number"
            },
            linkingId: {
              description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
              type: "string"
            },
            mark: {
              $ref: "#/definitions/Mark"
            },
            opacity: {
              anyOf: [
                {
                  $ref: "#/definitions/Opacity"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            orientation: {
              $ref: "#/definitions/Orientation",
              description: "Specify the orientation."
            },
            outerRadius: {
              description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
              type: "number"
            },
            overlayOnPreviousTrack: {
              type: "boolean"
            },
            overrideTemplate: {
              type: "boolean"
            },
            prerelease: {
              additionalProperties: false,
              description: "internal",
              type: "object"
            },
            row: {
              anyOf: [
                {
                  $ref: "#/definitions/Row"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            size: {
              anyOf: [
                {
                  $ref: "#/definitions/Size"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            spacing: {
              description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
              type: "number"
            },
            startAngle: {
              description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            "static": {
              description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
              type: "boolean"
            },
            stretch: {
              type: "boolean"
            },
            stroke: {
              anyOf: [
                {
                  $ref: "#/definitions/Stroke"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            strokeWidth: {
              anyOf: [
                {
                  $ref: "#/definitions/StrokeWidth"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            style: {
              $ref: "#/definitions/Style",
              description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
            },
            text: {
              anyOf: [
                {
                  $ref: "#/definitions/Text"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            tooltip: {
              items: {
                $ref: "#/definitions/Tooltip"
              },
              type: "array"
            },
            visibility: {
              items: {
                $ref: "#/definitions/VisibilityCondition"
              },
              type: "array"
            },
            x: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1e: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            xAxis: {
              $ref: "#/definitions/AxisPosition",
              description: "not supported"
            },
            xDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic x-axis"
            },
            xOffset: {
              description: "Specify the x offset of views in the unit of pixels",
              type: "number"
            },
            xe: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1e: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            yDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic y-axis"
            },
            yOffset: {
              description: "Specify the y offset of views in the unit of pixels",
              type: "number"
            },
            ye: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            zoomLimits: {
              $ref: "#/definitions/ZoomLimits"
            }
          },
          type: "object"
        },
        type: "array"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "_overlay"
    ],
    type: "object"
  },
  OverlaidTracks: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      alignment: {
        "const": "overlay",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      tracks: {
        items: {
          $ref: "#/definitions/PartialTrack"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "alignment",
      "tracks"
    ],
    type: "object"
  },
  PartialTrack: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _overlay: {
        items: {
          additionalProperties: false,
          properties: {
            _assignedHeight: {
              type: "number"
            },
            _assignedWidth: {
              description: "Internal: Used for responsive spec",
              type: "number"
            },
            _invalidTrack: {
              description: "internal",
              type: "boolean"
            },
            _renderingId: {
              description: "internal",
              type: "string"
            },
            assembly: {
              $ref: "#/definitions/Assembly",
              description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
            },
            baselineY: {
              type: "number"
            },
            centerRadius: {
              description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
              type: "number"
            },
            color: {
              anyOf: [
                {
                  $ref: "#/definitions/Color"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            data: {
              $ref: "#/definitions/DataDeep"
            },
            dataTransform: {
              items: {
                $ref: "#/definitions/DataTransform"
              },
              type: "array"
            },
            displacement: {
              $ref: "#/definitions/Displacement"
            },
            endAngle: {
              description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            experimental: {
              additionalProperties: false,
              properties: {
                mouseEvents: {
                  anyOf: [
                    {
                      type: "boolean"
                    },
                    {
                      $ref: "#/definitions/MouseEventsDeep"
                    }
                  ]
                },
                performanceMode: {
                  "default": false,
                  description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                  type: "boolean"
                }
              },
              type: "object"
            },
            flipY: {
              type: "boolean"
            },
            id: {
              description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
              type: "string"
            },
            innerRadius: {
              description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
              type: "number"
            },
            linkingId: {
              description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
              type: "string"
            },
            mark: {
              $ref: "#/definitions/Mark"
            },
            opacity: {
              anyOf: [
                {
                  $ref: "#/definitions/Opacity"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            orientation: {
              $ref: "#/definitions/Orientation",
              description: "Specify the orientation."
            },
            outerRadius: {
              description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
              type: "number"
            },
            overlayOnPreviousTrack: {
              type: "boolean"
            },
            overrideTemplate: {
              type: "boolean"
            },
            prerelease: {
              additionalProperties: false,
              description: "internal",
              type: "object"
            },
            row: {
              anyOf: [
                {
                  $ref: "#/definitions/Row"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            size: {
              anyOf: [
                {
                  $ref: "#/definitions/Size"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            spacing: {
              description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
              type: "number"
            },
            startAngle: {
              description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            "static": {
              description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
              type: "boolean"
            },
            stretch: {
              type: "boolean"
            },
            stroke: {
              anyOf: [
                {
                  $ref: "#/definitions/Stroke"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            strokeWidth: {
              anyOf: [
                {
                  $ref: "#/definitions/StrokeWidth"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            style: {
              $ref: "#/definitions/Style",
              description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
            },
            text: {
              anyOf: [
                {
                  $ref: "#/definitions/Text"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            tooltip: {
              items: {
                $ref: "#/definitions/Tooltip"
              },
              type: "array"
            },
            visibility: {
              items: {
                $ref: "#/definitions/VisibilityCondition"
              },
              type: "array"
            },
            x: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1e: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            xAxis: {
              $ref: "#/definitions/AxisPosition",
              description: "not supported"
            },
            xDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic x-axis"
            },
            xOffset: {
              description: "Specify the x offset of views in the unit of pixels",
              type: "number"
            },
            xe: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1e: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            yDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic y-axis"
            },
            yOffset: {
              description: "Specify the y offset of views in the unit of pixels",
              type: "number"
            },
            ye: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            zoomLimits: {
              $ref: "#/definitions/ZoomLimits"
            }
          },
          type: "object"
        },
        type: "array"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        anyOf: [
          {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          {
            "const": "unknown",
            description: "No assemblies can be associated with a dummy track",
            type: "string"
          }
        ],
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      encoding: {
        additionalProperties: {
          $ref: "#/definitions/Channel"
        },
        type: "object"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        anyOf: [
          {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          {
            "const": "linear",
            description: "Only linear layout are supported at this time",
            type: "string"
          }
        ],
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        anyOf: [
          {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          {
            "const": true,
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          }
        ],
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`."
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        anyOf: [
          {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          {
            $ref: "#/definitions/DummyTrackStyle",
            description: "Defines how the track is styled"
          }
        ],
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      template: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      type: {
        "const": "dummy-track",
        description: "Used to specify the dummy track",
        type: "string"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        anyOf: [
          {
            $ref: "#/definitions/ZoomLimits"
          },
          {
            description: "Unused property for DummyTrack",
            items: {
              type: "null"
            },
            maxItems: 2,
            minItems: 2,
            type: "array"
          }
        ]
      }
    },
    type: "object"
  },
  PredefinedColors: {
    "enum": [
      "viridis",
      "grey",
      "spectral",
      "warm",
      "cividis",
      "bupu",
      "rdbu",
      "hot",
      "pink"
    ],
    type: "string"
  },
  Range: {
    anyOf: [
      {
        $ref: "#/definitions/ValueExtent"
      },
      {
        $ref: "#/definitions/PredefinedColors"
      }
    ]
  },
  RangeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      inRange: {
        description: "Check whether the value is in a number range.",
        items: {
          type: "number"
        },
        type: "array"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "inRange",
      "type"
    ],
    type: "object"
  },
  ResponsiveSize: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        additionalProperties: false,
        properties: {
          height: {
            type: "boolean"
          },
          width: {
            type: "boolean"
          }
        },
        type: "object"
      }
    ]
  },
  Row: {
    additionalProperties: false,
    properties: {
      clip: {
        description: "Clip row when the actual y value exceeds the max value of the y scale. Used only for bar marks at the moment. __Default__: `true`",
        type: "boolean"
      },
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      padding: {
        description: "Determines the size of inner white spaces on the top and bottom of individiual rows. __Default__: `0`",
        type: "number"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Determine the start and end position of rendering area of this track along vertical axis. __Default__: `[0, height]`"
      },
      type: {
        "const": "nominal",
        description: "Specify the data type",
        type: "string"
      }
    },
    type: "object"
  },
  SelectivityCondition: {
    additionalProperties: false,
    properties: {
      measure: {
        "enum": [
          "width",
          "height",
          "aspectRatio"
        ],
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation"
      },
      target: {
        description: "Does the condition applied to the visualization itself or its container? __Default__: `'self'`",
        "enum": [
          "self",
          "container"
        ],
        type: "string"
      },
      threshold: {
        description: "Threshold in the unit of pixels.",
        type: "number"
      }
    },
    required: [
      "operation",
      "measure",
      "threshold"
    ],
    type: "object"
  },
  SingleTrack: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "data",
      "mark"
    ],
    type: "object"
  },
  SingleView: {
    anyOf: [
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "overlay",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              $ref: "#/definitions/PartialTrack"
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "alignment",
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "stack",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/PartialTrack"
                },
                {
                  $ref: "#/definitions/OverlaidTracks"
                }
              ]
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          tracks: {
            items: {
              $ref: "#/definitions/Track"
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      }
    ]
  },
  Size: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "not supported: Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  SizeVisibilityCondition: {
    additionalProperties: false,
    properties: {
      conditionPadding: {
        description: "Specify the buffer size (in pixel) of width or height when calculating the visibility.\n\n__Default__: `0`",
        type: "number"
      },
      measure: {
        description: "Specify which aspect of the `target` will be compared to the `threshold`.",
        "enum": [
          "width",
          "height"
        ],
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation",
        description: 'A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`. Support\n\n- greater than : "greater-than", "gt", "GT"\n\n- less than : "less-than", "lt", "LT"\n\n- greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"\n\n- less than or equal to : "less-than-or-equal-to", "ltet", "LTET"'
      },
      target: {
        description: "Target specifies the object that you want to compare with the threshold.",
        "enum": [
          "track",
          "mark"
        ],
        type: "string"
      },
      threshold: {
        anyOf: [
          {
            type: "number"
          },
          {
            "const": "|xe-x|",
            type: "string"
          }
        ],
        description: 'Specify the threshold as one of:\n\n- A number representing a fixed threshold in the unit of pixels;\n\n- `"|xe-x|"`, using the distance between `xe` and `x` as threshold'
      },
      transitionPadding: {
        description: "Specify the buffer size (in pixel) of width or height for smooth transition.\n\n__Default__: `0`",
        type: "number"
      }
    },
    required: [
      "measure",
      "operation",
      "target",
      "threshold"
    ],
    type: "object"
  },
  StrConcatTransform: {
    additionalProperties: false,
    properties: {
      fields: {
        items: {
          type: "string"
        },
        type: "array"
      },
      newField: {
        type: "string"
      },
      separator: {
        type: "string"
      },
      type: {
        "const": "concat",
        type: "string"
      }
    },
    required: [
      "type",
      "fields",
      "newField",
      "separator"
    ],
    type: "object"
  },
  StrReplaceTransform: {
    additionalProperties: false,
    properties: {
      field: {
        type: "string"
      },
      newField: {
        type: "string"
      },
      replace: {
        items: {
          additionalProperties: false,
          properties: {
            from: {
              type: "string"
            },
            to: {
              type: "string"
            }
          },
          required: [
            "from",
            "to"
          ],
          type: "object"
        },
        type: "array"
      },
      type: {
        "const": "replace",
        type: "string"
      }
    },
    required: [
      "type",
      "field",
      "newField",
      "replace"
    ],
    type: "object"
  },
  Stroke: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/Range",
        description: "Ranges of visual channel values"
      },
      scaleOffset: {
        description: "Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]`",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      title: {
        description: "Title of the legend. __Default__: `undefined`",
        type: "string"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  StrokeWidth: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Style: {
    additionalProperties: false,
    properties: {
      align: {
        description: "Specify the alignment of marks. This property is currently only supported for `triangle` marks.",
        "enum": [
          "left",
          "right"
        ],
        type: "string"
      },
      background: {
        type: "string"
      },
      backgroundOpacity: {
        type: "number"
      },
      brush: {
        additionalProperties: false,
        description: "Customize the style of the brush mark in the `rangeSelect` mouse event.",
        properties: {
          color: {
            description: "color of the marks when mouse events are triggered",
            type: "string"
          },
          opacity: {
            description: "opacity of the marks when mouse events are triggered",
            type: "number"
          },
          stroke: {
            description: "stroke color of the marks when mouse events are triggered",
            type: "string"
          },
          strokeOpacity: {
            type: "number"
          },
          strokeWidth: {
            description: "stroke width of the marks when mouse events are triggered",
            type: "number"
          }
        },
        type: "object"
      },
      curve: {
        description: "Specify the curve of `rule` marks.",
        "enum": [
          "top",
          "bottom",
          "left",
          "right"
        ],
        type: "string"
      },
      dashed: {
        description: "Specify the pattern of dashes and gaps for `rule` marks.",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      dx: {
        description: "Offset the position of marks in x direction. This property is currently only supported for `text` marks",
        type: "number"
      },
      dy: {
        description: "Offset the position of marks in y direction. This property is currently only supported for `text` marks.",
        type: "number"
      },
      enableSmoothPath: {
        description: "Whether to enable smooth paths when drawing curves.\n\n__Default__: `false`",
        type: "boolean"
      },
      inlineLegend: {
        description: "Specify whether to show legend in a single horizontal line?",
        type: "boolean"
      },
      legendTitle: {
        description: "If defined, show legend title on the top or left",
        type: "string"
      },
      linePattern: {
        additionalProperties: false,
        description: "Specify the pattern of dashes and gaps for `rule` marks.",
        properties: {
          size: {
            type: "number"
          },
          type: {
            "enum": [
              "triangleLeft",
              "triangleRight"
            ],
            type: "string"
          }
        },
        required: [
          "type",
          "size"
        ],
        type: "object"
      },
      linkConnectionType: {
        description: 'Specify the connetion type of `betweenLink` marks.\n\n__Default__: `"corner"`',
        "enum": [
          "straight",
          "curve",
          "corner"
        ],
        type: "string"
      },
      linkMinHeight: {
        description: "The minimum height of `withinLink` and `betweenLink` marks. Unit is a percentagle. __Default__: `0.5`",
        type: "number"
      },
      linkStyle: {
        description: "The style of `withinLink` and `betweenLink` marks. __Default__: `'circular'` `'elliptical'` will be used as a default option.",
        "enum": [
          "elliptical",
          "circular",
          "straight"
        ],
        type: "string"
      },
      matrixExtent: {
        description: 'Determine to show only one side of the diagonal in a HiGlass matrix. __Default__: `"full"`',
        "enum": [
          "full",
          "upper-right",
          "lower-left"
        ],
        type: "string"
      },
      mouseOver: {
        $ref: "#/definitions/EventStyle",
        description: "Customize visual effects of `mouseOver` events on marks."
      },
      outline: {
        type: "string"
      },
      outlineWidth: {
        type: "number"
      },
      select: {
        $ref: "#/definitions/EventStyle",
        description: "Customize visual effects of `rangeSelect` events on marks ."
      },
      textAnchor: {
        description: "Specify the alignment of `text` marks to a given point.",
        "enum": [
          "start",
          "middle",
          "end"
        ],
        type: "string"
      },
      textFontSize: {
        description: "Specify the font size of `text` marks. Can also be specified using the `size` channel option of `text` marks.",
        type: "number"
      },
      textFontWeight: {
        description: "Specify the font weight of `text` marks.",
        "enum": [
          "bold",
          "normal"
        ],
        type: "string"
      },
      textStroke: {
        description: "Specify the stroke of `text` marks. Can also be specified using the `stroke` channel option of `text` marks.",
        type: "string"
      },
      textStrokeWidth: {
        description: "Specify the stroke width of `text` marks. Can also be specified using the `strokeWidth` channel option of `text` marks.",
        type: "number"
      },
      withinLinkVerticalLines: {
        description: "Whether to show vertical lines that connect to the baseline (axis) when `y` and `ye` are both used. __Default__: `false`",
        type: "boolean"
      }
    },
    type: "object"
  },
  SvTypeTransform: {
    additionalProperties: false,
    properties: {
      firstBp: {
        additionalProperties: false,
        description: "Based on the BEDPE, infer SV types. SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.",
        properties: {
          chrField: {
            type: "string"
          },
          posField: {
            type: "string"
          },
          strandField: {
            type: "string"
          }
        },
        required: [
          "chrField",
          "posField",
          "strandField"
        ],
        type: "object"
      },
      newField: {
        type: "string"
      },
      secondBp: {
        additionalProperties: false,
        description: "Based on the BEDPE, infer SV types. SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.",
        properties: {
          chrField: {
            type: "string"
          },
          posField: {
            type: "string"
          },
          strandField: {
            type: "string"
          }
        },
        required: [
          "chrField",
          "posField",
          "strandField"
        ],
        type: "object"
      },
      type: {
        "const": "svType",
        type: "string"
      }
    },
    required: [
      "type",
      "firstBp",
      "secondBp",
      "newField"
    ],
    type: "object"
  },
  TemplateTrack: {
    additionalProperties: false,
    description: "Template specification that will be internally converted into `SingleTrack` for rendering.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      encoding: {
        additionalProperties: {
          $ref: "#/definitions/Channel"
        },
        type: "object"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      template: {
        type: "string"
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "template",
      "data"
    ],
    type: "object"
  },
  Text: {
    additionalProperties: false,
    properties: {
      domain: {
        description: "Values of the data",
        items: {
          type: "string"
        },
        type: "array"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        description: "Ranges of visual channel values",
        items: {
          type: "string"
        },
        type: "array"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Tooltip: {
    additionalProperties: false,
    properties: {
      alt: {
        description: "Name of the data field for showing in the tooltip. Will use the field name if not specified.",
        type: "string"
      },
      field: {
        description: "Specifiy a data field whose value will show in the tooltip.",
        type: "string"
      },
      format: {
        description: "format of the data value.",
        type: "string"
      },
      type: {
        $ref: "#/definitions/FieldType",
        description: "Type of the data field."
      }
    },
    required: [
      "field",
      "type"
    ],
    type: "object"
  },
  Track: {
    anyOf: [
      {
        $ref: "#/definitions/SingleTrack"
      },
      {
        $ref: "#/definitions/OverlaidTrack"
      },
      {
        $ref: "#/definitions/DataTrack"
      },
      {
        $ref: "#/definitions/TemplateTrack"
      },
      {
        $ref: "#/definitions/DummyTrack"
      }
    ]
  },
  ValueExtent: {
    anyOf: [
      {
        items: {
          type: "string"
        },
        type: "array"
      },
      {
        items: {
          type: "number"
        },
        type: "array"
      }
    ]
  },
  VcfData: {
    additionalProperties: false,
    description: "The Variant Call Format (VCF).",
    properties: {
      indexUrl: {
        description: "URL link to the tabix index file",
        type: "string"
      },
      sampleLength: {
        description: "The maximum number of rows to be loaded from the URL. __Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "vcf",
        type: "string"
      },
      url: {
        description: "URL link to the VCF file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  VectorData: {
    additionalProperties: false,
    description: 'One-dimensional quantitative values along genomic position (e.g., bigwig) can be converted into HiGlass\' `"vector"` format data. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bigwig-files).',
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "vector",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  VisibilityCondition: {
    anyOf: [
      {
        $ref: "#/definitions/SizeVisibilityCondition"
      },
      {
        $ref: "#/definitions/ZoomLevelVisibilityCondition"
      }
    ]
  },
  X: {
    additionalProperties: false,
    properties: {
      aggregate: {
        $ref: "#/definitions/Aggregate",
        description: "Specify how to aggregate data. __Default__: `undefined`"
      },
      axis: {
        $ref: "#/definitions/AxisPosition",
        description: "Specify where should the axis be put"
      },
      domain: {
        $ref: "#/definitions/GenomicDomain",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field.",
        type: "string"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      linkingId: {
        description: "Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking)",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the visual channel."
      },
      type: {
        "const": "genomic",
        description: "Specify the data type.",
        type: "string"
      }
    },
    type: "object"
  },
  Y: {
    additionalProperties: false,
    properties: {
      aggregate: {
        $ref: "#/definitions/Aggregate",
        description: "Specify how to aggregate data. __Default__: `undefined`"
      },
      axis: {
        $ref: "#/definitions/AxisPosition",
        description: "Specify where should the axis be put"
      },
      baseline: {
        description: "Custom baseline of the y-axis. __Default__: `0`",
        type: [
          "string",
          "number"
        ]
      },
      domain: {
        anyOf: [
          {
            $ref: "#/definitions/ValueExtent"
          },
          {
            $ref: "#/definitions/GenomicDomain"
          }
        ],
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field.",
        type: "string"
      },
      flip: {
        description: "Whether to flip the y-axis. This is done by inverting the `range` property. __Default__: `false`",
        type: "boolean"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      linkingId: {
        description: "Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking)",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the visual channel."
      },
      type: {
        description: "Specify the data type.",
        "enum": [
          "quantitative",
          "nominal",
          "genomic"
        ],
        type: "string"
      },
      zeroBaseline: {
        description: "Specify whether to use zero baseline. __Default__: `true`",
        type: "boolean"
      }
    },
    type: "object"
  },
  ZoomLevelVisibilityCondition: {
    additionalProperties: false,
    properties: {
      conditionPadding: {
        description: "Specify the buffer size (in pixel) of width or height when calculating the visibility.\n\n__Default__: `0`",
        type: "number"
      },
      measure: {
        "const": "zoomLevel",
        description: "Specify which aspect of the `target` will be compared to the `threshold`.",
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation",
        description: 'A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`. Support\n\n- greater than : "greater-than", "gt", "GT"\n\n- less than : "less-than", "lt", "LT"\n\n- greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"\n\n- less than or equal to : "less-than-or-equal-to", "ltet", "LTET"'
      },
      target: {
        description: "Target specifies the object that you want to compare with the threshold.",
        "enum": [
          "track",
          "mark"
        ],
        type: "string"
      },
      threshold: {
        description: "Set a threshold in the unit of base pairs (bp)",
        type: "number"
      },
      transitionPadding: {
        description: "Specify the buffer size (in pixel) of width or height for smooth transition.\n\n__Default__: `0`",
        type: "number"
      }
    },
    required: [
      "measure",
      "operation",
      "target",
      "threshold"
    ],
    type: "object"
  },
  ZoomLimits: {
    items: {
      type: [
        "number",
        "null"
      ]
    },
    maxItems: 2,
    minItems: 2,
    type: "array"
  }
};
const GoslingSchema = {
  $ref: $ref$2,
  $schema: $schema$2,
  definitions: definitions$2
};
function validateGoslingSpec(spec) {
  return validateSpec(GoslingSchema, spec);
}
function validateSpec(schema, spec, silence = false) {
  const validate2 = new Ajv$1({ extendRefs: true }).compile(schema);
  const valid = validate2(spec);
  let message = "";
  let details = "";
  if (validate2.errors) {
    details = JSON.stringify(validate2.errors, null, 2);
    if (!silence) {
      console.warn(details);
    }
    message = "⚠️ Some properties are incorrectly used.";
  }
  return { state: valid ? "success" : "warn", message, details };
}
function validateTrack(track) {
  let valid = true;
  const errorMessages = [];
  const resolvedTrack = resolveSuperposedTracks(track);
  resolvedTrack.forEach((spec) => {
    if (!getGenomicChannelFromTrack(spec) && spec.mark !== "brush" && spec.mark !== "rule") {
      errorMessages.push("genomic type is not encoded to either a x- or y- axis");
      valid = false;
    }
    const color2 = spec.color;
    if (spec.mark === "line" && IsChannelDeep(color2) && color2.type === "quantitative") {
      errorMessages.push("`line` mark cannot be used with `quantitative` value");
      valid = false;
    }
  });
  return { valid, errorMessages };
}
function getGenomicChannelFromTrack(track) {
  let genomicChannel = void 0;
  ["x", "y", "xe", "ye", "x1", "y1", "x1e", "y1e"].reverse().forEach((channelType) => {
    const channel = track[channelType];
    if (IsChannelDeep(channel) && channel.type === "genomic") {
      genomicChannel = channel;
    }
  });
  return genomicChannel;
}
function getGenomicChannelKeyFromTrack(track) {
  let genomicChannelKey = void 0;
  ["x", "xe", "y", "ye", "x1", "y1", "x1e", "y1e"].reverse().forEach((channelKey) => {
    const channel = track[channelKey];
    if (IsChannelDeep(channel) && channel.type === "genomic") {
      genomicChannelKey = channelKey;
    }
  });
  return genomicChannelKey;
}
const $ref$1 = "#/definitions/Theme";
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const definitions$1 = {
  AxisStyle: {
    additionalProperties: false,
    properties: {
      baselineColor: {
        type: "string"
      },
      gridColor: {
        type: "string"
      },
      gridStrokeDash: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      gridStrokeType: {
        "enum": [
          "solid",
          "dashed"
        ],
        type: "string"
      },
      gridStrokeWidth: {
        type: "number"
      },
      labelColor: {
        type: "string"
      },
      labelFontFamily: {
        type: "string"
      },
      labelFontSize: {
        type: "number"
      },
      labelFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      tickColor: {
        type: "string"
      }
    },
    type: "object"
  },
  LegendStyle: {
    additionalProperties: false,
    properties: {
      background: {
        type: "string"
      },
      backgroundOpacity: {
        type: "number"
      },
      backgroundStroke: {
        type: "string"
      },
      labelColor: {
        type: "string"
      },
      labelFontFamily: {
        type: "string"
      },
      labelFontSize: {
        type: "number"
      },
      labelFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      position: {
        "enum": [
          "top",
          "right"
        ],
        type: "string"
      },
      tickColor: {
        type: "string"
      }
    },
    type: "object"
  },
  MarkStyle: {
    additionalProperties: false,
    properties: {
      color: {
        type: "string"
      },
      nominalColorRange: {
        items: {
          type: "string"
        },
        type: "array"
      },
      opacity: {
        type: "number"
      },
      quantitativeSizeRange: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      size: {
        type: "number"
      },
      stroke: {
        type: "string"
      },
      strokeWidth: {
        type: "number"
      }
    },
    type: "object"
  },
  RootStyle: {
    additionalProperties: false,
    properties: {
      background: {
        type: "string"
      },
      mousePositionColor: {
        type: "string"
      },
      showMousePosition: {
        type: "boolean"
      },
      subtitleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      subtitleBackgroundColor: {
        type: "string"
      },
      subtitleColor: {
        type: "string"
      },
      subtitleFontFamily: {
        type: "string"
      },
      subtitleFontSize: {
        type: "number"
      },
      subtitleFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      titleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      titleBackgroundColor: {
        type: "string"
      },
      titleColor: {
        type: "string"
      },
      titleFontFamily: {
        type: "string"
      },
      titleFontSize: {
        type: "number"
      },
      titleFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Theme: {
    anyOf: [
      {
        $ref: "#/definitions/ThemeType"
      },
      {
        $ref: "#/definitions/ThemeDeep"
      }
    ]
  },
  ThemeDeep: {
    additionalProperties: false,
    properties: {
      area: {
        $ref: "#/definitions/MarkStyle"
      },
      axis: {
        $ref: "#/definitions/AxisStyle"
      },
      bar: {
        $ref: "#/definitions/MarkStyle"
      },
      base: {
        $ref: "#/definitions/ThemeType"
      },
      brush: {
        $ref: "#/definitions/MarkStyle"
      },
      legend: {
        $ref: "#/definitions/LegendStyle"
      },
      line: {
        $ref: "#/definitions/MarkStyle"
      },
      link: {
        $ref: "#/definitions/MarkStyle"
      },
      markCommon: {
        $ref: "#/definitions/MarkStyle"
      },
      point: {
        $ref: "#/definitions/MarkStyle"
      },
      rect: {
        $ref: "#/definitions/MarkStyle"
      },
      root: {
        $ref: "#/definitions/RootStyle"
      },
      rule: {
        $ref: "#/definitions/MarkStyle"
      },
      text: {
        additionalProperties: false,
        properties: {
          color: {
            type: "string"
          },
          nominalColorRange: {
            items: {
              type: "string"
            },
            type: "array"
          },
          opacity: {
            type: "number"
          },
          quantitativeSizeRange: {
            items: {
              type: "number"
            },
            maxItems: 2,
            minItems: 2,
            type: "array"
          },
          size: {
            type: "number"
          },
          stroke: {
            type: "string"
          },
          strokeWidth: {
            type: "number"
          },
          textAnchor: {
            "enum": [
              "start",
              "middle",
              "end"
            ],
            type: "string"
          },
          textFontWeight: {
            "enum": [
              "bold",
              "normal"
            ],
            type: "string"
          }
        },
        type: "object"
      },
      track: {
        $ref: "#/definitions/TrackStyle"
      },
      triangle: {
        $ref: "#/definitions/MarkStyle"
      }
    },
    required: [
      "base"
    ],
    type: "object"
  },
  ThemeType: {
    "enum": [
      "light",
      "dark",
      "warm",
      "ggplot",
      "igv",
      "ensembl",
      "jbrowse",
      "ucsc",
      "washu",
      "excel",
      "google"
    ],
    type: "string"
  },
  TrackStyle: {
    additionalProperties: false,
    properties: {
      alternatingBackground: {
        type: "string"
      },
      background: {
        type: "string"
      },
      outline: {
        type: "string"
      },
      outlineWidth: {
        type: "number"
      },
      titleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      titleBackground: {
        type: "string"
      },
      titleColor: {
        type: "string"
      },
      titleFontSize: {
        type: "number"
      }
    },
    type: "object"
  }
};
const theme_schema = {
  $ref: $ref$1,
  $schema: $schema$1,
  definitions: definitions$1
};
function getStyleOverridden(parent, child) {
  const base = parent ? JSON.parse(JSON.stringify(parent)) : {};
  return child ? Object.assign(base, child) : base;
}
function fallback() {
  return Math.random().toString(36).substring(2, 10);
}
function uuid() {
  var _a, _b, _c;
  return (_c = (_b = (_a = globalThis.crypto).randomUUID) == null ? void 0 : _b.call(_a)) != null ? _c : fallback();
}
function traverseTracks(spec, callback) {
  if ("tracks" in spec) {
    spec.tracks.forEach((t, i, ts) => {
      callback(t, i, ts);
      traverseTracks(t, callback);
    });
  } else if ("views" in spec) {
    spec.views.forEach((view) => traverseTracks(view, callback));
  }
}
function traverseTracksAndViews(spec, callback) {
  if ("tracks" in spec) {
    spec.tracks.forEach((t) => {
      callback(t);
      traverseTracksAndViews(t, callback);
    });
  } else if ("views" in spec) {
    spec.views.forEach((v) => {
      callback(v);
      traverseTracksAndViews(v, callback);
    });
  }
}
function traverseViewArrangements(spec, callback) {
  if ("tracks" in spec)
    ;
  else {
    callback(spec);
    spec.views.forEach((v) => {
      traverseViewArrangements(v, callback);
    });
  }
}
function convertToFlatTracks(spec) {
  if (IsFlatTracks(spec)) {
    const base = { ...spec, tracks: void 0, id: void 0 };
    return spec.tracks.filter((track) => !track._invalidTrack).map((track) => Object.assign(JSON.parse(JSON.stringify(base)), track));
  }
  const newTracks = [];
  if (IsStackedTracks(spec)) {
    spec.tracks.filter((track) => !track._invalidTrack).map((track) => {
      if ("alignment" in track) {
        newTracks.push({
          ...track,
          _overlay: [...track.tracks],
          tracks: void 0,
          alignment: void 0
        });
      } else {
        const base = { ...spec, tracks: void 0, id: void 0 };
        const newSpec = Object.assign(JSON.parse(JSON.stringify(base)), track);
        newTracks.push(newSpec);
      }
    });
  } else {
    newTracks.push({
      ...spec,
      _overlay: [...spec.tracks.filter((track) => !track._invalidTrack)],
      tracks: void 0,
      alignment: void 0
    });
  }
  return JSON.parse(JSON.stringify(newTracks));
}
function traverseToFixSpecDownstream(spec, parentDef) {
  if (parentDef) {
    if (spec.assembly === void 0)
      spec.assembly = parentDef.assembly;
    if (spec.layout === void 0)
      spec.layout = parentDef.layout;
    if (spec.orientation === void 0)
      spec.orientation = parentDef.orientation;
    if (spec.static === void 0)
      spec.static = parentDef.static !== void 0 ? parentDef.static : false;
    if (spec.zoomLimits === void 0)
      spec.zoomLimits = parentDef.zoomLimits;
    if (spec.xDomain === void 0)
      spec.xDomain = parentDef.xDomain;
    if (spec.yDomain === void 0)
      spec.yDomain = parentDef.yDomain;
    if (spec.linkingId === void 0)
      spec.linkingId = parentDef.linkingId;
    if (spec.centerRadius === void 0)
      spec.centerRadius = parentDef.centerRadius;
    if (spec.spacing === void 0 && !("tracks" in spec))
      spec.spacing = parentDef.spacing;
    if (spec.xOffset === void 0)
      spec.xOffset = parentDef.xOffset;
    if (spec.yOffset === void 0)
      spec.yOffset = parentDef.yOffset;
    if ("views" in spec && "arrangement" in parentDef && spec.arrangement === void 0)
      spec.arrangement = parentDef.arrangement;
    spec.style = getStyleOverridden(parentDef.style, spec.style);
  } else {
    if (spec.assembly === void 0)
      spec.assembly = "hg38";
    if (spec.layout === void 0)
      spec.layout = "linear";
    if (spec.orientation === void 0)
      spec.orientation = "horizontal";
    if (spec.static === void 0)
      spec.static = false;
    if (spec.zoomLimits === void 0)
      spec.zoomLimits = [1, null];
    if (spec.centerRadius === void 0)
      spec.centerRadius = DEFAULT_INNER_RADIUS_PROP;
    if (spec.spacing === void 0)
      spec.spacing = DEFAULT_VIEW_SPACING;
    if ("views" in spec && spec.arrangement === void 0)
      spec.arrangement = "vertical";
    if (spec.xOffset === void 0)
      spec.xOffset = 0;
    if (spec.yOffset === void 0)
      spec.yOffset = 0;
  }
  if (!spec.id) {
    spec.id = uuid();
  }
  if ("tracks" in spec) {
    let tracks = convertToFlatTracks(spec);
    tracks = spreadTracksByData(tracks);
    const linkID = uuid();
    tracks.forEach((track, i, array) => {
      var _a, _b, _c;
      if (!track.id) {
        track.id = uuid();
      }
      if (!track.width) {
        track.width = Is2DTrack(track) ? DEFAULT_TRACK_SIZE_2D : DEFAULT_TRACK_WIDTH_LINEAR;
      }
      if (!track.height) {
        track.height = Is2DTrack(track) ? DEFAULT_TRACK_SIZE_2D : DEFAULT_TRACK_HEIGHT_LINEAR;
      }
      if ("displacement" in track) {
        if (((_a = track.displacement) == null ? void 0 : _a.type) === "pile" && track.row === void 0 && IsChannelDeep(track.x) && track.x.field && IsChannelDeep(track.xe) && track.xe.field) {
          const newField = uuid();
          const startField = track.x.field;
          const endField = track.xe.field;
          const padding = track.displacement.padding;
          const displaceTransform = {
            type: "displace",
            newField,
            boundingBox: { startField, endField, padding },
            method: "pile"
          };
          if (!track.dataTransform) {
            track.dataTransform = [];
          }
          track.dataTransform = [...track.dataTransform, displaceTransform];
          track.row = { field: newField, type: "nominal" };
        } else if (((_b = track.displacement) == null ? void 0 : _b.type) === "spread")
          ;
      }
      if (track.layout)
        track.layout = void 0;
      if (track.zoomLimits)
        track.zoomLimits = void 0;
      if (!track.assembly)
        track.assembly = spec.assembly;
      if (!track.layout)
        track.layout = spec.layout;
      if (!track.orientation)
        track.orientation = spec.orientation;
      if (track.static === void 0)
        track.static = spec.static !== void 0 ? spec.static : false;
      if (!track.zoomLimits)
        track.zoomLimits = spec.zoomLimits;
      if (track.layout == "circular" && IsDummyTrack(track)) {
        track._invalidTrack = true;
        return;
      }
      track.style = getStyleOverridden(spec.style, track.style);
      if (IsOverlaidTrack(track)) {
        track._overlay = track._overlay.filter((overlayTrack) => {
          return !("type" in overlayTrack && overlayTrack.type == "dummy-track");
        });
        track._overlay.forEach((o) => {
          o.style = getStyleOverridden(track.style, o.style);
        });
      }
      if ((track.layout === "circular" || Is2DTrack(track)) && track.orientation === "vertical") {
        track.orientation = "horizontal";
      }
      if (Is2DTrack(track)) {
        track.layout = "linear";
        if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.y) && !track.y.domain) {
          track.y.domain = spec.yDomain;
        } else if (IsOverlaidTrack(track)) {
          track._overlay.forEach((o) => {
            if (IsChannelDeep(o.y) && !o.y.domain) {
              o.y.domain = spec.yDomain;
            }
          });
        }
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.domain) {
        track.x.domain = spec.xDomain;
      } else if (IsOverlaidTrack(track)) {
        track._overlay.forEach((o) => {
          if (IsChannelDeep(o.x) && !o.x.domain) {
            o.x.domain = spec.xDomain;
          }
        });
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.linkingId) {
        track.x.linkingId = (_c = spec.linkingId) != null ? _c : linkID;
      } else if (IsOverlaidTrack(track)) {
        let isAdded = false;
        track._overlay.forEach((o) => {
          var _a2;
          if (isAdded)
            return;
          if (IsChannelDeep(o.x) && !o.x.linkingId) {
            o.x.linkingId = (_a2 = spec.linkingId) != null ? _a2 : linkID;
            isAdded = true;
          }
        });
      }
      if (i === 0) {
        track.overlayOnPreviousTrack = false;
      }
      if (i === 0 || i !== 0 && tracks.slice(0, i).filter((d) => !d.overlayOnPreviousTrack).length === 1 && track.overlayOnPreviousTrack === true) {
        if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.axis) {
          if (track.orientation === "vertical") {
            track.x.axis = "left";
          } else {
            track.x.axis = "top";
          }
        } else if (IsOverlaidTrack(track)) {
          track._overlay.forEach((o) => {
            if (IsChannelDeep(o.x) && !o.x.axis) {
              if (track.orientation === "vertical") {
                o.x.axis = "left";
              } else {
                o.x.axis = "top";
              }
            }
          });
        }
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && track.x.axis && track.x.axis !== "none") {
        if (track.orientation === "vertical") {
          if (track.x.axis === "top") {
            track.x.axis = "left";
          } else if (track.x.axis === "bottom") {
            track.x.axis = "right";
          }
        } else {
          if (track.x.axis === "left") {
            track.x.axis = "top";
          } else if (track.x.axis === "right") {
            track.x.axis = "bottom";
          }
        }
      } else if (IsOverlaidTrack(track)) {
        track._overlay.forEach((o) => {
          if (IsChannelDeep(o.x) && o.x.axis && o.x.axis !== "none") {
            if (track.orientation === "vertical") {
              if (o.x.axis === "top") {
                o.x.axis = "left";
              } else if (o.x.axis === "bottom") {
                o.x.axis = "right";
              }
            } else {
              if (o.x.axis === "left") {
                o.x.axis = "top";
              } else if (o.x.axis === "right") {
                o.x.axis = "bottom";
              }
            }
          }
        });
      }
      if (
        // first track can never flipped by default
        i !== 0 && // [0, ..., i] tracks should not overlaid as a single track
        (i === array.length - 1 && array.slice(0, i + 1).filter((d) => d.overlayOnPreviousTrack).length < i || // Are the rest of the tracks overlaid as a single track?
        i !== array.length - 1 && array.slice(i + 1).filter((d) => d.overlayOnPreviousTrack).length === array.length - i - 1 && array.slice(0, i + 1).filter((d) => d.overlayOnPreviousTrack).length < i)
      ) {
        if (IsSingleTrack(track) && track.mark === "withinLink" && track.flipY === void 0) {
          track.flipY = true;
        } else if (IsOverlaidTrack(track)) {
          if (track.mark === "withinLink" && track.flipY === void 0) {
            track.flipY = true;
          }
          track._overlay.forEach((o) => {
            if (o.mark === "withinLink" && o.flipY === void 0) {
              o.flipY = true;
            }
          });
        }
      }
      if (track.overlayOnPreviousTrack && array[i - 1]) {
        track.width = array[i - 1].width;
        track.height = array[i - 1].height;
        track.layout = array[i - 1].layout;
        track.assembly = array[i - 1].assembly;
      }
    });
    tracks = tracks.filter((track) => !track._invalidTrack);
    spec.tracks = tracks;
  } else {
    spec.views.forEach((v) => {
      traverseToFixSpecDownstream(v, spec);
    });
  }
}
function getVectorTemplate(column, value) {
  return {
    data: {
      type: "vector",
      url: "",
      column,
      value
    },
    mark: "bar",
    x: { field: column, type: "genomic", axis: "top" },
    y: { field: value, type: "quantitative" },
    width: 400,
    height: 100
  };
}
function getMultivecTemplate(row, column, value, categories) {
  return categories && categories.length < 10 ? {
    data: {
      type: "multivec",
      url: "",
      row,
      column,
      value,
      categories
    },
    mark: "bar",
    x: { field: column, type: "genomic", axis: "top" },
    y: { field: value, type: "quantitative" },
    row: { field: row, type: "nominal", legend: true },
    color: { field: row, type: "nominal" },
    width: 400,
    height: 100
  } : {
    data: {
      type: "multivec",
      url: "",
      row,
      column,
      value,
      categories
    },
    mark: "rect",
    x: { field: column, type: "genomic", axis: "top" },
    row: { field: row, type: "nominal", legend: true },
    color: { field: value, type: "quantitative" },
    width: 400,
    height: 100
  };
}
function overrideDataTemplates(spec) {
  traverseTracks(spec, (t, i, ts) => {
    var _a, _b, _c, _d, _e;
    if (!("data" in t) || !t.data || !IsDataDeepTileset(t.data)) {
      return;
    }
    if ("alignment" in t) {
      return;
    }
    if (!IsDataTemplate(t)) {
      return;
    }
    switch (t.data.type) {
      case "vector":
      case "bigwig":
        ts[i] = Object.assign(getVectorTemplate((_a = t.data.column) != null ? _a : "position", (_b = t.data.value) != null ? _b : "value"), t);
        break;
      case "multivec":
        ts[i] = Object.assign(
          getMultivecTemplate(
            (_c = t.data.row) != null ? _c : "category",
            (_d = t.data.column) != null ? _d : "position",
            (_e = t.data.value) != null ? _e : "value",
            t.data.categories
          ),
          t
        );
        break;
    }
  });
}
const GoslingTemplates = [
  {
    name: "gene",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "strandColor", type: "nominal", required: true },
      { name: "strandRow", type: "nominal", required: true },
      { name: "opacity", type: "value", required: false },
      { name: "geneHeight", type: "value", required: false },
      { name: "geneLabel", type: "nominal", required: true },
      { name: "geneLabelColor", type: "nominal", required: true },
      { name: "geneLabelFontSize", type: "value", required: false },
      { name: "geneLabelStroke", type: "value", required: false },
      { name: "geneLabelStrokeThickness", type: "value", required: false },
      { name: "geneLabelOpacity", type: "value", required: false },
      { name: "type", type: "nominal", required: true }
      // either 'gene' or 'exon'
    ],
    mapping: [
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["-"] }
        ],
        mark: "triangleLeft",
        x: { base: "startPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        style: { align: "right" }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["+"] }
        ],
        mark: "triangleRight",
        x: { base: "endPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        style: { align: "left" }
      },
      {
        dataTransform: [{ type: "filter", base: "type", oneOf: ["exon"] }],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["+"] }
        ],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        size: { value: 3 }
        // style: {
        //     linePattern: { type: 'triangleRight', size: 5 }
        // }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["-"] }
        ],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        size: { value: 3 }
        // style: {
        //     linePattern: { type: 'triangleLeft', size: 5 }
        // }
      },
      {
        dataTransform: [{ type: "filter", base: "type", oneOf: ["gene"] }],
        mark: "text",
        text: { base: "geneLabel", type: "nominal" },
        // TODO: add dy here
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "geneLabelColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 1 },
        size: { base: "geneLabelFontSize", value: 18 },
        stroke: { base: "geneLabelStroke", value: "white" },
        strokeWidth: { base: "geneLabelStrokeThickness", value: 2 },
        // TODO: how to redefine style from the users' side? (e.g., dy: -30)
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 10,
            target: "mark"
          }
        ]
      }
    ]
  },
  {
    name: "ideogram",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "chrHeight", type: "value", required: false },
      // https://eweitz.github.io/ideogram/
      { name: "name", type: "nominal", required: true },
      { name: "stainBackgroundColor", type: "nominal", required: true },
      { name: "stainLabelColor", type: "nominal", required: true },
      { name: "stainStroke", type: "value", required: false },
      { name: "stainStrokeWidth", type: "value", required: false }
    ],
    mapping: [
      {
        mark: "rect",
        dataTransform: [{ type: "filter", base: "stainBackgroundColor", oneOf: ["acen"], not: true }],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "triangleRight",
        dataTransform: [
          { type: "filter", base: "stainBackgroundColor", oneOf: ["acen"] },
          { type: "filter", base: "name", include: "q" }
        ],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "triangleLeft",
        dataTransform: [
          { type: "filter", base: "stainBackgroundColor", oneOf: ["acen"] },
          { type: "filter", base: "name", include: "p" }
        ],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "text",
        dataTransform: [{ type: "filter", base: "stainLabelColor", oneOf: ["acen"], not: true }],
        color: {
          base: "stainLabelColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar"],
          range: ["black", "black", "black", "black", "white", "black"]
        },
        text: { base: "name", type: "nominal" },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 10,
            target: "mark"
          }
        ]
      }
    ]
  },
  {
    name: "sequence",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "barLength", type: "quantitative", required: true },
      { name: "baseBackground", type: "nominal", required: true },
      { name: "baseLabelColor", type: "nominal", required: true },
      { name: "baseLabelFontSize", type: "value", required: false }
    ],
    mapping: [
      {
        mark: "bar",
        // x: { base: 'position', type: 'genomic' },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        y: { base: "barLength", type: "quantitative", axis: "none" },
        color: { base: "baseBackground", type: "nominal", domain: ["A", "T", "G", "C"] }
      },
      {
        dataTransform: [{ type: "filter", base: "barLength", oneOf: [0], not: true }],
        mark: "text",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        color: { base: "baseLabelColor", type: "nominal", domain: ["A", "T", "G", "C"], range: ["white"] },
        text: { base: "baseBackground", type: "nominal" },
        size: { base: "baseLabelFontSize", value: 18 },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 30,
            target: "mark"
          },
          {
            operation: "LT",
            measure: "zoomLevel",
            threshold: 10,
            target: "track"
          }
        ]
      }
    ]
  }
];
function replaceTrackTemplates(spec, templates) {
  traverseTracks(spec, (t, i, ts) => {
    var _a, _b;
    if (!IsTemplateTrack(t)) {
      return;
    }
    const { template: name2 } = t;
    const templateDef = templates.find((d) => d.name === name2);
    if (!templateDef) {
      t._invalidTrack = true;
      console.warn(`There is no track template named '${name2}'`);
      return;
    }
    let isValid = true;
    templateDef.channels.forEach((d) => {
      if (d.required && (!t.encoding || !(d.name in t.encoding))) {
        isValid = false;
        console.warn(`A template spec ('${name2}') does not contain a required channel, ${d.name}`);
      }
    });
    if (!isValid) {
      t._invalidTrack = true;
      return;
    }
    const viewBase = JSON.parse(JSON.stringify(t));
    if ("encoding" in viewBase) {
      delete viewBase.encoding;
    }
    const convertedView = {
      ...viewBase,
      alignment: "overlay",
      tracks: [],
      width: (_a = t.width) != null ? _a : 100,
      height: (_b = t.height) != null ? _b : 100
    };
    templateDef.mapping.forEach((singleTrackMappingDef) => {
      const convertedTrack = {
        data: t.data,
        mark: singleTrackMappingDef.mark
      };
      const { dataTransform } = singleTrackMappingDef;
      if (dataTransform) {
        dataTransform.map((dataTramsformMap) => {
          const baseChannelName = dataTramsformMap.base;
          if (baseChannelName && t.encoding && baseChannelName in t.encoding && "field" in t.encoding[baseChannelName]) {
            delete dataTramsformMap.base;
            dataTramsformMap.field = t.encoding[baseChannelName].field;
          }
        });
      }
      const encodingSpec = t.encoding;
      if (!encodingSpec) {
        Object.keys(singleTrackMappingDef).filter((k) => k !== "mark").forEach((channelKey) => {
          const channelMap = JSON.parse(JSON.stringify(singleTrackMappingDef[channelKey]));
          if ("base" in channelMap) {
            delete channelMap.base;
          }
          convertedTrack[channelKey] = channelMap;
        });
      } else {
        Object.keys(singleTrackMappingDef).filter((k) => k !== "mark").forEach((channelKey) => {
          const channelMap = JSON.parse(JSON.stringify(singleTrackMappingDef[channelKey]));
          if ("base" in channelMap) {
            const baseChannelName = channelMap.base;
            if (baseChannelName in encodingSpec) {
              const base = JSON.parse(JSON.stringify(encodingSpec[baseChannelName]));
              delete channelMap.base;
              const newChannelSpec = Object.assign(channelMap, JSON.parse(JSON.stringify(base)));
              convertedTrack[channelKey] = newChannelSpec;
            } else {
              delete channelMap.base;
              convertedTrack[channelKey] = channelMap;
            }
          } else {
            convertedTrack[channelKey] = channelMap;
          }
        });
      }
      convertedView.tracks.push(convertedTrack);
    });
    ts[i] = convertedView;
  });
}
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}
function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};
function identity$1(x) {
  return x;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$1 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$1 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group2(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
const CHROM_SIZE_HG38 = {
  chr1: 248956422,
  chr2: 242193529,
  chr3: 198295559,
  chr4: 190214555,
  chr5: 181538259,
  chr6: 170805979,
  chr7: 159345973,
  chr8: 145138636,
  chr9: 138394717,
  chr10: 133797422,
  chr11: 135086622,
  chr12: 133275309,
  chr13: 114364328,
  chr14: 107043718,
  chr15: 101991189,
  chr16: 90338345,
  chr17: 83257441,
  chr18: 80373285,
  chr19: 58617616,
  chr20: 64444167,
  chr21: 46709983,
  chr22: 50818468,
  chrX: 156040895,
  chrY: 57227415
};
const CHROM_SIZE_HG19 = {
  chr1: 249250621,
  chr2: 243199373,
  chr3: 198022430,
  chr4: 191154276,
  chr5: 180915260,
  chr6: 171115067,
  chr7: 159138663,
  chr8: 146364022,
  chr9: 141213431,
  chr10: 135534747,
  chr11: 135006516,
  chr12: 133851895,
  chr13: 115169878,
  chr14: 107349540,
  chr15: 102531392,
  chr16: 90354753,
  chr17: 81195210,
  chr18: 78077248,
  chr19: 59128983,
  chr20: 63025520,
  chr21: 48129895,
  chr22: 51304566,
  chrX: 155270560,
  chrY: 59373566,
  chrM: 16571
};
const CHROM_SIZE_HG18 = {
  chr1: 247249719,
  chr2: 242951149,
  chr3: 199501827,
  chr4: 191273063,
  chr5: 180857866,
  chr6: 170899992,
  chr7: 158821424,
  chr8: 146274826,
  chr9: 140273252,
  chr10: 135374737,
  chr11: 134452384,
  chr12: 132349534,
  chr13: 114142980,
  chr14: 106368585,
  chr15: 100338915,
  chr16: 88827254,
  chr17: 78774742,
  chr18: 76117153,
  chr19: 63811651,
  chr20: 62435964,
  chr21: 46944323,
  chr22: 49691432,
  chrX: 154913754,
  chrY: 57772954,
  chrM: 16571
};
const CHROM_SIZE_HG17 = {
  chr1: 245522847,
  chr2: 243018229,
  chr3: 199505740,
  chr4: 191411218,
  chr5: 180857866,
  chr6: 170975699,
  chr7: 158628139,
  chr8: 146274826,
  chr9: 138429268,
  chr10: 135413628,
  chr11: 134452384,
  chr12: 132449811,
  chr13: 114142980,
  chr14: 106368585,
  chr15: 100338915,
  chr16: 88827254,
  chr17: 78774742,
  chr18: 76117153,
  chr19: 63811651,
  chr20: 62435964,
  chr21: 46944323,
  chr22: 49554710,
  chrX: 154824264,
  chrY: 57701691,
  chrM: 16571
};
const CHROM_SIZE_HG16 = {
  chr1: 246127941,
  chr2: 243615958,
  chr3: 199344050,
  chr4: 191731959,
  chr5: 181034922,
  chr6: 170914576,
  chr7: 158545518,
  chr8: 146308819,
  chr9: 136372045,
  chr10: 135037215,
  chr11: 134482954,
  chr12: 132078379,
  chr13: 113042980,
  chr14: 105311216,
  chr15: 100256656,
  chr16: 90041932,
  chr17: 81860266,
  chr18: 76115139,
  chr19: 63811651,
  chr20: 63741868,
  chr21: 46976097,
  chr22: 49396972,
  chrX: 153692391,
  chrY: 50286555,
  chrM: 16571
};
const CHROM_SIZE_MM10 = {
  chr1: 195471971,
  chr2: 182113224,
  chr3: 160039680,
  chr4: 156508116,
  chr5: 151834684,
  chr6: 149736546,
  chr7: 145441459,
  chr8: 129401213,
  chr9: 124595110,
  chr10: 130694993,
  chr11: 122082543,
  chr12: 120129022,
  chr13: 120421639,
  chr14: 124902244,
  chr15: 104043685,
  chr16: 98207768,
  chr17: 94987271,
  chr18: 90702639,
  chr19: 61431566,
  chrX: 171031299,
  chrY: 91744698,
  chrM: 16299
};
const CHROM_SIZE_MM9 = {
  chr1: 197195432,
  chr2: 181748087,
  chr3: 159599783,
  chr4: 155630120,
  chr5: 152537259,
  chr6: 149517037,
  chr7: 152524553,
  chr8: 131738871,
  chr9: 124076172,
  chr10: 129993255,
  chr11: 121843856,
  chr12: 121257530,
  chr13: 120284312,
  chr14: 125194864,
  chr15: 103494974,
  chr16: 98319150,
  chr17: 95272651,
  chr18: 90772031,
  chr19: 61342430,
  chrX: 166650296,
  chrY: 15902555,
  chrM: 16299
};
function getRelativeGenomicPosition(absPos, assembly, returnWithinAssembly = false) {
  const chrSizes = Object.entries(computeChromSizes(assembly).interval);
  const minPosChr = { chromosome: "unknown", position: Infinity };
  const maxPosChr = { chromosome: "unknown", position: 0 };
  for (const chrSize of chrSizes) {
    const [chromosome, absInterval] = chrSize;
    const [start, end] = absInterval;
    if (start <= absPos && absPos < end) {
      return { chromosome, position: absPos - start };
    }
    if (start < minPosChr.position) {
      minPosChr.chromosome = chromosome;
      minPosChr.position = start;
    }
    if (end > maxPosChr.position) {
      maxPosChr.chromosome = chromosome;
      maxPosChr.position = end;
    }
  }
  if (returnWithinAssembly) {
    if (absPos < minPosChr.position) {
      return minPosChr;
    } else {
      return maxPosChr;
    }
  } else {
    return { chromosome: "unknown", position: absPos };
  }
}
function createChromSizesUrl(chromSizes) {
  const text = chromSizes.map((d) => d.join("	")).join("\n");
  const tsv = new Blob([text], { type: "text/tsv" });
  return URL.createObjectURL(tsv);
}
function computeChromSizes(assembly) {
  if (assembly && typeof assembly === "string" && assembly in CRHOM_SIZES) {
    return CRHOM_SIZES[assembly];
  } else if (Array.isArray(assembly) && assembly.length !== 0) {
    const size = Object.fromEntries(assembly);
    return {
      size,
      interval: getChromInterval(size),
      total: getChromTotalSize(size),
      path: createChromSizesUrl(assembly)
    };
  } else {
    return CRHOM_SIZES.hg38;
  }
}
const basePath = (assembly) => `https://s3.amazonaws.com/gosling-lang.org/data/${assembly}.chrom.sizes`;
const CRHOM_SIZES = Object.freeze({
  hg38: {
    size: CHROM_SIZE_HG38,
    interval: getChromInterval(CHROM_SIZE_HG38),
    total: getChromTotalSize(CHROM_SIZE_HG38),
    path: basePath("hg38")
  },
  hg19: {
    size: CHROM_SIZE_HG19,
    interval: getChromInterval(CHROM_SIZE_HG19),
    total: getChromTotalSize(CHROM_SIZE_HG19),
    path: basePath("hg19")
  },
  hg18: {
    size: CHROM_SIZE_HG18,
    interval: getChromInterval(CHROM_SIZE_HG18),
    total: getChromTotalSize(CHROM_SIZE_HG18),
    path: basePath("hg18")
  },
  hg17: {
    size: CHROM_SIZE_HG17,
    interval: getChromInterval(CHROM_SIZE_HG17),
    total: getChromTotalSize(CHROM_SIZE_HG17),
    path: basePath("hg17")
  },
  hg16: {
    size: CHROM_SIZE_HG16,
    interval: getChromInterval(CHROM_SIZE_HG16),
    total: getChromTotalSize(CHROM_SIZE_HG16),
    path: basePath("hg16")
  },
  mm10: {
    size: CHROM_SIZE_MM10,
    interval: getChromInterval(CHROM_SIZE_MM10),
    total: getChromTotalSize(CHROM_SIZE_MM10),
    path: basePath("mm10")
  },
  mm9: {
    size: CHROM_SIZE_MM9,
    interval: getChromInterval(CHROM_SIZE_MM9),
    total: getChromTotalSize(CHROM_SIZE_MM9),
    path: basePath("mm9")
  },
  // `unknown` assembly contains only one chromosome with max length
  unknown: {
    size: { chr: Number.MAX_VALUE },
    interval: { chr: [0, Number.MAX_VALUE] },
    total: Number.MAX_VALUE,
    path: basePath("hg38")
    // just to ensure this does not make crash
  }
});
function getAutoCompleteId(assembly) {
  switch (assembly) {
    case "hg19":
      return "OHJakQICQD6gTD7skx4EWA";
    case "mm10":
      return "QDutvmyiSrec5nX4pA5WGQ";
    case "mm9":
      return "GUm5aBiLRCyz2PsBea7Yzg";
    case "hg38":
    default:
      return "P0PLbQMwTYGy-5uPIQid7A";
  }
}
function getChromInterval(chromSize) {
  const interval = {};
  Object.keys(chromSize).reduce((sum2, k) => {
    interval[k] = [sum2, sum2 + chromSize[k]];
    return sum2 + chromSize[k];
  }, 0);
  return interval;
}
function getChromTotalSize(chromSize) {
  return Object.values(chromSize).reduce((sum2, current) => sum2 + current, 0);
}
function parseGenomicPosition(position) {
  const [chromosome, intervalString] = position.split(":");
  if (intervalString) {
    const [start, end] = intervalString.split("-").map((s) => +s.replace(/,/g, ""));
    if (!Number.isNaN(start) && !Number.isNaN(end)) {
      return { chromosome, start, end };
    }
  }
  return { chromosome };
}
class GenomicPositionHelper {
  constructor(chromosome, start, end) {
    this.chromosome = chromosome;
    this.start = start;
    this.end = end;
  }
  static fromString(str) {
    const result = parseGenomicPosition(str);
    return new GenomicPositionHelper(result.chromosome, result.start, result.end);
  }
  toAbsoluteCoordinates(assembly, padding = 0) {
    const info = computeChromSizes(assembly);
    const size = info.size[this.chromosome];
    const interval = info.interval[this.chromosome];
    if (size === void 0 || interval === void 0) {
      throw new Error(`Chromosome name ${this.chromosome} is not valid`);
    }
    let { start, end } = this;
    if (start === void 0 || end === void 0) {
      [start, end] = [1, size];
    }
    const offset = interval[0];
    return [start + offset - padding, end + offset + padding];
  }
}
function createPluginTrack(config2, factory2) {
  var _a;
  function Track(...args) {
    if (!new.target) {
      throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
    }
    return factory2(...args);
  }
  Track.config = {
    ...config2,
    availableOptions: Object.keys((_a = config2.defaultOptions) != null ? _a : {})
  };
  return Track;
}
const TICK_WIDTH = 200;
const TICK_HEIGHT = 6;
const TICK_TEXT_SEPARATION = 2;
const TICK_COLOR = 7829367;
const icon$1 = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 5640 5420" preserveAspectRatio="xMidYMid meet"> <g id="layer101" fill="#000000" stroke="none"> <path d="M0 2710 l0 -2710 2820 0 2820 0 0 2710 0 2710 -2820 0 -2820 0 0 -2710z"/> </g> <g id="layer102" fill="#750075" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> <path d="M4340 2710 l0 -2510 560 0 560 0 0 2510 0 2510 -560 0 -560 0 0 -2510z"/> <path d="M200 1870 l0 -1670 630 0 630 0 0 1670 0 1670 -630 0 -630 0 0 -1670z"/> <path d="M1660 1810 l0 -1610 570 0 570 0 0 1610 0 1610 -570 0 -570 0 0 -1610z"/> <path d="M3000 840 l0 -640 570 0 570 0 0 640 0 640 -570 0 -570 0 0 -640z"/> </g> <g id="layer103" fill="#ffff04" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> </g> </svg>';
const config$3 = {
  type: "axis-track",
  datatype: ["multivec", "epilogos"],
  local: false,
  orientation: "1d-horizontal",
  thumbnail: new DOMParser().parseFromString(icon$1, "text/xml").documentElement,
  defaultOptions: {
    innerRadius: 340,
    outerRadius: 310,
    startAngle: 0,
    endAngle: 360,
    width: 700,
    height: 700,
    layout: "linear",
    labelPosition: "none",
    labelColor: "black",
    labelTextOpacity: 0.4,
    trackBorderWidth: 0,
    trackBorderColor: "black",
    tickPositions: "even",
    fontSize: 12,
    fontFamily: "sans-serif",
    // 'Arial',
    fontWeight: "normal",
    color: "#808080",
    stroke: "#ffffff",
    backgroundColor: "transparent",
    showMousePosition: false,
    tickColor: TICK_COLOR
  }
};
const factory$2 = (HGC, context, options) => {
  const { absToChr, colorToHex: colorToHex2, pixiTextToSvg, svgLine, showMousePosition } = HGC.utils;
  function createTickText(text, style) {
    return Object.assign(new HGC.libraries.PIXI.Text(text, style), { hashValue: Math.random() });
  }
  class AxisTrackClass extends HGC.tracks.PixiTrack {
    constructor() {
      super(context, options);
      __publicField(this, "allTexts");
      __publicField(this, "searchField");
      __publicField(this, "chromInfo");
      __publicField(this, "dataConfig");
      __publicField(this, "pTicksCircular");
      __publicField(this, "pTicks");
      __publicField(this, "gTicks");
      __publicField(this, "tickTexts");
      __publicField(this, "isShowGlobalMousePosition");
      __publicField(this, "pixiTextConfig");
      __publicField(this, "stroke");
      __publicField(this, "tickWidth");
      __publicField(this, "tickHeight");
      __publicField(this, "tickTextSeparation");
      __publicField(this, "tickColor");
      __publicField(this, "animate");
      __publicField(this, "hideMousePosition");
      __publicField(this, "gBoundTicks");
      __publicField(this, "leftBoundTick");
      __publicField(this, "rightBoundTick");
      __publicField(this, "is2d");
      __publicField(this, "texts");
      const { dataConfig, animate, chromInfoPath, isShowGlobalMousePosition } = context;
      this.searchField = null;
      this.dataConfig = dataConfig;
      this.allTexts = [];
      this.pTicksCircular = new HGC.libraries.PIXI.Graphics();
      this.pTicks = new HGC.libraries.PIXI.Graphics();
      this.pMain.addChild(this.pTicks);
      this.pMain.addChild(this.pTicksCircular);
      this.gTicks = {};
      this.tickTexts = {};
      this.options = options;
      this.isShowGlobalMousePosition = isShowGlobalMousePosition;
      this.pixiTextConfig = getTextStyle({
        size: +this.options.fontSize,
        fontFamily: this.options.fontFamily,
        fontWeight: this.options.fontWeight,
        color: this.options.color,
        stroke: this.options.stroke,
        strokeThickness: 2
      });
      this.stroke = colorToHex2(this.pixiTextConfig.stroke);
      this.tickWidth = TICK_WIDTH;
      this.tickHeight = TICK_HEIGHT;
      this.tickTextSeparation = TICK_TEXT_SEPARATION;
      this.tickColor = colorToHex2(this.options.tickColor);
      this.animate = animate;
      this.pubSubs = [];
      if (this.options.showMousePosition && !this.hideMousePosition) {
        this.hideMousePosition = showMousePosition(this, this.is2d, this.isShowGlobalMousePosition());
      }
      let chromSizesPath = chromInfoPath;
      if (!chromSizesPath) {
        chromSizesPath = `${dataConfig.server}/chrom-sizes/?id=${dataConfig.tilesetUid}`;
      }
      const assembly = this.options.assembly;
      const chrPositions = {};
      const chromLengths = { ...computeChromSizes(assembly).size };
      const cumPositions = [];
      Object.keys(computeChromSizes(assembly).size).forEach((k) => {
        chrPositions[k] = { chr: k, pos: computeChromSizes(assembly).size[k] };
      });
      Object.keys(computeChromSizes(assembly).interval).forEach((k) => {
        cumPositions.push({ chr: k, pos: computeChromSizes(assembly).interval[k][0] });
      });
      this.chromInfo = { chrPositions, chromLengths, cumPositions };
      this.rerender(this.options, true);
      this.draw();
      this.animate();
    }
    initBoundsTicks() {
      if (this.pTicks) {
        this.pMain.removeChild(this.pTicks);
        this.pTicks = null;
      }
      if (!this.gBoundTicks) {
        this.gBoundTicks = new HGC.libraries.PIXI.Graphics();
        this.leftBoundTick = createTickText("", this.pixiTextConfig);
        this.rightBoundTick = createTickText("", this.pixiTextConfig);
        this.gBoundTicks.addChild(this.leftBoundTick);
        this.gBoundTicks.addChild(this.rightBoundTick);
        this.pMain.addChild(this.gBoundTicks);
      }
      this.texts = [];
    }
    initChromLabels() {
      if (!this.chromInfo)
        return;
      if (this.gBoundTicks) {
        this.pMain.removeChild(this.gBoundTicks);
        this.gBoundTicks = void 0;
      }
      if (!this.pTicks) {
        this.pTicks = new HGC.libraries.PIXI.Graphics();
        this.pMain.addChild(this.pTicks);
      }
      this.texts = [];
      this.pTicks.removeChildren();
      this.chromInfo.cumPositions.forEach((info) => {
        var _a, _b, _c;
        const chromName = info.chr;
        this.gTicks[chromName] = new HGC.libraries.PIXI.Graphics();
        if (!this.tickTexts[chromName])
          this.tickTexts[chromName] = [];
        const text = createTickText(chromName, this.pixiTextConfig);
        (_a = this.pTicks) == null ? void 0 : _a.addChild(text);
        (_b = this.pTicks) == null ? void 0 : _b.addChild(this.gTicks[chromName]);
        (_c = this.texts) == null ? void 0 : _c.push(text);
      });
    }
    rerender(options2, force) {
      const strOptions = JSON.stringify(options2);
      if (!force && strOptions === this.prevOptions)
        return;
      this.prevOptions = strOptions;
      this.options = options2;
      this.pixiTextConfig.fontSize = +this.options.fontSize ? `${+this.options.fontSize}px` : this.pixiTextConfig.fontSize;
      this.pixiTextConfig.fill = this.options.color || this.pixiTextConfig.fill;
      this.pixiTextConfig.stroke = this.options.stroke || this.pixiTextConfig.stroke;
      this.stroke = colorToHex2(this.pixiTextConfig.stroke);
      this.tickColor = this.options.tickColor ? colorToHex2(this.options.tickColor) : TICK_COLOR;
      if (this.options.tickPositions === "ends" && this.options.layout !== "circular") {
        this.initBoundsTicks();
      } else {
        this.initChromLabels();
      }
      super.rerender(options2, force);
      if (this.options.showMousePosition && !this.hideMousePosition) {
        this.hideMousePosition = showMousePosition(this, this.is2d, this.isShowGlobalMousePosition());
      }
      if (!this.options.showMousePosition && this.hideMousePosition) {
        this.hideMousePosition();
        this.hideMousePosition = void 0;
      }
    }
    formatTick(pos) {
      if (isNaN(pos)) {
        return "null";
      }
      const domain = this._xScale.domain();
      const viewWidth = domain[1] - domain[0];
      const p = precisionPrefix(pos, viewWidth);
      const fPlain = format(",");
      const fPrecision = formatPrefix(`,.${p}`, viewWidth);
      let f = fPlain;
      if (this.options.tickFormat === "si") {
        f = fPrecision;
      } else if (this.options.tickFormat === "plain") {
        f = fPlain;
      } else if (this.options.tickPositions === "ends") {
        f = fPrecision;
      }
      return f(pos);
    }
    /** Show two labels at the end of both left and right sides */
    drawBoundsTicks(x1, x2) {
      if (!this.gBoundTicks || !this.leftBoundTick || !this.rightBoundTick)
        return;
      const graphics = this.gBoundTicks;
      graphics.clear();
      graphics.lineStyle(1, 0);
      const lineYStart = this.options.reverseOrientation ? 0 : this.dimensions[1];
      const lineYEnd = this.options.reverseOrientation ? this.tickHeight : this.dimensions[1] - this.tickHeight;
      graphics.moveTo(1, lineYStart);
      graphics.lineTo(1, lineYEnd);
      graphics.moveTo(this.dimensions[0] - 1, lineYStart);
      graphics.lineTo(this.dimensions[0] - 1, lineYEnd);
      this.leftBoundTick.x = 0;
      this.leftBoundTick.y = this.options.reverseOrientation ? lineYEnd + this.tickTextSeparation : lineYEnd - this.tickTextSeparation;
      this.leftBoundTick.text = this.options.assembly === "unknown" ? `${this.formatTick(x1[1])}` : `${x1[0]}: ${this.formatTick(x1[1])}`;
      this.leftBoundTick.anchor.y = this.options.reverseOrientation ? 0 : 1;
      this.rightBoundTick.x = this.dimensions[0];
      this.rightBoundTick.text = this.options.assembly === "unknown" ? `${this.formatTick(x2[1])}` : `${x2[0]}: ${this.formatTick(x2[1])}`;
      this.rightBoundTick.y = this.options.reverseOrientation ? lineYEnd + this.tickTextSeparation : lineYEnd - this.tickTextSeparation;
      this.rightBoundTick.anchor.y = this.options.reverseOrientation ? 0 : 1;
      this.rightBoundTick.anchor.x = 1;
      if (this.flipText) {
        this.leftBoundTick.scale.x = -1;
        this.leftBoundTick.anchor.x = 1;
        this.rightBoundTick.scale.x = -1;
        this.rightBoundTick.anchor.x = 0;
      }
      this.leftBoundTick.tickLine = [1, this.dimensions[1], 1, this.dimensions[1] - this.tickHeight];
      this.rightBoundTick.tickLine = [
        this.dimensions[0] - 1,
        this.dimensions[1],
        this.dimensions[0] - 1,
        this.dimensions[1] - this.tickHeight
      ];
      this.tickTexts = {};
      this.tickTexts.all = [this.leftBoundTick, this.rightBoundTick];
    }
    drawTicks(cumPos) {
      const graphics = this.gTicks[cumPos.chr];
      graphics.visible = true;
      graphics.clear();
      const chromLen = +this.chromInfo.chromLengths[cumPos.chr];
      const vpLeft = Math.max(this._xScale(cumPos.pos), 0);
      const vpRight = Math.min(this._xScale(cumPos.pos + chromLen), this.dimensions[0]);
      const numTicks = (vpRight - vpLeft) / this.tickWidth;
      const xScale = scaleLinear().domain([
        Math.max(1, this._xScale.invert(0) - cumPos.pos),
        Math.min(chromLen, this._xScale.invert(this.dimensions[0]) - cumPos.pos)
      ]).range([vpLeft, vpRight]);
      const ticks = xScale.ticks(numTicks).filter((tick) => Number.isInteger(tick));
      const tickTexts = this.tickTexts[cumPos.chr];
      const tickHeight = this.tickHeight;
      const xPadding = 0;
      let yPadding = tickHeight + this.tickTextSeparation;
      if (this.options.reverseOrientation) {
        yPadding = this.dimensions[1] - yPadding;
      }
      while (tickTexts.length < ticks.length) {
        const newText = createTickText("", this.pixiTextConfig);
        tickTexts.push(newText);
        this.gTicks[cumPos.chr].addChild(newText);
      }
      while (tickTexts.length > ticks.length) {
        const text = tickTexts.pop();
        this.gTicks[cumPos.chr].removeChild(text);
      }
      let i = 0;
      while (i < ticks.length) {
        tickTexts[i].visible = true;
        tickTexts[i].anchor.x = 0.5;
        tickTexts[i].anchor.y = this.options.layout === "circular" ? 0 : this.options.reverseOrientation ? 0 : 1;
        if (this.flipText)
          tickTexts[i].scale.x = -1;
        const chrText = this.options.assembly === "unknown" ? "" : `${cumPos.chr}: `;
        tickTexts[i].text = ticks[i] === 0 ? `${chrText}1` : `${chrText}${this.formatTick(ticks[i])}`;
        const x = this._xScale(cumPos.pos + ticks[i]);
        if (this.options.layout === "circular") {
          const rope = this.addCurvedText(tickTexts[i], x + xPadding);
          rope && this.pTicksCircular.addChild(rope);
        } else {
          tickTexts[i].x = x + xPadding;
          tickTexts[i].y = this.dimensions[1] - yPadding;
          tickTexts[i].tickLine = [x - 1, this.dimensions[1], x - 1, this.dimensions[1] - tickHeight - 1];
          const lineYStart = this.options.reverseOrientation ? 0 : this.dimensions[1];
          const lineYEnd = this.options.reverseOrientation ? tickHeight : this.dimensions[1] - tickHeight;
          graphics.lineStyle(1, this.tickColor);
          graphics.moveTo(x, lineYStart);
          graphics.lineTo(x, lineYEnd);
        }
        i += 1;
      }
      if (this.options.layout === "circular")
        i = 0;
      while (i < tickTexts.length) {
        tickTexts[i].visible = false;
        i += 1;
      }
      return ticks.length;
    }
    addCurvedText(textObj, cx) {
      const [width, height] = this.dimensions;
      const { startAngle, endAngle } = this.options;
      const factor = Math.min(width, height) / Math.min(this.options.width, this.options.height);
      const innerRadius = this.options.innerRadius * factor;
      const outerRadius = this.options.outerRadius * factor;
      const r = (outerRadius + innerRadius) / 2;
      const centerPos = cartesianToPolar(cx, width, r, width / 2, height / 2, startAngle, endAngle);
      textObj.x = centerPos.x;
      textObj.y = centerPos.y;
      textObj.resolution = 4;
      const txtStyle = new HGC.libraries.PIXI.TextStyle(this.pixiTextConfig);
      const metric = HGC.libraries.PIXI.TextMetrics.measureText(textObj.text, txtStyle);
      const tw = metric.width / (2 * r * Math.PI) * width * 360 / (endAngle - startAngle);
      let [minX, maxX] = [cx - tw / 2, cx + tw / 2];
      if (minX < 0) {
        const gap = -minX;
        minX = 0;
        maxX += gap;
      } else if (maxX > width) {
        const gap = maxX - width;
        maxX = width;
        minX -= gap;
      }
      const ropePoints = [];
      const baseR = innerRadius + metric.height / 2 + 3;
      for (let i = maxX; i >= minX; i -= tw / 10) {
        const p = cartesianToPolar(i, width, baseR, width / 2, height / 2, startAngle, endAngle);
        ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
      }
      if (ropePoints.length === 0) {
        return void 0;
      }
      textObj.updateText();
      const rope = new HGC.libraries.PIXI.SimpleRope(textObj.texture, ropePoints);
      return rope;
    }
    draw() {
      this.allTexts = [];
      if (!this.texts)
        return;
      const x1 = absToChr(this._xScale.domain()[0], this.chromInfo);
      const x2 = absToChr(this._xScale.domain()[1], this.chromInfo);
      if (!x1 || !x2) {
        console.warn("Empty chromInfo:", this.dataConfig, this.chromInfo);
        return;
      }
      if (this.options.tickPositions === "ends" && this.options.layout !== "circular") {
        if (!this.gBoundTicks)
          return;
        this.gBoundTicks.visible = true;
        this.drawBoundsTicks(x1, x2);
        return;
      }
      if (!this.pTicks) {
        return;
      }
      const circular = this.options.layout === "circular";
      for (let i = 0; i < this.texts.length; i++) {
        this.texts[i].visible = false;
        this.gTicks[this.chromInfo.cumPositions[i].chr].visible = false;
      }
      let yPadding = this.tickHeight + this.tickTextSeparation;
      if (this.options.reverseOrientation) {
        yPadding = this.dimensions[1] - yPadding;
      }
      Object.keys(this.chromInfo.chrPositions).forEach((chrom) => {
        if (this.tickTexts[chrom]) {
          this.tickTexts[chrom].forEach((tick) => {
            tick.visible = false;
          });
        }
      });
      this.pTicksCircular.removeChildren();
      for (let i = x1[3]; i <= x2[3]; i++) {
        const xCumPos = this.chromInfo.cumPositions[i];
        const midX = xCumPos.pos + this.chromInfo.chromLengths[xCumPos.chr] / 2;
        const viewportMidX = this._xScale(midX);
        const chrText = this.texts[i];
        chrText.anchor.x = 0.5;
        chrText.anchor.y = circular ? 0.5 : this.options.reverseOrientation ? 0 : 1;
        let rope;
        if (circular) {
          rope = this.addCurvedText(chrText, viewportMidX);
          if (rope) {
            this.pTicksCircular.addChild(rope);
          }
        } else {
          chrText.x = viewportMidX;
          chrText.y = this.dimensions[1] - yPadding;
        }
        chrText.updateTransform();
        if (this.flipText)
          chrText.scale.x = -1;
        const numTicksDrawn = this.drawTicks(xCumPos);
        if (!circular) {
          chrText.visible = numTicksDrawn <= 0;
        } else {
          if (numTicksDrawn > 0) {
            rope && this.pTicksCircular.removeChild(rope);
          }
        }
        this.allTexts.push({
          importance: chrText.hashValue,
          text: chrText,
          rope
        });
      }
      this.hideOverlaps(this.allTexts);
    }
    hideOverlaps(allTexts) {
      const tree = new RBush();
      allTexts.sort((a, b) => b.importance - a.importance).forEach(({ text, rope }) => {
        text.updateTransform();
        const b = text.getBounds();
        const m2 = 5;
        const boxWithMargin = {
          minX: b.x - m2,
          minY: b.y - m2,
          maxX: b.x + b.width + m2 * 2,
          maxY: b.y + b.height + m2 * 2
        };
        if (!tree.collides(boxWithMargin)) {
          tree.insert(boxWithMargin);
        } else {
          text.visible = false;
          if (this.options.layout === "circular" && rope) {
            this.pTicksCircular.removeChild(rope);
          }
        }
      });
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      [this.pMain.position.x, this.pMain.position.y] = this.position;
    }
    zoomed(newXScale, newYScale) {
      const domainValues = [...newXScale.domain(), ...newYScale.domain()];
      if (domainValues.filter((d) => isNaN(d)).length !== 0) {
        return;
      }
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.draw();
    }
    exportSVG() {
      let track = null;
      let base = null;
      if (super.exportSVG) {
        [base, track] = super.exportSVG();
      } else {
        base = document.createElement("g");
        track = base;
      }
      base.setAttribute("class", "chromosome-labels");
      const output = document.createElement("g");
      track.appendChild(output);
      output.setAttribute("transform", `translate(${this.position[0]},${this.position[1]})`);
      this.allTexts.filter((text) => text.text.visible).forEach((text) => {
        const g = pixiTextToSvg(text.text);
        output.appendChild(g);
      });
      Object.values(this.tickTexts).forEach((texts) => {
        texts.filter((x) => x.visible).forEach((text) => {
          if (!text.tickLine)
            return;
          let g = pixiTextToSvg(text);
          output.appendChild(g);
          g = svgLine(
            text.x,
            this.options.reverseOrientation ? 0 : this.dimensions[1],
            text.x,
            this.options.reverseOrientation ? this.tickHeight : this.dimensions[1] - this.tickHeight,
            1,
            this.tickColor
          );
          const line = document.createElement("line");
          line.setAttribute("x1", String(text.tickLine[0]));
          line.setAttribute("y1", String(text.tickLine[1]));
          line.setAttribute("x2", String(text.tickLine[2]));
          line.setAttribute("y2", String(text.tickLine[3]));
          line.setAttribute("style", "stroke: grey");
          output.appendChild(g);
          output.appendChild(line);
        });
      });
      return [base, track];
    }
  }
  return new AxisTrackClass();
};
const AxisTrack = createPluginTrack(config$3, factory$2);
function BrushTrack(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class BrushTrackClass extends HGC.tracks.SVGTrack {
    constructor(params) {
      var _a, _b;
      super(...params);
      __publicField(this, "circularBrushData");
      __publicField(this, "prevExtent");
      const [context, options] = params;
      const { registerViewportChanged, removeViewportChanged, setDomainsCallback } = context;
      this.uid = uuid();
      this.options = options;
      this.hasFromView = !context.projectionXDomain;
      this.removeViewportChanged = removeViewportChanged;
      this.setDomainsCallback = setDomainsCallback;
      this.viewportXDomain = this.hasFromView ? null : context.projectionXDomain;
      this.viewportYDomain = this.hasFromView ? null : [0, 0];
      this.prevExtent = [0, 0];
      this.RR = 0.02;
      const extent = [0, Math.PI * 1.7];
      this.circularBrushData = this.getBrushData(extent);
      this.brush = arc().innerRadius((_a = this.options.innerRadius) != null ? _a : 100).outerRadius((_b = this.options.outerRadius) != null ? _b : 200);
      this.gBrush = this.gMain.append("g").attr("id", `brush-${this.uid}`).selectAll(".brush").data(this.circularBrushData).enter().append("path").attr("class", "brush").attr("d", this.brush).attr("fill", this.options.projectionFillColor).attr("stroke", this.options.projectionStrokeColor).attr(
        "fill-opacity",
        (d) => d.type === "brush" ? this.options.projectionFillOpacity : 0
      ).attr(
        "stroke-opacity",
        (d) => d.type === "brush" ? this.options.projectionStrokeOpacity : 0
      ).attr("stroke-width", this.options.strokeWidth).style("pointer-events", "all").style("cursor", (d) => d.cursor).call(this.dragged());
      registerViewportChanged(this.uid, this.viewportChanged.bind(this));
      this.draw();
    }
    /**
     * Get information for circular brush for given extent of angle.
     */
    getBrushData(extent) {
      return [
        {
          type: "brush",
          startAngle: extent[0],
          endAngle: extent[1],
          cursor: "grab"
        },
        {
          type: "start",
          startAngle: extent[0],
          endAngle: extent[0] + this.RR,
          cursor: "move"
        },
        {
          type: "end",
          startAngle: extent[1] - this.RR,
          endAngle: extent[1],
          cursor: "move"
        }
      ];
    }
    cropExtent(extent) {
      let [s, e] = extent;
      let round = 0;
      while (s > Math.PI * 2 || e > Math.PI * 2 || s < 0 || e < 0) {
        if (round++ > 10) {
          break;
        }
        if (s > Math.PI * 2 || e > Math.PI * 2) {
          s -= Math.PI * 2;
          e -= Math.PI * 2;
        } else if (s < 0 || e < 0) {
          s += Math.PI * 2;
          e += Math.PI * 2;
        }
      }
      return [s, e].sort((a, b) => a - b);
    }
    /**
     * Update the position and size of brush.
     */
    updateBrush(extent) {
      let [s, e] = extent;
      if (s <= RADIAN_GAP && e <= RADIAN_GAP || s >= Math.PI * 2 - RADIAN_GAP && e >= Math.PI * 2 - RADIAN_GAP) {
        this.gBrush.attr("visibility", "hidden");
        return;
      }
      if (s < RADIAN_GAP) {
        s = RADIAN_GAP;
      }
      if (s > Math.PI * 2 - RADIAN_GAP) {
        s = Math.PI * 2 - RADIAN_GAP;
      }
      if (e < RADIAN_GAP) {
        e = RADIAN_GAP;
      }
      if (e > Math.PI * 2 - RADIAN_GAP) {
        e = Math.PI * 2 - RADIAN_GAP;
      }
      this.circularBrushData = this.getBrushData(extent);
      this.gBrush.data(this.circularBrushData).attr("d", this.brush).attr("visibility", "visible");
    }
    /**
     * Function to call upon hearing click event on the brush
     */
    dragged() {
      const start = (event) => {
        this.startEvent = event.sourceEvent;
        this.prevExtent = [this.circularBrushData[0].startAngle, this.circularBrushData[0].endAngle];
      };
      const drag = (event, d) => {
        const [x, y] = this.position;
        const [w, h] = this.dimensions;
        const endEvent = event.sourceEvent;
        const startX = this.startEvent.layerX - x;
        const startY = this.startEvent.layerY - y;
        const endX = endEvent.layerX - x;
        const endY = endEvent.layerY - y;
        const radDiff = (
          // radian of the start position
          Math.atan2(startX - w / 2, startY - h / 2) - // radian of the current position
          Math.atan2(endX - w / 2, endY - h / 2)
        );
        let [s, e] = this.prevExtent;
        if (d.type === "brush") {
          s = s + radDiff;
          e = e + radDiff;
          if (s < RADIAN_GAP || Math.PI * 2 - RADIAN_GAP < e) {
            const sto = RADIAN_GAP - s;
            const eto = e - (Math.PI * 2 - RADIAN_GAP);
            if (sto > eto) {
              e += sto;
              s += sto;
            } else {
              s -= eto;
              e -= eto;
            }
          }
        } else if (d.type === "start") {
          s = s + radDiff;
        } else if (d.type === "end") {
          e = e + radDiff;
        }
        [s, e] = this.cropExtent([s, e]);
        if (!this._xScale || !this._yScale) {
          return;
        }
        const scale = (this.options.endAngle - this.options.startAngle) / 360;
        const offsetedS = s - this.options.startAngle / 360 * Math.PI * 2;
        const offsetedE = e - this.options.startAngle / 360 * Math.PI * 2;
        const xDomain = [
          this._xScale.invert(w - w * offsetedE / (Math.PI * 2 * scale)),
          this._xScale.invert(w - w * offsetedS / (Math.PI * 2 * scale))
        ];
        const yDomain = this.viewportYDomain;
        if (!this.hasFromView) {
          this.viewportXDomain = xDomain;
        }
        this.setDomainsCallback(xDomain, yDomain);
        this.updateBrush([s, e]);
      };
      return HGC.libraries.d3Drag.drag().on("start", start).on("drag", drag);
    }
    draw() {
      if (!this._xScale || !this.yScale) {
        return;
      }
      if (!this.viewportXDomain || !this.viewportYDomain) {
        return;
      }
      const x0 = this._xScale(this.viewportXDomain[0]);
      const x1 = this._xScale(this.viewportXDomain[1]);
      const [w] = this.dimensions;
      let e = valueToRadian(x0, w, this.options.startAngle, this.options.endAngle) + Math.PI / 2;
      let s = valueToRadian(x1, w, this.options.startAngle, this.options.endAngle) + Math.PI / 2;
      [s, e] = this.cropExtent([s, e]);
      this.updateBrush([s, e]);
    }
    viewportChanged(viewportXScale, viewportYScale) {
      const viewportXDomain = viewportXScale.domain();
      const viewportYDomain = viewportYScale.domain();
      this.viewportXDomain = viewportXDomain;
      this.viewportYDomain = viewportYDomain;
      this.draw();
    }
    remove() {
      this.removeViewportChanged(this.uid);
      super.remove();
    }
    rerender() {
    }
    zoomed(newXScale, newYScale) {
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.draw();
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      this.draw();
    }
    setDimensions(newDimensions) {
      super.setDimensions(newDimensions);
      this.gBrush.attr("transform", `translate(${newDimensions[0] / 2},${newDimensions[1] / 2})`);
      this.draw();
    }
  }
  return new BrushTrackClass(args);
}
const icon = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 5640 5420" preserveAspectRatio="xMidYMid meet"> <g id="layer101" fill="#000000" stroke="none"> <path d="M0 2710 l0 -2710 2820 0 2820 0 0 2710 0 2710 -2820 0 -2820 0 0 -2710z"/> </g> <g id="layer102" fill="#750075" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> <path d="M4340 2710 l0 -2510 560 0 560 0 0 2510 0 2510 -560 0 -560 0 0 -2510z"/> <path d="M200 1870 l0 -1670 630 0 630 0 0 1670 0 1670 -630 0 -630 0 0 -1670z"/> <path d="M1660 1810 l0 -1610 570 0 570 0 0 1610 0 1610 -570 0 -570 0 0 -1610z"/> <path d="M3000 840 l0 -640 570 0 570 0 0 640 0 640 -570 0 -570 0 0 -640z"/> </g> <g id="layer103" fill="#ffff04" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> </g> </svg>';
BrushTrack.config = {
  type: "brush-track",
  datatype: ["projection"],
  local: false,
  // TODO:
  projection: true,
  orientation: "2d",
  thumbnail: new DOMParser().parseFromString(icon, "text/xml").documentElement,
  availableOptions: [
    "innerRadius",
    "outerRadius",
    "startAngle",
    "endAngle",
    "axisPositionHorizontal",
    "projectionFillColor",
    "projectionStrokeColor",
    "projectionFillOpacity",
    "projectionStrokeOpacity",
    "strokeWidth"
  ],
  defaultOptions: {
    innerRadius: 100,
    outerRadius: 200,
    startAngle: 0,
    endAngle: 360,
    axisPositionHorizontal: "left",
    projectionFillColor: "#777",
    projectionStrokeColor: "#777",
    projectionFillOpacity: 0.3,
    projectionStrokeOpacity: 0.7,
    strokeWidth: 1
  }
};
const HIDDEN_BRUSH_EDGE_SIZE = 3;
const BRUSH_STYLE_DEFAULT = {
  color: "#777",
  stroke: "#777",
  strokeWidth: 1,
  strokeOpacity: 0.7,
  opacity: 0.3
};
class LinearBrushModel {
  constructor(selection, hgLibraries, style = {}) {
    /* graphical elements */
    __publicField(this, "brushSelection");
    __publicField(this, "style");
    /* data */
    __publicField(this, "range");
    __publicField(this, "data");
    /* drag */
    __publicField(this, "startEvent");
    __publicField(this, "prevExtent");
    /* visual parameters */
    __publicField(this, "offset");
    __publicField(this, "size");
    // fixed size of one-dimension of a brush (e.g., height)
    /* External libraries that we re-use from HiGlass */
    __publicField(this, "externals");
    __publicField(this, "emitter");
    this.emitter = createNanoEvents();
    this.range = null;
    this.prevExtent = [0, 0];
    this.data = this.rangeToData(0, 0);
    this.offset = [0, 0];
    this.size = 0;
    this.externals = {
      d3Selection: hgLibraries.d3Selection,
      d3Drag: hgLibraries.d3Drag
    };
    this.style = Object.assign({}, BRUSH_STYLE_DEFAULT, style);
    this.brushSelection = selection.selectAll(".genomic-range-brush").data(this.data).enter().append("rect").attr("class", "genomic-range-brush").call(this.onDrag());
  }
  getRange() {
    return this.range;
  }
  setSize(size) {
    this.size = size;
    return this;
  }
  /**
   * Update the left and top offsets for drawing the brush.
   */
  setOffset(offsetX, offsetY) {
    this.offset = [offsetX, offsetY];
    return this;
  }
  /**
   * Update brush data based on the positions of two edges.
   */
  updateRange(range) {
    if (range) {
      this.range = [Math.min(...range), Math.max(...range)];
      this.data = this.rangeToData(...this.range);
    } else {
      this.range = null;
    }
    return this;
  }
  /**
   * Update the brush using the internal range value. By default,
   * This function calls a render function from gosling-track.
   */
  drawBrush(skipApiTrigger = false) {
    const [x, y] = this.offset;
    const height = this.size;
    const getWidth = (d) => Math.abs(d.end - d.start);
    this.brushSelection.data(this.data).attr("transform", (d) => `translate(${x + d.start}, ${y + 1})`).attr("width", (d) => `${getWidth(d)}px`).attr("height", `${height - 2}px`).attr("fill", this.style.color).attr("stroke", this.style.stroke).attr("stroke-width", `${this.style.strokeWidth}px`).attr("fill-opacity", (d) => d.type === "body" ? this.style.opacity : 0).attr("stroke-opacity", (d) => d.type === "body" ? this.style.strokeOpacity : 0).attr("cursor", (d) => d.cursor);
    this.emitter.emit("brush", this.getRange(), skipApiTrigger);
    return this;
  }
  enable() {
    this.brushSelection.attr("pointer-events", "all");
    return this;
  }
  disable() {
    this.brushSelection.attr("pointer-events", "none");
    return this;
  }
  visible() {
    this.brushSelection.attr("visibility", "visible");
    return this;
  }
  hidden() {
    this.brushSelection.attr("visibility", "hidden");
    return this;
  }
  clear() {
    this.updateRange(null).drawBrush().hidden().disable();
    return this;
  }
  remove() {
    this.brushSelection.remove();
    return this;
  }
  /**
   * Based on the extent values, generate a JSON object for the brush.
   */
  rangeToData(start, end) {
    return [
      {
        type: "body",
        cursor: "grab",
        start,
        end
      },
      {
        type: "start",
        cursor: "ew-resize",
        start: start - HIDDEN_BRUSH_EDGE_SIZE,
        end: start
      },
      {
        type: "end",
        cursor: "ew-resize",
        start: end,
        end: end + HIDDEN_BRUSH_EDGE_SIZE
      }
    ];
  }
  onDrag() {
    const started = (event) => {
      this.startEvent = event.sourceEvent;
      this.prevExtent = this.range;
    };
    const dragged = (event, d) => {
      var _a;
      const delta = event.sourceEvent.layerX - this.startEvent.layerX;
      let [s, e] = (_a = this.prevExtent) != null ? _a : [0, 0];
      if (d.type === "body") {
        s += delta;
        e += delta;
      } else if (d.type === "start") {
        s += delta;
      } else if (d.type === "end") {
        e += delta;
      }
      this.updateRange([s, e]).drawBrush();
    };
    return this.externals.d3Drag.drag().on("start", started).on("drag", dragged);
  }
  on(event, callback) {
    this.emitter.on(event, callback);
  }
}
const isPointInsideDonutSlice = ([x, y], [cx, cy], [innerRadius, outerRadius], [startAngle, endAngle]) => {
  const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
  if (dist < innerRadius || outerRadius < dist) {
    return false;
  }
  const degree = pointsToDegree(x, y, cx, cy);
  if (degree < startAngle || endAngle < degree) {
    return false;
  }
  return true;
};
const isPointNearPoint = ([x1, y1], [x2, y2], radius = 5) => {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) < radius;
};
const isPointInsideRange = ([x1, x2], x) => {
  return x1 <= x && x <= x2;
};
const isCircleWithinRange = (range, x, radius = 5) => {
  return isPointInsideRange(range, x - radius) && isPointInsideRange(range, x + radius);
};
const isAllPointsWithinRange = (range, path) => {
  return path.filter((_, i) => i % 2 === 0).every((x) => isPointInsideRange(range, x));
};
const isPointNearLine = ([x, y], path, dist = 5) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0; i < path.length - 2; i += 2) {
    x1 = path[i];
    y1 = path[i + 1];
    x2 = path[i + 2];
    y2 = path[i + 3];
    const AB = [x2 - x1, y2 - y1];
    const BE = [x - x2, y - y2];
    const AE = [x - x1, y - y1];
    const AB_BE = AB[0] * BE[0] + AB[1] * BE[1];
    const AB_AE = AB[0] * AE[0] + AB[1] * AE[1];
    let actDist = 0;
    if (AB_BE > 0) {
      actDist = Math.sqrt((y - y2) ** 2 + (x - x2) ** 2);
    } else if (AB_AE < 0) {
      actDist = Math.sqrt((y - y1) ** 2 + (x - x1) ** 2);
    } else {
      actDist = Math.abs(AB[0] * AE[1] - AB[1] * AE[0]) / Math.sqrt(AB[0] ** 2 + AB[1] ** 2);
    }
    if (actDist < dist) {
      isWithin = true;
    }
  }
  return isWithin;
};
const isPointInPolygon = ([x, y], polygon) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
    x1 = polygon[i];
    y1 = polygon[i + 1];
    x2 = polygon[j];
    y2 = polygon[j + 1];
    if (y1 > y !== y2 > y && x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {
      isWithin = !isWithin;
    }
    j = i;
  }
  return isWithin;
};
class MouseEventModel {
  constructor() {
    // main data that this model manage
    __publicField(this, "data");
    this.data = [];
  }
  /**
   * Access the number of mouse events stored.
   */
  size() {
    return this.data.length;
  }
  /**
   * Add a new mouse event that is polygon-based.
   */
  addPolygonBasedEvent(value, polygon) {
    this.data.push({ uid: uuid(), type: "polygon", value, polygon });
  }
  /**
   * Add a new mouse event that is point-based.
   */
  addPointBasedEvent(value, pointAndRadius) {
    this.data.push({ uid: uuid(), type: "point", value, polygon: pointAndRadius });
  }
  /**
   * Add a new mouse event that is line-based.
   */
  addLineBasedEvent(value, path) {
    this.data.push({ uid: uuid(), type: "line", value, polygon: path });
  }
  /**
   * Make the data array empty.
   */
  clear() {
    this.data = [];
  }
  /**
   * Find the first event data that is within the mouse position.
   */
  find(x, y, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.find((d) => this.isMouseWithin(d, x, y));
  }
  /**
   * Find all event data that is within the mouse position.
   */
  findAll(x, y, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.filter((d) => this.isMouseWithin(d, x, y));
  }
  /**
   * Find all event data that matches the id values in the source and return them.
   */
  getSiblings(source, idField) {
    const siblings = [];
    const sourceUids = Array.from(new Set(source.map((d) => d.uid)));
    source.forEach((s) => {
      const id = s.value[idField];
      if (id) {
        siblings.push(...this.data.filter((_) => _.value[idField] === id && sourceUids.indexOf(_.uid) === -1));
      }
    });
    return siblings;
  }
  /**
   * Test if a mouse position is within a given object.
   */
  isMouseWithin(data2, x, y) {
    switch (data2.type) {
      case "point":
        return isPointNearPoint([x, y], data2.polygon);
      case "line":
        return isPointNearLine([x, y], data2.polygon);
      case "polygon":
      default:
        return isPointInPolygon([x, y], data2.polygon);
    }
  }
  /**
   * Find all event data that is within the range along the x-axis.
   */
  findAllWithinRange(x1, x2, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.filter((d) => this.isWithinRange(d, x1, x2));
  }
  /**
   * Test if a given object is within an 1D range.
   */
  isWithinRange(data2, x1, x2) {
    switch (data2.type) {
      case "point":
        return isCircleWithinRange([x1, x2], data2.polygon[0], data2.polygon[2]);
      case "line":
      case "polygon":
      default:
        return isAllPointsWithinRange([x1, x2], data2.polygon);
    }
  }
}
const encodedJs$3 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZSwgZGVzYykgPT4gewogICAgaWYgKG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlID09PSAib2JqZWN0IiB8fCB0eXBlb2YgbW9kdWxlID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUpKQogICAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gImRlZmF1bHQiKQogICAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdGFyZ2V0OwogIH07CiAgdmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlKSA9PiB7CiAgICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlKSkgOiB7fSwgImRlZmF1bHQiLCBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgJiYgImRlZmF1bHQiIGluIG1vZHVsZSA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYmFzZTY0X2pzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKICAgICAgZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5OwogICAgICBleHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5OwogICAgICB2YXIgbG9va3VwID0gW107CiAgICAgIHZhciByZXZMb29rdXAgPSBbXTsKICAgICAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiA/IFVpbnQ4QXJyYXkgOiBBcnJheTsKICAgICAgdmFyIGNvZGUgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICBsb29rdXBbaV0gPSBjb2RlW2ldOwogICAgICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTsKICAgICAgfQogICAgICB2YXIgaTsKICAgICAgdmFyIGxlbjsKICAgICAgcmV2TG9va3VwWyItIi5jaGFyQ29kZUF0KDApXSA9IDYyOwogICAgICByZXZMb29rdXBbIl8iLmNoYXJDb2RlQXQoMCldID0gNjM7CiAgICAgIGZ1bmN0aW9uIGdldExlbnMoYjY0KSB7CiAgICAgICAgdmFyIGxlbjIgPSBiNjQubGVuZ3RoOwogICAgICAgIGlmIChsZW4yICUgNCA+IDApIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCIpOwogICAgICAgIH0KICAgICAgICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZigiPSIpOwogICAgICAgIGlmICh2YWxpZExlbiA9PT0gLTEpCiAgICAgICAgICB2YWxpZExlbiA9IGxlbjI7CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4yID8gMCA6IDQgLSB2YWxpZExlbiAlIDQ7CiAgICAgICAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCkgewogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHsKICAgICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRvQnl0ZUFycmF5KGI2NCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7CiAgICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTsKICAgICAgICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTsKICAgICAgICB2YXIgY3VyQnl0ZSA9IDA7CiAgICAgICAgdmFyIGxlbjIgPSBwbGFjZUhvbGRlcnNMZW4gPiAwID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47CiAgICAgICAgdmFyIGkyOwogICAgICAgIGZvciAoaTIgPSAwOyBpMiA8IGxlbjI7IGkyICs9IDQpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAzKV07CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA+PiA0OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPj4gMjsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGFycjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7CiAgICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiA2M10gKyBsb29rdXBbbnVtID4+IDEyICYgNjNdICsgbG9va3VwW251bSA+PiA2ICYgNjNdICsgbG9va3VwW251bSAmIDYzXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIG91dHB1dCA9IFtdOwogICAgICAgIGZvciAodmFyIGkyID0gc3RhcnQ7IGkyIDwgZW5kOyBpMiArPSAzKSB7CiAgICAgICAgICB0bXAgPSAodWludDhbaTJdIDw8IDE2ICYgMTY3MTE2ODApICsgKHVpbnQ4W2kyICsgMV0gPDwgOCAmIDY1MjgwKSArICh1aW50OFtpMiArIDJdICYgMjU1KTsKICAgICAgICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5KHVpbnQ4KSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgbGVuMiA9IHVpbnQ4Lmxlbmd0aDsKICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbjIgJSAzOwogICAgICAgIHZhciBwYXJ0cyA9IFtdOwogICAgICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOwogICAgICAgIGZvciAodmFyIGkyID0gMCwgbGVuMjIgPSBsZW4yIC0gZXh0cmFCeXRlczsgaTIgPCBsZW4yMjsgaTIgKz0gbWF4Q2h1bmtMZW5ndGgpIHsKICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGkyLCBpMiArIG1heENodW5rTGVuZ3RoID4gbGVuMjIgPyBsZW4yMiA6IGkyICsgbWF4Q2h1bmtMZW5ndGgpKTsKICAgICAgICB9CiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHsKICAgICAgICAgIHRtcCA9IHVpbnQ4W2xlbjIgLSAxXTsKICAgICAgICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAyXSArIGxvb2t1cFt0bXAgPDwgNCAmIDYzXSArICI9PSIpOwogICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2xlbjIgLSAyXSA8PCA4KSArIHVpbnQ4W2xlbjIgLSAxXTsKICAgICAgICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAxMF0gKyBsb29rdXBbdG1wID4+IDQgJiA2M10gKyBsb29rdXBbdG1wIDw8IDIgJiA2M10gKyAiPSIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcGFydHMuam9pbigiIik7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pZWVlNzU0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgICAgICAgdmFyIGUsIG07CiAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CiAgICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7CiAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgICAgIHZhciBuQml0cyA9IC03OwogICAgICAgIHZhciBpID0gaXNMRSA/IG5CeXRlcyAtIDEgOiAwOwogICAgICAgIHZhciBkID0gaXNMRSA/IC0xIDogMTsKICAgICAgICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsKICAgICAgICBpICs9IGQ7CiAgICAgICAgZSA9IHMgJiAoMSA8PCAtbkJpdHMpIC0gMTsKICAgICAgICBzID4+PSAtbkJpdHM7CiAgICAgICAgbkJpdHMgKz0gZUxlbjsKICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgZSA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IG1MZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBpZiAoZSA9PT0gMCkgewogICAgICAgICAgZSA9IDEgLSBlQmlhczsKICAgICAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKICAgICAgICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICBlID0gZSAtIGVCaWFzOwogICAgICAgIH0KICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTsKICAgICAgfTsKICAgICAgZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgICAgICAgdmFyIGUsIG0sIGM7CiAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CiAgICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7CiAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgICAgIHZhciBydCA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwOwogICAgICAgIHZhciBpID0gaXNMRSA/IDAgOiBuQnl0ZXMgLSAxOwogICAgICAgIHZhciBkID0gaXNMRSA/IDEgOiAtMTsKICAgICAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7CiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7CiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHsKICAgICAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDsKICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7CiAgICAgICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgICAgICAgIGUtLTsKICAgICAgICAgICAgYyAqPSAyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgICAgIHZhbHVlICs9IHJ0IC8gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikgewogICAgICAgICAgICBlKys7CiAgICAgICAgICAgIGMgLz0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewogICAgICAgICAgICBtID0gMDsKICAgICAgICAgICAgZSA9IGVNYXg7CiAgICAgICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgICAgZSA9IGUgKyBlQmlhczsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgICAgZSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAyNTUsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkgewogICAgICAgIH0KICAgICAgICBlID0gZSA8PCBtTGVuIHwgbTsKICAgICAgICBlTGVuICs9IG1MZW47CiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMjU1LCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYnVmZmVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGJhc2U2NCA9IHJlcXVpcmVfYmFzZTY0X2pzKCk7CiAgICAgIHZhciBpZWVlNzU0ID0gcmVxdWlyZV9pZWVlNzU0KCk7CiAgICAgIHZhciBjdXN0b21JbnNwZWN0U3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgU3ltYm9sWyJmb3IiXSA9PT0gImZ1bmN0aW9uIiA/IFN5bWJvbFsiZm9yIl0oIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tIikgOiBudWxsOwogICAgICBleHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjU7CiAgICAgIGV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXI7CiAgICAgIGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDsKICAgICAgdmFyIEtfTUFYX0xFTkdUSCA9IDIxNDc0ODM2NDc7CiAgICAgIGV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSDsKICAgICAgQnVmZmVyNS5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKTsKICAgICAgaWYgKCFCdWZmZXI1LlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IGBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpOwogICAgICAgICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiA0MjsKICAgICAgICAgIH0gfTsKICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pOwogICAgICAgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDI7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyNS5wcm90b3R5cGUsICJwYXJlbnQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCFCdWZmZXI1LmlzQnVmZmVyKHRoaXMpKQogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXI1LnByb3RvdHlwZSwgIm9mZnNldCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjUuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihsZW5ndGgpIHsKICAgICAgICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlICInICsgbGVuZ3RoICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOwogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlcjUucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEJ1ZmZlcjUoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjUucG9vbFNpemUgPSA4MTkyOwogICAgICBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAic3RyaW5nIikgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICIgKyB0eXBlb2YgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICJ1bmRlZmluZWQiICYmIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHwgdmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpOwogICAgICAgIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBCdWZmZXI1LmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpOwogICAgICAgIGlmIChiKQogICAgICAgICAgcmV0dXJuIGI7CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyNS5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oInN0cmluZyIpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgfQogICAgICBCdWZmZXI1LmZyb20gPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH07CiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXI1LnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyNSwgVWludDhBcnJheSk7CiAgICAgIGZ1bmN0aW9uIGFzc2VydFNpemUoc2l6ZSkgewogICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfSBlbHNlIGlmIChzaXplIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHNpemUgKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICBpZiAoc2l6ZSA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKSA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICB9CiAgICAgIEJ1ZmZlcjUuYWxsb2MgPSBmdW5jdGlvbihzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHsKICAgICAgICBhc3NlcnRTaXplKHNpemUpOwogICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApOwogICAgICB9CiAgICAgIEJ1ZmZlcjUuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBCdWZmZXI1LmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcyKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjUuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwOwogICAgICAgIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7CiAgICAgICAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7CiAgICAgICAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwOwogICAgICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheVZpZXcoYXJyYXlWaWV3KSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkgewogICAgICAgICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5Vmlldyk7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcib2Zmc2V0IiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJsZW5ndGgiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpOwogICAgICAgIH0KICAgICAgICBsZXQgYnVmOwogICAgICAgIGlmIChieXRlT2Zmc2V0ID09PSB2b2lkIDAgJiYgbGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KTsKICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXI1LnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikgewogICAgICAgIGlmIChCdWZmZXI1LmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjUuYWxsb2MoK2xlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyNS5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHsKICAgICAgICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIgIT09IEJ1ZmZlcjUucHJvdG90eXBlOwogICAgICB9OwogICAgICBCdWZmZXI1LmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlMihhLCBiKSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpCiAgICAgICAgICBhID0gQnVmZmVyNS5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYiA9IEJ1ZmZlcjUuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKTsKICAgICAgICBpZiAoIUJ1ZmZlcjUuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlcjUuaXNCdWZmZXIoYikpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAiYnVmMSIsICJidWYyIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpOwogICAgICAgIH0KICAgICAgICBpZiAoYSA9PT0gYikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gYS5sZW5ndGg7CiAgICAgICAgbGV0IHkgPSBiLmxlbmd0aDsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgICAgICAgeCA9IGFbaV07CiAgICAgICAgICAgIHkgPSBiW2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBCdWZmZXI1LmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7CiAgICAgICAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHsKICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyNS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobGlzdCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjUuYWxsb2MoMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyNS5hbGxvY1Vuc2FmZShsZW5ndGgpOwogICAgICAgIGxldCBwb3MgPSAwOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBsZXQgYnVmID0gbGlzdFtpXTsKICAgICAgICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHsKICAgICAgICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgaWYgKCFCdWZmZXI1LmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICAgICAgICBidWYgPSBCdWZmZXI1LmZyb20oYnVmKTsKICAgICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoYnVmZmVyLCBidWYsIHBvcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoIUJ1ZmZlcjUuaXNCdWZmZXIoYnVmKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICB9CiAgICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZmZlcjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjUuaXNCdWZmZXIoc3RyaW5nKSkgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBjb25zdCBtdXN0TWF0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWU7CiAgICAgICAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGVuOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gbGVuICogMjsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gbGVuID4+PiAxOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBCdWZmZXI1LmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCB8fCBzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICIiKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyNS5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTsKICAgICAgZnVuY3Rpb24gc3dhcChiLCBuLCBtKSB7CiAgICAgICAgY29uc3QgaSA9IGJbbl07CiAgICAgICAgYltuXSA9IGJbbV07CiAgICAgICAgYlttXSA9IGk7CiAgICAgIH0KICAgICAgQnVmZmVyNS5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2KCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSAyICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCgpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgOCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDcpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZzIoKSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTsKICAgICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyNS5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFsczIoYikgewogICAgICAgIGlmICghQnVmZmVyNS5pc0J1ZmZlcihiKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAodGhpcyA9PT0gYikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBCdWZmZXI1LmNvbXBhcmUodGhpcywgYikgPT09IDA7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkgewogICAgICAgIGxldCBzdHIgPSAiIjsKICAgICAgICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoImhleCIsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICIkMSAiKS50cmltKCk7CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KQogICAgICAgICAgc3RyICs9ICIgLi4uICI7CiAgICAgICAgcmV0dXJuICI8QnVmZmVyICIgKyBzdHIgKyAiPiI7CiAgICAgIH07CiAgICAgIGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7CiAgICAgICAgQnVmZmVyNS5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXI1LnByb3RvdHlwZS5pbnNwZWN0OwogICAgICB9CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlMih0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkgewogICAgICAgIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHsKICAgICAgICAgIHRhcmdldCA9IEJ1ZmZlcjUuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFCdWZmZXI1LmlzQnVmZmVyKHRhcmdldCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAidGFyZ2V0IiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgdGFyZ2V0KTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICB0aGlzU3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc0VuZCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm91dCBvZiByYW5nZSBpbmRleCIpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7CiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA+PSBlbmQpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBzdGFydCA+Pj49IDA7CiAgICAgICAgZW5kID4+Pj0gMDsKICAgICAgICB0aGlzU3RhcnQgPj4+PSAwOwogICAgICAgIHRoaXNFbmQgPj4+PSAwOwogICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7CiAgICAgICAgbGV0IHkgPSBlbmQgLSBzdGFydDsKICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KTsKICAgICAgICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTsKICAgICAgICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkgewogICAgICAgICAgICB4ID0gdGhpc0NvcHlbaV07CiAgICAgICAgICAgIHkgPSB0YXJnZXRDb3B5W2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDIxNDc0ODM2NDcpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAyMTQ3NDgzNjQ3OwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0yMTQ3NDgzNjQ4KSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gLTIxNDc0ODM2NDg7CiAgICAgICAgfQogICAgICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsKICAgICAgICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogYnVmZmVyLmxlbmd0aCAtIDE7CiAgICAgICAgfQogICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCkKICAgICAgICAgIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoZGlyKQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7CiAgICAgICAgICBpZiAoZGlyKQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHZhbCA9IEJ1ZmZlcjUuZnJvbSh2YWwsIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgaWYgKEJ1ZmZlcjUuaXNCdWZmZXIodmFsKSkgewogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlciIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogICAgICAgIGxldCBpbmRleFNpemUgPSAxOwogICAgICAgIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoOwogICAgICAgIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoOwogICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gInVjczIiIHx8IGVuY29kaW5nID09PSAidWNzLTIiIHx8IGVuY29kaW5nID09PSAidXRmMTZsZSIgfHwgZW5jb2RpbmcgPT09ICJ1dGYtMTZsZSIpIHsKICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGluZGV4U2l6ZSA9IDI7CiAgICAgICAgICAgIGFyckxlbmd0aCAvPSAyOwogICAgICAgICAgICB2YWxMZW5ndGggLz0gMjsKICAgICAgICAgICAgYnl0ZU9mZnNldCAvPSAyOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiByZWFkKGJ1ZiwgaTIpIHsKICAgICAgICAgIGlmIChpbmRleFNpemUgPT09IDEpIHsKICAgICAgICAgICAgcmV0dXJuIGJ1ZltpMl07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpMiAqIGluZGV4U2l6ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gLTE7CiAgICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewogICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkKICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpOwogICAgICAgICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkKICAgICAgICAgICAgICAgIGkgLT0gaSAtIGZvdW5kSW5kZXg7CiAgICAgICAgICAgICAgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykgewogICAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGZvdW5kKQogICAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgQnVmZmVyNS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGhleFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAoIWxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTsKICAgICAgICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHsKICAgICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7CiAgICAgICAgICBsZW5ndGggPSBzdHJMZW4gLyAyOwogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7CiAgICAgICAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkKICAgICAgICAgICAgcmV0dXJuIGk7CiAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7CiAgICAgICAgfQogICAgICAgIHJldHVybiBpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVjczJXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwICYmIHR5cGVvZiBvZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBlbmNvZGluZyA9IG9mZnNldDsKICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHsKICAgICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMDsKICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApCiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlbmNvZGluZyA9IGxlbmd0aDsKICAgICAgICAgICAgbGVuZ3RoID0gdm9pZCAwOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkIik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0OwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCB8fCBsZW5ndGggPiByZW1haW5pbmcpCiAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7CiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMiKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9ICgiIiArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogIkJ1ZmZlciIsCiAgICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMCkKICAgICAgICB9OwogICAgICB9OwogICAgICBmdW5jdGlvbiBiYXNlNjRTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGNvbnN0IHJlcyA9IFtdOwogICAgICAgIGxldCBpID0gc3RhcnQ7CiAgICAgICAgd2hpbGUgKGkgPCBlbmQpIHsKICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXTsKICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBudWxsOwogICAgICAgICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSBmaXJzdEJ5dGUgPiAyMzkgPyA0IDogZmlyc3RCeXRlID4gMjIzID8gMyA6IGZpcnN0Qnl0ZSA+IDE5MSA/IDIgOiAxOwogICAgICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkgewogICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHsKICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMTI4KSB7CiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMTI3KSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMjA0NyAmJiAodGVtcENvZGVQb2ludCA8IDU1Mjk2IHx8IHRlbXBDb2RlUG9pbnQgPiA1NzM0MykpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmIChmb3VydGhCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDE4IHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgMTIgfCAodGhpcmRCeXRlICYgNjMpIDw8IDYgfCBmb3VydGhCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHsKICAgICAgICAgICAgY29kZVBvaW50ID0gNjU1MzM7CiAgICAgICAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkgewogICAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7CiAgICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpOwogICAgICAgICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgaSArPSBieXRlc1BlclNlcXVlbmNlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcyk7CiAgICAgIH0KICAgICAgdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gNDA5NjsKICAgICAgZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpIHsKICAgICAgICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDsKICAgICAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7CiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpOwogICAgICAgIH0KICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlIChpIDwgbGVuKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDEyNyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGF0aW4xU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaGV4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICBsZXQgb3V0ID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpOwogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIHN0YXJ0ID0gfn5zdGFydDsKICAgICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IGxlbiA6IH5+ZW5kOwogICAgICAgIGlmIChzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ICs9IGxlbjsKICAgICAgICAgIGlmIChzdGFydCA8IDApCiAgICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7CiAgICAgICAgICBzdGFydCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IDApIHsKICAgICAgICAgIGVuZCArPSBsZW47CiAgICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgICAgZW5kID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGVuZCA+IGxlbikgewogICAgICAgICAgZW5kID0gbGVuOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpOwogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlcjUucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gbmV3QnVmOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja09mZnNldChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKG9mZnNldCAlIDEgIT09IDAgfHwgb2Zmc2V0IDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJvZmZzZXQgaXMgbm90IHVpbnQiKTsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgiKTsKICAgICAgfQogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkVWludExFID0gQnVmZmVyNS5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldF07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkVWludEJFID0gQnVmZmVyNS5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHdoaWxlIChieXRlTGVuZ3RoMiA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUucmVhZFVpbnQ4ID0gQnVmZmVyNS5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF07CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9IEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4OwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkVWludDE2QkUgPSBCdWZmZXI1LnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUucmVhZFVpbnQzMkxFID0gQnVmZmVyNS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiAodGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgKyB0aGlzW29mZnNldCArIDNdICogMTY3NzcyMTY7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9IEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdICogMTY3NzcyMTYgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbG8gPSBmaXJzdCArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDI0OwogICAgICAgIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIGxhc3QgKiAyICoqIDI0OwogICAgICAgIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0OwogICAgICAgIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7CiAgICAgIH0pOwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldF07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV07CiAgICAgICAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgaWYgKCEodGhpc1tvZmZzZXRdICYgMTI4KSkKICAgICAgICAgIHJldHVybiB0aGlzW29mZnNldF07CiAgICAgICAgcmV0dXJuICgyNTUgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCB0aGlzW29mZnNldF0gPDwgODsKICAgICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDI0IHwgdGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM107CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggKyB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArIChsYXN0IDw8IDI0KTsKICAgICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpOwogICAgICB9KTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdCk7CiAgICAgIH0pOwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrSW50KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogICAgICAgIGlmICghQnVmZmVyNS5pc0J1ZmZlcihidWYpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImJ1ZmZlciIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpOwogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgfQogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZVVpbnRMRSA9IEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBtYXhCeXRlcywgMCk7CiAgICAgICAgfQogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVVaW50QkUgPSBCdWZmZXI1LnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyIC0gMTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlVWludDggPSBCdWZmZXI1LnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMjU1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9IEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID0gQnVmZmVyNS5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlVWludDMyTEUgPSBCdWZmZXI1LnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9IEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cnRCaWdVSW50NjRMRShidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7CiAgICAgICAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KTsKICAgICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIHJldHVybiBvZmZzZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0QkUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0ICsgN10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDZdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA1XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNF0gPSBsbzsKICAgICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDNdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyAyXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldF0gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoIjB4ZmZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyIC0gMSk7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbGltaXQgLSAxLCAtbGltaXQpOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHsKICAgICAgICAgICAgc3ViID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyIC0gMSk7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbGltaXQgLSAxLCAtbGltaXQpOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyIC0gMTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgc3ViID0gMDsKICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHsKICAgICAgICAgICAgc3ViID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAxMjcsIC0xMjgpOwogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICB2YWx1ZSA9IDI1NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTsKICAgICAgfTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgdmFsdWUgPSA0Mjk0OTY3Mjk1ICsgdmFsdWUgKyAxOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgiMHg4MDAwMDAwMDAwMDAwMDAwIiksIEJpZ0ludCgiMHg3ZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIC0zNDAyODIzNDY2Mzg1Mjg4NmUyMik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfQogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjUucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxNzk3NjkzMTM0ODYyMzE1N2UyOTIsIC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpOwogICAgICAgIH0KICAgICAgICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyNS5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7CiAgICAgICAgaWYgKCFCdWZmZXI1LmlzQnVmZmVyKHRhcmdldCkpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAoIXN0YXJ0KQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kICYmIGVuZCAhPT0gMCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoOwogICAgICAgIGlmICghdGFyZ2V0U3RhcnQpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IDA7CiAgICAgICAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBpZiAoZW5kID09PSBzdGFydCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCwgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSwgdGFyZ2V0U3RhcnQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuOwogICAgICB9OwogICAgICBCdWZmZXI1LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBlbmNvZGluZyA9IHN0YXJ0OwogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAic3RyaW5nIikgewogICAgICAgICAgICBlbmNvZGluZyA9IGVuZDsKICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmciKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICJzdHJpbmciICYmICFCdWZmZXI1LmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gInV0ZjgiICYmIGNvZGUgPCAxMjggfHwgZW5jb2RpbmcgPT09ICJsYXRpbjEiKSB7CiAgICAgICAgICAgICAgdmFsID0gY29kZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJib29sZWFuIikgewogICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk91dCBvZiByYW5nZSBpbmRleCIpOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgc3RhcnQgPSBzdGFydCA+Pj4gMDsKICAgICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwOwogICAgICAgIGlmICghdmFsKQogICAgICAgICAgdmFsID0gMDsKICAgICAgICBsZXQgaTsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgICAgdGhpc1tpXSA9IHZhbDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3QgYnl0ZXMgPSBCdWZmZXI1LmlzQnVmZmVyKHZhbCkgPyB2YWwgOiBCdWZmZXI1LmZyb20odmFsLCBlbmNvZGluZyk7CiAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7CiAgICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHZhbCArICciIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50ICJ2YWx1ZSInKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgdmFyIGVycm9ycyA9IHt9OwogICAgICBmdW5jdGlvbiBFKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkgewogICAgICAgIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7CiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJtZXNzYWdlIiwgewogICAgICAgICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksCiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYDsKICAgICAgICAgICAgdGhpcy5zdGFjazsKICAgICAgICAgICAgZGVsZXRlIHRoaXMubmFtZTsKICAgICAgICAgIH0KICAgICAgICAgIGdldCBjb2RlKCkgewogICAgICAgICAgICByZXR1cm4gc3ltOwogICAgICAgICAgfQogICAgICAgICAgc2V0IGNvZGUodmFsdWUpIHsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJjb2RlIiwgewogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgRSgiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwgZnVuY3Rpb24obmFtZSkgewogICAgICAgIGlmIChuYW1lKSB7CiAgICAgICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuICJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzIjsKICAgICAgfSwgUmFuZ2VFcnJvcik7CiAgICAgIEUoIkVSUl9JTlZBTElEX0FSR19UWVBFIiwgZnVuY3Rpb24obmFtZSwgYWN0dWFsKSB7CiAgICAgICAgcmV0dXJuIGBUaGUgIiR7bmFtZX0iIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7CiAgICAgIH0sIFR5cGVFcnJvcik7CiAgICAgIEUoIkVSUl9PVVRfT0ZfUkFOR0UiLCBmdW5jdGlvbihzdHIsIHJhbmdlLCBpbnB1dCkgewogICAgICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mICIke3N0cn0iIGlzIG91dCBvZiByYW5nZS5gOwogICAgICAgIGxldCByZWNlaXZlZCA9IGlucHV0OwogICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7CiAgICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gImJpZ2ludCIpIHsKICAgICAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KTsKICAgICAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHsKICAgICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpOwogICAgICAgICAgfQogICAgICAgICAgcmVjZWl2ZWQgKz0gIm4iOwogICAgICAgIH0KICAgICAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWA7CiAgICAgICAgcmV0dXJuIG1zZzsKICAgICAgfSwgUmFuZ2VFcnJvcik7CiAgICAgIGZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvcih2YWwpIHsKICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSB2YWwubGVuZ3RoOwogICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAiLSIgPyAxIDogMDsKICAgICAgICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykgewogICAgICAgICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gdm9pZCAwIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoMl0gPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGgyICsgMSkpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKSB7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7CiAgICAgICAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gImJpZ2ludCIgPyAibiIgOiAiIjsKICAgICAgICAgIGxldCByYW5nZTsKICAgICAgICAgIGlmIChieXRlTGVuZ3RoMiA+IDMpIHsKICAgICAgICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkgewogICAgICAgICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4fSR7bn1gOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn1gOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YDsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgidmFsdWUiLCByYW5nZSwgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgIm51bWJlciIsIHZhbHVlKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYm91bmRzRXJyb3IodmFsdWUsIGxlbmd0aCwgdHlwZSkgewogICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHsKICAgICAgICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKTsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICJvZmZzZXQiLCAiYW4gaW50ZWdlciIsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCk7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICJvZmZzZXQiLCBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLCB2YWx1ZSk7CiAgICAgIH0KICAgICAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZzsKICAgICAgZnVuY3Rpb24gYmFzZTY0Y2xlYW4oc3RyKSB7CiAgICAgICAgc3RyID0gc3RyLnNwbGl0KCI9IilbMF07CiAgICAgICAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAiIik7CiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCAyKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkgewogICAgICAgICAgc3RyID0gc3RyICsgIj0iOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHsKICAgICAgICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5OwogICAgICAgIGxldCBjb2RlUG9pbnQ7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7CiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NTI5NSAmJiBjb2RlUG9pbnQgPCA1NzM0NCkgewogICAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTYzMTkpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkgewogICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7CiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjsKICAgICAgICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgIH0KICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDEyOCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAyMDQ4KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiA2IHwgMTkyLCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDY1NTM2KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxMiB8IDIyNCwgY29kZVBvaW50ID4+IDYgJiA2MyB8IDEyOCwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxOCB8IDI0MCwgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb2RlIHBvaW50Iik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIsIHVuaXRzKSB7CiAgICAgICAgbGV0IGMsIGhpLCBsbzsKICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgaGkgPSBjID4+IDg7CiAgICAgICAgICBsbyA9IGMgJSAyNTY7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChsbyk7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChoaSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpIHsKICAgICAgICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoIHx8IGkgPj0gc3JjLmxlbmd0aCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2Uob2JqLCB0eXBlKSB7CiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHwgb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG51bWJlcklzTmFOKG9iaikgewogICAgICAgIHJldHVybiBvYmogIT09IG9iajsKICAgICAgfQogICAgICB2YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIGNvbnN0IGFscGhhYmV0ID0gIjAxMjM0NTY3ODlhYmNkZWYiOwogICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1Nik7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7CiAgICAgICAgICBjb25zdCBpMTYgPSBpICogMTY7CiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHsKICAgICAgICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFibGU7CiAgICAgIH0oKTsKICAgICAgZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kKGZuKSB7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICJ1bmRlZmluZWQiID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQoKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCaWdJbnQgbm90IHN1cHBvcnRlZCIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIHNyYy9hbGlhcy9idWZmZXItc2hpbS5qcwogIHZhciBpbXBvcnRfYnVmZmVyOwogIHZhciBpbml0X2J1ZmZlcl9zaGltID0gX19lc20oewogICAgInNyYy9hbGlhcy9idWZmZXItc2hpbS5qcyIoKSB7CiAgICAgIGltcG9ydF9idWZmZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvaXMtb2JzZXJ2YWJsZS9pbmRleC5qcwogIHZhciByZXF1aXJlX2lzX29ic2VydmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvaXMtb2JzZXJ2YWJsZS9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUuZXhwb3J0cyA9ICh2YWx1ZSkgPT4gewogICAgICAgIGlmICghdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wub2JzZXJ2YWJsZSA9PT0gInN5bWJvbCIgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5vYnNlcnZhYmxlXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0oKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVsiQEBvYnNlcnZhYmxlIl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbIkBAb2JzZXJ2YWJsZSJdKCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zZXJpYWxpemVycy5qcwogIHZhciByZXF1aXJlX3NlcmlhbGl6ZXJzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zZXJpYWxpemVycy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5EZWZhdWx0U2VyaWFsaXplciA9IGV4cG9ydHMuZXh0ZW5kU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgZnVuY3Rpb24gZXh0ZW5kU2VyaWFsaXplcihleHRlbmQsIGltcGxlbWVudGF0aW9uKSB7CiAgICAgICAgY29uc3QgZmFsbGJhY2tEZXNlcmlhbGl6ZXIgPSBleHRlbmQuZGVzZXJpYWxpemUuYmluZChleHRlbmQpOwogICAgICAgIGNvbnN0IGZhbGxiYWNrU2VyaWFsaXplciA9IGV4dGVuZC5zZXJpYWxpemUuYmluZChleHRlbmQpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbi5kZXNlcmlhbGl6ZShtZXNzYWdlLCBmYWxsYmFja0Rlc2VyaWFsaXplcik7CiAgICAgICAgICB9LAogICAgICAgICAgc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbi5zZXJpYWxpemUoaW5wdXQsIGZhbGxiYWNrU2VyaWFsaXplcik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzLmV4dGVuZFNlcmlhbGl6ZXIgPSBleHRlbmRTZXJpYWxpemVyOwogICAgICB2YXIgRGVmYXVsdEVycm9yU2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihFcnJvcihtZXNzYWdlLm1lc3NhZ2UpLCB7CiAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSwKICAgICAgICAgICAgc3RhY2s6IG1lc3NhZ2Uuc3RhY2sKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGVycm9yKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBfX2Vycm9yX21hcmtlcjogIiQkZXJyb3IiLAogICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLAogICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLAogICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2sKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgaXNTZXJpYWxpemVkRXJyb3IgPSAodGhpbmcpID0+IHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgIl9fZXJyb3JfbWFya2VyIiBpbiB0aGluZyAmJiB0aGluZy5fX2Vycm9yX21hcmtlciA9PT0gIiQkZXJyb3IiOwogICAgICBleHBvcnRzLkRlZmF1bHRTZXJpYWxpemVyID0gewogICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRFcnJvcihtZXNzYWdlKSkgewogICAgICAgICAgICByZXR1cm4gRGVmYXVsdEVycm9yU2VyaWFsaXplci5kZXNlcmlhbGl6ZShtZXNzYWdlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICAgICAgICByZXR1cm4gRGVmYXVsdEVycm9yU2VyaWFsaXplci5zZXJpYWxpemUoaW5wdXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGlucHV0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L2NvbW1vbi5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5zZXJpYWxpemUgPSBleHBvcnRzLmRlc2VyaWFsaXplID0gZXhwb3J0cy5yZWdpc3RlclNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIHZhciBzZXJpYWxpemVyc18xID0gcmVxdWlyZV9zZXJpYWxpemVycygpOwogICAgICB2YXIgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLkRlZmF1bHRTZXJpYWxpemVyOwogICAgICBmdW5jdGlvbiByZWdpc3RlclNlcmlhbGl6ZXIyKHNlcmlhbGl6ZXIpIHsKICAgICAgICByZWdpc3RlcmVkU2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzXzEuZXh0ZW5kU2VyaWFsaXplcihyZWdpc3RlcmVkU2VyaWFsaXplciwgc2VyaWFsaXplcik7CiAgICAgIH0KICAgICAgZXhwb3J0cy5yZWdpc3RlclNlcmlhbGl6ZXIgPSByZWdpc3RlclNlcmlhbGl6ZXIyOwogICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLmRlc2VyaWFsaXplKG1lc3NhZ2UpOwogICAgICB9CiAgICAgIGV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTsKICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgIH0KICAgICAgZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc3ltYm9scy5qcwogIHZhciByZXF1aXJlX3N5bWJvbHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuJHdvcmtlciA9IGV4cG9ydHMuJHRyYW5zZmVyYWJsZSA9IGV4cG9ydHMuJHRlcm1pbmF0ZSA9IGV4cG9ydHMuJGV2ZW50cyA9IGV4cG9ydHMuJGVycm9ycyA9IHZvaWQgMDsKICAgICAgZXhwb3J0cy4kZXJyb3JzID0gU3ltYm9sKCJ0aHJlYWQuZXJyb3JzIik7CiAgICAgIGV4cG9ydHMuJGV2ZW50cyA9IFN5bWJvbCgidGhyZWFkLmV2ZW50cyIpOwogICAgICBleHBvcnRzLiR0ZXJtaW5hdGUgPSBTeW1ib2woInRocmVhZC50ZXJtaW5hdGUiKTsKICAgICAgZXhwb3J0cy4kdHJhbnNmZXJhYmxlID0gU3ltYm9sKCJ0aHJlYWQudHJhbnNmZXJhYmxlIik7CiAgICAgIGV4cG9ydHMuJHdvcmtlciA9IFN5bWJvbCgidGhyZWFkLndvcmtlciIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcwogIHZhciByZXF1aXJlX3RyYW5zZmVyYWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHJhbnNmZXJhYmxlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLlRyYW5zZmVyID0gZXhwb3J0cy5pc1RyYW5zZmVyRGVzY3JpcHRvciA9IHZvaWQgMDsKICAgICAgdmFyIHN5bWJvbHNfMSA9IHJlcXVpcmVfc3ltYm9scygpOwogICAgICBmdW5jdGlvbiBpc1RyYW5zZmVyYWJsZSh0aGluZykgewogICAgICAgIGlmICghdGhpbmcgfHwgdHlwZW9mIHRoaW5nICE9PSAib2JqZWN0IikKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHRoaW5nW3N5bWJvbHNfMS4kdHJhbnNmZXJhYmxlXTsKICAgICAgfQogICAgICBleHBvcnRzLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gaXNUcmFuc2ZlckRlc2NyaXB0b3I7CiAgICAgIGZ1bmN0aW9uIFRyYW5zZmVyMihwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgaWYgKCF0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgICBpZiAoIWlzVHJhbnNmZXJhYmxlKHBheWxvYWQpKQogICAgICAgICAgICB0aHJvdyBFcnJvcigpOwogICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IFtwYXlsb2FkXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIFtzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV06IHRydWUsCiAgICAgICAgICBzZW5kOiBwYXlsb2FkLAogICAgICAgICAgdHJhbnNmZXJhYmxlcwogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0cy5UcmFuc2ZlciA9IFRyYW5zZmVyMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90eXBlcy9tZXNzYWdlcy5qcwogIHZhciByZXF1aXJlX21lc3NhZ2VzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90eXBlcy9tZXNzYWdlcy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5Xb3JrZXJNZXNzYWdlVHlwZSA9IGV4cG9ydHMuTWFzdGVyTWVzc2FnZVR5cGUgPSB2b2lkIDA7CiAgICAgIHZhciBNYXN0ZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKE1hc3Rlck1lc3NhZ2VUeXBlMikgewogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsiY2FuY2VsIl0gPSAiY2FuY2VsIjsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbInJ1biJdID0gInJ1biI7CiAgICAgIH0pKE1hc3Rlck1lc3NhZ2VUeXBlID0gZXhwb3J0cy5NYXN0ZXJNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5NYXN0ZXJNZXNzYWdlVHlwZSA9IHt9KSk7CiAgICAgIHZhciBXb3JrZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKFdvcmtlck1lc3NhZ2VUeXBlMikgewogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsiZXJyb3IiXSA9ICJlcnJvciI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJpbml0Il0gPSAiaW5pdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJyZXN1bHQiXSA9ICJyZXN1bHQiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsicnVubmluZyJdID0gInJ1bm5pbmciOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsidW5jYXVnaHRFcnJvciJdID0gInVuY2F1Z2h0RXJyb3IiOwogICAgICB9KShXb3JrZXJNZXNzYWdlVHlwZSA9IGV4cG9ydHMuV29ya2VyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuV29ya2VyTWVzc2FnZVR5cGUgPSB7fSkpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2ltcGxlbWVudGF0aW9uLmJyb3dzZXIuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBpc1dvcmtlclJ1bnRpbWUgPSBmdW5jdGlvbiBpc1dvcmtlclJ1bnRpbWUyKCkgewogICAgICAgIGNvbnN0IGlzV2luZG93Q29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgV2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmIGluc3RhbmNlb2YgV2luZG93OwogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZi5wb3N0TWVzc2FnZSAmJiAhaXNXaW5kb3dDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlOwogICAgICB9OwogICAgICB2YXIgcG9zdE1lc3NhZ2VUb01hc3RlciA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlVG9NYXN0ZXIyKGRhdGEsIHRyYW5zZmVyTGlzdCkgewogICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTsKICAgICAgfTsKICAgICAgdmFyIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMgPSBmdW5jdGlvbiBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzMihvbk1lc3NhZ2UpIHsKICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlRXZlbnQuZGF0YSk7CiAgICAgICAgfTsKICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHsKICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICB9OwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7CiAgICAgIH07CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHsKICAgICAgICBpc1dvcmtlclJ1bnRpbWUsCiAgICAgICAgcG9zdE1lc3NhZ2VUb01hc3RlciwKICAgICAgICBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfd29ya2VyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2F3YWl0ZXIgPSBleHBvcnRzICYmIGV4cG9ydHMuX19hd2FpdGVyIHx8IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikgewogICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7CiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbInRocm93Il0odmFsdWUpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsKICAgICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzICYmIGV4cG9ydHMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuZXhwb3NlID0gZXhwb3J0cy5pc1dvcmtlclJ1bnRpbWUgPSBleHBvcnRzLlRyYW5zZmVyID0gZXhwb3J0cy5yZWdpc3RlclNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIHZhciBpc19vYnNlcnZhYmxlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9pc19vYnNlcnZhYmxlKCkpOwogICAgICB2YXIgY29tbW9uXzEgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzEgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICB2YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIGltcGxlbWVudGF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9pbXBsZW1lbnRhdGlvbl9icm93c2VyKCkpOwogICAgICB2YXIgY29tbW9uXzIgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgInJlZ2lzdGVyU2VyaWFsaXplciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gY29tbW9uXzIucmVnaXN0ZXJTZXJpYWxpemVyOwogICAgICB9IH0pOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzIgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIlRyYW5zZmVyIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMi5UcmFuc2ZlcjsKICAgICAgfSB9KTsKICAgICAgZXhwb3J0cy5pc1dvcmtlclJ1bnRpbWUgPSBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lOwogICAgICB2YXIgZXhwb3NlQ2FsbGVkID0gZmFsc2U7CiAgICAgIHZhciBhY3RpdmVTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpOwogICAgICB2YXIgaXNNYXN0ZXJKb2JDYW5jZWxNZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLmNhbmNlbDsKICAgICAgdmFyIGlzTWFzdGVySm9iUnVuTWVzc2FnZSA9ICh0aGluZykgPT4gdGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gbWVzc2FnZXNfMS5NYXN0ZXJNZXNzYWdlVHlwZS5ydW47CiAgICAgIHZhciBpc09ic2VydmFibGUgPSAodGhpbmcpID0+IGlzX29ic2VydmFibGVfMS5kZWZhdWx0KHRoaW5nKSB8fCBpc1plbk9ic2VydmFibGUodGhpbmcpOwogICAgICBmdW5jdGlvbiBpc1plbk9ic2VydmFibGUodGhpbmcpIHsKICAgICAgICByZXR1cm4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiB0eXBlb2YgdGhpbmcuc3Vic2NyaWJlID09PSAiZnVuY3Rpb24iOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlY29uc3RydWN0VHJhbnNmZXIodGhpbmcpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzEuaXNUcmFuc2ZlckRlc2NyaXB0b3IodGhpbmcpID8geyBwYXlsb2FkOiB0aGluZy5zZW5kLCB0cmFuc2ZlcmFibGVzOiB0aGluZy50cmFuc2ZlcmFibGVzIH0gOiB7IHBheWxvYWQ6IHRoaW5nLCB0cmFuc2ZlcmFibGVzOiB2b2lkIDAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0RnVuY3Rpb25Jbml0TWVzc2FnZSgpIHsKICAgICAgICBjb25zdCBpbml0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuaW5pdCwKICAgICAgICAgIGV4cG9zZWQ6IHsKICAgICAgICAgICAgdHlwZTogImZ1bmN0aW9uIgogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RNb2R1bGVJbml0TWVzc2FnZShtZXRob2ROYW1lcykgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAibW9kdWxlIiwKICAgICAgICAgICAgbWV0aG9kczogbWV0aG9kTmFtZXMKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGluaXRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iRXJyb3JNZXNzYWdlKHVpZCwgcmF3RXJyb3IpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQ6IGVycm9yLCB0cmFuc2ZlcmFibGVzIH0gPSBkZWNvbnN0cnVjdFRyYW5zZmVyKHJhd0Vycm9yKTsKICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmVycm9yLAogICAgICAgICAgdWlkLAogICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGVycm9yTWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlJlc3VsdE1lc3NhZ2UodWlkLCBjb21wbGV0ZWQsIHJlc3VsdFZhbHVlKSB7CiAgICAgICAgY29uc3QgeyBwYXlsb2FkLCB0cmFuc2ZlcmFibGVzIH0gPSBkZWNvbnN0cnVjdFRyYW5zZmVyKHJlc3VsdFZhbHVlKTsKICAgICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5yZXN1bHQsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVkID8gdHJ1ZSA6IHZvaWQgMCwKICAgICAgICAgIHBheWxvYWQKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKHJlc3VsdE1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JTdGFydE1lc3NhZ2UodWlkLCByZXN1bHRUeXBlKSB7CiAgICAgICAgY29uc3Qgc3RhcnRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5ydW5uaW5nLAogICAgICAgICAgdWlkLAogICAgICAgICAgcmVzdWx0VHlwZQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoc3RhcnRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpIHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gewogICAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnVuY2F1Z2h0RXJyb3IsCiAgICAgICAgICAgIGVycm9yOiBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpCiAgICAgICAgICB9OwogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlKTsKICAgICAgICB9IGNhdGNoIChzdWJFcnJvcikgewogICAgICAgICAgY29uc29sZS5lcnJvcigiTm90IHJlcG9ydGluZyB1bmNhdWdodCBlcnJvciBiYWNrIHRvIG1hc3RlciB0aHJlYWQgYXMgaXQgb2NjdXJlZCB3aGlsZSByZXBvcnRpbmcgYW4gdW5jYXVnaHQgZXJyb3IgYWxyZWFkeS5cbkxhdGVzdCBlcnJvcjoiLCBzdWJFcnJvciwgIlxuT3JpZ2luYWwgZXJyb3I6IiwgZXJyb3IpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBydW5GdW5jdGlvbihqb2JVSUQsIGZuLCBhcmdzKSB7CiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsKICAgICAgICAgIGxldCBzeW5jUmVzdWx0OwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgc3luY1Jlc3VsdCA9IGZuKC4uLmFyZ3MpOwogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCByZXN1bHRUeXBlID0gaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpID8gIm9ic2VydmFibGUiIDogInByb21pc2UiOwogICAgICAgICAgcG9zdEpvYlN0YXJ0TWVzc2FnZShqb2JVSUQsIHJlc3VsdFR5cGUpOwogICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShzeW5jUmVzdWx0KSkgewogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzeW5jUmVzdWx0LnN1YnNjcmliZSgodmFsdWUpID0+IHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgZmFsc2UsIGNvbW1vbl8xLnNlcmlhbGl6ZSh2YWx1ZSkpLCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgICBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKSk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfSwgKCkgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuc2V0KGpvYlVJRCwgc3Vic2NyaXB0aW9uKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc3luY1Jlc3VsdDsKICAgICAgICAgICAgICBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIHRydWUsIGNvbW1vbl8xLnNlcmlhbGl6ZShyZXN1bHQpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBleHBvc2UyKGV4cG9zZWQpIHsKICAgICAgICBpZiAoIWltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgICAgdGhyb3cgRXJyb3IoImV4cG9zZSgpIGNhbGxlZCBpbiB0aGUgbWFzdGVyIHRocmVhZC4iKTsKICAgICAgICB9CiAgICAgICAgaWYgKGV4cG9zZUNhbGxlZCkgewogICAgICAgICAgdGhyb3cgRXJyb3IoImV4cG9zZSgpIGNhbGxlZCBtb3JlIHRoYW4gb25jZS4gVGhpcyBpcyBub3QgcG9zc2libGUuIFBhc3MgYW4gb2JqZWN0IHRvIGV4cG9zZSgpIGlmIHlvdSB3YW50IHRvIGV4cG9zZSBtdWx0aXBsZSBmdW5jdGlvbnMuIik7CiAgICAgICAgfQogICAgICAgIGV4cG9zZUNhbGxlZCA9IHRydWU7CiAgICAgICAgaWYgKHR5cGVvZiBleHBvc2VkID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgICAgaWYgKGlzTWFzdGVySm9iUnVuTWVzc2FnZShtZXNzYWdlRGF0YSkgJiYgIW1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZCwgbWVzc2FnZURhdGEuYXJncy5tYXAoY29tbW9uXzEuZGVzZXJpYWxpemUpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBwb3N0RnVuY3Rpb25Jbml0TWVzc2FnZSgpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJvYmplY3QiICYmIGV4cG9zZWQpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiBtZXNzYWdlRGF0YS5tZXRob2QpIHsKICAgICAgICAgICAgICBydW5GdW5jdGlvbihtZXNzYWdlRGF0YS51aWQsIGV4cG9zZWRbbWVzc2FnZURhdGEubWV0aG9kXSwgbWVzc2FnZURhdGEuYXJncy5tYXAoY29tbW9uXzEuZGVzZXJpYWxpemUpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBjb25zdCBtZXRob2ROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9zZWQpLmZpbHRlcigoa2V5KSA9PiB0eXBlb2YgZXhwb3NlZFtrZXldID09PSAiZnVuY3Rpb24iKTsKICAgICAgICAgIHBvc3RNb2R1bGVJbml0TWVzc2FnZShtZXRob2ROYW1lcyk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBleHBvc2UoKS4gRXhwZWN0ZWQgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QsIGdvdDogJHtleHBvc2VkfWApOwogICAgICAgIH0KICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgIGlmIChpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UobWVzc2FnZURhdGEpKSB7CiAgICAgICAgICAgIGNvbnN0IGpvYlVJRCA9IG1lc3NhZ2VEYXRhLnVpZDsKICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0aXZlU3Vic2NyaXB0aW9ucy5nZXQoam9iVUlEKTsKICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikgewogICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBleHBvcnRzLmV4cG9zZSA9IGV4cG9zZTI7CiAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHNlbGYuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShldmVudC5lcnJvciB8fCBldmVudCksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJ1bmhhbmRsZWRyZWplY3Rpb24iLCAoZXZlbnQpID0+IHsKICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQucmVhc29uOwogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHByb2Nlc3Mub24oInVuaGFuZGxlZFJlamVjdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMKICB2YXIgcmVxdWlyZV9sb25nID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gTG9uZzQ7CiAgICAgIHZhciB3YXNtMiA9IG51bGw7CiAgICAgIHRyeSB7CiAgICAgICAgd2FzbTIgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nNChsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwOwogICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICB9CiAgICAgIExvbmc0LnByb3RvdHlwZS5fX2lzTG9uZ19fOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZzQucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZzIob2JqKSB7CiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqWyJfX2lzTG9uZ19fIl0pID09PSB0cnVlOwogICAgICB9CiAgICAgIExvbmc0LmlzTG9uZyA9IGlzTG9uZzI7CiAgICAgIHZhciBJTlRfQ0FDSEUyID0ge307CiAgICAgIHZhciBVSU5UX0NBQ0hFMiA9IHt9OwogICAgICBmdW5jdGlvbiBmcm9tSW50Mih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgdmFsdWUgPj4+PSAwOwogICAgICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFMlt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzMih2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTsKICAgICAgICAgIGlmIChjYWNoZSkKICAgICAgICAgICAgVUlOVF9DQUNIRTJbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFsdWUgfD0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFMlt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzMih2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIElOVF9DQUNIRTJbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUludCA9IGZyb21JbnQyOwogICAgICBmdW5jdGlvbiBmcm9tTnVtYmVyMih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpKQogICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgICByZXR1cm4gVVpFUk8yOwogICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMMikKICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwyKQogICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwyKQogICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFMjsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyMigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwyIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTDIgfCAwLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbU51bWJlciA9IGZyb21OdW1iZXIyOwogICAgICBmdW5jdGlvbiBmcm9tQml0czIobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21CaXRzID0gZnJvbUJpdHMyOwogICAgICB2YXIgcG93X2RibDIgPSBNYXRoLnBvdzsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZzIoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHsKICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHRocm93IEVycm9yKCJlbXB0eSBzdHJpbmciKTsKICAgICAgICBpZiAoc3RyID09PSAiTmFOIiB8fCBzdHIgPT09ICJJbmZpbml0eSIgfHwgc3RyID09PSAiK0luZmluaXR5IiB8fCBzdHIgPT09ICItSW5maW5pdHkiKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLCB1bnNpZ25lZCA9IGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgICAgfQogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICB2YXIgcDsKICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcyKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyMihwb3dfZGJsMihyYWRpeCwgOCkpOwogICAgICAgIHZhciByZXN1bHQgPSBaRVJPMjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkgewogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyMihwb3dfZGJsMihyYWRpeCwgc2l6ZSkpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcjIodmFsdWUpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyMih2YWx1ZSkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIExvbmc0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nMjsKICAgICAgZnVuY3Rpb24gZnJvbVZhbHVlMih2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIyKHZhbCwgdW5zaWduZWQpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nMih2YWwsIHVuc2lnbmVkKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tVmFsdWUgPSBmcm9tVmFsdWUyOwogICAgICB2YXIgVFdPX1BXUl8xNl9EQkwyID0gMSA8PCAxNjsKICAgICAgdmFyIFRXT19QV1JfMjRfREJMMiA9IDEgPDwgMjQ7CiAgICAgIHZhciBUV09fUFdSXzMyX0RCTDIgPSBUV09fUFdSXzE2X0RCTDIgKiBUV09fUFdSXzE2X0RCTDI7CiAgICAgIHZhciBUV09fUFdSXzY0X0RCTDIgPSBUV09fUFdSXzMyX0RCTDIgKiBUV09fUFdSXzMyX0RCTDI7CiAgICAgIHZhciBUV09fUFdSXzYzX0RCTDIgPSBUV09fUFdSXzY0X0RCTDIgLyAyOwogICAgICB2YXIgVFdPX1BXUl8yNDIgPSBmcm9tSW50MihUV09fUFdSXzI0X0RCTDIpOwogICAgICB2YXIgWkVSTzIgPSBmcm9tSW50MigwKTsKICAgICAgTG9uZzQuWkVSTyA9IFpFUk8yOwogICAgICB2YXIgVVpFUk8yID0gZnJvbUludDIoMCwgdHJ1ZSk7CiAgICAgIExvbmc0LlVaRVJPID0gVVpFUk8yOwogICAgICB2YXIgT05FMiA9IGZyb21JbnQyKDEpOwogICAgICBMb25nNC5PTkUgPSBPTkUyOwogICAgICB2YXIgVU9ORTIgPSBmcm9tSW50MigxLCB0cnVlKTsKICAgICAgTG9uZzQuVU9ORSA9IFVPTkUyOwogICAgICB2YXIgTkVHX09ORTIgPSBmcm9tSW50MigtMSk7CiAgICAgIExvbmc0Lk5FR19PTkUgPSBORUdfT05FMjsKICAgICAgdmFyIE1BWF9WQUxVRTIgPSBmcm9tQml0czIoNDI5NDk2NzI5NSB8IDAsIDIxNDc0ODM2NDcgfCAwLCBmYWxzZSk7CiAgICAgIExvbmc0Lk1BWF9WQUxVRSA9IE1BWF9WQUxVRTI7CiAgICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUyID0gZnJvbUJpdHMyKDQyOTQ5NjcyOTUgfCAwLCA0Mjk0OTY3Mjk1IHwgMCwgdHJ1ZSk7CiAgICAgIExvbmc0Lk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTI7CiAgICAgIHZhciBNSU5fVkFMVUUyID0gZnJvbUJpdHMyKDAsIDIxNDc0ODM2NDggfCAwLCBmYWxzZSk7CiAgICAgIExvbmc0Lk1JTl9WQUxVRSA9IE1JTl9WQUxVRTI7CiAgICAgIHZhciBMb25nUHJvdG90eXBlMiA9IExvbmc0LnByb3RvdHlwZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9JbnQgPSBmdW5jdGlvbiB0b0ludDIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyMigpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMMiArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMMiArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcyKHJhZGl4KSB7CiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpCiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuICIwIjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKSB7CiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyMihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcjIocG93X2RibDIocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgcmVtID0gcmVtRGl2OwogICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgICAgICByZXN1bHQgPSAiIiArIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMyKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkMigpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0czIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQyKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMyKCkgewogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRTIpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTsKICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdzsKICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgICAgICBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybzIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXF6ID0gTG9uZ1Byb3RvdHlwZTIuaXNaZXJvOwogICAgICBMb25nUHJvdG90eXBlMi5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZTIoKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlMigpIHsKICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuaXNPZGQgPSBmdW5jdGlvbiBpc09kZDIoKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4yKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzMihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nMihvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZTIob3RoZXIpOwogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXEgPSBMb25nUHJvdG90eXBlMi5lcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUyLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFsczIob3RoZXIpIHsKICAgICAgICByZXR1cm4gIXRoaXMuZXEob3RoZXIpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5uZXEgPSBMb25nUHJvdG90eXBlMi5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUyLm5lID0gTG9uZ1Byb3RvdHlwZTIubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlMi5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubHQgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmx0ZSA9IExvbmdQcm90b3R5cGUyLmxlc3NUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGUgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4yKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5ndCA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuOwogICAgICBMb25nUHJvdG90eXBlMi5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwyKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ3RlID0gTG9uZ1Byb3RvdHlwZTIuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlMi5nZSA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuY29tcCA9IExvbmdQcm90b3R5cGUyLmNvbXBhcmU7CiAgICAgIExvbmdQcm90b3R5cGUyLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZTIoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FMik7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm5lZyA9IExvbmdQcm90b3R5cGUyLm5lZ2F0ZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuYWRkID0gZnVuY3Rpb24gYWRkMihhZGRlbmQpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoYWRkZW5kKSkKICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZTIoYWRkZW5kKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKyBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKyBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKyBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKyBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0czIoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0MihzdWJ0cmFoZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKHN1YnRyYWhlbmQpKQogICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZTIoc3VidHJhaGVuZCk7CiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zdWIgPSBMb25nUHJvdG90eXBlMi5zdWJ0cmFjdDsKICAgICAgTG9uZ1Byb3RvdHlwZTIubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseTIobXVsdGlwbGllcikgewogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICghaXNMb25nMihtdWx0aXBsaWVyKSkKICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUyKG11bHRpcGxpZXIpOwogICAgICAgIGlmICh3YXNtMikgewogICAgICAgICAgdmFyIGxvdyA9IHdhc20yLm11bCh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0czIobG93LCB3YXNtMi5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gWkVSTzI7CiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFMiA6IFpFUk8yOwogICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRTIgOiBaRVJPMjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTsKICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0MikgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0MikpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcjIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICogYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICogYjAwOwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTAwICogYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICogYjAwOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTE2ICogYjE2OwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTAwICogYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubXVsID0gTG9uZ1Byb3RvdHlwZTIubXVsdGlwbHk7CiAgICAgIExvbmdQcm90b3R5cGUyLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZTIoZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nMihkaXZpc29yKSkKICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUyKGRpdmlzb3IpOwogICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKQogICAgICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbTIuZGl2X3UgOiB3YXNtMi5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGxvdywgd2FzbTIuZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTzIgOiBaRVJPMjsKICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlczsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKSB7CiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORTIpIHx8IGRpdmlzb3IuZXEoTkVHX09ORTIpKQogICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUUyOwogICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgICAgIHJldHVybiBPTkUyOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTsKICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpOwogICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTzIpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUyIDogTkVHX09ORTI7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTsKICAgICAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpOwogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICAgICAgcmVzID0gWkVSTzI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkKICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgICAgIHJldHVybiBVWkVSTzI7CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgICAgICByZXR1cm4gVU9ORTI7CiAgICAgICAgICByZXMgPSBVWkVSTzI7CiAgICAgICAgfQogICAgICAgIHJlbSA9IHRoaXM7CiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHsKICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsKICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsMigyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyMihhcHByb3gpLCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhOwogICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyMihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICAgICAgYXBwcm94UmVzID0gT05FMjsKICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZGl2ID0gTG9uZ1Byb3RvdHlwZTIuZGl2aWRlOwogICAgICBMb25nUHJvdG90eXBlMi5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8yKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlMihkaXZpc29yKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20yLnJlbV91IDogd2FzbTIucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3csIHdhc20yLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubW9kID0gTG9uZ1Byb3RvdHlwZTIubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlMi5yZW0gPSBMb25nUHJvdG90eXBlMi5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUyLm5vdCA9IGZ1bmN0aW9uIG5vdDIoKSB7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5hbmQgPSBmdW5jdGlvbiBhbmQyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm9yID0gZnVuY3Rpb24gb3IyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnhvciA9IGZ1bmN0aW9uIHhvcjIob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZzIob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUyKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0MihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMigwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaGwgPSBMb25nUHJvdG90eXBlMi5zaGlmdExlZnQ7CiAgICAgIExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0MihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaHIgPSBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0OwogICAgICBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQyKG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nMihudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgbnVtQml0cyAmPSA2MzsKICAgICAgICBpZiAobnVtQml0cyA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7CiAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdzsKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3cgPj4+IG51bUJpdHMgfCBoaWdoIDw8IDMyIC0gbnVtQml0cywgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaHJ1ID0gTG9uZ1Byb3RvdHlwZTIuc2hpZnRSaWdodFVuc2lnbmVkOwogICAgICBMb25nUHJvdG90eXBlMi5zaHJfdSA9IExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZDIoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkMigpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzMihsZSkgewogICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUyKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgbG8gJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGhpICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMjQKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUyKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgaGkgPj4+IDI0LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gJiAyNTUKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nNC5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZzQuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRTIoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LCBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0LCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmc0LmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUyKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBUWVBFRF9PSyA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgVWludDE2QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAidW5kZWZpbmVkIjsKICAgICAgZnVuY3Rpb24gX2hhcyhvYmosIGtleSkgewogICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpOwogICAgICB9CiAgICAgIGV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24ob2JqKSB7CiAgICAgICAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgICAgIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkgewogICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTsKICAgICAgICAgIGlmICghc291cmNlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICJvYmplY3QiKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgIm11c3QgYmUgbm9uLW9iamVjdCIpOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHsKICAgICAgICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkgewogICAgICAgICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqOwogICAgICB9OwogICAgICBleHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uKGJ1Ziwgc2l6ZSkgewogICAgICAgIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7CiAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgIH0KICAgICAgICBpZiAoYnVmLnN1YmFycmF5KSB7CiAgICAgICAgICByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOwogICAgICAgIH0KICAgICAgICBidWYubGVuZ3RoID0gc2l6ZTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICB2YXIgZm5UeXBlZCA9IHsKICAgICAgICBhcnJheVNldDogZnVuY3Rpb24oZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkgewogICAgICAgICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDsKICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7CiAgICAgICAgICBwb3MgPSAwOwogICAgICAgICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07CiAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7CiAgICAgICAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGZuVW50eXBlZCA9IHsKICAgICAgICBhcnJheVNldDogZnVuY3Rpb24oZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7CiAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uKG9uKSB7CiAgICAgICAgaWYgKG9uKSB7CiAgICAgICAgICBleHBvcnRzLkJ1ZjggPSBVaW50OEFycmF5OwogICAgICAgICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5OwogICAgICAgICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7CiAgICAgICAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZXhwb3J0cy5CdWY4ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzCiAgdmFyIHJlcXVpcmVfdHJlZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBaX0ZJWEVEID0gNDsKICAgICAgdmFyIFpfQklOQVJZID0gMDsKICAgICAgdmFyIFpfVEVYVCA9IDE7CiAgICAgIHZhciBaX1VOS05PV04gPSAyOwogICAgICBmdW5jdGlvbiB6ZXJvKGJ1ZikgewogICAgICAgIHZhciBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSB7CiAgICAgICAgICBidWZbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBTVE9SRURfQkxPQ0sgPSAwOwogICAgICB2YXIgU1RBVElDX1RSRUVTID0gMTsKICAgICAgdmFyIERZTl9UUkVFUyA9IDI7CiAgICAgIHZhciBNSU5fTUFUQ0ggPSAzOwogICAgICB2YXIgTUFYX01BVENIID0gMjU4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIEJ1Zl9zaXplID0gMTY7CiAgICAgIHZhciBNQVhfQkxfQklUUyA9IDc7CiAgICAgIHZhciBFTkRfQkxPQ0sgPSAyNTY7CiAgICAgIHZhciBSRVBfM182ID0gMTY7CiAgICAgIHZhciBSRVBaXzNfMTAgPSAxNzsKICAgICAgdmFyIFJFUFpfMTFfMTM4ID0gMTg7CiAgICAgIHZhciBleHRyYV9sYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwXTsKICAgICAgdmFyIGV4dHJhX2RiaXRzID0gWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxM107CiAgICAgIHZhciBleHRyYV9ibGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgN107CiAgICAgIHZhciBibF9vcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgdmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7CiAgICAgIHZhciBzdGF0aWNfbHRyZWUgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpOwogICAgICB6ZXJvKHN0YXRpY19sdHJlZSk7CiAgICAgIHZhciBzdGF0aWNfZHRyZWUgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpOwogICAgICB6ZXJvKHN0YXRpY19kdHJlZSk7CiAgICAgIHZhciBfZGlzdF9jb2RlID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pOwogICAgICB6ZXJvKF9kaXN0X2NvZGUpOwogICAgICB2YXIgX2xlbmd0aF9jb2RlID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpOwogICAgICB6ZXJvKF9sZW5ndGhfY29kZSk7CiAgICAgIHZhciBiYXNlX2xlbmd0aCA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpOwogICAgICB6ZXJvKGJhc2VfbGVuZ3RoKTsKICAgICAgdmFyIGJhc2VfZGlzdCA9IG5ldyBBcnJheShEX0NPREVTKTsKICAgICAgemVybyhiYXNlX2Rpc3QpOwogICAgICBmdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHsKICAgICAgICB0aGlzLnN0YXRpY190cmVlID0gc3RhdGljX3RyZWU7CiAgICAgICAgdGhpcy5leHRyYV9iaXRzID0gZXh0cmFfYml0czsKICAgICAgICB0aGlzLmV4dHJhX2Jhc2UgPSBleHRyYV9iYXNlOwogICAgICAgIHRoaXMuZWxlbXMgPSBlbGVtczsKICAgICAgICB0aGlzLm1heF9sZW5ndGggPSBtYXhfbGVuZ3RoOwogICAgICAgIHRoaXMuaGFzX3N0cmVlID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoOwogICAgICB9CiAgICAgIHZhciBzdGF0aWNfbF9kZXNjOwogICAgICB2YXIgc3RhdGljX2RfZGVzYzsKICAgICAgdmFyIHN0YXRpY19ibF9kZXNjOwogICAgICBmdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7CiAgICAgICAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOwogICAgICAgIHRoaXMubWF4X2NvZGUgPSAwOwogICAgICAgIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRfY29kZShkaXN0KSB7CiAgICAgICAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSB3ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyA+Pj4gOCAmIDI1NTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID4gQnVmX3NpemUgLSBsZW5ndGgpIHsKICAgICAgICAgIHMuYmlfYnVmIHw9IHZhbHVlIDw8IHMuYmlfdmFsaWQgJiA2NTUzNTsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IEJ1Zl9zaXplIC0gcy5iaV92YWxpZDsKICAgICAgICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHMuYmlfYnVmIHw9IHZhbHVlIDw8IHMuYmlfdmFsaWQgJiA2NTUzNTsKICAgICAgICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkgewogICAgICAgIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXSwgdHJlZVtjICogMiArIDFdKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikgewogICAgICAgIHZhciByZXMgPSAwOwogICAgICAgIGRvIHsKICAgICAgICAgIHJlcyB8PSBjb2RlICYgMTsKICAgICAgICAgIGNvZGUgPj4+PSAxOwogICAgICAgICAgcmVzIDw8PSAxOwogICAgICAgIH0gd2hpbGUgKC0tbGVuID4gMCk7CiAgICAgICAgcmV0dXJuIHJlcyA+Pj4gMTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV9mbHVzaChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAyNTU7CiAgICAgICAgICBzLmJpX2J1ZiA+Pj0gODsKICAgICAgICAgIHMuYmlfdmFsaWQgLT0gODsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKSB7CiAgICAgICAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlOwogICAgICAgIHZhciBtYXhfY29kZSA9IGRlc2MubWF4X2NvZGU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZXh0cmEgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzOwogICAgICAgIHZhciBiYXNlID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTsKICAgICAgICB2YXIgbWF4X2xlbmd0aCA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7CiAgICAgICAgdmFyIGg7CiAgICAgICAgdmFyIG4sIG07CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIHhiaXRzOwogICAgICAgIHZhciBmOwogICAgICAgIHZhciBvdmVyZmxvdyA9IDA7CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDsKICAgICAgICB9CiAgICAgICAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0gPSAwOwogICAgICAgIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHsKICAgICAgICAgIG4gPSBzLmhlYXBbaF07CiAgICAgICAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0gKiAyICsgMV0gKyAxOwogICAgICAgICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7CiAgICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoOwogICAgICAgICAgICBvdmVyZmxvdysrOwogICAgICAgICAgfQogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gYml0czsKICAgICAgICAgIGlmIChuID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdKys7CiAgICAgICAgICB4Yml0cyA9IDA7CiAgICAgICAgICBpZiAobiA+PSBiYXNlKSB7CiAgICAgICAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdOwogICAgICAgICAgfQogICAgICAgICAgZiA9IHRyZWVbbiAqIDJdOwogICAgICAgICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTsKICAgICAgICAgIGlmIChoYXNfc3RyZWUpIHsKICAgICAgICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXSArIHhiaXRzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGRvIHsKICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTsKICAgICAgICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7CiAgICAgICAgICAgIGJpdHMtLTsKICAgICAgICAgIH0KICAgICAgICAgIHMuYmxfY291bnRbYml0c10tLTsKICAgICAgICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7CiAgICAgICAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07CiAgICAgICAgICBvdmVyZmxvdyAtPSAyOwogICAgICAgIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7CiAgICAgICAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7CiAgICAgICAgICBuID0gcy5ibF9jb3VudFtiaXRzXTsKICAgICAgICAgIHdoaWxlIChuICE9PSAwKSB7CiAgICAgICAgICAgIG0gPSBzLmhlYXBbLS1oXTsKICAgICAgICAgICAgaWYgKG0gPiBtYXhfY29kZSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0cmVlW20gKiAyICsgMV0gIT09IGJpdHMpIHsKICAgICAgICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0pICogdHJlZVttICogMl07CiAgICAgICAgICAgICAgdHJlZVttICogMiArIDFdID0gYml0czsKICAgICAgICAgICAgfQogICAgICAgICAgICBuLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpIHsKICAgICAgICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7CiAgICAgICAgdmFyIGNvZGUgPSAwOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBuOwogICAgICAgIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0gPDwgMTsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGVuZ3RoOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9sYml0c1tjb2RlXTsgbisrKSB7CiAgICAgICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlOwogICAgICAgIGRpc3QgPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkaXN0ID4+PSA3OwogICAgICAgIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9kYml0c1tjb2RlXSAtIDc7IG4rKykgewogICAgICAgICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIGJsX2NvdW50W2JpdHNdID0gMDsKICAgICAgICB9CiAgICAgICAgbiA9IDA7CiAgICAgICAgd2hpbGUgKG4gPD0gMTQzKSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDg7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs4XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNTUpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gOTsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzldKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI3OSkgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA3OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbN10rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjg3KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDg7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs4XSsrOwogICAgICAgIH0KICAgICAgICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHsKICAgICAgICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdID0gNTsKICAgICAgICAgIHN0YXRpY19kdHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG4sIDUpOwogICAgICAgIH0KICAgICAgICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpOwogICAgICAgIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgRF9DT0RFUywgTUFYX0JJVFMpOwogICAgICAgIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluaXRfYmxvY2socykgewogICAgICAgIHZhciBuOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuZHluX2x0cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuZHluX2R0cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmJsX3RyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0gPSAxOwogICAgICAgIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfd2luZHVwKHMpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IDgpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkgewogICAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjsKICAgICAgICB9CiAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcikgewogICAgICAgIGJpX3dpbmR1cChzKTsKICAgICAgICBpZiAoaGVhZGVyKSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgbGVuKTsKICAgICAgICAgIHB1dF9zaG9ydChzLCB+bGVuKTsKICAgICAgICB9CiAgICAgICAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpOwogICAgICAgIHMucGVuZGluZyArPSBsZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkgewogICAgICAgIHZhciBfbjIgPSBuICogMjsKICAgICAgICB2YXIgX20yID0gbSAqIDI7CiAgICAgICAgcmV0dXJuIHRyZWVbX24yXSA8IHRyZWVbX20yXSB8fCB0cmVlW19uMl0gPT09IHRyZWVbX20yXSAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspIHsKICAgICAgICB2YXIgdiA9IHMuaGVhcFtrXTsKICAgICAgICB2YXIgaiA9IGsgPDwgMTsKICAgICAgICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7CiAgICAgICAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiYgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGorKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzLmhlYXBba10gPSBzLmhlYXBbal07CiAgICAgICAgICBrID0gajsKICAgICAgICAgIGogPDw9IDE7CiAgICAgICAgfQogICAgICAgIHMuaGVhcFtrXSA9IHY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKSB7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGxjOwogICAgICAgIHZhciBseCA9IDA7CiAgICAgICAgdmFyIGNvZGU7CiAgICAgICAgdmFyIGV4dHJhOwogICAgICAgIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGRpc3QgPSBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDggfCBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXTsKICAgICAgICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07CiAgICAgICAgICAgIGx4Kys7CiAgICAgICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsKICAgICAgICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdOwogICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkgewogICAgICAgICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07CiAgICAgICAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZGlzdC0tOwogICAgICAgICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsKICAgICAgICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdOwogICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkgewogICAgICAgICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07CiAgICAgICAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTsKICAgICAgICB9CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTsKICAgICAgICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgICAgIHZhciBlbGVtcyA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBtYXhfY29kZSA9IC0xOwogICAgICAgIHZhciBub2RlOwogICAgICAgIHMuaGVhcF9sZW4gPSAwOwogICAgICAgIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHsKICAgICAgICAgIGlmICh0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjsKICAgICAgICAgICAgcy5kZXB0aFtuXSA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHsKICAgICAgICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSAxOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IDA7CiAgICAgICAgICBzLm9wdF9sZW4tLTsKICAgICAgICAgIGlmIChoYXNfc3RyZWUpIHsKICAgICAgICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTsKICAgICAgICBmb3IgKG4gPSBzLmhlYXBfbGVuID4+IDE7IG4gPj0gMTsgbi0tKSB7CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOwogICAgICAgIH0KICAgICAgICBub2RlID0gZWxlbXM7CiAgICAgICAgZG8gewogICAgICAgICAgbiA9IHMuaGVhcFsxXTsKICAgICAgICAgIHMuaGVhcFsxXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dOwogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxKTsKICAgICAgICAgIG0gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47CiAgICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07CiAgICAgICAgICB0cmVlW25vZGUgKiAyXSA9IHRyZWVbbiAqIDJdICsgdHJlZVttICogMl07CiAgICAgICAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7CiAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSB0cmVlW20gKiAyICsgMV0gPSBub2RlOwogICAgICAgICAgcy5oZWFwWzFdID0gbm9kZSsrOwogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxKTsKICAgICAgICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpOwogICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzFdOwogICAgICAgIGdlbl9iaXRsZW4ocywgZGVzYyk7CiAgICAgICAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgcHJldmxlbiA9IC0xOwogICAgICAgIHZhciBjdXJsZW47CiAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsKICAgICAgICB2YXIgbWluX2NvdW50ID0gNDsKICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICB9CiAgICAgICAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXSA9IDY1NTM1OwogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07CiAgICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSArPSBjb3VudDsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsKICAgICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0rKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdKys7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKzsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07CiAgICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOwogICAgICAgICAgICB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOwogICAgICAgICAgICAgIGNvdW50LS07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpOwogICAgICAgICAgfQogICAgICAgICAgY291bnQgPSAwOwogICAgICAgICAgcHJldmxlbiA9IGN1cmxlbjsKICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtYXhfY291bnQgPSA3OwogICAgICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHsKICAgICAgICB2YXIgbWF4X2JsaW5kZXg7CiAgICAgICAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7CiAgICAgICAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7CiAgICAgICAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpOwogICAgICAgIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHsKICAgICAgICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0OwogICAgICAgIHJldHVybiBtYXhfYmxpbmRleDsKICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgewogICAgICAgIHZhciByYW5rOwogICAgICAgIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOwogICAgICAgIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsIDQpOwogICAgICAgIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0sIDMpOwogICAgICAgIH0KICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOwogICAgICAgIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7CiAgICAgICAgdmFyIGJsYWNrX21hc2sgPSA0MDkzNjI0NDQ3OwogICAgICAgIHZhciBuOwogICAgICAgIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHsKICAgICAgICAgIGlmIChibGFja19tYXNrICYgMSAmJiBzLmR5bl9sdHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIFpfQklOQVJZOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5keW5fbHRyZWVbOSAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0gIT09IDAgfHwgcy5keW5fbHRyZWVbMTMgKiAyXSAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7CiAgICAgICAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlOwogICAgICBmdW5jdGlvbiBfdHJfaW5pdChzKSB7CiAgICAgICAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7CiAgICAgICAgICB0cl9zdGF0aWNfaW5pdCgpOwogICAgICAgICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7CiAgICAgICAgfQogICAgICAgIHMubF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTsKICAgICAgICBzLmRfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7CiAgICAgICAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpOwogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9hbGlnbihzKSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTsKICAgICAgICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpOwogICAgICAgIGJpX2ZsdXNoKHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpIHsKICAgICAgICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOwogICAgICAgIHZhciBtYXhfYmxpbmRleCA9IDA7CiAgICAgICAgaWYgKHMubGV2ZWwgPiAwKSB7CiAgICAgICAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7CiAgICAgICAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpOwogICAgICAgICAgfQogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7CiAgICAgICAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTsKICAgICAgICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTsKICAgICAgICAgIG9wdF9sZW5iID0gcy5vcHRfbGVuICsgMyArIDcgPj4+IDM7CiAgICAgICAgICBzdGF0aWNfbGVuYiA9IHMuc3RhdGljX2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7CiAgICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmI7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iICYmIGJ1ZiAhPT0gLTEpIHsKICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTsKICAgICAgICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTsKICAgICAgICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7CiAgICAgICAgfQogICAgICAgIGluaXRfYmxvY2socyk7CiAgICAgICAgaWYgKGxhc3QpIHsKICAgICAgICAgIGJpX3dpbmR1cChzKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdID0gZGlzdCA+Pj4gOCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMjU1OwogICAgICAgIHMubGFzdF9saXQrKzsKICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgcy5keW5fbHRyZWVbbGMgKiAyXSsrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLm1hdGNoZXMrKzsKICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdKys7CiAgICAgICAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXSsrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDE7CiAgICAgIH0KICAgICAgZXhwb3J0cy5fdHJfaW5pdCA9IF90cl9pbml0OwogICAgICBleHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrOwogICAgICBleHBvcnRzLl90cl9mbHVzaF9ibG9jayA9IF90cl9mbHVzaF9ibG9jazsKICAgICAgZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7CiAgICAgIGV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzCiAgdmFyIHJlcXVpcmVfYWRsZXIzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykgewogICAgICAgIHZhciBzMSA9IGFkbGVyICYgNjU1MzUgfCAwLCBzMiA9IGFkbGVyID4+PiAxNiAmIDY1NTM1IHwgMCwgbiA9IDA7CiAgICAgICAgd2hpbGUgKGxlbiAhPT0gMCkgewogICAgICAgICAgbiA9IGxlbiA+IDJlMyA/IDJlMyA6IGxlbjsKICAgICAgICAgIGxlbiAtPSBuOwogICAgICAgICAgZG8gewogICAgICAgICAgICBzMSA9IHMxICsgYnVmW3BvcysrXSB8IDA7CiAgICAgICAgICAgIHMyID0gczIgKyBzMSB8IDA7CiAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgczEgJT0gNjU1MjE7CiAgICAgICAgICBzMiAlPSA2NTUyMTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMxIHwgczIgPDwgMTYgfCAwOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMKICB2YXIgcmVxdWlyZV9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIG1ha2VUYWJsZSgpIHsKICAgICAgICB2YXIgYywgdGFibGUgPSBbXTsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7CiAgICAgICAgICBjID0gbjsKICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7CiAgICAgICAgICAgIGMgPSBjICYgMSA/IDM5ODgyOTIzODQgXiBjID4+PiAxIDogYyA+Pj4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRhYmxlW25dID0gYzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9CiAgICAgIHZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpOwogICAgICBmdW5jdGlvbiBjcmMzMjIoY3JjLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuOwogICAgICAgIGNyYyBePSAtMTsKICAgICAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHsKICAgICAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAyNTVdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JjIF4gLTE7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjcmMzMjI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgdmFyIHRyZWVzID0gcmVxdWlyZV90cmVlcygpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIyID0gcmVxdWlyZV9jcmMzMigpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlczIoKTsKICAgICAgdmFyIFpfTk9fRkxVU0ggPSAwOwogICAgICB2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTsKICAgICAgdmFyIFpfRlVMTF9GTFVTSCA9IDM7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX0JMT0NLID0gNTsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfQlVGX0VSUk9SID0gLTU7CiAgICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTsKICAgICAgdmFyIFpfRklMVEVSRUQgPSAxOwogICAgICB2YXIgWl9IVUZGTUFOX09OTFkgPSAyOwogICAgICB2YXIgWl9STEUgPSAzOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgTUFYX01FTV9MRVZFTCA9IDk7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9NRU1fTEVWRUwgPSA4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBNSU5fTE9PS0FIRUFEID0gTUFYX01BVENIICsgTUlOX01BVENIICsgMTsKICAgICAgdmFyIFBSRVNFVF9ESUNUID0gMzI7CiAgICAgIHZhciBJTklUX1NUQVRFID0gNDI7CiAgICAgIHZhciBFWFRSQV9TVEFURSA9IDY5OwogICAgICB2YXIgTkFNRV9TVEFURSA9IDczOwogICAgICB2YXIgQ09NTUVOVF9TVEFURSA9IDkxOwogICAgICB2YXIgSENSQ19TVEFURSA9IDEwMzsKICAgICAgdmFyIEJVU1lfU1RBVEUgPSAxMTM7CiAgICAgIHZhciBGSU5JU0hfU1RBVEUgPSA2NjY7CiAgICAgIHZhciBCU19ORUVEX01PUkUgPSAxOwogICAgICB2YXIgQlNfQkxPQ0tfRE9ORSA9IDI7CiAgICAgIHZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7CiAgICAgIHZhciBCU19GSU5JU0hfRE9ORSA9IDQ7CiAgICAgIHZhciBPU19DT0RFID0gMzsKICAgICAgZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkgewogICAgICAgIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07CiAgICAgICAgcmV0dXJuIGVycm9yQ29kZTsKICAgICAgfQogICAgICBmdW5jdGlvbiByYW5rKGYpIHsKICAgICAgICByZXR1cm4gKGYgPDwgMSkgLSAoZiA+IDQgPyA5IDogMCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHsKICAgICAgICB2YXIgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgdmFyIGxlbiA9IHMucGVuZGluZzsKICAgICAgICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHsKICAgICAgICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpOwogICAgICAgIHN0cm0ubmV4dF9vdXQgKz0gbGVuOwogICAgICAgIHMucGVuZGluZ19vdXQgKz0gbGVuOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLmF2YWlsX291dCAtPSBsZW47CiAgICAgICAgcy5wZW5kaW5nIC09IGxlbjsKICAgICAgICBpZiAocy5wZW5kaW5nID09PSAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7CiAgICAgICAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIGZsdXNoX3BlbmRpbmcocy5zdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHsKICAgICAgICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBpZiAobGVuID4gc2l6ZSkgewogICAgICAgICAgbGVuID0gc2l6ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIHN0cm0uYXZhaWxfaW4gLT0gbGVuOwogICAgICAgIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTsKICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpOwogICAgICAgIH0gZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBsZW47CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkgewogICAgICAgIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7CiAgICAgICAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OwogICAgICAgIHZhciBtYXRjaDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7CiAgICAgICAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7CiAgICAgICAgdmFyIGxpbWl0ID0gcy5zdHJzdGFydCA+IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCA/IHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDA7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICB2YXIgd21hc2sgPSBzLndfbWFzazsKICAgICAgICB2YXIgcHJldiA9IHMucHJldjsKICAgICAgICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICB2YXIgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICB2YXIgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7CiAgICAgICAgICBjaGFpbl9sZW5ndGggPj49IDI7CiAgICAgICAgfQogICAgICAgIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgbWF0Y2ggPSBjdXJfbWF0Y2g7CiAgICAgICAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAhPT0gc2Nhbl9lbmQgfHwgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fCBfd2luW21hdGNoXSAhPT0gX3dpbltzY2FuXSB8fCBfd2luWysrbWF0Y2hdICE9PSBfd2luW3NjYW4gKyAxXSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHNjYW4gKz0gMjsKICAgICAgICAgIG1hdGNoKys7CiAgICAgICAgICBkbyB7CiAgICAgICAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIHNjYW4gPCBzdHJlbmQpOwogICAgICAgICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDsKICAgICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikgewogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoOwogICAgICAgICAgICBiZXN0X2xlbiA9IGxlbjsKICAgICAgICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICAgICAgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTsKICAgICAgICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBiZXN0X2xlbjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubG9va2FoZWFkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHsKICAgICAgICB2YXIgX3dfc2l6ZSA9IHMud19zaXplOwogICAgICAgIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7CiAgICAgICAgZG8gewogICAgICAgICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApOwogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBuID0gcy5oYXNoX3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMuaGVhZFstLXBdOwogICAgICAgICAgICAgIHMuaGVhZFtwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbiA9IF93X3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMucHJldlstLXBdOwogICAgICAgICAgICAgIHMucHJldltwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbW9yZSArPSBfd19zaXplOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpOwogICAgICAgICAgcy5sb29rYWhlYWQgKz0gbjsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7CiAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdOwogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHdoaWxlIChzLmluc2VydCkgewogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgICBzdHIrKzsKICAgICAgICAgICAgICBzLmluc2VydC0tOwogICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgewogICAgICAgIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDY1NTM1OwogICAgICAgIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHsKICAgICAgICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTsKICAgICAgICB9CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkgewogICAgICAgICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaCAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTsKICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkgewogICAgICAgIHZhciBoYXNoX2hlYWQ7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICB2YXIgbWF4X2luc2VydDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYXNoX2hlYWQgPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgIH0KICAgICAgICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJiAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCBzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5NikpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7CiAgICAgICAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxOwogICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC09IDI7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApOwogICAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBwcmV2OwogICAgICAgIHZhciBzY2FuLCBzdHJlbmQ7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7CiAgICAgICAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTsKICAgICAgICAgICAgcHJldiA9IF93aW5bc2Nhbl07CiAgICAgICAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkgewogICAgICAgICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7CiAgICAgICAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoOwogICAgICAgIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTsKICAgICAgICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47CiAgICAgICAgdGhpcy5mdW5jID0gZnVuYzsKICAgICAgfQogICAgICB2YXIgY29uZmlndXJhdGlvbl90YWJsZTsKICAgICAgY29uZmlndXJhdGlvbl90YWJsZSA9IFsKICAgICAgICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykKICAgICAgXTsKICAgICAgZnVuY3Rpb24gbG1faW5pdChzKSB7CiAgICAgICAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTsKICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7CiAgICAgICAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDsKICAgICAgICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoOwogICAgICAgIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluOwogICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgcy5pbnNfaCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMuc3RybSA9IG51bGw7CiAgICAgICAgdGhpcy5zdGF0dXMgPSAwOwogICAgICAgIHRoaXMucGVuZGluZ19idWYgPSBudWxsOwogICAgICAgIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nID0gMDsKICAgICAgICB0aGlzLndyYXAgPSAwOwogICAgICAgIHRoaXMuZ3poZWFkID0gbnVsbDsKICAgICAgICB0aGlzLmd6aW5kZXggPSAwOwogICAgICAgIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsKICAgICAgICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICB0aGlzLndfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy53X2JpdHMgPSAwOwogICAgICAgIHRoaXMud19tYXNrID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuaW5zX2ggPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaXplID0gMDsKICAgICAgICB0aGlzLmhhc2hfYml0cyA9IDA7CiAgICAgICAgdGhpcy5oYXNoX21hc2sgPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaGlmdCA9IDA7CiAgICAgICAgdGhpcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgIHRoaXMucHJldl9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHRoaXMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHRoaXMubWF0Y2hfc3RhcnQgPSAwOwogICAgICAgIHRoaXMubG9va2FoZWFkID0gMDsKICAgICAgICB0aGlzLnByZXZfbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubGV2ZWwgPSAwOwogICAgICAgIHRoaXMuc3RyYXRlZ3kgPSAwOwogICAgICAgIHRoaXMuZ29vZF9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5uaWNlX21hdGNoID0gMDsKICAgICAgICB0aGlzLmR5bl9sdHJlZSA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTsKICAgICAgICB0aGlzLmR5bl9kdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHRoaXMuYmxfdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2x0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2R0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuYmxfdHJlZSk7CiAgICAgICAgdGhpcy5sX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuZF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmJsX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTsKICAgICAgICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsKICAgICAgICB6ZXJvKHRoaXMuaGVhcCk7CiAgICAgICAgdGhpcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgdGhpcy5oZWFwX21heCA9IDA7CiAgICAgICAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5kZXB0aCk7CiAgICAgICAgdGhpcy5sX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0X2xpdCA9IDA7CiAgICAgICAgdGhpcy5kX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5vcHRfbGVuID0gMDsKICAgICAgICB0aGlzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHRoaXMubWF0Y2hlcyA9IDA7CiAgICAgICAgdGhpcy5pbnNlcnQgPSAwOwogICAgICAgIHRoaXMuYmlfYnVmID0gMDsKICAgICAgICB0aGlzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgczsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwOwogICAgICAgIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOOwogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHMucGVuZGluZyA9IDA7CiAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgaWYgKHMud3JhcCA8IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHMuc3RhdHVzID0gcy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEU7CiAgICAgICAgc3RybS5hZGxlciA9IHMud3JhcCA9PT0gMiA/IDAgOiAxOwogICAgICAgIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7CiAgICAgICAgdHJlZXMuX3RyX2luaXQocyk7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgICBpZiAocmV0ID09PSBaX09LKSB7CiAgICAgICAgICBsbV9pbml0KHN0cm0uc3RhdGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHZhciB3cmFwID0gMTsKICAgICAgICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikgewogICAgICAgICAgbGV2ZWwgPSA2OwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7CiAgICAgICAgICB3cmFwID0gMjsKICAgICAgICAgIHdpbmRvd0JpdHMgLT0gMTY7CiAgICAgICAgfQogICAgICAgIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fCB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fCBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHsKICAgICAgICAgIHdpbmRvd0JpdHMgPSA5OwogICAgICAgIH0KICAgICAgICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gczsKICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcy5nemhlYWQgPSBudWxsOwogICAgICAgIHMud19iaXRzID0gd2luZG93Qml0czsKICAgICAgICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7CiAgICAgICAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7CiAgICAgICAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzOwogICAgICAgIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxOwogICAgICAgIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTsKICAgICAgICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7CiAgICAgICAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTsKICAgICAgICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpOwogICAgICAgIHMubGl0X2J1ZnNpemUgPSAxIDw8IG1lbUxldmVsICsgNjsKICAgICAgICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDsKICAgICAgICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTsKICAgICAgICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplOwogICAgICAgIHMubGV2ZWwgPSBsZXZlbDsKICAgICAgICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7CiAgICAgICAgcy5tZXRob2QgPSBtZXRob2Q7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkgewogICAgICAgIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIG9sZF9mbHVzaCwgczsKICAgICAgICB2YXIgYmVnLCB2YWw7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8IGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHsKICAgICAgICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgc3RybS5hdmFpbF9vdXQgPT09IDAgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJtID0gc3RybTsKICAgICAgICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAzMSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDEzOSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDgpOwogICAgICAgICAgICBpZiAoIXMuZ3poZWFkKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICsgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNikpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAxNiAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAyNCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMjU1KTsKICAgICAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAyNTUpOwogICAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBaX0RFRkxBVEVEICsgKHMud19iaXRzIC0gOCA8PCA0KSA8PCA4OwogICAgICAgICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTsKICAgICAgICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDA7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDE7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyIHw9IGxldmVsX2ZsYWdzIDw8IDY7CiAgICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7CiAgICAgICAgICAgICAgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlYWRlciArPSAzMSAtIGhlYWRlciAlIDMxOwogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7CiAgICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc3RybS5hZGxlciA9IDE7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMjU1KTsKICAgICAgICAgICAgICBzLmd6aW5kZXgrKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5uYW1lKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMjIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuY29tbWVudCkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkgewogICAgICAgICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7CiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fCBmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSB7CiAgICAgICAgICB2YXIgYnN0YXRlID0gcy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDogcy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOiBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpOwogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkgewogICAgICAgICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkgewogICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkgewogICAgICAgICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgewogICAgICAgICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpOwogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgIH0KICAgICAgICBpZiAocy53cmFwIDw9IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAyNCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gOCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDE2ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMjQgJiAyNTUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgNjU1MzUpOwogICAgICAgIH0KICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgIGlmIChzLndyYXAgPiAwKSB7CiAgICAgICAgICBzLndyYXAgPSAtcy53cmFwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHsKICAgICAgICB2YXIgc3RhdHVzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1czsKICAgICAgICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiYgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJiBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiYgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgczsKICAgICAgICB2YXIgc3RyLCBuOwogICAgICAgIHZhciB3cmFwOwogICAgICAgIHZhciBhdmFpbDsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgaW5wdXQ7CiAgICAgICAgdmFyIHRtcERpY3Q7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHdyYXAgPSBzLndyYXA7CiAgICAgICAgaWYgKHdyYXAgPT09IDIgfHwgd3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSB8fCBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAod3JhcCA9PT0gMSkgewogICAgICAgICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7CiAgICAgICAgfQogICAgICAgIHMud3JhcCA9IDA7CiAgICAgICAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHsKICAgICAgICAgIGlmICh3cmFwID09PSAwKSB7CiAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpOwogICAgICAgICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7CiAgICAgICAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDsKICAgICAgICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTsKICAgICAgICB9CiAgICAgICAgYXZhaWwgPSBzdHJtLmF2YWlsX2luOwogICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7CiAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgc3RyID0gcy5zdHJzdGFydDsKICAgICAgICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7CiAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgIHMuc3Ryc3RhcnQgPSBzdHI7CiAgICAgICAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDsKICAgICAgICBzLmluc2VydCA9IHMubG9va2FoZWFkOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgIHN0cm0uaW5wdXQgPSBpbnB1dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gYXZhaWw7CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyOwogICAgICBleHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDsKICAgICAgZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjsKICAgICAgZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDsKICAgICAgZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzLmRlZmxhdGVJbmZvID0gInBha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcwogIHZhciByZXF1aXJlX3N0cmluZ3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBTVFJfQVBQTFlfT0sgPSB0cnVlOwogICAgICB2YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbMF0pOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7CiAgICAgIGZvciAocSA9IDA7IHEgPCAyNTY7IHErKykgewogICAgICAgIF91dGY4bGVuW3FdID0gcSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMTsKICAgICAgfQogICAgICB2YXIgcTsKICAgICAgX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOwogICAgICBleHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDsKICAgICAgICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBidWZfbGVuICs9IGMgPCAxMjggPyAxIDogYyA8IDIwNDggPyAyIDogYyA8IDY1NTM2ID8gMyA6IDQ7CiAgICAgICAgfQogICAgICAgIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pOwogICAgICAgIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIG1fcG9zICsgMSA8IHN0cl9sZW4pIHsKICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgICAgICBpZiAoKGMyICYgNjQ1MTIpID09PSA1NjMyMCkgewogICAgICAgICAgICAgIGMgPSA2NTUzNiArIChjIC0gNTUyOTYgPDwgMTApICsgKGMyIC0gNTYzMjApOwogICAgICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gYzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHsKICAgICAgICAgICAgYnVmW2krK10gPSAxOTIgfCBjID4+PiA2OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjI0IHwgYyA+Pj4gMTI7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjQwIHwgYyA+Pj4gMTg7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gMTIgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiA2ICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBmdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7CiAgICAgICAgaWYgKGxlbiA8IDY1NTM0KSB7CiAgICAgICAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0sgfHwgIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spIHsKICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIGV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZikgewogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7CiAgICAgIH07CiAgICAgIGV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTsKICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgaSwgb3V0LCBjLCBjX2xlbjsKICAgICAgICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpOwogICAgICAgIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47ICkgewogICAgICAgICAgYyA9IGJ1ZltpKytdOwogICAgICAgICAgaWYgKGMgPCAxMjgpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdOwogICAgICAgICAgaWYgKGNfbGVuID4gNCkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgaSArPSBjX2xlbiAtIDE7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDMxIDogY19sZW4gPT09IDMgPyAxNSA6IDc7CiAgICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHsKICAgICAgICAgICAgYyA9IGMgPDwgNiB8IGJ1ZltpKytdICYgNjM7CiAgICAgICAgICAgIGNfbGVuLS07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY19sZW4gPiAxKSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDY1NTMzOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgNjU1MzYpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGMgLT0gNjU1MzY7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU1Mjk2IHwgYyA+PiAxMCAmIDEwMjM7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU2MzIwIHwgYyAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpOwogICAgICB9OwogICAgICBleHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbihidWYsIG1heCkgewogICAgICAgIHZhciBwb3M7CiAgICAgICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIG1heCA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHBvcyA9IG1heCAtIDE7CiAgICAgICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgcG9zLS07CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPCAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICBpZiAocG9zID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICByZXR1cm4gcG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4ID8gcG9zIDogbWF4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzCiAgdmFyIHJlcXVpcmVfenN0cmVhbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZV9kZWZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlczIoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIHRvU3RyaW5nMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIHZhciBaX05PX0ZMVVNIID0gMDsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1lOQ19GTFVTSDIgPSAyOwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIGZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkKICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTiwKICAgICAgICAgIG1ldGhvZDogWl9ERUZMQVRFRCwKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAxNSwKICAgICAgICAgIG1lbUxldmVsOiA4LAogICAgICAgICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPiAwKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICB9IGVsc2UgaWYgKG9wdC5nemlwICYmIG9wdC53aW5kb3dCaXRzID4gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAxNjsKICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC5sZXZlbCwgb3B0Lm1ldGhvZCwgb3B0LndpbmRvd0JpdHMsIG9wdC5tZW1MZXZlbCwgb3B0LnN0cmF0ZWd5KTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LmhlYWRlcikgewogICAgICAgICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICB2YXIgZGljdDsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZzIuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nMi5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSDIpKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikgewogICAgICAgICAgdGhpcy5vbkVuZChaX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoZGVmbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMuZ3ppcCA9IHRydWU7CiAgICAgICAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMuZ3ppcCA9IGd6aXA7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMKICB2YXIgcmVxdWlyZV9pbmZmYXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgQkFEID0gMzA7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBfaW47CiAgICAgICAgdmFyIGxhc3Q7CiAgICAgICAgdmFyIF9vdXQ7CiAgICAgICAgdmFyIGJlZzsKICAgICAgICB2YXIgZW5kOwogICAgICAgIHZhciBkbWF4OwogICAgICAgIHZhciB3c2l6ZTsKICAgICAgICB2YXIgd2hhdmU7CiAgICAgICAgdmFyIHduZXh0OwogICAgICAgIHZhciBzX3dpbmRvdzsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGNvZGU7CiAgICAgICAgdmFyIGRjb2RlOwogICAgICAgIHZhciBsbWFzazsKICAgICAgICB2YXIgZG1hc2s7CiAgICAgICAgdmFyIGhlcmU7CiAgICAgICAgdmFyIG9wOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGZyb207CiAgICAgICAgdmFyIGZyb21fc291cmNlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBfaW4gPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpOwogICAgICAgIF9vdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7CiAgICAgICAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7CiAgICAgICAgZG1heCA9IHN0YXRlLmRtYXg7CiAgICAgICAgd3NpemUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB3aGF2ZSA9IHN0YXRlLndoYXZlOwogICAgICAgIHduZXh0ID0gc3RhdGUud25leHQ7CiAgICAgICAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlOwogICAgICAgIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7CiAgICAgICAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7CiAgICAgICAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxOwogICAgICAgIHRvcDoKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdOwogICAgICAgICAgICBkb2xlbjoKICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICBsZW4gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICBpZiAob3ApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsZW4gKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdOwogICAgICAgICAgICAgICAgICBkb2Rpc3Q6CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdzsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod25leHQgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgY29udGludWUgZG9sZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7CiAgICAgICAgbGVuID0gYml0cyA+PiAzOwogICAgICAgIF9pbiAtPSBsZW47CiAgICAgICAgYml0cyAtPSBsZW4gPDwgMzsKICAgICAgICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTsKICAgICAgICBzdHJtLm5leHRfaW4gPSBfaW47CiAgICAgICAgc3RybS5uZXh0X291dCA9IF9vdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KTsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCk7CiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgcmV0dXJuOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcwogIHZhciByZXF1aXJlX2luZnRyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBNQVhCSVRTID0gMTU7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgbGJhc2UgPSBbCiAgICAgICAgMywKICAgICAgICA0LAogICAgICAgIDUsCiAgICAgICAgNiwKICAgICAgICA3LAogICAgICAgIDgsCiAgICAgICAgOSwKICAgICAgICAxMCwKICAgICAgICAxMSwKICAgICAgICAxMywKICAgICAgICAxNSwKICAgICAgICAxNywKICAgICAgICAxOSwKICAgICAgICAyMywKICAgICAgICAyNywKICAgICAgICAzMSwKICAgICAgICAzNSwKICAgICAgICA0MywKICAgICAgICA1MSwKICAgICAgICA1OSwKICAgICAgICA2NywKICAgICAgICA4MywKICAgICAgICA5OSwKICAgICAgICAxMTUsCiAgICAgICAgMTMxLAogICAgICAgIDE2MywKICAgICAgICAxOTUsCiAgICAgICAgMjI3LAogICAgICAgIDI1OCwKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGxleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMTYsCiAgICAgICAgNzIsCiAgICAgICAgNzgKICAgICAgXTsKICAgICAgdmFyIGRiYXNlID0gWwogICAgICAgIDEsCiAgICAgICAgMiwKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA3LAogICAgICAgIDksCiAgICAgICAgMTMsCiAgICAgICAgMTcsCiAgICAgICAgMjUsCiAgICAgICAgMzMsCiAgICAgICAgNDksCiAgICAgICAgNjUsCiAgICAgICAgOTcsCiAgICAgICAgMTI5LAogICAgICAgIDE5MywKICAgICAgICAyNTcsCiAgICAgICAgMzg1LAogICAgICAgIDUxMywKICAgICAgICA3NjksCiAgICAgICAgMTAyNSwKICAgICAgICAxNTM3LAogICAgICAgIDIwNDksCiAgICAgICAgMzA3MywKICAgICAgICA0MDk3LAogICAgICAgIDYxNDUsCiAgICAgICAgODE5MywKICAgICAgICAxMjI4OSwKICAgICAgICAxNjM4NSwKICAgICAgICAyNDU3NywKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGRleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjIsCiAgICAgICAgMjIsCiAgICAgICAgMjMsCiAgICAgICAgMjMsCiAgICAgICAgMjQsCiAgICAgICAgMjQsCiAgICAgICAgMjUsCiAgICAgICAgMjUsCiAgICAgICAgMjYsCiAgICAgICAgMjYsCiAgICAgICAgMjcsCiAgICAgICAgMjcsCiAgICAgICAgMjgsCiAgICAgICAgMjgsCiAgICAgICAgMjksCiAgICAgICAgMjksCiAgICAgICAgNjQsCiAgICAgICAgNjQKICAgICAgXTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdCA9IDA7CiAgICAgICAgdmFyIGN1cnIgPSAwOwogICAgICAgIHZhciBkcm9wID0gMDsKICAgICAgICB2YXIgbGVmdCA9IDA7CiAgICAgICAgdmFyIHVzZWQgPSAwOwogICAgICAgIHZhciBodWZmID0gMDsKICAgICAgICB2YXIgaW5jcjsKICAgICAgICB2YXIgZmlsbDsKICAgICAgICB2YXIgbG93OwogICAgICAgIHZhciBtYXNrOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBiYXNlID0gbnVsbDsKICAgICAgICB2YXIgYmFzZV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOwogICAgICAgIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgZXh0cmEgPSBudWxsOwogICAgICAgIHZhciBleHRyYV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGNvdW50W2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICAgICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKzsKICAgICAgICB9CiAgICAgICAgcm9vdCA9IGJpdHM7CiAgICAgICAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHsKICAgICAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdCA+IG1heCkgewogICAgICAgICAgcm9vdCA9IG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKG1heCA9PT0gMCkgewogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgb3B0cy5iaXRzID0gMTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHsKICAgICAgICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdCA8IG1pbikgewogICAgICAgICAgcm9vdCA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3Q7CiAgICAgICAgZHJvcCA9IDA7CiAgICAgICAgbG93ID0gLTE7CiAgICAgICAgdXNlZCA9IDEgPDwgcm9vdDsKICAgICAgICBtYXNrID0gdXNlZCAtIDE7CiAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7CiAgICAgICAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAwOwogICAgICAgICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTsKICAgICAgICAgIH0gZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAzMiArIDY0OwogICAgICAgICAgICBoZXJlX3ZhbCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSBkcm9wOwogICAgICAgICAgZmlsbCA9IDEgPDwgY3VycjsKICAgICAgICAgIG1pbiA9IGZpbGw7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGZpbGwgLT0gaW5jcjsKICAgICAgICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSBoZXJlX2JpdHMgPDwgMjQgfCBoZXJlX29wIDw8IDE2IHwgaGVyZV92YWwgfCAwOwogICAgICAgICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSAxOwogICAgICAgICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7CiAgICAgICAgICAgIGluY3IgPj49IDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5jciAhPT0gMCkgewogICAgICAgICAgICBodWZmICY9IGluY3IgLSAxOwogICAgICAgICAgICBodWZmICs9IGluY3I7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBodWZmID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHN5bSsrOwogICAgICAgICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkgewogICAgICAgICAgICBpZiAobGVuID09PSBtYXgpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbmV4dCArPSBtaW47CiAgICAgICAgICAgIGN1cnIgPSBsZW4gLSBkcm9wOwogICAgICAgICAgICBsZWZ0ID0gMSA8PCBjdXJyOwogICAgICAgICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHsKICAgICAgICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTsKICAgICAgICAgICAgICBpZiAobGVmdCA8PSAwKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY3VycisrOwogICAgICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdXNlZCArPSAxIDw8IGN1cnI7CiAgICAgICAgICAgIGlmICh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUyB8fCB0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSB7CiAgICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbG93ID0gaHVmZiAmIG1hc2s7CiAgICAgICAgICAgIHRhYmxlW2xvd10gPSByb290IDw8IDI0IHwgY3VyciA8PCAxNiB8IG5leHQgLSB0YWJsZV9pbmRleCB8IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChodWZmICE9PSAwKSB7CiAgICAgICAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgIH0KICAgICAgICBvcHRzLmJpdHMgPSByb290OwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIyID0gcmVxdWlyZV9jcmMzMigpOwogICAgICB2YXIgaW5mbGF0ZV9mYXN0ID0gcmVxdWlyZV9pbmZmYXN0KCk7CiAgICAgIHZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZV9pbmZ0cmVlcygpOwogICAgICB2YXIgQ09ERVMgPSAwOwogICAgICB2YXIgTEVOUyA9IDE7CiAgICAgIHZhciBESVNUUyA9IDI7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX0JMT0NLID0gNTsKICAgICAgdmFyIFpfVFJFRVMgPSA2OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9ORUVEX0RJQ1QgPSAyOwogICAgICB2YXIgWl9TVFJFQU1fRVJST1IgPSAtMjsKICAgICAgdmFyIFpfREFUQV9FUlJPUiA9IC0zOwogICAgICB2YXIgWl9NRU1fRVJST1IgPSAtNDsKICAgICAgdmFyIFpfQlVGX0VSUk9SID0gLTU7CiAgICAgIHZhciBaX0RFRkxBVEVEID0gODsKICAgICAgdmFyIEhFQUQgPSAxOwogICAgICB2YXIgRkxBR1MgPSAyOwogICAgICB2YXIgVElNRSA9IDM7CiAgICAgIHZhciBPUyA9IDQ7CiAgICAgIHZhciBFWExFTiA9IDU7CiAgICAgIHZhciBFWFRSQSA9IDY7CiAgICAgIHZhciBOQU1FID0gNzsKICAgICAgdmFyIENPTU1FTlQgPSA4OwogICAgICB2YXIgSENSQyA9IDk7CiAgICAgIHZhciBESUNUSUQgPSAxMDsKICAgICAgdmFyIERJQ1QgPSAxMTsKICAgICAgdmFyIFRZUEUgPSAxMjsKICAgICAgdmFyIFRZUEVETyA9IDEzOwogICAgICB2YXIgU1RPUkVEID0gMTQ7CiAgICAgIHZhciBDT1BZXyA9IDE1OwogICAgICB2YXIgQ09QWSA9IDE2OwogICAgICB2YXIgVEFCTEUgPSAxNzsKICAgICAgdmFyIExFTkxFTlMgPSAxODsKICAgICAgdmFyIENPREVMRU5TID0gMTk7CiAgICAgIHZhciBMRU5fID0gMjA7CiAgICAgIHZhciBMRU4gPSAyMTsKICAgICAgdmFyIExFTkVYVCA9IDIyOwogICAgICB2YXIgRElTVCA9IDIzOwogICAgICB2YXIgRElTVEVYVCA9IDI0OwogICAgICB2YXIgTUFUQ0ggPSAyNTsKICAgICAgdmFyIExJVCA9IDI2OwogICAgICB2YXIgQ0hFQ0sgPSAyNzsKICAgICAgdmFyIExFTkdUSCA9IDI4OwogICAgICB2YXIgRE9ORSA9IDI5OwogICAgICB2YXIgQkFEID0gMzA7CiAgICAgIHZhciBNRU0gPSAzMTsKICAgICAgdmFyIFNZTkMgPSAzMjsKICAgICAgdmFyIEVOT1VHSF9MRU5TID0gODUyOwogICAgICB2YXIgRU5PVUdIX0RJU1RTID0gNTkyOwogICAgICB2YXIgTUFYX1dCSVRTID0gMTU7CiAgICAgIHZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7CiAgICAgIGZ1bmN0aW9uIHpzd2FwMzIocSkgewogICAgICAgIHJldHVybiAocSA+Pj4gMjQgJiAyNTUpICsgKHEgPj4+IDggJiA2NTI4MCkgKyAoKHEgJiA2NTI4MCkgPDwgOCkgKyAoKHEgJiAyNTUpIDw8IDI0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7CiAgICAgICAgdGhpcy5tb2RlID0gMDsKICAgICAgICB0aGlzLmxhc3QgPSBmYWxzZTsKICAgICAgICB0aGlzLndyYXAgPSAwOwogICAgICAgIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsKICAgICAgICB0aGlzLmZsYWdzID0gMDsKICAgICAgICB0aGlzLmRtYXggPSAwOwogICAgICAgIHRoaXMuY2hlY2sgPSAwOwogICAgICAgIHRoaXMudG90YWwgPSAwOwogICAgICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy53Yml0cyA9IDA7CiAgICAgICAgdGhpcy53c2l6ZSA9IDA7CiAgICAgICAgdGhpcy53aGF2ZSA9IDA7CiAgICAgICAgdGhpcy53bmV4dCA9IDA7CiAgICAgICAgdGhpcy53aW5kb3cgPSBudWxsOwogICAgICAgIHRoaXMuaG9sZCA9IDA7CiAgICAgICAgdGhpcy5iaXRzID0gMDsKICAgICAgICB0aGlzLmxlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5vZmZzZXQgPSAwOwogICAgICAgIHRoaXMuZXh0cmEgPSAwOwogICAgICAgIHRoaXMubGVuY29kZSA9IG51bGw7CiAgICAgICAgdGhpcy5kaXN0Y29kZSA9IG51bGw7CiAgICAgICAgdGhpcy5sZW5iaXRzID0gMDsKICAgICAgICB0aGlzLmRpc3RiaXRzID0gMDsKICAgICAgICB0aGlzLm5jb2RlID0gMDsKICAgICAgICB0aGlzLm5sZW4gPSAwOwogICAgICAgIHRoaXMubmRpc3QgPSAwOwogICAgICAgIHRoaXMuaGF2ZSA9IDA7CiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDsKICAgICAgICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsKICAgICAgICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsKICAgICAgICB0aGlzLmxlbmR5biA9IG51bGw7CiAgICAgICAgdGhpcy5kaXN0ZHluID0gbnVsbDsKICAgICAgICB0aGlzLnNhbmUgPSAwOwogICAgICAgIHRoaXMuYmFjayA9IDA7CiAgICAgICAgdGhpcy53YXMgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDsKICAgICAgICBzdHJtLm1zZyA9ICIiOwogICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7CiAgICAgICAgfQogICAgICAgIHN0YXRlLm1vZGUgPSBIRUFEOwogICAgICAgIHN0YXRlLmxhc3QgPSAwOwogICAgICAgIHN0YXRlLmhhdmVkaWN0ID0gMDsKICAgICAgICBzdGF0ZS5kbWF4ID0gMzI3Njg7CiAgICAgICAgc3RhdGUuaGVhZCA9IG51bGw7CiAgICAgICAgc3RhdGUuaG9sZCA9IDA7CiAgICAgICAgc3RhdGUuYml0cyA9IDA7CiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7CiAgICAgICAgc3RhdGUuc2FuZSA9IDE7CiAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RhdGUud3NpemUgPSAwOwogICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7CiAgICAgICAgdmFyIHdyYXA7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7CiAgICAgICAgICB3cmFwID0gMDsKICAgICAgICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0czsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTsKICAgICAgICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHsKICAgICAgICAgICAgd2luZG93Qml0cyAmPSAxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykgewogICAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGUud3JhcCA9IHdyYXA7CiAgICAgICAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzOwogICAgICAgIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgcmV0OwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0pIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7CiAgICAgICAgc3RybS5zdGF0ZSA9IHN0YXRlOwogICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTsKICAgICAgICBpZiAocmV0ICE9PSBaX09LKSB7CiAgICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7CiAgICAgICAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpOwogICAgICB9CiAgICAgIHZhciB2aXJnaW4gPSB0cnVlOwogICAgICB2YXIgbGVuZml4OwogICAgICB2YXIgZGlzdGZpeDsKICAgICAgZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHsKICAgICAgICBpZiAodmlyZ2luKSB7CiAgICAgICAgICB2YXIgc3ltOwogICAgICAgICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7CiAgICAgICAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTsKICAgICAgICAgIHN5bSA9IDA7CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gODsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyNTYpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA5OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI4MCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjg4KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gODsKICAgICAgICAgIH0KICAgICAgICAgIGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTsKICAgICAgICAgIHN5bSA9IDA7CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMzIpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA1OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTsKICAgICAgICAgIHZpcmdpbiA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4OwogICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwogICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDsKICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7CiAgICAgICAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7CiAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICBzdGF0ZS53aGF2ZSA9IDA7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0OwogICAgICAgICAgaWYgKGRpc3QgPiBjb3B5KSB7CiAgICAgICAgICAgIGRpc3QgPSBjb3B5OwogICAgICAgICAgfQogICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTsKICAgICAgICAgIGNvcHkgLT0gZGlzdDsKICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTsKICAgICAgICAgICAgc3RhdGUud25leHQgPSBjb3B5OwogICAgICAgICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3RhdGUud25leHQgKz0gZGlzdDsKICAgICAgICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgICAgIHN0YXRlLndoYXZlICs9IGRpc3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgaW5wdXQsIG91dHB1dDsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgcHV0OwogICAgICAgIHZhciBoYXZlLCBsZWZ0OwogICAgICAgIHZhciBob2xkOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBfaW4sIF9vdXQ7CiAgICAgICAgdmFyIGNvcHk7CiAgICAgICAgdmFyIGZyb207CiAgICAgICAgdmFyIGZyb21fc291cmNlOwogICAgICAgIHZhciBoZXJlID0gMDsKICAgICAgICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsKICAgICAgICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsKICAgICAgICB2YXIgb3B0czsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgb3JkZXIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fCAhc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgewogICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETzsKICAgICAgICB9CiAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDsKICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgX2luID0gaGF2ZTsKICAgICAgICBfb3V0ID0gbGVmdDsKICAgICAgICByZXQgPSBaX09LOwogICAgICAgIGluZl9sZWF2ZToKICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHsKICAgICAgICAgICAgICBjYXNlIEhFQUQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgJiAyICYmIGhvbGQgPT09IDM1NjE1KSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gMDsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmZsYWdzID0gMDsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICgoKGhvbGQgJiAyNTUpIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGhlYWRlciBjaGVjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgMTUpICE9PSBaX0RFRkxBVEVEKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNDsKICAgICAgICAgICAgICAgIGxlbiA9IChob2xkICYgMTUpICsgODsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCB3aW5kb3cgc2l6ZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuOwogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgNTEyID8gRElDVElEIDogVFlQRTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIEZMQUdTOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7CiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMjU1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTczNDQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSBob2xkID4+IDggJiAxOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMjIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FOwogICAgICAgICAgICAgIGNhc2UgVElNRToKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMl0gPSBob2xkID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlszXSA9IGhvbGQgPj4+IDI0ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE9TOwogICAgICAgICAgICAgIGNhc2UgT1M6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IGhvbGQgPj4gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47CiAgICAgICAgICAgICAgY2FzZSBFWExFTjoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDEwMjQpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMjIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTsKICAgICAgICAgICAgICBjYXNlIEVYVFJBOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkgewogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLmhlYWQuZXh0cmEsIGlucHV0LCBuZXh0LCBjb3B5LCBsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FOwogICAgICAgICAgICAgIGNhc2UgTkFNRToKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDIwNDgpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY29weSA9IDA7CiAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiYgc3RhdGUubGVuZ3RoIDwgNjU1MzYpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDsKICAgICAgICAgICAgICBjYXNlIENPTU1FTlQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA0MDk2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMjIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gSENSQzsKICAgICAgICAgICAgICBjYXNlIEhDUkM6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImhlYWRlciBjcmMgbWlzbWF0Y2giOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gc3RhdGUuZmxhZ3MgPj4gOSAmIDE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIERJQ1RJRDoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDsKICAgICAgICAgICAgICBjYXNlIERJQ1Q6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgY2FzZSBUWVBFOgogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIFRZUEVETzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0ID0gaG9sZCAmIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMTsKICAgICAgICAgICAgICAgIHN3aXRjaCAoaG9sZCAmIDMpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJsb2NrIHR5cGUiOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgU1RPUkVEOgogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgNjU1MzUpICE9PSAoaG9sZCA+Pj4gMTYgXiA2NTUzNSkpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDY1NTM1OwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBDT1BZXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZOwogICAgICAgICAgICAgIGNhc2UgQ09QWToKICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpOwogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBwdXQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIFRBQkxFOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAzMSkgKyAyNTc7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAzMSkgKyAxOwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMTUpICsgNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUzsKICAgICAgICAgICAgICBjYXNlIExFTkxFTlM6CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IGhvbGQgJiA3OwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSAzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNzsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgY29kZSBsZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7CiAgICAgICAgICAgICAgY2FzZSBDT0RFTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAzKTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMzsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDcpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDEyNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gNzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gNzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjsKICAgICAgICAgICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2VzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgTEVOXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgY2FzZSBMRU46CiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpOwogICAgICAgICAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgICAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgICAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICAgICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IDA7CiAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDI0MCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUOwogICAgICAgICAgICAgIGNhc2UgTEVORVhUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgxIDw8IHN0YXRlLmV4dHJhKSAtIDE7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNUOwogICAgICAgICAgICAgIGNhc2UgRElTVDoKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDsKICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDsKICAgICAgICAgICAgICBjYXNlIE1BVENIOgogICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5OwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IGxlZnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBMSVQ6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgbGVmdC0tOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgQ0hFQ0s6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0IC09IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIGlmIChfb3V0KSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMjIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBkYXRhIGNoZWNrIjsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7CiAgICAgICAgICAgICAgY2FzZSBMRU5HVEg6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgNDI5NDk2NzI5NSkpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrIjsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBET05FOwogICAgICAgICAgICAgIGNhc2UgRE9ORToKICAgICAgICAgICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDsKICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICBjYXNlIEJBRDoKICAgICAgICAgICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjsKICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICBjYXNlIE1FTToKICAgICAgICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICAgICAgICBjYXNlIFNZTkM6CiAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgaWYgKHN0YXRlLndzaXplIHx8IF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiYgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7CiAgICAgICAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNRU07CiAgICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgX2luIC09IHN0cm0uYXZhaWxfaW47CiAgICAgICAgX291dCAtPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBzdHJtLnRvdGFsX2luICs9IF9pbjsKICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0OwogICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkgewogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMjIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCk7CiAgICAgICAgfQogICAgICAgIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApOwogICAgICAgIGlmICgoX2luID09PSAwICYmIF9vdXQgPT09IDAgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHsKICAgICAgICAgIHJldCA9IFpfQlVGX0VSUk9SOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhlYWQgPSBoZWFkOwogICAgICAgIGhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgZGljdGlkOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7CiAgICAgICAgICBkaWN0aWQgPSAxOwogICAgICAgICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpOwogICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBNRU07CiAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhhdmVkaWN0ID0gMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDsKICAgICAgZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjsKICAgICAgZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0OwogICAgICBleHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjsKICAgICAgZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDsKICAgICAgZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjsKICAgICAgZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzLmluZmxhdGVJbmZvID0gInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMKICB2YXIgcmVxdWlyZV9jb25zdGFudHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgWl9OT19GTFVTSDogMCwKICAgICAgICBaX1BBUlRJQUxfRkxVU0g6IDEsCiAgICAgICAgWl9TWU5DX0ZMVVNIOiAyLAogICAgICAgIFpfRlVMTF9GTFVTSDogMywKICAgICAgICBaX0ZJTklTSDogNCwKICAgICAgICBaX0JMT0NLOiA1LAogICAgICAgIFpfVFJFRVM6IDYsCiAgICAgICAgWl9PSzogMCwKICAgICAgICBaX1NUUkVBTV9FTkQ6IDEsCiAgICAgICAgWl9ORUVEX0RJQ1Q6IDIsCiAgICAgICAgWl9FUlJOTzogLTEsCiAgICAgICAgWl9TVFJFQU1fRVJST1I6IC0yLAogICAgICAgIFpfREFUQV9FUlJPUjogLTMsCiAgICAgICAgWl9CVUZfRVJST1I6IC01LAogICAgICAgIFpfTk9fQ09NUFJFU1NJT046IDAsCiAgICAgICAgWl9CRVNUX1NQRUVEOiAxLAogICAgICAgIFpfQkVTVF9DT01QUkVTU0lPTjogOSwKICAgICAgICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IC0xLAogICAgICAgIFpfRklMVEVSRUQ6IDEsCiAgICAgICAgWl9IVUZGTUFOX09OTFk6IDIsCiAgICAgICAgWl9STEU6IDMsCiAgICAgICAgWl9GSVhFRDogNCwKICAgICAgICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsCiAgICAgICAgWl9CSU5BUlk6IDAsCiAgICAgICAgWl9URVhUOiAxLAogICAgICAgIFpfVU5LTk9XTjogMiwKICAgICAgICBaX0RFRkxBVEVEOiA4CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzCiAgdmFyIHJlcXVpcmVfZ3poZWFkZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBHWmhlYWRlcigpIHsKICAgICAgICB0aGlzLnRleHQgPSAwOwogICAgICAgIHRoaXMudGltZSA9IDA7CiAgICAgICAgdGhpcy54ZmxhZ3MgPSAwOwogICAgICAgIHRoaXMub3MgPSAwOwogICAgICAgIHRoaXMuZXh0cmEgPSBudWxsOwogICAgICAgIHRoaXMuZXh0cmFfbGVuID0gMDsKICAgICAgICB0aGlzLm5hbWUgPSAiIjsKICAgICAgICB0aGlzLmNvbW1lbnQgPSAiIjsKICAgICAgICB0aGlzLmhjcmMgPSAwOwogICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmVfaW5mbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgdmFyIHN0cmluZ3MgPSByZXF1aXJlX3N0cmluZ3MoKTsKICAgICAgdmFyIGMgPSByZXF1aXJlX2NvbnN0YW50cygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlczIoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIEdaaGVhZGVyID0gcmVxdWlyZV9nemhlYWRlcigpOwogICAgICB2YXIgdG9TdHJpbmcyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgZnVuY3Rpb24gSW5mbGF0ZTIob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlMikpCiAgICAgICAgICByZXR1cm4gbmV3IEluZmxhdGUyKG9wdGlvbnMpOwogICAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7CiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMCwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC0xNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID49IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNiAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQud2luZG93Qml0cyA+IDE1ICYmIG9wdC53aW5kb3dCaXRzIDwgNDgpIHsKICAgICAgICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHsKICAgICAgICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQud2luZG93Qml0cyk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpOwogICAgICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpOwogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZzIuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAob3B0LnJhdykgewogICAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7CiAgICAgICAgdmFyIHN0cm0gPSB0aGlzLnN0cm07CiAgICAgICAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7CiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTsKICAgICAgICB2YXIgc3RhdHVzLCBfbW9kZTsKICAgICAgICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjsKICAgICAgICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIOwogICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7CiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZzIuY2FsbChkYXRhKSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gZGF0YTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CiAgICAgICAgZG8gewogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTsKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IDA7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsKICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkgewogICAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkgewogICAgICAgICAgICBzdGF0dXMgPSBjLlpfT0s7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLm5leHRfb3V0KSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpIHsKICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7CiAgICAgICAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7CiAgICAgICAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTsKICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsOwogICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsOwogICAgICAgICAgICAgICAgaWYgKHRhaWwpIHsKICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHsKICAgICAgICAgIF9tb2RlID0gYy5aX0ZJTklTSDsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHsKICAgICAgICAgIHRoaXMub25FbmQoYy5aX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGNodW5rKSB7CiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgICAgIH07CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9PSykgewogICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCIiKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5lcnIgPSBzdGF0dXM7CiAgICAgICAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogICAgICB9OwogICAgICBmdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUyKG9wdGlvbnMpOwogICAgICAgIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBleHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlMjsKICAgICAgZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdzsKICAgICAgZXhwb3J0cy51bmd6aXAgPSBpbmZsYXRlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcwogIHZhciByZXF1aXJlX3Bha28gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYXNzaWduID0gcmVxdWlyZV9jb21tb24yKCkuYXNzaWduOwogICAgICB2YXIgZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZTIoKTsKICAgICAgdmFyIGluZmxhdGUgPSByZXF1aXJlX2luZmxhdGUyKCk7CiAgICAgIHZhciBjb25zdGFudHMgPSByZXF1aXJlX2NvbnN0YW50cygpOwogICAgICB2YXIgcGFrbyA9IHt9OwogICAgICBhc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYWtvOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2xvY2FsRmlsZQogIHZhciByZXF1aXJlX2xvY2FsRmlsZSA9IF9fY29tbW9uSlMoewogICAgIihkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vbG9jYWxGaWxlIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYnVmZmVyLWNyYzMyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYnVmZmVyX2NyYzMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2J1ZmZlci1jcmMzMi9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIEJ1ZmZlcjUgPSByZXF1aXJlX2J1ZmZlcigpLkJ1ZmZlcjsKICAgICAgdmFyIENSQ19UQUJMRSA9IFsKICAgICAgICAwLAogICAgICAgIDE5OTY5NTk4OTQsCiAgICAgICAgMzk5MzkxOTc4OCwKICAgICAgICAyNTY3NTI0Nzk0LAogICAgICAgIDEyNDYzNDEzNywKICAgICAgICAxODg2MDU3NjE1LAogICAgICAgIDM5MTU2MjE2ODUsCiAgICAgICAgMjY1NzM5MjAzNSwKICAgICAgICAyNDkyNjgyNzQsCiAgICAgICAgMjA0NDUwODMyNCwKICAgICAgICAzNzcyMTE1MjMwLAogICAgICAgIDI1NDcxNzc4NjQsCiAgICAgICAgMTYyOTQxOTk1LAogICAgICAgIDIxMjU1NjEwMjEsCiAgICAgICAgMzg4NzYwNzA0NywKICAgICAgICAyNDI4NDQ0MDQ5LAogICAgICAgIDQ5ODUzNjU0OCwKICAgICAgICAxNzg5OTI3NjY2LAogICAgICAgIDQwODkwMTY2NDgsCiAgICAgICAgMjIyNzA2MTIxNCwKICAgICAgICA0NTA1NDg4NjEsCiAgICAgICAgMTg0MzI1ODYwMywKICAgICAgICA0MTA3NTgwNzUzLAogICAgICAgIDIyMTE2Nzc2MzksCiAgICAgICAgMzI1ODgzOTkwLAogICAgICAgIDE2ODQ3NzcxNTIsCiAgICAgICAgNDI1MTEyMjA0MiwKICAgICAgICAyMzIxOTI2NjM2LAogICAgICAgIDMzNTYzMzQ4NywKICAgICAgICAxNjYxMzY1NDY1LAogICAgICAgIDQxOTUzMDI3NTUsCiAgICAgICAgMjM2NjExNTMxNywKICAgICAgICA5OTcwNzMwOTYsCiAgICAgICAgMTI4MTk1Mzg4NiwKICAgICAgICAzNTc5ODU1MzMyLAogICAgICAgIDI3MjQ2ODgyNDIsCiAgICAgICAgMTAwNjg4ODE0NSwKICAgICAgICAxMjU4NjA3Njg3LAogICAgICAgIDM1MjQxMDE2MjksCiAgICAgICAgMjc2ODk0MjQ0MywKICAgICAgICA5MDEwOTc3MjIsCiAgICAgICAgMTExOTAwMDY4NCwKICAgICAgICAzNjg2NTE3MjA2LAogICAgICAgIDI4OTgwNjU3MjgsCiAgICAgICAgODUzMDQ0NDUxLAogICAgICAgIDExNzIyNjYxMDEsCiAgICAgICAgMzcwNTAxNTc1OSwKICAgICAgICAyODgyNjE2NjY1LAogICAgICAgIDY1MTc2Nzk4MCwKICAgICAgICAxMzczNTAzNTQ2LAogICAgICAgIDMzNjk1NTQzMDQsCiAgICAgICAgMzIxODEwNDU5OCwKICAgICAgICA1NjU1MDcyNTMsCiAgICAgICAgMTQ1NDYyMTczMSwKICAgICAgICAzNDg1MTExNzA1LAogICAgICAgIDMwOTk0MzYzMDMsCiAgICAgICAgNjcxMjY2OTc0LAogICAgICAgIDE1OTQxOTgwMjQsCiAgICAgICAgMzMyMjczMDkzMCwKICAgICAgICAyOTcwMzQ3ODEyLAogICAgICAgIDc5NTgzNTUyNywKICAgICAgICAxNDgzMjMwMjI1LAogICAgICAgIDMyNDQzNjcyNzUsCiAgICAgICAgMzA2MDE0OTU2NSwKICAgICAgICAxOTk0MTQ2MTkyLAogICAgICAgIDMxMTU4NTM0LAogICAgICAgIDI1NjM5MDc3NzIsCiAgICAgICAgNDAyMzcxNzkzMCwKICAgICAgICAxOTA3NDU5NDY1LAogICAgICAgIDExMjYzNzIxNSwKICAgICAgICAyNjgwMTUzMjUzLAogICAgICAgIDM5MDQ0MjcwNTksCiAgICAgICAgMjAxMzc3NjI5MCwKICAgICAgICAyNTE3MjIwMzYsCiAgICAgICAgMjUxNzIxNTM3NCwKICAgICAgICAzNzc1ODMwMDQwLAogICAgICAgIDIxMzc2NTY3NjMsCiAgICAgICAgMTQxMzc2ODEzLAogICAgICAgIDI0MzkyNzc3MTksCiAgICAgICAgMzg2NTI3MTI5NywKICAgICAgICAxODAyMTk1NDQ0LAogICAgICAgIDQ3Njg2NDg2NiwKICAgICAgICAyMjM4MDAxMzY4LAogICAgICAgIDQwNjY1MDg4NzgsCiAgICAgICAgMTgxMjM3MDkyNSwKICAgICAgICA0NTMwOTI3MzEsCiAgICAgICAgMjE4MTYyNTAyNSwKICAgICAgICA0MTExNDUxMjIzLAogICAgICAgIDE3MDYwODg5MDIsCiAgICAgICAgMzE0MDQyNzA0LAogICAgICAgIDIzNDQ1MzIyMDIsCiAgICAgICAgNDI0MDAxNzUzMiwKICAgICAgICAxNjU4NjU4MjcxLAogICAgICAgIDM2NjYxOTk3NywKICAgICAgICAyMzYyNjcwMzIzLAogICAgICAgIDQyMjQ5OTQ0MDUsCiAgICAgICAgMTMwMzUzNTk2MCwKICAgICAgICA5ODQ5NjE0ODYsCiAgICAgICAgMjc0NzAwNzA5MiwKICAgICAgICAzNTY5MDM3NTM4LAogICAgICAgIDEyNTYxNzA4MTcsCiAgICAgICAgMTAzNzYwNDMxMSwKICAgICAgICAyNzY1MjEwNzMzLAogICAgICAgIDM1NTQwNzk5OTUsCiAgICAgICAgMTEzMTAxNDUwNiwKICAgICAgICA4Nzk2Nzk5OTYsCiAgICAgICAgMjkwOTI0MzQ2MiwKICAgICAgICAzNjYzNzcxODU2LAogICAgICAgIDExNDExMjQ0NjcsCiAgICAgICAgODU1ODQyMjc3LAogICAgICAgIDI4NTI4MDE2MzEsCiAgICAgICAgMzcwODY0ODY0OSwKICAgICAgICAxMzQyNTMzOTQ4LAogICAgICAgIDY1NDQ1OTMwNiwKICAgICAgICAzMTg4Mzk2MDQ4LAogICAgICAgIDMzNzMwMTUxNzQsCiAgICAgICAgMTQ2NjQ3OTkwOSwKICAgICAgICA1NDQxNzk2MzUsCiAgICAgICAgMzExMDUyMzkxMywKICAgICAgICAzNDYyNTIyMDE1LAogICAgICAgIDE1OTE2NzEwNTQsCiAgICAgICAgNzAyMTM4Nzc2LAogICAgICAgIDI5NjY0NjA0NTAsCiAgICAgICAgMzM1Mjc5OTQxMiwKICAgICAgICAxNTA0OTE4ODA3LAogICAgICAgIDc4MzU1MTg3MywKICAgICAgICAzMDgyNjQwNDQzLAogICAgICAgIDMyMzM0NDI5ODksCiAgICAgICAgMzk4ODI5MjM4NCwKICAgICAgICAyNTk2MjU0NjQ2LAogICAgICAgIDYyMzE3MDY4LAogICAgICAgIDE5NTc4MTA4NDIsCiAgICAgICAgMzkzOTg0NTk0NSwKICAgICAgICAyNjQ3ODE2MTExLAogICAgICAgIDgxNDcwOTk3LAogICAgICAgIDE5NDM4MDM1MjMsCiAgICAgICAgMzgxNDkxODkzMCwKICAgICAgICAyNDg5NTk2ODA0LAogICAgICAgIDIyNTI3NDQzMCwKICAgICAgICAyMDUzNzkwMzc2LAogICAgICAgIDM4MjYxNzU3NTUsCiAgICAgICAgMjQ2NjkwNjAxMywKICAgICAgICAxNjc4MTY3NDMsCiAgICAgICAgMjA5NzY1MTM3NywKICAgICAgICA0MDI3NTUyNTgwLAogICAgICAgIDIyNjU0OTAzODYsCiAgICAgICAgNTAzNDQ0MDcyLAogICAgICAgIDE3NjIwNTA4MTQsCiAgICAgICAgNDE1MDQxNzI0NSwKICAgICAgICAyMTU0MTI5MzU1LAogICAgICAgIDQyNjUyMjIyNSwKICAgICAgICAxODUyNTA3ODc5LAogICAgICAgIDQyNzUzMTM1MjYsCiAgICAgICAgMjMxMjMxNzkyMCwKICAgICAgICAyODI3NTM2MjYsCiAgICAgICAgMTc0MjU1NTg1MiwKICAgICAgICA0MTg5NzA4MTQzLAogICAgICAgIDIzOTQ4Nzc5NDUsCiAgICAgICAgMzk3OTE3NzYzLAogICAgICAgIDE2MjIxODM2MzcsCiAgICAgICAgMzYwNDM5MDg4OCwKICAgICAgICAyNzE0ODY2NTU4LAogICAgICAgIDk1MzcyOTczMiwKICAgICAgICAxMzQwMDc2NjI2LAogICAgICAgIDM1MTg3MTk5ODUsCiAgICAgICAgMjc5NzM2MDk5OSwKICAgICAgICAxMDY4ODI4MzgxLAogICAgICAgIDEyMTk2Mzg4NTksCiAgICAgICAgMzYyNDc0MTg1MCwKICAgICAgICAyOTM2Njc1MTQ4LAogICAgICAgIDkwNjE4NTQ2MiwKICAgICAgICAxMDkwODEyNTEyLAogICAgICAgIDM3NDc2NzIwMDMsCiAgICAgICAgMjgyNTM3OTY2OSwKICAgICAgICA4MjkzMjkxMzUsCiAgICAgICAgMTE4MTMzNTE2MSwKICAgICAgICAzNDEyMTc3ODA0LAogICAgICAgIDMxNjA4MzQ4NDIsCiAgICAgICAgNjI4MDg1NDA4LAogICAgICAgIDEzODI2MDUzNjYsCiAgICAgICAgMzQyMzM2OTEwOSwKICAgICAgICAzMTM4MDc4NDY3LAogICAgICAgIDU3MDU2MjIzMywKICAgICAgICAxNDI2NDAwODE1LAogICAgICAgIDMzMTczMTY1NDIsCiAgICAgICAgMjk5ODczMzYwOCwKICAgICAgICA3MzMyMzk5NTQsCiAgICAgICAgMTU1NTI2MTk1NiwKICAgICAgICAzMjY4OTM1NTkxLAogICAgICAgIDMwNTAzNjA2MjUsCiAgICAgICAgNzUyNDU5NDAzLAogICAgICAgIDE1NDEzMjAyMjEsCiAgICAgICAgMjYwNzA3MTkyMCwKICAgICAgICAzOTY1OTczMDMwLAogICAgICAgIDE5Njk5MjI5NzIsCiAgICAgICAgNDA3MzU0OTgsCiAgICAgICAgMjYxNzgzNzIyNSwKICAgICAgICAzOTQzNTc3MTUxLAogICAgICAgIDE5MTMwODc4NzcsCiAgICAgICAgODM5MDgzNzEsCiAgICAgICAgMjUxMjM0MTYzNCwKICAgICAgICAzODAzNzQwNjkyLAogICAgICAgIDIwNzUyMDg2MjIsCiAgICAgICAgMjEzMjYxMTEyLAogICAgICAgIDI0NjMyNzI2MDMsCiAgICAgICAgMzg1NTk5MDI4NSwKICAgICAgICAyMDk0ODU0MDcxLAogICAgICAgIDE5ODk1ODg4MSwKICAgICAgICAyMjYyMDI5MDEyLAogICAgICAgIDQwNTcyNjA2MTAsCiAgICAgICAgMTc1OTM1OTk5MiwKICAgICAgICA1MzQ0MTQxOTAsCiAgICAgICAgMjE3NjcxODU0MSwKICAgICAgICA0MTM5MzI5MTE1LAogICAgICAgIDE4NzM4MzYwMDEsCiAgICAgICAgNDE0NjY0NTY3LAogICAgICAgIDIyODIyNDg5MzQsCiAgICAgICAgNDI3OTIwMDM2OCwKICAgICAgICAxNzExNjg0NTU0LAogICAgICAgIDI4NTI4MTExNiwKICAgICAgICAyNDA1ODAxNzI3LAogICAgICAgIDQxNjcyMTY3NDUsCiAgICAgICAgMTYzNDQ2Nzc5NSwKICAgICAgICAzNzYyMjk3MDEsCiAgICAgICAgMjY4NTA2Nzg5NiwKICAgICAgICAzNjA4MDA3NDA2LAogICAgICAgIDEzMDg5MTg2MTIsCiAgICAgICAgOTU2NTQzOTM4LAogICAgICAgIDI4MDg1NTUxMDUsCiAgICAgICAgMzQ5NTk1ODI2MywKICAgICAgICAxMjMxNjM2MzAxLAogICAgICAgIDEwNDc0MjcwMzUsCiAgICAgICAgMjkzMjk1OTgxOCwKICAgICAgICAzNjU0NzAzODM2LAogICAgICAgIDEwODgzNTkyNzAsCiAgICAgICAgOTM2OTE4ZTMsCiAgICAgICAgMjg0NzcxNDg5OSwKICAgICAgICAzNzM2ODM3ODI5LAogICAgICAgIDEyMDI5MDA4NjMsCiAgICAgICAgODE3MjMzODk3LAogICAgICAgIDMxODMzNDIxMDgsCiAgICAgICAgMzQwMTIzNzEzMCwKICAgICAgICAxNDA0Mjc3NTUyLAogICAgICAgIDYxNTgxODE1MCwKICAgICAgICAzMTM0MjA3NDkzLAogICAgICAgIDM0NTM0MjEyMDMsCiAgICAgICAgMTQyMzg1NzQ0OSwKICAgICAgICA2MDE0NTA0MzEsCiAgICAgICAgMzAwOTgzNzYxNCwKICAgICAgICAzMjk0NzEwNDU2LAogICAgICAgIDE1NjcxMDM3NDYsCiAgICAgICAgNzExOTI4NzI0LAogICAgICAgIDMwMjA2Njg0NzEsCiAgICAgICAgMzI3MjM4MDA2NSwKICAgICAgICAxNTEwMzM0MjM1LAogICAgICAgIDc1NTE2NzExNwogICAgICBdOwogICAgICBpZiAodHlwZW9mIEludDMyQXJyYXkgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgQ1JDX1RBQkxFID0gbmV3IEludDMyQXJyYXkoQ1JDX1RBQkxFKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbnN1cmVCdWZmZXIoaW5wdXQpIHsKICAgICAgICBpZiAoQnVmZmVyNS5pc0J1ZmZlcihpbnB1dCkpIHsKICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICB9CiAgICAgICAgdmFyIGhhc05ld0J1ZmZlckFQSSA9IHR5cGVvZiBCdWZmZXI1LmFsbG9jID09PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBCdWZmZXI1LmZyb20gPT09ICJmdW5jdGlvbiI7CiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHJldHVybiBoYXNOZXdCdWZmZXJBUEkgPyBCdWZmZXI1LmFsbG9jKGlucHV0KSA6IG5ldyBCdWZmZXI1KGlucHV0KTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHJldHVybiBoYXNOZXdCdWZmZXJBUEkgPyBCdWZmZXI1LmZyb20oaW5wdXQpIDogbmV3IEJ1ZmZlcjUoaW5wdXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImlucHV0IG11c3QgYmUgYnVmZmVyLCBudW1iZXIsIG9yIHN0cmluZywgcmVjZWl2ZWQgIiArIHR5cGVvZiBpbnB1dCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1ZmZlcml6ZUludChudW0pIHsKICAgICAgICB2YXIgdG1wID0gZW5zdXJlQnVmZmVyKDQpOwogICAgICAgIHRtcC53cml0ZUludDMyQkUobnVtLCAwKTsKICAgICAgICByZXR1cm4gdG1wOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmMzMihidWYsIHByZXZpb3VzKSB7CiAgICAgICAgYnVmID0gZW5zdXJlQnVmZmVyKGJ1Zik7CiAgICAgICAgaWYgKEJ1ZmZlcjUuaXNCdWZmZXIocHJldmlvdXMpKSB7CiAgICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnJlYWRVSW50MzJCRSgwKTsKICAgICAgICB9CiAgICAgICAgdmFyIGNyYyA9IH5+cHJldmlvdXMgXiAtMTsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGJ1Zi5sZW5ndGg7IG4rKykgewogICAgICAgICAgY3JjID0gQ1JDX1RBQkxFWyhjcmMgXiBidWZbbl0pICYgMjU1XSBeIGNyYyA+Pj4gODsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyYyBeIC0xOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNyYzMyMigpIHsKICAgICAgICByZXR1cm4gYnVmZmVyaXplSW50KF9jcmMzMi5hcHBseShudWxsLCBhcmd1bWVudHMpKTsKICAgICAgfQogICAgICBjcmMzMjIuc2lnbmVkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIF9jcmMzMi5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICB9OwogICAgICBjcmMzMjIudW5zaWduZWQgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gX2NyYzMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgPj4+IDA7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gY3JjMzIyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMtcG9ueWZpbGwvZW50cmllcy5qcwogIHZhciByZXF1aXJlX2VudHJpZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMtcG9ueWZpbGwvZW50cmllcy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgaGFzID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOwogICAgICB9OwogICAgICB2YXIgaXNFbnVtZXJhYmxlID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHByb3ApOwogICAgICB9OwogICAgICBmdW5jdGlvbiBlbnRyaWVzMihvYmopIHsKICAgICAgICBpZiAob2JqID09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCIpOwogICAgICAgIH0KICAgICAgICB2YXIgcGFpcnMgPSBbXTsKICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7CiAgICAgICAgICBpZiAoaGFzKG9iaiwga2V5KSAmJiBpc0VudW1lcmFibGUob2JqLCBrZXkpKSB7CiAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgb2JqW2tleV1dKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhaXJzOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZW50cmllczI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9pbmRleC5qcwogIHZhciByZXF1aXJlX29iamVjdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmVudHJpZXMgPT09ICJmdW5jdGlvbiIgPyBPYmplY3QuZW50cmllcyA6IHJlcXVpcmVfZW50cmllcygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvY2pzLXBvbnlmaWxsLmpzCiAgdmFyIHJlcXVpcmVfY2pzX3BvbnlmaWxsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAidW5kZWZpbmVkIiAmJiBSZWZsZWN0LmdldCkgewogICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgInJlYXNvbiIsIHsKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbDIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcyKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRTaWduYWxdIjsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAiYWJvcnQiKSB7CiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25hYm9ydCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgdGhpcy5vbmFib3J0LmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbDIucHJvdG90eXBlKSwgImRpc3BhdGNoRXZlbnQiLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0U2lnbmFsMjsKICAgICAgfShFbWl0dGVyKTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIyKCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0Q29udHJvbGxlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJzaWduYWwiLCB7CiAgICAgICAgICAgIHZhbHVlOiBuZXcgQWJvcnRTaWduYWwoKSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydENvbnRyb2xsZXIyLCBbewogICAgICAgICAga2V5OiAiYWJvcnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHJlYXNvbikgewogICAgICAgICAgICB2YXIgZXZlbnQ7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoImFib3J0Iik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7CiAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSAiYWJvcnQiOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgiRXZlbnQiKTsKICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCJhYm9ydCIsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGV2ZW50ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAiYWJvcnQiLAogICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzaWduYWxSZWFzb24gPSByZWFzb247CiAgICAgICAgICAgIGlmIChzaWduYWxSZWFzb24gPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IERPTUV4Y2VwdGlvbigic2lnbmFsIGlzIGFib3J0ZWQgd2l0aG91dCByZWFzb24iKTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSBzaWduYWxSZWFzb247CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZzIoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydENvbnRyb2xsZXJdIjsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjI7CiAgICAgIH0oKTsKICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1N0cmluZ1RhZykgewogICAgICAgIEFib3J0Q29udHJvbGxlci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydENvbnRyb2xsZXIiOwogICAgICAgIEFib3J0U2lnbmFsLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gIkFib3J0U2lnbmFsIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmMikgewogICAgICAgIGlmIChzZWxmMi5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTD10cnVlIGlzIHNldCwgd2lsbCBmb3JjZSBpbnN0YWxsIHBvbHlmaWxsIik7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmMi5SZXF1ZXN0ID09PSAiZnVuY3Rpb24iICYmICFzZWxmMi5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgIXNlbGYyLkFib3J0Q29udHJvbGxlcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHsKICAgICAgICBpZiAodHlwZW9mIHBhdGNoVGFyZ2V0cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcGF0Y2hUYXJnZXRzID0gewogICAgICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgX3BhdGNoVGFyZ2V0cyA9IHBhdGNoVGFyZ2V0cywgZmV0Y2gyID0gX3BhdGNoVGFyZ2V0cy5mZXRjaCwgX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cy5SZXF1ZXN0LCBOYXRpdmVSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID09PSB2b2lkIDAgPyBmZXRjaDIuUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCwgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7CiAgICAgICAgaWYgKCFwb2x5ZmlsbE5lZWRlZCh7CiAgICAgICAgICBmZXRjaDogZmV0Y2gyLAogICAgICAgICAgUmVxdWVzdDogTmF0aXZlUmVxdWVzdCwKICAgICAgICAgIEFib3J0Q29udHJvbGxlcjogTmF0aXZlQWJvcnRDb250cm9sbGVyLAogICAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTAogICAgICAgIH0pKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBmZXRjaDogZmV0Y2gyLAogICAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgUmVxdWVzdCA9IE5hdGl2ZVJlcXVlc3Q7CiAgICAgICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCJzaWduYWwiKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICAgIHZhciBzaWduYWw7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBzaWduYWwgPSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0Mik7CiAgICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwgInNpZ25hbCIsIHsKICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0OwogICAgICAgICAgfTsKICAgICAgICAgIFJlcXVlc3QucHJvdG90eXBlID0gTmF0aXZlUmVxdWVzdC5wcm90b3R5cGU7CiAgICAgICAgfQogICAgICAgIHZhciByZWFsRmV0Y2ggPSBmZXRjaDI7CiAgICAgICAgdmFyIGFib3J0YWJsZUZldGNoID0gZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2gyKGlucHV0LCBpbml0MikgewogICAgICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0MiA/IGluaXQyLnNpZ25hbCA6IHZvaWQgMDsKICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgdmFyIGFib3J0RXJyb3I7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IEVycm9yKCJBYm9ydGVkIik7CiAgICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgY2FuY2VsbGF0aW9uID0gbmV3IFByb21pc2UoZnVuY3Rpb24oXywgcmVqZWN0KSB7CiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICAgIH0sIHsKICAgICAgICAgICAgICAgIG9uY2U6IHRydWUKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0MildKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZWFsRmV0Y2goaW5wdXQsIGluaXQyKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBmZXRjaDogYWJvcnRhYmxlRmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0cy5BYm9ydFNpZ25hbCA9IEFib3J0U2lnbmFsOwogICAgICBleHBvcnRzLmFib3J0YWJsZUZldGNoID0gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3I7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vYWJvcnRjb250cm9sbGVyLXBvbnlmaWxsLmpzCiAgdmFyIHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuQWJvcnRTaWduYWwgPSBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IHZvaWQgMDsKICAgICAgdmFyIGNqc19wb255ZmlsbF8xID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBzZWxmOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3c7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIGdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QiKTsKICAgICAgfTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gdHlwZW9mIGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlciA9PT0gInVuZGVmaW5lZCIgPyBjanNfcG9ueWZpbGxfMS5BYm9ydFNpZ25hbCA6IGdldEdsb2JhbCgpLkFib3J0U2lnbmFsOwogICAgICBleHBvcnRzLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlQWJvcnRDb250cm9sbGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMSA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBOdWxsU2lnbmFsID0gY2xhc3MgewogICAgICB9OwogICAgICB2YXIgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgdGhpcy5zaWduYWxzID0gbmV3IFNldCgpOwogICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyKCk7CiAgICAgICAgfQogICAgICAgIGFkZFNpZ25hbChzaWduYWwgPSBuZXcgTnVsbFNpZ25hbCgpKSB7CiAgICAgICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBhZGQgYSBzaWduYWwsIGFscmVhZHkgYWJvcnRlZCEiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuc2lnbmFscy5hZGQoc2lnbmFsKTsKICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICB0aGlzLmhhbmRsZUFib3J0ZWQoc2lnbmFsKTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFib3J0ZWQoc2lnbmFsKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGhhbmRsZUFib3J0ZWQoc2lnbmFsKSB7CiAgICAgICAgICB0aGlzLnNpZ25hbHMuZGVsZXRlKHNpZ25hbCk7CiAgICAgICAgICBpZiAodGhpcy5zaWduYWxzLnNpemUgPT09IDApIHsKICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpZ25hbCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWw7CiAgICAgICAgfQogICAgICAgIGFib3J0KCkgewogICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgU2V0KCk7CiAgICAgICAgfQogICAgICAgIGFkZENhbGxiYWNrKGNhbGxiYWNrID0gKCkgPT4gewogICAgICAgIH0pIHsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7CiAgICAgICAgICBjYWxsYmFjayh0aGlzLmN1cnJlbnRNZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSkgewogICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2U7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKChlbHQpID0+IHsKICAgICAgICAgICAgZWx0KG1lc3NhZ2UpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BYm9ydGFibGVQcm9taXNlQ2FjaGUuanMKICB2YXIgcmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyKCkpOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNhY2hlIH0pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBmaWxsIGZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWNoZSBtdXN0IGltcGxlbWVudCBnZXQoa2V5KSwgc2V0KGtleSwgdmFsKSwgYW5kIGFuZCBkZWxldGUoa2V5KSIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlOwogICAgICAgICAgdGhpcy5maWxsQ2FsbGJhY2sgPSBmaWxsOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfQogICAgICAgIGV2aWN0KGtleSwgZW50cnkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmdldChrZXkpID09PSBlbnRyeSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmaWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgY29uc3QgYWJvcnRlciA9IG5ldyBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBjb25zdCBzdGF0dXNSZXBvcnRlciA9IG5ldyBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcl8xLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gewogICAgICAgICAgICBhYm9ydGVyLAogICAgICAgICAgICBwcm9taXNlOiB0aGlzLmZpbGxDYWxsYmFjayhkYXRhLCBhYm9ydGVyLnNpZ25hbCwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgaWYgKCFuZXdFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oKCkgPT4gewogICAgICAgICAgICBuZXdFbnRyeS5zZXR0bGVkID0gdHJ1ZTsKICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIG5ld0VudHJ5KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGNoZWNrU2luZ2xlUHJvbWlzZShwcm9taXNlLCBzaWduYWwpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yU2luZ2xlQWJvcnQoKSB7CiAgICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiYWJvcnRlZCIpLCB7IGNvZGU6ICJFUlJfQUJPUlRFRCIgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gewogICAgICAgICAgICBjaGVja0ZvclNpbmdsZUFib3J0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9LCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgaWYgKCFzaWduYWwgJiYgZGF0YSBpbnN0YW5jZW9mIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0U2lnbmFsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInNlY29uZCBnZXQgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhbiBBYm9ydFNpZ25hbCwgcGVyaGFwcyB5b3UgbWVhbnQgdG8gcGFzcyBgbnVsbGAgZm9yIHRoZSBmaWxsIGRhdGE/Iik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSB7CiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBjYWNoZUVudHJ5KTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZUVudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGNhY2hlRW50cnkuc3RhdHVzUmVwb3J0ZXIuYWRkQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5maWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVkRW50cnkpIHsKICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgY29uc3Qga2V5SXRlciA9IHRoaXMuY2FjaGUua2V5cygpOwogICAgICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMDsKICAgICAgICAgIGZvciAobGV0IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpOyAhcmVzdWx0LmRvbmU7IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICAgIGRlbGV0ZUNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVsZXRlQ291bnQ7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGUyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfZXNtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9pbmRleC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIEFib3J0YWJsZVByb21pc2VDYWNoZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWJvcnRhYmxlUHJvbWlzZUNhY2hlKCkpOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMS5kZWZhdWx0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9xdWlja19scnUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFF1aWNrTFJVMyA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgICAgIGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplOwogICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgX3NldChrZXksIHZhbHVlKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIHRoaXMuX3NpemUrKzsKICAgICAgICAgIGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkgewogICAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7CiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldChrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIGhhcyhrZXkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMub2xkQ2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIHBlZWsoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIGlmIChkZWxldGVkKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUtLTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgICprZXlzKCkgewogICAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIGtleTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKnZhbHVlcygpIHsKICAgICAgICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQgdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgICAgICBjb25zdCBba2V5XSA9IGl0ZW07CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpemUoKSB7CiAgICAgICAgICBsZXQgb2xkQ2FjaGVTaXplID0gMDsKICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIG9sZENhY2hlU2l6ZSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSArIG9sZENhY2hlU2l6ZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gUXVpY2tMUlUzOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzCiAgdmFyIHJlcXVpcmVfYnJvd3Nlcl9wb2x5ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAoZnVuY3Rpb24oc2VsZjIpIHsKICAgICAgICB2YXIgaXJyZWxldmFudCA9IGZ1bmN0aW9uKGV4cG9ydHMyKSB7CiAgICAgICAgICB2YXIgc3VwcG9ydCA9IHsKICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiAiVVJMU2VhcmNoUGFyYW1zIiBpbiBzZWxmMiwKICAgICAgICAgICAgaXRlcmFibGU6ICJTeW1ib2wiIGluIHNlbGYyICYmICJpdGVyYXRvciIgaW4gU3ltYm9sLAogICAgICAgICAgICBibG9iOiAiRmlsZVJlYWRlciIgaW4gc2VsZjIgJiYgIkJsb2IiIGluIHNlbGYyICYmIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBuZXcgQmxvYigpOwogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSgpLAogICAgICAgICAgICBmb3JtRGF0YTogIkZvcm1EYXRhIiBpbiBzZWxmMiwKICAgICAgICAgICAgYXJyYXlCdWZmZXI6ICJBcnJheUJ1ZmZlciIgaW4gc2VsZjIKICAgICAgICAgIH07CiAgICAgICAgICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikgewogICAgICAgICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iaik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikgewogICAgICAgICAgICB2YXIgdmlld0NsYXNzZXMgPSBbCiAgICAgICAgICAgICAgIltvYmplY3QgSW50OEFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgVWludDhBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgSW50MTZBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IFVpbnQxNkFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgSW50MzJBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IFVpbnQzMkFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgRmxvYXQzMkFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgRmxvYXQ2NEFycmF5XSIKICAgICAgICAgICAgXTsKICAgICAgICAgICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikgewogICAgICAgICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkgewogICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoL1teYS16MC05XC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZSIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkgewogICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAic3RyaW5nIikgewogICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykgewogICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB7CiAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpOwogICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUgPT09IHZvaWQgMCwgdmFsdWUgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7CiAgICAgICAgICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7CiAgICAgICAgICAgIHRoaXMubWFwID0ge307CiAgICAgICAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykgewogICAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgewogICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpOwogICAgICAgICAgICAgIH0sIHRoaXMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHsKICAgICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7CiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSk7CiAgICAgICAgICAgICAgfSwgdGhpcyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVycykgewogICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkgewogICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7CiAgICAgICAgICAgICAgfSwgdGhpcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7CiAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpOwogICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTsKICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07CiAgICAgICAgICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICIsICIgKyB2YWx1ZSA6IHZhbHVlOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlWyJkZWxldGUiXSA9IGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICAgICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbDsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKTsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgewogICAgICAgICAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHsKICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkgewogICAgICAgICAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgewogICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTsKICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgICAgICAgaXRlbXMucHVzaChuYW1lKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcyk7CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdOwogICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcyk7CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTsKICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcyk7CiAgICAgICAgICB9OwogICAgICAgICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHsKICAgICAgICAgICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7CiAgICAgICAgICAgIGlmIChib2R5LmJvZHlVc2VkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoIkFscmVhZHkgcmVhZCIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikgewogICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTsKICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTsKICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpOwogICAgICAgICAgICByZXR1cm4gcHJvbWlzZTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHsKICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7CiAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7CiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpOwogICAgICAgICAgICByZXR1cm4gcHJvbWlzZTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHsKICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpOwogICAgICAgICAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oIiIpOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7CiAgICAgICAgICAgIGlmIChidWYuc2xpY2UpIHsKICAgICAgICAgICAgICByZXR1cm4gYnVmLnNsaWNlKDApOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpOwogICAgICAgICAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpOwogICAgICAgICAgICAgIHJldHVybiB2aWV3LmJ1ZmZlcjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gQm9keSgpIHsKICAgICAgICAgICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlOwogICAgICAgICAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHsKICAgICAgICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7CiAgICAgICAgICAgICAgaWYgKCFib2R5KSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICIiOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCJjb250ZW50LXR5cGUiKSkgewogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCAidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Iik7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIiwgdGhpcy5fYm9keUJsb2IudHlwZSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkgewogICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCAiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgiKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHsKICAgICAgICAgICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpOwogICAgICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikgewogICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iIik7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpOwogICAgICAgICAgICAgIGlmIChyZWplY3RlZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHsKICAgICAgICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYik7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCIpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7CiAgICAgICAgICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpOwogICAgICAgICAgICB9OwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBtZXRob2RzID0gWyJERUxFVEUiLCAiR0VUIiwgIkhFQUQiLCAiT1BUSU9OUyIsICJQT1NUIiwgIlBVVCJdOwogICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkgewogICAgICAgICAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpOwogICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykgewogICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICAgICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7CiAgICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHsKICAgICAgICAgICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFscmVhZHkgcmVhZCIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0aGlzLnVybCA9IGlucHV0LnVybDsKICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7CiAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHsKICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDsKICAgICAgICAgICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlOwogICAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsOwogICAgICAgICAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkgewogICAgICAgICAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDsKICAgICAgICAgICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgInNhbWUtb3JpZ2luIjsKICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7CiAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAiR0VUIik7CiAgICAgICAgICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDsKICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDsKICAgICAgICAgICAgdGhpcy5yZWZlcnJlciA9IG51bGw7CiAgICAgICAgICAgIGlmICgodGhpcy5tZXRob2QgPT09ICJHRVQiIHx8IHRoaXMubWV0aG9kID09PSAiSEVBRCIpICYmIGJvZHkpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cyIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpOwogICAgICAgICAgfQogICAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHsgYm9keTogdGhpcy5fYm9keUluaXQgfSk7CiAgICAgICAgICB9OwogICAgICAgICAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHsKICAgICAgICAgICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTsKICAgICAgICAgICAgYm9keS50cmltKCkuc3BsaXQoIiYiKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7CiAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7CiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgiPSIpOwogICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1wrL2csICIgIik7CiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCI9IikucmVwbGFjZSgvXCsvZywgIiAiKTsKICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIGZvcm07CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykgewogICAgICAgICAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7CiAgICAgICAgICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9ccj9cbltcdCBdKy9nLCAiICIpOwogICAgICAgICAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9ccj9cbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkgewogICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoIjoiKTsKICAgICAgICAgICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7CiAgICAgICAgICAgICAgaWYgKGtleSkgewogICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbigiOiIpLnRyaW0oKTsKICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzOwogICAgICAgICAgfQogICAgICAgICAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTsKICAgICAgICAgIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7CiAgICAgICAgICAgIGlmICghb3B0aW9ucykgewogICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnR5cGUgPSAiZGVmYXVsdCI7CiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHZvaWQgMCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzOwogICAgICAgICAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwOwogICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSAic3RhdHVzVGV4dCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICJPSyI7CiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7CiAgICAgICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgIiI7CiAgICAgICAgICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTsKICAgICAgICAgIH0KICAgICAgICAgIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpOwogICAgICAgICAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHsKICAgICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLAogICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCwKICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLAogICAgICAgICAgICAgIHVybDogdGhpcy51cmwKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9OwogICAgICAgICAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAiIiB9KTsKICAgICAgICAgICAgcmVzcG9uc2UudHlwZSA9ICJlcnJvciI7CiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTsKICAgICAgICAgIH07CiAgICAgICAgICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07CiAgICAgICAgICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7CiAgICAgICAgICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW52YWxpZCBzdGF0dXMgY29kZSIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXMsIGhlYWRlcnM6IHsgbG9jYXRpb246IHVybCB9IH0pOwogICAgICAgICAgfTsKICAgICAgICAgIGV4cG9ydHMyLkRPTUV4Y2VwdGlvbiA9IHNlbGYyLkRPTUV4Y2VwdGlvbjsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIG5ldyBleHBvcnRzMi5ET01FeGNlcHRpb24oKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBleHBvcnRzMi5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7CiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOwogICAgICAgICAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpOwogICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjazsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgZXhwb3J0czIuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTsKICAgICAgICAgICAgZXhwb3J0czIuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMyLkRPTUV4Y2VwdGlvbjsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGZldGNoMihpbnB1dCwgaW5pdDIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQyKTsKICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0czIuRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwgIkFib3J0RXJyb3IiKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsKICAgICAgICAgICAgICBmdW5jdGlvbiBhYm9ydFhocigpIHsKICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsKICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLAogICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCwKICAgICAgICAgICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAiIikKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9ICJyZXNwb25zZVVSTCIgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgiWC1SZXF1ZXN0LVVSTCIpOwogICAgICAgICAgICAgICAgdmFyIGJvZHkgPSAicmVzcG9uc2UiIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7CiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQiKSk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigiTmV0d29yayByZXF1ZXN0IGZhaWxlZCIpKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4cG9ydHMyLkRPTUV4Y2VwdGlvbigiQWJvcnRlZCIsICJBYm9ydEVycm9yIikpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTsKICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gImluY2x1ZGUiKSB7CiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICJvbWl0IikgewogICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoInJlc3BvbnNlVHlwZSIgaW4geGhyICYmIHN1cHBvcnQuYmxvYikgewogICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICJibG9iIjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsKICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHsKICAgICAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgYWJvcnRYaHIpOwogICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHsKICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCJhYm9ydCIsIGFib3J0WGhyKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAidW5kZWZpbmVkIiA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgZmV0Y2gyLnBvbHlmaWxsID0gdHJ1ZTsKICAgICAgICAgIGlmICghc2VsZjIuZmV0Y2gpIHsKICAgICAgICAgICAgc2VsZjIuZmV0Y2ggPSBmZXRjaDI7CiAgICAgICAgICAgIHNlbGYyLkhlYWRlcnMgPSBIZWFkZXJzOwogICAgICAgICAgICBzZWxmMi5SZXF1ZXN0ID0gUmVxdWVzdDsKICAgICAgICAgICAgc2VsZjIuUmVzcG9uc2UgPSBSZXNwb25zZTsKICAgICAgICAgIH0KICAgICAgICAgIGV4cG9ydHMyLkhlYWRlcnMgPSBIZWFkZXJzOwogICAgICAgICAgZXhwb3J0czIuUmVxdWVzdCA9IFJlcXVlc3Q7CiAgICAgICAgICBleHBvcnRzMi5SZXNwb25zZSA9IFJlc3BvbnNlOwogICAgICAgICAgZXhwb3J0czIuZmV0Y2ggPSBmZXRjaDI7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgICAgIHJldHVybiBleHBvcnRzMjsKICAgICAgICB9KHt9KTsKICAgICAgfSkodHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IGV4cG9ydHMpOwogICAgfQogIH0pOwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iYW0vYmFtLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy93b3JrZXIubWpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfd29ya2VyID0gX190b01vZHVsZShyZXF1aXJlX3dvcmtlcigpKTsKICB2YXIgZXhwb3NlID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LmV4cG9zZTsKICB2YXIgcmVnaXN0ZXJTZXJpYWxpemVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LnJlZ2lzdGVyU2VyaWFsaXplcjsKICB2YXIgVHJhbnNmZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuVHJhbnNmZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9iYWkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nID0gX190b01vZHVsZShyZXF1aXJlX2xvbmcoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL3ZpcnR1YWxPZmZzZXQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIFZpcnR1YWxPZmZzZXQgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihibG9ja1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24pIHsKICAgICAgdGhpcy5ibG9ja1Bvc2l0aW9uID0gYmxvY2tQb3NpdGlvbjsKICAgICAgdGhpcy5kYXRhUG9zaXRpb24gPSBkYXRhUG9zaXRpb247CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIGAke3RoaXMuYmxvY2tQb3NpdGlvbn06JHt0aGlzLmRhdGFQb3NpdGlvbn1gOwogICAgfQogICAgY29tcGFyZVRvKGIpIHsKICAgICAgcmV0dXJuIHRoaXMuYmxvY2tQb3NpdGlvbiAtIGIuYmxvY2tQb3NpdGlvbiB8fCB0aGlzLmRhdGFQb3NpdGlvbiAtIGIuZGF0YVBvc2l0aW9uOwogICAgfQogICAgc3RhdGljIG1pbiguLi5hcmdzKSB7CiAgICAgIGxldCBtaW47CiAgICAgIGxldCBpID0gMDsKICAgICAgZm9yICg7ICFtaW47IGkgKz0gMSkgewogICAgICAgIG1pbiA9IGFyZ3NbaV07CiAgICAgIH0KICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKG1pbi5jb21wYXJlVG8oYXJnc1tpXSkgPiAwKSB7CiAgICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbWluOwogICAgfQogIH07CiAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCBvZmZzZXQgPSAwLCBiaWdlbmRpYW4gPSBmYWxzZSkgewogICAgaWYgKGJpZ2VuZGlhbikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoImJpZy1lbmRpYW4gdmlydHVhbCBmaWxlIG9mZnNldHMgbm90IGltcGxlbWVudGVkIik7CiAgICB9CiAgICByZXR1cm4gbmV3IFZpcnR1YWxPZmZzZXQoYnl0ZXNbb2Zmc2V0ICsgN10gKiAxMDk5NTExNjI3Nzc2ICsgYnl0ZXNbb2Zmc2V0ICsgNl0gKiA0Mjk0OTY3Mjk2ICsgYnl0ZXNbb2Zmc2V0ICsgNV0gKiAxNjc3NzIxNiArIGJ5dGVzW29mZnNldCArIDRdICogNjU1MzYgKyBieXRlc1tvZmZzZXQgKyAzXSAqIDI1NiArIGJ5dGVzW29mZnNldCArIDJdLCBieXRlc1tvZmZzZXQgKyAxXSA8PCA4IHwgYnl0ZXNbb2Zmc2V0XSk7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9jaHVuay5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgQ2h1bmsgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihtaW52LCBtYXh2LCBiaW4sIGZldGNoZWRTaXplID0gdm9pZCAwKSB7CiAgICAgIHRoaXMubWludiA9IG1pbnY7CiAgICAgIHRoaXMubWF4diA9IG1heHY7CiAgICAgIHRoaXMuYmluID0gYmluOwogICAgICB0aGlzLl9mZXRjaGVkU2l6ZSA9IGZldGNoZWRTaXplOwogICAgfQogICAgdG9VbmlxdWVTdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLm1pbnZ9Li4ke3RoaXMubWF4dn0gKGJpbiAke3RoaXMuYmlufSwgZmV0Y2hlZFNpemUgJHt0aGlzLmZldGNoZWRTaXplKCl9KWA7CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIHRoaXMudG9VbmlxdWVTdHJpbmcoKTsKICAgIH0KICAgIGNvbXBhcmVUbyhiKSB7CiAgICAgIHJldHVybiB0aGlzLm1pbnYuY29tcGFyZVRvKGIubWludikgfHwgdGhpcy5tYXh2LmNvbXBhcmVUbyhiLm1heHYpIHx8IHRoaXMuYmluIC0gYi5iaW47CiAgICB9CiAgICBmZXRjaGVkU2l6ZSgpIHsKICAgICAgaWYgKHRoaXMuX2ZldGNoZWRTaXplICE9PSB2b2lkIDApIHsKICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hlZFNpemU7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMubWF4di5ibG9ja1Bvc2l0aW9uICsgKDEgPDwgMTYpIC0gdGhpcy5taW52LmJsb2NrUG9zaXRpb247CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vaW5kZXhGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBJbmRleEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IGZpbGVoYW5kbGUsIHJlbmFtZVJlZlNlcSA9IChuKSA9PiBuIH0pIHsKICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXE7CiAgICB9CiAgICBfZmluZEZpcnN0RGF0YShkYXRhLCB2aXJ0dWFsT2Zmc2V0KSB7CiAgICAgIGNvbnN0IGN1cnJlbnRGZGwgPSBkYXRhLmZpcnN0RGF0YUxpbmU7CiAgICAgIGlmIChjdXJyZW50RmRsKSB7CiAgICAgICAgZGF0YS5maXJzdERhdGFMaW5lID0gY3VycmVudEZkbC5jb21wYXJlVG8odmlydHVhbE9mZnNldCkgPiAwID8gdmlydHVhbE9mZnNldCA6IGN1cnJlbnRGZGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGF0YS5maXJzdERhdGFMaW5lID0gdmlydHVhbE9mZnNldDsKICAgICAgfQogICAgfQogICAgYXN5bmMgcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGlmICghdGhpcy5zZXR1cFApIHsKICAgICAgICB0aGlzLnNldHVwUCA9IHRoaXMuX3BhcnNlKG9wdHMpLmNhdGNoKChlKSA9PiB7CiAgICAgICAgICB0aGlzLnNldHVwUCA9IHZvaWQgMDsKICAgICAgICAgIHRocm93IGU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuc2V0dXBQOwogICAgfQogICAgYXN5bmMgaGFzUmVmU2VxKHNlcUlkLCBvcHRzID0ge30pIHsKICAgICAgcmV0dXJuICEhKChhd2FpdCB0aGlzLnBhcnNlKG9wdHMpKS5pbmRpY2VzW3NlcUlkXSB8fCB7fSkuYmluSW5kZXg7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiB0aW1lb3V0KG1zKSB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTsKICB9CiAgZnVuY3Rpb24gbG9uZ1RvTnVtYmVyKGxvbmcpIHsKICAgIGlmIChsb25nLmdyZWF0ZXJUaGFuKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB8fCBsb25nLmxlc3NUaGFuKE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoImludGVnZXIgb3ZlcmZsb3ciKTsKICAgIH0KICAgIHJldHVybiBsb25nLnRvTnVtYmVyKCk7CiAgfQogIGZ1bmN0aW9uIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKSB7CiAgICBpZiAoIXNpZ25hbCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbigiYWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcigiYWJvcnRlZCIpOwogICAgICAgIGUuY29kZSA9ICJFUlJfQUJPUlRFRCI7CiAgICAgICAgdGhyb3cgZTsKICAgICAgfQogICAgfQogIH0KICBhc3luYyBmdW5jdGlvbiBhYm9ydEJyZWFrUG9pbnQoc2lnbmFsKSB7CiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTsKICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICB9CiAgZnVuY3Rpb24gY2FuTWVyZ2VCbG9ja3MoY2h1bmsxLCBjaHVuazIpIHsKICAgIHJldHVybiBjaHVuazIubWludi5ibG9ja1Bvc2l0aW9uIC0gY2h1bmsxLm1heHYuYmxvY2tQb3NpdGlvbiA8IDY1ZTMgJiYgY2h1bmsyLm1heHYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5taW52LmJsb2NrUG9zaXRpb24gPCA1ZTY7CiAgfQogIGZ1bmN0aW9uIG1ha2VPcHRzKG9iaiA9IHt9KSB7CiAgICByZXR1cm4gImFib3J0ZWQiIGluIG9iaiA/IHsgc2lnbmFsOiBvYmogfSA6IG9iajsKICB9CiAgZnVuY3Rpb24gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBsb3dlc3QpIHsKICAgIGNvbnN0IG1lcmdlZENodW5rcyA9IFtdOwogICAgbGV0IGxhc3RDaHVuayA9IG51bGw7CiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gY2h1bmtzOwogICAgfQogICAgY2h1bmtzLnNvcnQoKGMwLCBjMSkgPT4gewogICAgICBjb25zdCBkaWYgPSBjMC5taW52LmJsb2NrUG9zaXRpb24gLSBjMS5taW52LmJsb2NrUG9zaXRpb247CiAgICAgIGlmIChkaWYgIT09IDApIHsKICAgICAgICByZXR1cm4gZGlmOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBjMC5taW52LmRhdGFQb3NpdGlvbiAtIGMxLm1pbnYuZGF0YVBvc2l0aW9uOwogICAgICB9CiAgICB9KTsKICAgIGNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gewogICAgICBpZiAoIWxvd2VzdCB8fCBjaHVuay5tYXh2LmNvbXBhcmVUbyhsb3dlc3QpID4gMCkgewogICAgICAgIGlmIChsYXN0Q2h1bmsgPT09IG51bGwpIHsKICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoY2FuTWVyZ2VCbG9ja3MobGFzdENodW5rLCBjaHVuaykpIHsKICAgICAgICAgICAgaWYgKGNodW5rLm1heHYuY29tcGFyZVRvKGxhc3RDaHVuay5tYXh2KSA+IDApIHsKICAgICAgICAgICAgICBsYXN0Q2h1bmsubWF4diA9IGNodW5rLm1heHY7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgICAgbGFzdENodW5rID0gY2h1bms7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBtZXJnZWRDaHVua3M7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9iYWkuanMKICB2YXIgQkFJX01BR0lDID0gMjE1NzgwNTA7CiAgZnVuY3Rpb24gcm91bmREb3duKG4sIG11bHRpcGxlKSB7CiAgICByZXR1cm4gbiAtIG4gJSBtdWx0aXBsZTsKICB9CiAgZnVuY3Rpb24gcm91bmRVcChuLCBtdWx0aXBsZSkgewogICAgcmV0dXJuIG4gLSBuICUgbXVsdGlwbGUgKyBtdWx0aXBsZTsKICB9CiAgdmFyIEJBSSA9IGNsYXNzIGV4dGVuZHMgSW5kZXhGaWxlIHsKICAgIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKGltcG9ydF9sb25nLmRlZmF1bHQuZnJvbUJ5dGVzTEUoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMsIG9mZnNldCArIDE2LCBvZmZzZXQgKyAyNCksIHRydWUpKTsKICAgICAgcmV0dXJuIHsgbGluZUNvdW50IH07CiAgICB9CiAgICBhc3luYyBsaW5lQ291bnQocmVmSWQsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBwcm9tID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgY29uc3QgaW5kZXggPSBwcm9tLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWluZGV4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJldCA9IGluZGV4LnN0YXRzIHx8IHt9OwogICAgICByZXR1cm4gcmV0LmxpbmVDb3VudCA9PT0gdm9pZCAwID8gLTEgOiByZXQubGluZUNvdW50OwogICAgfQogICAgZmV0Y2hCYWkob3B0cyA9IHt9KSB7CiAgICAgIGlmICghdGhpcy5iYWlQKSB7CiAgICAgICAgdGhpcy5iYWlQID0gdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpLmNhdGNoKChlKSA9PiB7CiAgICAgICAgICB0aGlzLmJhaVAgPSB2b2lkIDA7CiAgICAgICAgICB0aHJvdyBlOwogICAgICAgIH0pOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLmJhaVA7CiAgICB9CiAgICBhc3luYyBfcGFyc2UoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB7IGJhaTogdHJ1ZSwgbWF4QmxvY2tTaXplOiAxIDw8IDE2IH07CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5mZXRjaEJhaSgpOwogICAgICBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApICE9PSBCQUlfTUFHSUMpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIEJBSSBmaWxlIik7CiAgICAgIH0KICAgICAgZGF0YS5yZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICBjb25zdCBkZXB0aCA9IDU7CiAgICAgIGNvbnN0IGJpbkxpbWl0ID0gKCgxIDw8IChkZXB0aCArIDEpICogMykgLSAxKSAvIDc7CiAgICAgIGRhdGEuaW5kaWNlcyA9IG5ldyBBcnJheShkYXRhLnJlZkNvdW50KTsKICAgICAgbGV0IGN1cnJPZmZzZXQgPSA4OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEucmVmQ291bnQ7IGkgKz0gMSkgewogICAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgbGV0IHN0YXRzOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmluQ291bnQ7IGogKz0gMSkgewogICAgICAgICAgY29uc3QgYmluID0gYnl0ZXMucmVhZFVJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgaWYgKGJpbiA9PT0gYmluTGltaXQgKyAxKSB7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSAzMjsKICAgICAgICAgIH0gZWxzZSBpZiAoYmluID4gYmluTGltaXQgKyAxKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiYmFpIGluZGV4IGNvbnRhaW5zIHRvbyBtYW55IGJpbnMsIHBsZWFzZSB1c2UgQ1NJIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgIGNvbnN0IHYgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIHRoaXMuX2ZpbmRGaXJzdERhdGEoZGF0YSwgdSk7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgbGluZWFySW5kZXhba10gPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgY3Vyck9mZnNldCArPSA4OwogICAgICAgICAgdGhpcy5fZmluZEZpcnN0RGF0YShkYXRhLCBsaW5lYXJJbmRleFtrXSk7CiAgICAgICAgfQogICAgICAgIGRhdGEuaW5kaWNlc1tpXSA9IHsgYmluSW5kZXgsIGxpbmVhckluZGV4LCBzdGF0cyB9OwogICAgICB9CiAgICAgIHJldHVybiBkYXRhOwogICAgfQogICAgYXN5bmMgaW5kZXhDb3Yoc2VxSWQsIHN0YXJ0LCBlbmQsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCB2ID0gMTYzODQ7CiAgICAgIGNvbnN0IHJhbmdlID0gc3RhcnQgIT09IHZvaWQgMDsKICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgY29uc3Qgc2VxSWR4ID0gaW5kZXhEYXRhLmluZGljZXNbc2VxSWRdOwogICAgICBpZiAoIXNlcUlkeCkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCB7IGxpbmVhckluZGV4ID0gW10sIHN0YXRzIH0gPSBzZXFJZHg7CiAgICAgIGlmICghbGluZWFySW5kZXgubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IGUgPSBlbmQgIT09IHZvaWQgMCA/IHJvdW5kVXAoZW5kLCB2KSA6IChsaW5lYXJJbmRleC5sZW5ndGggLSAxKSAqIHY7CiAgICAgIGNvbnN0IHMgPSBzdGFydCAhPT0gdm9pZCAwID8gcm91bmREb3duKHN0YXJ0LCB2KSA6IDA7CiAgICAgIGxldCBkZXB0aHM7CiAgICAgIGlmIChyYW5nZSkgewogICAgICAgIGRlcHRocyA9IG5ldyBBcnJheSgoZSAtIHMpIC8gdik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVwdGhzID0gbmV3IEFycmF5KGxpbmVhckluZGV4Lmxlbmd0aCAtIDEpOwogICAgICB9CiAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGxpbmVhckluZGV4W2xpbmVhckluZGV4Lmxlbmd0aCAtIDFdLmJsb2NrUG9zaXRpb247CiAgICAgIGlmIChlID4gKGxpbmVhckluZGV4Lmxlbmd0aCAtIDEpICogdikgewogICAgICAgIHRocm93IG5ldyBFcnJvcigicXVlcnkgb3V0c2lkZSBvZiByYW5nZSBvZiBsaW5lYXIgaW5kZXgiKTsKICAgICAgfQogICAgICBsZXQgY3VycmVudFBvcyA9IGxpbmVhckluZGV4W3MgLyB2XS5ibG9ja1Bvc2l0aW9uOwogICAgICBmb3IgKGxldCBpID0gcyAvIHYsIGogPSAwOyBpIDwgZSAvIHY7IGkrKywgaisrKSB7CiAgICAgICAgZGVwdGhzW2pdID0gewogICAgICAgICAgc2NvcmU6IGxpbmVhckluZGV4W2kgKyAxXS5ibG9ja1Bvc2l0aW9uIC0gY3VycmVudFBvcywKICAgICAgICAgIHN0YXJ0OiBpICogdiwKICAgICAgICAgIGVuZDogaSAqIHYgKyB2CiAgICAgICAgfTsKICAgICAgICBjdXJyZW50UG9zID0gbGluZWFySW5kZXhbaSArIDFdLmJsb2NrUG9zaXRpb247CiAgICAgIH0KICAgICAgcmV0dXJuIGRlcHRocy5tYXAoKGQpID0+IHsKICAgICAgICByZXR1cm4geyAuLi5kLCBzY29yZTogZC5zY29yZSAqIHN0YXRzLmxpbmVDb3VudCAvIHRvdGFsU2l6ZSB9OwogICAgICB9KTsKICAgIH0KICAgIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICAgIGVuZCAtPSAxOwogICAgICByZXR1cm4gWwogICAgICAgIFswLCAwXSwKICAgICAgICBbMSArIChiZWcgPj4gMjYpLCAxICsgKGVuZCA+PiAyNildLAogICAgICAgIFs5ICsgKGJlZyA+PiAyMyksIDkgKyAoZW5kID4+IDIzKV0sCiAgICAgICAgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLAogICAgICAgIFs1ODUgKyAoYmVnID4+IDE3KSwgNTg1ICsgKGVuZCA+PiAxNyldLAogICAgICAgIFs0NjgxICsgKGJlZyA+PiAxNCksIDQ2ODEgKyAoZW5kID4+IDE0KV0KICAgICAgXTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZklkLCBtaW4sIG1heCwgb3B0cyA9IHt9KSB7CiAgICAgIGlmIChtaW4gPCAwKSB7CiAgICAgICAgbWluID0gMDsKICAgICAgfQogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSB0aGlzLnJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDsKICAgICAgbGV0IGxvd2VzdCA9IG51bGw7CiAgICAgIGNvbnN0IG1pbkxpbiA9IE1hdGgubWluKG1pbiA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgY29uc3QgbWF4TGluID0gTWF0aC5taW4obWF4ID4+IDE0LCBuaW50diAtIDEpOwogICAgICBmb3IgKGxldCBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7CiAgICAgICAgY29uc3QgdnAgPSBiYS5saW5lYXJJbmRleFtpXTsKICAgICAgICBpZiAodnApIHsKICAgICAgICAgIGlmICghbG93ZXN0IHx8IHZwLmNvbXBhcmVUbyhsb3dlc3QpIDwgMCkgewogICAgICAgICAgICBsb3dlc3QgPSB2cDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9jc2kuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2JnekZpbGVoYW5kbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9lc20vdW56aXAtcGFrby5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X3Bha28gPSBfX3RvTW9kdWxlKHJlcXVpcmVfcGFrbygpKTsKICBhc3luYyBmdW5jdGlvbiB1bnppcChpbnB1dERhdGEpIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBsZXQgcG9zID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7CiAgICAgIGxldCBpbmZsYXRvcjsKICAgICAgZG8gewogICAgICAgIGNvbnN0IHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnN1YmFycmF5KHBvcyk7CiAgICAgICAgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGNodW5rc1tpXSA9IGluZmxhdG9yLnJlc3VsdDsKICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICBpICs9IDE7CiAgICAgIH0gd2hpbGUgKHN0cm0uYXZhaWxfaW4pOwogICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpOwogICAgICBmb3IgKGxldCBpMiA9IDAsIG9mZnNldCA9IDA7IGkyIDwgY2h1bmtzLmxlbmd0aDsgaTIrKykgewogICAgICAgIHJlc3VsdC5zZXQoY2h1bmtzW2kyXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQgKz0gY2h1bmtzW2kyXS5sZW5ndGg7CiAgICAgIH0KICAgICAgcmV0dXJuIGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20ocmVzdWx0KTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQogIGFzeW5jIGZ1bmN0aW9uIHVuemlwQ2h1bmtTbGljZShpbnB1dERhdGEsIGNodW5rKSB7CiAgICB0cnkgewogICAgICBsZXQgc3RybTsKICAgICAgY29uc3QgeyBtaW52LCBtYXh2IH0gPSBjaHVuazsKICAgICAgbGV0IGNwb3MgPSBtaW52LmJsb2NrUG9zaXRpb247CiAgICAgIGxldCBkcG9zID0gbWludi5kYXRhUG9zaXRpb247CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBjb25zdCBjcG9zaXRpb25zID0gW107CiAgICAgIGNvbnN0IGRwb3NpdGlvbnMgPSBbXTsKICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7CiAgICAgIGxldCBpID0gMDsKICAgICAgZG8gewogICAgICAgIGNvbnN0IHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnN1YmFycmF5KGNwb3MgLSBtaW52LmJsb2NrUG9zaXRpb24pOwogICAgICAgIGNvbnN0IGluZmxhdG9yID0gbmV3IGltcG9ydF9wYWtvLkluZmxhdGUoKTsKICAgICAgICAoeyBzdHJtIH0gPSBpbmZsYXRvcik7CiAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgaW1wb3J0X3Bha28uWl9TWU5DX0ZMVVNIKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyMiA9IGluZmxhdG9yLnJlc3VsdDsKICAgICAgICBjaHVua3MucHVzaChidWZmZXIyKTsKICAgICAgICBsZXQgbGVuID0gYnVmZmVyMi5sZW5ndGg7CiAgICAgICAgY3Bvc2l0aW9ucy5wdXNoKGNwb3MpOwogICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSAmJiBtaW52LmRhdGFQb3NpdGlvbikgewogICAgICAgICAgY2h1bmtzWzBdID0gY2h1bmtzWzBdLnN1YmFycmF5KG1pbnYuZGF0YVBvc2l0aW9uKTsKICAgICAgICAgIGxlbiA9IGNodW5rc1swXS5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGNvbnN0IG9yaWdDcG9zID0gY3BvczsKICAgICAgICBjcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICBkcG9zICs9IGxlbjsKICAgICAgICBpZiAob3JpZ0Nwb3MgPj0gbWF4di5ibG9ja1Bvc2l0aW9uKSB7CiAgICAgICAgICBjaHVua3NbaV0gPSBjaHVua3NbaV0uc3ViYXJyYXkoMCwgbWF4di5ibG9ja1Bvc2l0aW9uID09PSBtaW52LmJsb2NrUG9zaXRpb24gPyBtYXh2LmRhdGFQb3NpdGlvbiAtIG1pbnYuZGF0YVBvc2l0aW9uICsgMSA6IG1heHYuZGF0YVBvc2l0aW9uICsgMSk7CiAgICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgICBkcG9zaXRpb25zLnB1c2goZHBvcyk7CiAgICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICBpKys7CiAgICAgIH0gd2hpbGUgKHN0cm0uYXZhaWxfaW4pOwogICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpOwogICAgICBmb3IgKGxldCBpMiA9IDAsIG9mZnNldCA9IDA7IGkyIDwgY2h1bmtzLmxlbmd0aDsgaTIrKykgewogICAgICAgIHJlc3VsdC5zZXQoY2h1bmtzW2kyXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQgKz0gY2h1bmtzW2kyXS5sZW5ndGg7CiAgICAgIH0KICAgICAgY29uc3QgYnVmZmVyID0gaW1wb3J0X2J1ZmZlci5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgICByZXR1cm4geyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2d6aUluZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvbm9kZV9tb2R1bGVzL2xvbmcvaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIHdhc20gPSBudWxsOwogIHRyeSB7CiAgICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoWwogICAgICAwLAogICAgICA5NywKICAgICAgMTE1LAogICAgICAxMDksCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDEzLAogICAgICAyLAogICAgICA5NiwKICAgICAgMCwKICAgICAgMSwKICAgICAgMTI3LAogICAgICA5NiwKICAgICAgNCwKICAgICAgMTI3LAogICAgICAxMjcsCiAgICAgIDEyNywKICAgICAgMTI3LAogICAgICAxLAogICAgICAxMjcsCiAgICAgIDMsCiAgICAgIDcsCiAgICAgIDYsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDYsCiAgICAgIDYsCiAgICAgIDEsCiAgICAgIDEyNywKICAgICAgMSwKICAgICAgNjUsCiAgICAgIDAsCiAgICAgIDExLAogICAgICA3LAogICAgICA1MCwKICAgICAgNiwKICAgICAgMywKICAgICAgMTA5LAogICAgICAxMTcsCiAgICAgIDEwOCwKICAgICAgMCwKICAgICAgMSwKICAgICAgNSwKICAgICAgMTAwLAogICAgICAxMDUsCiAgICAgIDExOCwKICAgICAgOTUsCiAgICAgIDExNSwKICAgICAgMCwKICAgICAgMiwKICAgICAgNSwKICAgICAgMTAwLAogICAgICAxMDUsCiAgICAgIDExOCwKICAgICAgOTUsCiAgICAgIDExNywKICAgICAgMCwKICAgICAgMywKICAgICAgNSwKICAgICAgMTE0LAogICAgICAxMDEsCiAgICAgIDEwOSwKICAgICAgOTUsCiAgICAgIDExNSwKICAgICAgMCwKICAgICAgNCwKICAgICAgNSwKICAgICAgMTE0LAogICAgICAxMDEsCiAgICAgIDEwOSwKICAgICAgOTUsCiAgICAgIDExNywKICAgICAgMCwKICAgICAgNSwKICAgICAgOCwKICAgICAgMTAzLAogICAgICAxMDEsCiAgICAgIDExNiwKICAgICAgOTUsCiAgICAgIDEwNCwKICAgICAgMTA1LAogICAgICAxMDMsCiAgICAgIDEwNCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMTAsCiAgICAgIDE5MSwKICAgICAgMSwKICAgICAgNiwKICAgICAgNCwKICAgICAgMCwKICAgICAgMzUsCiAgICAgIDAsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMjYsCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEsCiAgICAgIDM2LAogICAgICAxLAogICAgICAxLAogICAgICAxMjYsCiAgICAgIDMyLAogICAgICAwLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAxLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDMyLAogICAgICAyLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAzLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDEyNywKICAgICAgMzQsCiAgICAgIDQsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM1LAogICAgICAxNjcsCiAgICAgIDM2LAogICAgICAwLAogICAgICAzMiwKICAgICAgNCwKICAgICAgMTY3LAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTI4LAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMjksCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEsCiAgICAgIDM2LAogICAgICAxLAogICAgICAxLAogICAgICAxMjYsCiAgICAgIDMyLAogICAgICAwLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAxLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDMyLAogICAgICAyLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAzLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDEzMCwKICAgICAgMzQsCiAgICAgIDQsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM1LAogICAgICAxNjcsCiAgICAgIDM2LAogICAgICAwLAogICAgICAzMiwKICAgICAgNCwKICAgICAgMTY3LAogICAgICAxMQogICAgXSkpLCB7fSkuZXhwb3J0czsKICB9IGNhdGNoIChlKSB7CiAgfQogIGZ1bmN0aW9uIExvbmcyKGxvdywgaGlnaCwgdW5zaWduZWQpIHsKICAgIHRoaXMubG93ID0gbG93IHwgMDsKICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgfQogIExvbmcyLnByb3RvdHlwZS5fX2lzTG9uZ19fOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nMi5wcm90b3R5cGUsICJfX2lzTG9uZ19fIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICBmdW5jdGlvbiBpc0xvbmcob2JqKSB7CiAgICByZXR1cm4gKG9iaiAmJiBvYmpbIl9faXNMb25nX18iXSkgPT09IHRydWU7CiAgfQogIGZ1bmN0aW9uIGN0ejMyKHZhbHVlKSB7CiAgICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpOwogICAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYzsKICB9CiAgTG9uZzIuaXNMb25nID0gaXNMb25nOwogIHZhciBJTlRfQ0FDSEUgPSB7fTsKICB2YXIgVUlOVF9DQUNIRSA9IHt9OwogIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7CiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdOwogICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICB9CiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTsKICAgICAgaWYgKGNhY2hlKQogICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICByZXR1cm4gb2JqOwogICAgfSBlbHNlIHsKICAgICAgdmFsdWUgfD0gMDsKICAgICAgaWYgKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkgewogICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7CiAgICAgIH0KICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICBpZiAoY2FjaGUpCiAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgcmV0dXJuIG9iajsKICAgIH0KICB9CiAgTG9uZzIuZnJvbUludCA9IGZyb21JbnQ7CiAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHsKICAgIGlmIChpc05hTih2YWx1ZSkpCiAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgIGlmICh1bnNpZ25lZCkgewogICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgIHJldHVybiBVWkVSTzsKICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKQogICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7CiAgICB9IGVsc2UgewogICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKQogICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpCiAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTsKICAgIH0KICAgIGlmICh2YWx1ZSA8IDApCiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpOwogICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpOwogIH0KICBMb25nMi5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjsKICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHsKICAgIHJldHVybiBuZXcgTG9uZzIobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICB9CiAgTG9uZzIuZnJvbUJpdHMgPSBmcm9tQml0czsKICB2YXIgcG93X2RibCA9IE1hdGgucG93OwogIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHsKICAgIGlmIChzdHIubGVuZ3RoID09PSAwKQogICAgICB0aHJvdyBFcnJvcigiZW1wdHkgc3RyaW5nIik7CiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAibnVtYmVyIikgewogICAgICByYWRpeCA9IHVuc2lnbmVkOwogICAgICB1bnNpZ25lZCA9IGZhbHNlOwogICAgfSBlbHNlIHsKICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgfQogICAgaWYgKHN0ciA9PT0gIk5hTiIgfHwgc3RyID09PSAiSW5maW5pdHkiIHx8IHN0ciA9PT0gIitJbmZpbml0eSIgfHwgc3RyID09PSAiLUluZmluaXR5IikKICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgIHZhciBwOwogICAgaWYgKChwID0gc3RyLmluZGV4T2YoIi0iKSkgPiAwKQogICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICBlbHNlIGlmIChwID09PSAwKSB7CiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICB9CiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7CiAgICB2YXIgcmVzdWx0ID0gWkVSTzsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7CiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLCB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7CiAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpOwogICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpOwogICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpOwogICAgICB9CiAgICB9CiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDsKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIExvbmcyLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nOwogIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7CiAgICBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpCiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpOwogICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKQogICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTsKICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAiYm9vbGVhbiIgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7CiAgfQogIExvbmcyLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsKICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2OwogIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7CiAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDsKICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMOwogIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjsKICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpOwogIHZhciBaRVJPID0gZnJvbUludCgwKTsKICBMb25nMi5aRVJPID0gWkVSTzsKICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpOwogIExvbmcyLlVaRVJPID0gVVpFUk87CiAgdmFyIE9ORSA9IGZyb21JbnQoMSk7CiAgTG9uZzIuT05FID0gT05FOwogIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTsKICBMb25nMi5VT05FID0gVU9ORTsKICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpOwogIExvbmcyLk5FR19PTkUgPSBORUdfT05FOwogIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgMjE0NzQ4MzY0NyB8IDAsIGZhbHNlKTsKICBMb25nMi5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7CiAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDQyOTQ5NjcyOTUgfCAwLCA0Mjk0OTY3Mjk1IHwgMCwgdHJ1ZSk7CiAgTG9uZzIuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFOwogIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAyMTQ3NDgzNjQ4IHwgMCwgZmFsc2UpOwogIExvbmcyLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTsKICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcyLnByb3RvdHlwZTsKICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7CiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7CiAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICB9OwogIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkgewogICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICByZXR1cm4gIjAiOwogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgfSBlbHNlCiAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgfQogICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLCByZW0gPSB0aGlzOwogICAgdmFyIHJlc3VsdCA9ICIiOwogICAgd2hpbGUgKHRydWUpIHsKICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSwgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7CiAgICAgIHJlbSA9IHJlbURpdjsKICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0OwogICAgICBlbHNlIHsKICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICBkaWdpdHMgPSAiMCIgKyBkaWdpdHM7CiAgICAgICAgcmVzdWx0ID0gIiIgKyBkaWdpdHMgKyByZXN1bHQ7CiAgICAgIH0KICAgIH0KICB9OwogIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkgewogICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7CiAgICByZXR1cm4gdGhpcy5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHsKICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7CiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpCiAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpOwogICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApCiAgICAgICAgYnJlYWs7CiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgfTsKICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvOwogIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7CiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDsKICB9OwogIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7CiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICB9OwogIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHsKICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTsKICB9OwogIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkgewogICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpCiAgICAgIHJldHVybiBmYWxzZTsKICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICB9OwogIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFsczsKICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikgewogICAgcmV0dXJuICF0aGlzLmVxKG90aGVyKTsKICB9OwogIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikgewogICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47CiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogIExvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuOwogIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7CiAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikgewogICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICBpZiAodGhpcy5lcShvdGhlcikpCiAgICAgIHJldHVybiAwOwogICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpCiAgICAgIHJldHVybiAtMTsKICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgcmV0dXJuIDE7CiAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlOwogIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkgewogICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTsKICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHsKICAgIGlmICghaXNMb25nKGFkZGVuZCkpCiAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpOwogICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgNjU1MzU7CiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7CiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICBjMDAgKz0gYTAwICsgYjAwOwogICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICBjMDAgJj0gNjU1MzU7CiAgICBjMTYgKz0gYTE2ICsgYjE2OwogICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICBjMTYgJj0gNjU1MzU7CiAgICBjMzIgKz0gYTMyICsgYjMyOwogICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICBjMzIgJj0gNjU1MzU7CiAgICBjNDggKz0gYTQ4ICsgYjQ4OwogICAgYzQ4ICY9IDY1NTM1OwogICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7CiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSkKICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTsKICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICB9OwogIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDsKICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikgewogICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpCiAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7CiAgICBpZiAod2FzbSkgewogICAgICB2YXIgbG93ID0gd2FzbVsibXVsIl0odGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bImdldF9oaWdoIl0oKSwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkKICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKQogICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpCiAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPOwogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7CiAgICAgIGVsc2UKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKQogICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpOwogICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiA2NTUzNTsKICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgYzAwICs9IGEwMCAqIGIwMDsKICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgYzAwICY9IDY1NTM1OwogICAgYzE2ICs9IGExNiAqIGIwMDsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzMyICs9IGEzMiAqIGIwMDsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzMyICs9IGExNiAqIGIxNjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzMyICs9IGEwMCAqIGIzMjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgIGM0OCAmPSA2NTUzNTsKICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7CiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikgewogICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkKICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgIGlmICh3YXNtKSB7CiAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVsiZGl2X3UiXSA6IHdhc21bImRpdl9zIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtWyJnZXRfaGlnaCJdKCksIHRoaXMudW5zaWduZWQpOwogICAgfQogICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgdmFyIGFwcHJveCwgcmVtLCByZXM7CiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSkKICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIE9ORTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpOwogICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTsKICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHsKICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpOwogICAgICAgICAgICByZXR1cm4gcmVzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7CiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICByZXMgPSBaRVJPOwogICAgfSBlbHNlIHsKICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKQogICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgIHJldHVybiBVT05FOwogICAgICByZXMgPSBVWkVSTzsKICAgIH0KICAgIHJlbSA9IHRoaXM7CiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkgewogICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSwgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICBhcHByb3ggLT0gZGVsdGE7CiAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgIH0KICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICBhcHByb3hSZXMgPSBPTkU7CiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pOwogICAgfQogICAgcmV0dXJuIHJlczsKICB9OwogIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7CiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikgewogICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICBpZiAod2FzbSkgewogICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtWyJyZW1fdSJdIDogd2FzbVsicmVtX3MiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bImdldF9oaWdoIl0oKSwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICB9OwogIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbzsKICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHsKICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50TGVhZGluZ1plcm9zKCkgewogICAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7CiAgfTsKICBMb25nUHJvdG90eXBlLmNseiA9IExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3M7CiAgTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3MoKSB7CiAgICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7CiAgfTsKICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zOwogIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgZWxzZQogICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7CiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgIGVsc2UKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0OwogIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICBpZiAobnVtQml0cyA9PT0gMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gbnVtQml0cyAtIDMyLCAwLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkOwogIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHsKICAgIHZhciBiOwogICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7CiAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgIGIgPSAzMiAtIG51bUJpdHM7CiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLnVuc2lnbmVkKTsKICAgIH0KICAgIG51bUJpdHMgLT0gMzI7CiAgICBiID0gMzIgLSBudW1CaXRzOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IGIsIHRoaXMubG93IDw8IG51bUJpdHMgfCB0aGlzLmhpZ2ggPj4+IGIsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0OwogIExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7CiAgICB2YXIgYjsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzID09PSAzMikKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpOwogICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICBiID0gMzIgLSBudW1CaXRzOwogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBudW1CaXRzIC09IDMyOwogICAgYiA9IDMyIC0gbnVtQml0czsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBiIHwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgYiB8IHRoaXMubG93ID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUucm90ciA9IExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQ7CiAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkgewogICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICByZXR1cm4gdGhpczsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkgewogICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiB0aGlzOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkgewogICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHsKICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgIHJldHVybiBbCiAgICAgIGxvICYgMjU1LAogICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICBsbyA+Pj4gMjQsCiAgICAgIGhpICYgMjU1LAogICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICBoaSA+Pj4gMjQKICAgIF07CiAgfTsKICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHsKICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgIHJldHVybiBbCiAgICAgIGhpID4+PiAyNCwKICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgaGkgJiAyNTUsCiAgICAgIGxvID4+PiAyNCwKICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgbG8gJiAyNTUKICAgIF07CiAgfTsKICBMb25nMi5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMyKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgIHJldHVybiBsZSA/IExvbmcyLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nMi5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpOwogIH07CiAgTG9uZzIuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHsKICAgIHJldHVybiBuZXcgTG9uZzIoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpOwogIH07CiAgTG9uZzIuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHsKICAgIHJldHVybiBuZXcgTG9uZzIoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpOwogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9jYWxGaWxlID0gX190b01vZHVsZShyZXF1aXJlX2xvY2FsRmlsZSgpKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vcmVtb3RlRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogIHZhciBteUdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHsgZmV0Y2g6IHZvaWQgMCB9OwogIHZhciBSZW1vdGVGaWxlID0gY2xhc3MgewogICAgYXN5bmMgZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7CiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYnVmZmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJ1ZmZlcigpOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5hcnJheUJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpOwogICAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuZnJvbShyZXNwKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBoYXMgbm8gYnVmZmVyIG1ldGhvZCwgYW5kIG5vIGFycmF5QnVmZmVyIG1ldGhvZCIpOwogICAgICB9CiAgICB9CiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdHMgPSB7fSkgewogICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSB7fTsKICAgICAgdGhpcy51cmwgPSBzb3VyY2U7CiAgICAgIGNvbnN0IGZldGNoMiA9IG9wdHMuZmV0Y2ggfHwgbXlHbG9iYWwuZmV0Y2ggJiYgbXlHbG9iYWwuZmV0Y2guYmluZChteUdsb2JhbCk7CiAgICAgIGlmICghZmV0Y2gyKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8gZmV0Y2ggZnVuY3Rpb24gc3VwcGxpZWQsIGFuZCBub25lIGZvdW5kIGluIGdsb2JhbCBlbnZpcm9ubWVudGApOwogICAgICB9CiAgICAgIGlmIChvcHRzLm92ZXJyaWRlcykgewogICAgICAgIHRoaXMuYmFzZU92ZXJyaWRlcyA9IG9wdHMub3ZlcnJpZGVzOwogICAgICB9CiAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoMjsKICAgIH0KICAgIGFzeW5jIGZldGNoKGlucHV0LCBpbml0MikgewogICAgICBsZXQgcmVzcG9uc2U7CiAgICAgIHRyeSB7CiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24oaW5wdXQsIGluaXQyKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmIChgJHtlfWAuaW5jbHVkZXMoIkZhaWxlZCB0byBmZXRjaCIpKSB7CiAgICAgICAgICBjb25zb2xlLndhcm4oYGdlbmVyaWMtZmlsZWhhbmRsZTogcmVmZXRjaGluZyAke2lucHV0fSB0byBhdHRlbXB0IHRvIHdvcmsgYXJvdW5kIGNocm9tZSBDT1JTIGhlYWRlciBjYWNoaW5nIGJ1Z2ApOwogICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24oaW5wdXQsIHsKICAgICAgICAgICAgLi4uaW5pdDIsCiAgICAgICAgICAgIGNhY2hlOiAicmVsb2FkIgogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IGU7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiByZXNwb25zZTsKICAgIH0KICAgIGFzeW5jIHJlYWQoYnVmZmVyLCBvZmZzZXQgPSAwLCBsZW5ndGgsIHBvc2l0aW9uID0gMCwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBpZiAobGVuZ3RoIDwgSW5maW5pdHkpIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YDsKICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IEluZmluaXR5ICYmIHBvc2l0aW9uICE9PSAwKSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gOwogICAgICB9CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLAogICAgICAgIC4uLm92ZXJyaWRlcywKICAgICAgICBoZWFkZXJzOiB7CiAgICAgICAgICAuLi5oZWFkZXJzLAogICAgICAgICAgLi4ub3ZlcnJpZGVzLmhlYWRlcnMsCiAgICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycwogICAgICAgIH0sCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbAogICAgICB9OwogICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godGhpcy51cmwsIGFyZ3MpOwogICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7dGhpcy51cmx9YCk7CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHBvc2l0aW9uID09PSAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7CiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gcmVzcG9uc2VEYXRhLmNvcHkoYnVmZmVyLCBvZmZzZXQsIDAsIE1hdGgubWluKGxlbmd0aCwgcmVzcG9uc2VEYXRhLmxlbmd0aCkpOwogICAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgY29uc3Qgc2l6ZU1hdGNoID0gL1wvKFxkKykkLy5leGVjKHJlcyB8fCAiIik7CiAgICAgICAgaWYgKHNpemVNYXRjaCAmJiBzaXplTWF0Y2hbMV0pIHsKICAgICAgICAgIHRoaXMuX3N0YXQgPSB7IHNpemU6IHBhcnNlSW50KHNpemVNYXRjaFsxXSwgMTApIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9OwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiJHt0aGlzLnVybH0gZmV0Y2ggcmV0dXJuZWQgc3RhdHVzIDIwMCwgZXhwZWN0ZWQgMjA2Iik7CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApOwogICAgfQogICAgYXN5bmMgcmVhZEZpbGUob3B0aW9ucyA9IHt9KSB7CiAgICAgIGxldCBlbmNvZGluZzsKICAgICAgbGV0IG9wdHM7CiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gInN0cmluZyIpIHsKICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnM7CiAgICAgICAgb3B0cyA9IHt9OwogICAgICB9IGVsc2UgewogICAgICAgIGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZzsKICAgICAgICBvcHRzID0gb3B0aW9uczsKICAgICAgICBkZWxldGUgb3B0cy5lbmNvZGluZzsKICAgICAgfQogICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICBoZWFkZXJzLAogICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICBzaWduYWwsCiAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLAogICAgICAgIC4uLm92ZXJyaWRlcwogICAgICB9OwogICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godGhpcy51cmwsIGFyZ3MpOwogICAgICBpZiAoIXJlc3BvbnNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJnZW5lcmljLWZpbGVoYW5kbGUgZmFpbGVkIHRvIGZldGNoIik7CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7CiAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCksIHsKICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKGVuY29kaW5nID09PSAidXRmOCIpIHsKICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpOwogICAgICB9CiAgICAgIGlmIChlbmNvZGluZykgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgIH0KICAgIGFzeW5jIHN0YXQoKSB7CiAgICAgIGlmICghdGhpcy5fc3RhdCkgewogICAgICAgIGNvbnN0IGJ1ZiA9IGltcG9ydF9idWZmZXIyLkJ1ZmZlci5hbGxvY1Vuc2FmZSgxMCk7CiAgICAgICAgYXdhaXQgdGhpcy5yZWFkKGJ1ZiwgMCwgMTAsIDApOwogICAgICAgIGlmICghdGhpcy5fc3RhdCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZGV0ZXJtaW5lIHNpemUgb2YgZmlsZSBhdCAke3RoaXMudXJsfWApOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gdGhpcy5fc3RhdDsKICAgIH0KICAgIGFzeW5jIGNsb3NlKCkgewogICAgICByZXR1cm47CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vYmxvYkZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIzID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vZmlsZWhhbmRsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vY3NpLmpzCiAgdmFyIENTSTFfTUFHSUMgPSAyMTU4MjY1OTsKICB2YXIgQ1NJMl9NQUdJQyA9IDM4MzU5ODc1OwogIGZ1bmN0aW9uIGxzaGlmdChudW0sIGJpdHMpIHsKICAgIHJldHVybiBudW0gKiAyICoqIGJpdHM7CiAgfQogIGZ1bmN0aW9uIHJzaGlmdChudW0sIGJpdHMpIHsKICAgIHJldHVybiBNYXRoLmZsb29yKG51bSAvIDIgKiogYml0cyk7CiAgfQogIHZhciBDU0kgPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7CiAgICAgIHN1cGVyKGFyZ3MpOwogICAgICB0aGlzLm1heEJpbk51bWJlciA9IDA7CiAgICAgIHRoaXMuZGVwdGggPSAwOwogICAgICB0aGlzLm1pblNoaWZ0ID0gMDsKICAgIH0KICAgIGFzeW5jIGxpbmVDb3VudChyZWZJZCkgewogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKCk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IGlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFpZHgpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoc3RhdHMpIHsKICAgICAgICByZXR1cm4gc3RhdHMubGluZUNvdW50OwogICAgICB9CiAgICAgIHJldHVybiAtMTsKICAgIH0KICAgIGFzeW5jIGluZGV4Q292KCkgewogICAgICByZXR1cm4gW107CiAgICB9CiAgICBwYXJzZUF1eERhdGEoYnl0ZXMsIG9mZnNldCwgYXV4TGVuZ3RoKSB7CiAgICAgIGlmIChhdXhMZW5ndGggPCAzMCkgewogICAgICAgIHJldHVybiB7fTsKICAgICAgfQogICAgICBjb25zdCBkYXRhID0ge307CiAgICAgIGRhdGEuZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQpOwogICAgICBkYXRhLmNvb3JkaW5hdGVUeXBlID0gZGF0YS5mb3JtYXRGbGFncyAmIDY1NTM2ID8gInplcm8tYmFzZWQtaGFsZi1vcGVuIiA6ICIxLWJhc2VkLWNsb3NlZCI7CiAgICAgIGRhdGEuZm9ybWF0ID0geyAwOiAiZ2VuZXJpYyIsIDE6ICJTQU0iLCAyOiAiVkNGIiB9W2RhdGEuZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZGF0YS5mb3JtYXQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgVGFiaXggcHJlc2V0IGZvcm1hdCBmbGFncyAke2RhdGEuZm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgZGF0YS5jb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgNCksCiAgICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDgpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTIpCiAgICAgIH07CiAgICAgIGRhdGEubWV0YVZhbHVlID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTYpOwogICAgICBkYXRhLm1ldGFDaGFyID0gZGF0YS5tZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGEubWV0YVZhbHVlKSA6ICIiOwogICAgICBkYXRhLnNraXBMaW5lcyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDIwKTsKICAgICAgY29uc3QgbmFtZVNlY3Rpb25MZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAyNCk7CiAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdGhpcy5fcGFyc2VOYW1lQnl0ZXMoYnl0ZXMuc3ViYXJyYXkob2Zmc2V0ICsgMjgsIG9mZnNldCArIDI4ICsgbmFtZVNlY3Rpb25MZW5ndGgpKSk7CiAgICAgIHJldHVybiBkYXRhOwogICAgfQogICAgX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXMpIHsKICAgICAgbGV0IGN1cnJSZWZJZCA9IDA7CiAgICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMDsKICAgICAgY29uc3QgcmVmSWRUb05hbWUgPSBbXTsKICAgICAgY29uc3QgcmVmTmFtZVRvSWQgPSB7fTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc0J5dGVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7CiAgICAgICAgICBpZiAoY3Vyck5hbWVTdGFydCA8IGkpIHsKICAgICAgICAgICAgbGV0IHJlZk5hbWUgPSBuYW1lc0J5dGVzLnRvU3RyaW5nKCJ1dGY4IiwgY3Vyck5hbWVTdGFydCwgaSk7CiAgICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKTsKICAgICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWU7CiAgICAgICAgICAgIHJlZk5hbWVUb0lkW3JlZk5hbWVdID0gY3VyclJlZklkOwogICAgICAgICAgfQogICAgICAgICAgY3Vyck5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VyclJlZklkICs9IDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHJlZk5hbWVUb0lkLCByZWZJZFRvTmFtZSB9OwogICAgfQogICAgYXN5bmMgX3BhcnNlKG9wdHMpIHsKICAgICAgY29uc3QgZGF0YSA9IHsgY3NpOiB0cnVlLCBtYXhCbG9ja1NpemU6IDEgPDwgMTYgfTsKICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpOwogICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHVuemlwKGJ1ZmZlcik7CiAgICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTFfTUFHSUMpIHsKICAgICAgICBkYXRhLmNzaVZlcnNpb24gPSAxOwogICAgICB9IGVsc2UgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMl9NQUdJQykgewogICAgICAgIGRhdGEuY3NpVmVyc2lvbiA9IDI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBDU0kgZmlsZSIpOwogICAgICB9CiAgICAgIHRoaXMubWluU2hpZnQgPSBieXRlcy5yZWFkSW50MzJMRSg0KTsKICAgICAgdGhpcy5kZXB0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDgpOwogICAgICB0aGlzLm1heEJpbk51bWJlciA9ICgoMSA8PCAodGhpcy5kZXB0aCArIDEpICogMykgLSAxKSAvIDc7CiAgICAgIGNvbnN0IGF1eExlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDEyKTsKICAgICAgaWYgKGF1eExlbmd0aCkgewogICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdGhpcy5wYXJzZUF1eERhdGEoYnl0ZXMsIDE2LCBhdXhMZW5ndGgpKTsKICAgICAgfQogICAgICBkYXRhLnJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoMTYgKyBhdXhMZW5ndGgpOwogICAgICBkYXRhLmluZGljZXMgPSBuZXcgQXJyYXkoZGF0YS5yZWZDb3VudCk7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gMTYgKyBhdXhMZW5ndGggKyA0OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEucmVmQ291bnQ7IGkgKz0gMSkgewogICAgICAgIGF3YWl0IGFib3J0QnJlYWtQb2ludChvcHRzLnNpZ25hbCk7CiAgICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBsZXQgc3RhdHM7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICBpZiAoYmluID4gdGhpcy5tYXhCaW5OdW1iZXIpIHsKICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNCArIDggKyA0ICsgMTYgKyAxNjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGxvZmZzZXQgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA0KTsKICAgICAgICAgICAgdGhpcy5fZmluZEZpcnN0RGF0YShkYXRhLCBsb2Zmc2V0KTsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQgKyAxMik7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOCk7CiAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgICBjaHVua3Nba10gPSBuZXcgQ2h1bmsodSwgdiwgYmluKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkYXRhLmluZGljZXNbaV0gPSB7IGJpbkluZGV4LCBzdGF0cyB9OwogICAgICB9CiAgICAgIHJldHVybiBkYXRhOwogICAgfQogICAgcGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBsaW5lQ291bnQgPSBsb25nVG9OdW1iZXIoaW1wb3J0X2xvbmczLmRlZmF1bHQuZnJvbUJ5dGVzTEUoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMsIG9mZnNldCArIDI4LCBvZmZzZXQgKyAzNiksIHRydWUpKTsKICAgICAgcmV0dXJuIHsgbGluZUNvdW50IH07CiAgICB9CiAgICBhc3luYyBibG9ja3NGb3JSYW5nZShyZWZJZCwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgY29uc3QgYmEgPSBpbmRleERhdGEgPT09IG51bGwgfHwgaW5kZXhEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghYmEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdCaW5zID0gdGhpcy5yZWcyYmlucyhtaW4sIG1heCk7CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBvdmVybGFwcGluZ0JpbnMpIHsKICAgICAgICBmb3IgKGxldCBiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHsKICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7CiAgICAgICAgICAgIGNvbnN0IGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl07CiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYmluQ2h1bmtzLmxlbmd0aDsgKytjKSB7CiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IENodW5rKGJpbkNodW5rc1tjXS5taW52LCBiaW5DaHVua3NbY10ubWF4diwgYmluKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbmV3IFZpcnR1YWxPZmZzZXQoMCwgMCkpOwogICAgfQogICAgcmVnMmJpbnMoYmVnLCBlbmQpIHsKICAgICAgYmVnIC09IDE7CiAgICAgIGlmIChiZWcgPCAxKSB7CiAgICAgICAgYmVnID0gMTsKICAgICAgfQogICAgICBpZiAoZW5kID4gMiAqKiA1MCkgewogICAgICAgIGVuZCA9IDIgKiogMzQ7CiAgICAgIH0KICAgICAgZW5kIC09IDE7CiAgICAgIGxldCBsID0gMDsKICAgICAgbGV0IHQgPSAwOwogICAgICBsZXQgcyA9IHRoaXMubWluU2hpZnQgKyB0aGlzLmRlcHRoICogMzsKICAgICAgY29uc3QgYmlucyA9IFtdOwogICAgICBmb3IgKDsgbCA8PSB0aGlzLmRlcHRoOyBzIC09IDMsIHQgKz0gbHNoaWZ0KDEsIGwgKiAzKSwgbCArPSAxKSB7CiAgICAgICAgY29uc3QgYiA9IHQgKyByc2hpZnQoYmVnLCBzKTsKICAgICAgICBjb25zdCBlID0gdCArIHJzaGlmdChlbmQsIHMpOwogICAgICAgIGlmIChlIC0gYiArIGJpbnMubGVuZ3RoID4gdGhpcy5tYXhCaW5OdW1iZXIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcXVlcnkgJHtiZWd9LSR7ZW5kfSBpcyB0b28gbGFyZ2UgZm9yIGN1cnJlbnQgYmlubmluZyBzY2hlbWUgKHNoaWZ0ICR7dGhpcy5taW5TaGlmdH0sIGRlcHRoICR7dGhpcy5kZXB0aH0pLCB0cnkgYSBzbWFsbGVyIHF1ZXJ5IG9yIGEgY29hcnNlciBpbmRleCBiaW5uaW5nIHNjaGVtZWApOwogICAgICAgIH0KICAgICAgICBiaW5zLnB1c2goW2IsIGVdKTsKICAgICAgfQogICAgICByZXR1cm4gYmluczsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9iYW1GaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyX2NyYzMyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcl9jcmMzMigpKTsKICB2YXIgaW1wb3J0X29iamVjdCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9vYmplY3QoKSk7CiAgdmFyIGltcG9ydF9hYm9ydGFibGVfcHJvbWlzZV9jYWNoZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9lc20oKSk7CiAgdmFyIGltcG9ydF9xdWlja19scnUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfcXVpY2tfbHJ1KCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9yZWNvcmQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL2NvbnN0YW50cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgY29uc3RhbnRzX2RlZmF1bHQgPSB7CiAgICBCQU1fRlBBSVJFRDogMSwKICAgIEJBTV9GUFJPUEVSX1BBSVI6IDIsCiAgICBCQU1fRlVOTUFQOiA0LAogICAgQkFNX0ZNVU5NQVA6IDgsCiAgICBCQU1fRlJFVkVSU0U6IDE2LAogICAgQkFNX0ZNUkVWRVJTRTogMzIsCiAgICBCQU1fRlJFQUQxOiA2NCwKICAgIEJBTV9GUkVBRDI6IDEyOCwKICAgIEJBTV9GU0VDT05EQVJZOiAyNTYsCiAgICBCQU1fRlFDRkFJTDogNTEyLAogICAgQkFNX0ZEVVA6IDEwMjQsCiAgICBCQU1fRlNVUFBMRU1FTlRBUlk6IDIwNDgKICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9yZWNvcmQuanMKICB2YXIgU0VRUkVUX0RFQ09ERVIgPSAiPUFDTUdSU1ZUV1lIS0RCTiIuc3BsaXQoIiIpOwogIHZhciBDSUdBUl9ERUNPREVSID0gIk1JRE5TSFA9WD8/Pz8/Pz8iLnNwbGl0KCIiKTsKICB2YXIgQmFtUmVjb3JkID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoYXJncykgewogICAgICB0aGlzLmRhdGEgPSB7fTsKICAgICAgdGhpcy5fdGFnTGlzdCA9IFtdOwogICAgICB0aGlzLl9hbGxUYWdzUGFyc2VkID0gZmFsc2U7CiAgICAgIGNvbnN0IHsgYnl0ZXMsIGZpbGVPZmZzZXQgfSA9IGFyZ3M7CiAgICAgIGNvbnN0IHsgYnl0ZUFycmF5LCBzdGFydCB9ID0gYnl0ZXM7CiAgICAgIHRoaXMuZGF0YSA9IHt9OwogICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7CiAgICAgIHRoaXMuX2lkID0gZmlsZU9mZnNldDsKICAgICAgdGhpcy5fcmVmSUQgPSBieXRlQXJyYXkucmVhZEludDMyTEUoc3RhcnQgKyA0KTsKICAgICAgdGhpcy5kYXRhLnN0YXJ0ID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHN0YXJ0ICsgOCk7CiAgICAgIHRoaXMuZmxhZ3MgPSAoYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHN0YXJ0ICsgMTYpICYgNDI5NDkwMTc2MCkgPj4gMTY7CiAgICB9CiAgICBnZXQoZmllbGQpIHsKICAgICAgaWYgKHRoaXNbZmllbGRdKSB7CiAgICAgICAgaWYgKHRoaXMuZGF0YVtmaWVsZF0pIHsKICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgICAgIH0KICAgICAgICB0aGlzLmRhdGFbZmllbGRdID0gdGhpc1tmaWVsZF0oKTsKICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2ZpZWxkXTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5fZ2V0KGZpZWxkLnRvTG93ZXJDYXNlKCkpOwogICAgfQogICAgZW5kKCkgewogICAgICByZXR1cm4gdGhpcy5nZXQoInN0YXJ0IikgKyB0aGlzLmdldCgibGVuZ3RoX29uX3JlZiIpOwogICAgfQogICAgc2VxX2lkKCkgewogICAgICByZXR1cm4gdGhpcy5fcmVmSUQ7CiAgICB9CiAgICBfZ2V0KGZpZWxkKSB7CiAgICAgIGlmIChmaWVsZCBpbiB0aGlzLmRhdGEpIHsKICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2ZpZWxkXTsKICAgICAgfQogICAgICB0aGlzLmRhdGFbZmllbGRdID0gdGhpcy5fcGFyc2VUYWcoZmllbGQpOwogICAgICByZXR1cm4gdGhpcy5kYXRhW2ZpZWxkXTsKICAgIH0KICAgIF90YWdzKCkgewogICAgICB0aGlzLl9wYXJzZUFsbFRhZ3MoKTsKICAgICAgbGV0IHRhZ3MgPSBbInNlcSJdOwogICAgICBpZiAoIXRoaXMuaXNTZWdtZW50VW5tYXBwZWQoKSkgewogICAgICAgIHRhZ3MucHVzaCgic3RhcnQiLCAiZW5kIiwgInN0cmFuZCIsICJzY29yZSIsICJxdWFsIiwgIk1RIiwgIkNJR0FSIiwgImxlbmd0aF9vbl9yZWYiLCAidGVtcGxhdGVfbGVuZ3RoIik7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuaXNQYWlyZWQoKSkgewogICAgICAgIHRhZ3MucHVzaCgibmV4dF9zZWdtZW50X3Bvc2l0aW9uIiwgInBhaXJfb3JpZW50YXRpb24iKTsKICAgICAgfQogICAgICB0YWdzID0gdGFncy5jb25jYXQodGhpcy5fdGFnTGlzdCB8fCBbXSk7CiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaCgoaykgPT4gewogICAgICAgIGlmIChrWzBdICE9PSAiXyIgJiYgayAhPT0gIm5leHRfc2VxX2lkIikgewogICAgICAgICAgdGFncy5wdXNoKGspOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGNvbnN0IHNlZW4gPSB7fTsKICAgICAgcmV0dXJuIHRhZ3MuZmlsdGVyKCh0KSA9PiB7CiAgICAgICAgaWYgKHQgaW4gdGhpcy5kYXRhICYmIHRoaXMuZGF0YVt0XSA9PT0gdm9pZCAwIHx8IHQgPT09ICJDRyIgfHwgdCA9PT0gImNnIikgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBjb25zdCBsdCA9IHQudG9Mb3dlckNhc2UoKTsKICAgICAgICBjb25zdCBzID0gc2VlbltsdF07CiAgICAgICAgc2VlbltsdF0gPSB0cnVlOwogICAgICAgIHJldHVybiAhczsKICAgICAgfSk7CiAgICB9CiAgICBwYXJlbnQoKSB7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBjaGlsZHJlbigpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJzdWJmZWF0dXJlcyIpOwogICAgfQogICAgaWQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9pZDsKICAgIH0KICAgIG1xKCkgewogICAgICBjb25zdCBtcSA9ICh0aGlzLmdldCgiX2Jpbl9tcV9ubCIpICYgNjUyODApID4+IDg7CiAgICAgIHJldHVybiBtcSA9PT0gMjU1ID8gdm9pZCAwIDogbXE7CiAgICB9CiAgICBzY29yZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJtcSIpOwogICAgfQogICAgcXVhbCgpIHsKICAgICAgdmFyIF9hOwogICAgICByZXR1cm4gKF9hID0gdGhpcy5xdWFsUmF3KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2luKCIgIik7CiAgICB9CiAgICBxdWFsUmF3KCkgewogICAgICBpZiAodGhpcy5pc1NlZ21lbnRVbm1hcHBlZCgpKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBjb25zdCB7IHN0YXJ0LCBieXRlQXJyYXkgfSA9IHRoaXMuYnl0ZXM7CiAgICAgIGNvbnN0IHAgPSBzdGFydCArIDM2ICsgdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpICsgdGhpcy5nZXQoIl9uX2NpZ2FyX29wIikgKiA0ICsgdGhpcy5nZXQoIl9zZXFfYnl0ZXMiKTsKICAgICAgY29uc3QgbHNlcSA9IHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgIHJldHVybiBieXRlQXJyYXkuc3ViYXJyYXkocCwgcCArIGxzZXEpOwogICAgfQogICAgc3RyYW5kKCkgewogICAgICByZXR1cm4gdGhpcy5pc1JldmVyc2VDb21wbGVtZW50ZWQoKSA/IC0xIDogMTsKICAgIH0KICAgIG11bHRpX3NlZ21lbnRfbmV4dF9zZWdtZW50X3N0cmFuZCgpIHsKICAgICAgaWYgKHRoaXMuaXNNYXRlVW5tYXBwZWQoKSkgewogICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuaXNNYXRlUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gLTEgOiAxOwogICAgfQogICAgbmFtZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJfcmVhZF9uYW1lIik7CiAgICB9CiAgICBfcmVhZF9uYW1lKCkgewogICAgICBjb25zdCBubCA9IHRoaXMuZ2V0KCJfbF9yZWFkX25hbWUiKTsKICAgICAgY29uc3QgeyBieXRlQXJyYXksIHN0YXJ0IH0gPSB0aGlzLmJ5dGVzOwogICAgICByZXR1cm4gYnl0ZUFycmF5LnRvU3RyaW5nKCJhc2NpaSIsIHN0YXJ0ICsgMzYsIHN0YXJ0ICsgMzYgKyBubCAtIDEpOwogICAgfQogICAgX3BhcnNlVGFnKHRhZ05hbWUpIHsKICAgICAgaWYgKHRoaXMuX2FsbFRhZ3NQYXJzZWQpIHsKICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICB9CiAgICAgIGNvbnN0IHsgYnl0ZUFycmF5LCBzdGFydCB9ID0gdGhpcy5ieXRlczsKICAgICAgbGV0IHAgPSB0aGlzLl90YWdPZmZzZXQgfHwgc3RhcnQgKyAzNiArIHRoaXMuZ2V0KCJfbF9yZWFkX25hbWUiKSArIHRoaXMuZ2V0KCJfbl9jaWdhcl9vcCIpICogNCArIHRoaXMuZ2V0KCJfc2VxX2J5dGVzIikgKyB0aGlzLmdldCgic2VxX2xlbmd0aCIpOwogICAgICBjb25zdCBibG9ja0VuZCA9IHRoaXMuYnl0ZXMuZW5kOwogICAgICBsZXQgbGNUYWc7CiAgICAgIHdoaWxlIChwIDwgYmxvY2tFbmQgJiYgbGNUYWcgIT09IHRhZ05hbWUpIHsKICAgICAgICBjb25zdCB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVBcnJheVtwXSwgYnl0ZUFycmF5W3AgKyAxXSk7CiAgICAgICAgbGNUYWcgPSB0YWcudG9Mb3dlckNhc2UoKTsKICAgICAgICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlQXJyYXlbcCArIDJdKTsKICAgICAgICBwICs9IDM7CiAgICAgICAgbGV0IHZhbHVlOwogICAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgICAgY2FzZSAiQSI6CiAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlQXJyYXlbcF0pOwogICAgICAgICAgICBwICs9IDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiaSI6CiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiSSI6CiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRVSW50MzJMRShwKTsKICAgICAgICAgICAgcCArPSA0OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgImMiOgogICAgICAgICAgICB2YWx1ZSA9IGJ5dGVBcnJheS5yZWFkSW50OChwKTsKICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgIkMiOgogICAgICAgICAgICB2YWx1ZSA9IGJ5dGVBcnJheS5yZWFkVUludDgocCk7CiAgICAgICAgICAgIHAgKz0gMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJzIjoKICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZEludDE2TEUocCk7CiAgICAgICAgICAgIHAgKz0gMjsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJTIjoKICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZFVJbnQxNkxFKHApOwogICAgICAgICAgICBwICs9IDI7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiZiI6CiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRGbG9hdExFKHApOwogICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiWiI6CiAgICAgICAgICBjYXNlICJIIjoKICAgICAgICAgICAgdmFsdWUgPSAiIjsKICAgICAgICAgICAgd2hpbGUgKHAgPD0gYmxvY2tFbmQpIHsKICAgICAgICAgICAgICBjb25zdCBjYyA9IGJ5dGVBcnJheVtwKytdOwogICAgICAgICAgICAgIGlmIChjYyA9PT0gMCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgIkIiOiB7CiAgICAgICAgICAgIHZhbHVlID0gIiI7CiAgICAgICAgICAgIGNvbnN0IGNjID0gYnl0ZUFycmF5W3ArK107CiAgICAgICAgICAgIGNvbnN0IEJ0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShjYyk7CiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgIGlmIChCdHlwZSA9PT0gImkiKSB7CiAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gIkNHIikgewogICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgICBjb25zdCBsb3AgPSBjaWdvcCA+PiA0OwogICAgICAgICAgICAgICAgICBjb25zdCBvcCA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAxNV07CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGxvcCArIG9wOwogICAgICAgICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGltaXQ7IGsrKykgewogICAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgIGlmIChrICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiSSIpIHsKICAgICAgICAgICAgICBpZiAodGFnID09PSAiQ0ciKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbWl0OyBrKyspIHsKICAgICAgICAgICAgICAgICAgY29uc3QgY2lnb3AgPSBieXRlQXJyYXkucmVhZFVJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgICBjb25zdCBsb3AgPSBjaWdvcCA+PiA0OwogICAgICAgICAgICAgICAgICBjb25zdCBvcCA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAxNV07CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGxvcCArIG9wOwogICAgICAgICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGltaXQ7IGsrKykgewogICAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZFVJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgICBpZiAoayArIDEgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChCdHlwZSA9PT0gInMiKSB7CiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZEludDE2TEUocCk7CiAgICAgICAgICAgICAgICBpZiAoayArIDEgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICB2YWx1ZSArPSAiLCI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBwICs9IDI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChCdHlwZSA9PT0gIlMiKSB7CiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZFVJbnQxNkxFKHApOwogICAgICAgICAgICAgICAgaWYgKGsgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcCArPSAyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoQnR5cGUgPT09ICJjIikgewogICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGltaXQ7IGsrKykgewogICAgICAgICAgICAgICAgdmFsdWUgKz0gYnl0ZUFycmF5LnJlYWRJbnQ4KHApOwogICAgICAgICAgICAgICAgaWYgKGsgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoQnR5cGUgPT09ICJDIikgewogICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGltaXQ7IGsrKykgewogICAgICAgICAgICAgICAgdmFsdWUgKz0gYnl0ZUFycmF5LnJlYWRVSW50OChwKTsKICAgICAgICAgICAgICAgIGlmIChrICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHAgKz0gMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiZiIpIHsKICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbWl0OyBrKyspIHsKICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkRmxvYXRMRShwKTsKICAgICAgICAgICAgICAgIGlmIChrICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gQkFNIHRhZyB0eXBlICcke3R5cGV9JywgdGFncyBtYXkgYmUgaW5jb21wbGV0ZWApOwogICAgICAgICAgICB2YWx1ZSA9IHZvaWQgMDsKICAgICAgICAgICAgcCA9IGJsb2NrRW5kOwogICAgICAgIH0KICAgICAgICB0aGlzLl90YWdPZmZzZXQgPSBwOwogICAgICAgIHRoaXMuX3RhZ0xpc3QucHVzaCh0YWcpOwogICAgICAgIGlmIChsY1RhZyA9PT0gdGFnTmFtZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgIH0KICAgICAgICB0aGlzLmRhdGFbbGNUYWddID0gdmFsdWU7CiAgICAgIH0KICAgICAgdGhpcy5fYWxsVGFnc1BhcnNlZCA9IHRydWU7CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBfcGFyc2VBbGxUYWdzKCkgewogICAgICB0aGlzLl9wYXJzZVRhZygiIik7CiAgICB9CiAgICBfcGFyc2VDaWdhcihjaWdhcikgewogICAgICByZXR1cm4gY2lnYXIubWF0Y2goL1xkK1xEL2cpLm1hcCgob3ApID0+IFtvcC5tYXRjaCgvXEQvKVswXS50b1VwcGVyQ2FzZSgpLCBwYXJzZUludChvcCwgMTApXSk7CiAgICB9CiAgICBpc1BhaXJlZCgpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRlBBSVJFRCk7CiAgICB9CiAgICBpc1Byb3Blcmx5UGFpcmVkKCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GUFJPUEVSX1BBSVIpOwogICAgfQogICAgaXNTZWdtZW50VW5tYXBwZWQoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZVTk1BUCk7CiAgICB9CiAgICBpc01hdGVVbm1hcHBlZCgpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRk1VTk1BUCk7CiAgICB9CiAgICBpc1JldmVyc2VDb21wbGVtZW50ZWQoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZSRVZFUlNFKTsKICAgIH0KICAgIGlzTWF0ZVJldmVyc2VDb21wbGVtZW50ZWQoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZNUkVWRVJTRSk7CiAgICB9CiAgICBpc1JlYWQxKCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GUkVBRDEpOwogICAgfQogICAgaXNSZWFkMigpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRlJFQUQyKTsKICAgIH0KICAgIGlzU2Vjb25kYXJ5KCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GU0VDT05EQVJZKTsKICAgIH0KICAgIGlzRmFpbGVkUWMoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZRQ0ZBSUwpOwogICAgfQogICAgaXNEdXBsaWNhdGUoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZEVVApOwogICAgfQogICAgaXNTdXBwbGVtZW50YXJ5KCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GU1VQUExFTUVOVEFSWSk7CiAgICB9CiAgICBjaWdhcigpIHsKICAgICAgaWYgKHRoaXMuaXNTZWdtZW50VW5tYXBwZWQoKSkgewogICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgICAgY29uc3QgeyBieXRlQXJyYXksIHN0YXJ0IH0gPSB0aGlzLmJ5dGVzOwogICAgICBjb25zdCBudW1DaWdhck9wcyA9IHRoaXMuZ2V0KCJfbl9jaWdhcl9vcCIpOwogICAgICBsZXQgcCA9IHN0YXJ0ICsgMzYgKyB0aGlzLmdldCgiX2xfcmVhZF9uYW1lIik7CiAgICAgIGNvbnN0IHNlcUxlbiA9IHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgIGxldCBjaWdhciA9ICIiOwogICAgICBsZXQgbHJlZiA9IDA7CiAgICAgIGxldCBjaWdvcCA9IGJ5dGVBcnJheS5yZWFkSW50MzJMRShwKTsKICAgICAgbGV0IGxvcCA9IGNpZ29wID4+IDQ7CiAgICAgIGxldCBvcCA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAxNV07CiAgICAgIGlmIChvcCA9PT0gIlMiICYmIGxvcCA9PT0gc2VxTGVuKSB7CiAgICAgICAgcCArPSA0OwogICAgICAgIGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgIGxvcCA9IGNpZ29wID4+IDQ7CiAgICAgICAgb3AgPSBDSUdBUl9ERUNPREVSW2NpZ29wICYgMTVdOwogICAgICAgIGlmIChvcCAhPT0gIk4iKSB7CiAgICAgICAgICBjb25zb2xlLndhcm4oIkNHIHRhZyB3aXRoIG5vIE4gdGFnIik7CiAgICAgICAgfQogICAgICAgIHRoaXMuZGF0YS5sZW5ndGhfb25fcmVmID0gbG9wOwogICAgICAgIHJldHVybiB0aGlzLmdldCgiQ0ciKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG51bUNpZ2FyT3BzOyArK2MpIHsKICAgICAgICAgIGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgbG9wID0gY2lnb3AgPj4gNDsKICAgICAgICAgIG9wID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDE1XTsKICAgICAgICAgIGNpZ2FyICs9IGxvcCArIG9wOwogICAgICAgICAgaWYgKG9wICE9PSAiSCIgJiYgb3AgIT09ICJTIiAmJiBvcCAhPT0gIkkiKSB7CiAgICAgICAgICAgIGxyZWYgKz0gbG9wOwogICAgICAgICAgfQogICAgICAgICAgcCArPSA0OwogICAgICAgIH0KICAgICAgICB0aGlzLmRhdGEubGVuZ3RoX29uX3JlZiA9IGxyZWY7CiAgICAgICAgcmV0dXJuIGNpZ2FyOwogICAgICB9CiAgICB9CiAgICBfZmxhZ3MoKSB7CiAgICB9CiAgICBsZW5ndGhfb25fcmVmKCkgewogICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aF9vbl9yZWYpIHsKICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aF9vbl9yZWY7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5nZXQoImNpZ2FyIik7CiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGhfb25fcmVmOwogICAgICB9CiAgICB9CiAgICBfbl9jaWdhcl9vcCgpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJfZmxhZ19uYyIpICYgNjU1MzU7CiAgICB9CiAgICBfbF9yZWFkX25hbWUoKSB7CiAgICAgIHJldHVybiB0aGlzLmdldCgiX2Jpbl9tcV9ubCIpICYgMjU1OwogICAgfQogICAgX3NlcV9ieXRlcygpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIikgKyAxID4+IDE7CiAgICB9CiAgICBnZXRSZWFkQmFzZXMoKSB7CiAgICAgIHJldHVybiB0aGlzLnNlcSgpOwogICAgfQogICAgc2VxKCkgewogICAgICBjb25zdCB7IGJ5dGVBcnJheSwgc3RhcnQgfSA9IHRoaXMuYnl0ZXM7CiAgICAgIGNvbnN0IHAgPSBzdGFydCArIDM2ICsgdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpICsgdGhpcy5nZXQoIl9uX2NpZ2FyX29wIikgKiA0OwogICAgICBjb25zdCBzZXFCeXRlcyA9IHRoaXMuZ2V0KCJfc2VxX2J5dGVzIik7CiAgICAgIGNvbnN0IGxlbiA9IHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgIGxldCBidWYgPSAiIjsKICAgICAgbGV0IGkgPSAwOwogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlcUJ5dGVzOyArK2opIHsKICAgICAgICBjb25zdCBzYiA9IGJ5dGVBcnJheVtwICsgal07CiAgICAgICAgYnVmICs9IFNFUVJFVF9ERUNPREVSWyhzYiAmIDI0MCkgPj4gNF07CiAgICAgICAgaSsrOwogICAgICAgIGlmIChpIDwgbGVuKSB7CiAgICAgICAgICBidWYgKz0gU0VRUkVUX0RFQ09ERVJbc2IgJiAxNV07CiAgICAgICAgICBpKys7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBidWY7CiAgICB9CiAgICBnZXRQYWlyT3JpZW50YXRpb24oKSB7CiAgICAgIGlmICghdGhpcy5pc1NlZ21lbnRVbm1hcHBlZCgpICYmICF0aGlzLmlzTWF0ZVVubWFwcGVkKCkgJiYgdGhpcy5fcmVmSUQgPT09IHRoaXMuX25leHRfcmVmaWQoKSkgewogICAgICAgIGNvbnN0IHMxID0gdGhpcy5pc1JldmVyc2VDb21wbGVtZW50ZWQoKSA/ICJSIiA6ICJGIjsKICAgICAgICBjb25zdCBzMiA9IHRoaXMuaXNNYXRlUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gIlIiIDogIkYiOwogICAgICAgIGxldCBvMSA9ICIgIjsKICAgICAgICBsZXQgbzIgPSAiICI7CiAgICAgICAgaWYgKHRoaXMuaXNSZWFkMSgpKSB7CiAgICAgICAgICBvMSA9ICIxIjsKICAgICAgICAgIG8yID0gIjIiOwogICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlYWQyKCkpIHsKICAgICAgICAgIG8xID0gIjIiOwogICAgICAgICAgbzIgPSAiMSI7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHRtcCA9IFtdOwogICAgICAgIGNvbnN0IGlzaXplID0gdGhpcy50ZW1wbGF0ZV9sZW5ndGgoKTsKICAgICAgICBpZiAoaXNpemUgPiAwKSB7CiAgICAgICAgICB0bXBbMF0gPSBzMTsKICAgICAgICAgIHRtcFsxXSA9IG8xOwogICAgICAgICAgdG1wWzJdID0gczI7CiAgICAgICAgICB0bXBbM10gPSBvMjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdG1wWzJdID0gczE7CiAgICAgICAgICB0bXBbM10gPSBvMTsKICAgICAgICAgIHRtcFswXSA9IHMyOwogICAgICAgICAgdG1wWzFdID0gbzI7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0bXAuam9pbigiIik7CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBfYmluX21xX25sKCkgewogICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkucmVhZEludDMyTEUodGhpcy5ieXRlcy5zdGFydCArIDEyKTsKICAgIH0KICAgIF9mbGFnX25jKCkgewogICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkucmVhZEludDMyTEUodGhpcy5ieXRlcy5zdGFydCArIDE2KTsKICAgIH0KICAgIHNlcV9sZW5ndGgoKSB7CiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMjApOwogICAgfQogICAgX25leHRfcmVmaWQoKSB7CiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMjQpOwogICAgfQogICAgX25leHRfcG9zKCkgewogICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkucmVhZEludDMyTEUodGhpcy5ieXRlcy5zdGFydCArIDI4KTsKICAgIH0KICAgIHRlbXBsYXRlX2xlbmd0aCgpIHsKICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHRoaXMuYnl0ZXMuc3RhcnQgKyAzMik7CiAgICB9CiAgICB0b0pTT04oKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB7fTsKICAgICAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaCgoaykgPT4gewogICAgICAgIGlmIChrLmNoYXJBdCgwKSA9PT0gIl8iIHx8IGsgPT09ICJieXRlcyIpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZGF0YVtrXSA9IHRoaXNba107CiAgICAgIH0pOwogICAgICByZXR1cm4gZGF0YTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9zYW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJUZXh0KHRleHQpIHsKICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgvXHI/XG4vKTsKICAgIGNvbnN0IGRhdGEgPSBbXTsKICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHsKICAgICAgY29uc3QgW3RhZywgLi4uZmllbGRzXSA9IGxpbmUuc3BsaXQoL1x0Lyk7CiAgICAgIGNvbnN0IHBhcnNlZEZpZWxkcyA9IGZpZWxkcy5tYXAoKGYpID0+IHsKICAgICAgICBjb25zdCBbZmllbGRUYWcsIHZhbHVlXSA9IGYuc3BsaXQoIjoiLCAyKTsKICAgICAgICByZXR1cm4geyB0YWc6IGZpZWxkVGFnLCB2YWx1ZSB9OwogICAgICB9KTsKICAgICAgaWYgKHRhZykgewogICAgICAgIGRhdGEucHVzaCh7IHRhZzogdGFnLnN1YnN0cigxKSwgZGF0YTogcGFyc2VkRmllbGRzIH0pOwogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBkYXRhOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vYmFtRmlsZS5qcwogIHZhciBCQU1fTUFHSUMgPSAyMTg0MDE5NDsKICB2YXIgYmxvY2tMZW4gPSAxIDw8IDE2OwogIGZ1bmN0aW9uIGZsYXQoYXJyKSB7CiAgICByZXR1cm4gW10uY29uY2F0KC4uLmFycik7CiAgfQogIGFzeW5jIGZ1bmN0aW9uIGdlbjJhcnJheShnZW4pIHsKICAgIGNvbnN0IG91dCA9IFtdOwogICAgZm9yIGF3YWl0IChjb25zdCB4IG9mIGdlbikgewogICAgICBvdXQucHVzaCh4KTsKICAgIH0KICAgIHJldHVybiBvdXQ7CiAgfQogIHZhciBCYW1GaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoeyBiYW1GaWxlaGFuZGxlLCBiYW1QYXRoLCBiYW1VcmwsIGJhaVBhdGgsIGJhaUZpbGVoYW5kbGUsIGJhaVVybCwgY3NpUGF0aCwgY3NpRmlsZWhhbmRsZSwgY3NpVXJsLCBmZXRjaFNpemVMaW1pdCwgY2h1bmtTaXplTGltaXQsIHlpZWxkVGhyZWFkVGltZSA9IDEwMCwgcmVuYW1lUmVmU2VxcyA9IChuKSA9PiBuIH0pIHsKICAgICAgdGhpcy5mZWF0dXJlQ2FjaGUgPSBuZXcgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlLmRlZmF1bHQoewogICAgICAgIGNhY2hlOiBuZXcgaW1wb3J0X3F1aWNrX2xydS5kZWZhdWx0KHsKICAgICAgICAgIG1heFNpemU6IDUwCiAgICAgICAgfSksCiAgICAgICAgZmlsbDogYXN5bmMgKHsgY2h1bmssIG9wdHMgfSwgc2lnbmFsKSA9PiB7CiAgICAgICAgICBjb25zdCB7IGRhdGEsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSA9IGF3YWl0IHRoaXMuX3JlYWRDaHVuayh7CiAgICAgICAgICAgIGNodW5rLAogICAgICAgICAgICBvcHRzOiB7IC4uLm9wdHMsIHNpZ25hbCB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0IGZlYXRzID0gYXdhaXQgdGhpcy5yZWFkQmFtRmVhdHVyZXMoZGF0YSwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgY2h1bmspOwogICAgICAgICAgcmV0dXJuIGZlYXRzOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgICAgaWYgKGJhbUZpbGVoYW5kbGUpIHsKICAgICAgICB0aGlzLmJhbSA9IGJhbUZpbGVoYW5kbGU7CiAgICAgIH0gZWxzZSBpZiAoYmFtUGF0aCkgewogICAgICAgIHRoaXMuYmFtID0gbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChiYW1QYXRoKTsKICAgICAgfSBlbHNlIGlmIChiYW1VcmwpIHsKICAgICAgICB0aGlzLmJhbSA9IG5ldyBSZW1vdGVGaWxlKGJhbVVybCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gaW5pdGlhbGl6ZSBiYW0iKTsKICAgICAgfQogICAgICBpZiAoY3NpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHsgZmlsZWhhbmRsZTogY3NpRmlsZWhhbmRsZSB9KTsKICAgICAgfSBlbHNlIGlmIChjc2lQYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koeyBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KGNzaVBhdGgpIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaVVybCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHsgZmlsZWhhbmRsZTogbmV3IFJlbW90ZUZpbGUoY3NpVXJsKSB9KTsKICAgICAgfSBlbHNlIGlmIChiYWlGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBCQUkoeyBmaWxlaGFuZGxlOiBiYWlGaWxlaGFuZGxlIH0pOwogICAgICB9IGVsc2UgaWYgKGJhaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IEJBSSh7IGZpbGVoYW5kbGU6IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQoYmFpUGF0aCkgfSk7CiAgICAgIH0gZWxzZSBpZiAoYmFpVXJsKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBCQUkoeyBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZShiYWlVcmwpIH0pOwogICAgICB9IGVsc2UgaWYgKGJhbVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IEJBSSh7IGZpbGVoYW5kbGU6IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQoYCR7YmFtUGF0aH0uYmFpYCkgfSk7CiAgICAgIH0gZWxzZSBpZiAoYmFtVXJsKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBCQUkoeyBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZShgJHtiYW1Vcmx9LmJhaWApIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGluZmVyIGluZGV4IGZvcm1hdCIpOwogICAgICB9CiAgICAgIHRoaXMuZmV0Y2hTaXplTGltaXQgPSBmZXRjaFNpemVMaW1pdCB8fCA1ZTg7CiAgICAgIHRoaXMuY2h1bmtTaXplTGltaXQgPSBjaHVua1NpemVMaW1pdCB8fCAzZTg7CiAgICAgIHRoaXMueWllbGRUaHJlYWRUaW1lID0geWllbGRUaHJlYWRUaW1lOwogICAgfQogICAgYXN5bmMgZ2V0SGVhZGVyKG9yaWdPcHRzID0ge30pIHsKICAgICAgY29uc3Qgb3B0cyA9IG1ha2VPcHRzKG9yaWdPcHRzKTsKICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5pbmRleC5wYXJzZShvcHRzKTsKICAgICAgY29uc3QgcmV0ID0gaW5kZXhEYXRhLmZpcnN0RGF0YUxpbmUgPyBpbmRleERhdGEuZmlyc3REYXRhTGluZS5ibG9ja1Bvc2l0aW9uICsgNjU1MzUgOiB2b2lkIDA7CiAgICAgIGxldCBidWZmZXI7CiAgICAgIGlmIChyZXQpIHsKICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmJhbS5yZWFkKGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jKHJldCArIGJsb2NrTGVuKSwgMCwgcmV0ICsgYmxvY2tMZW4sIDAsIG9wdHMpOwogICAgICAgIGNvbnN0IHsgYnl0ZXNSZWFkIH0gPSByZXM7CiAgICAgICAgKHsgYnVmZmVyIH0gPSByZXMpOwogICAgICAgIGlmICghYnl0ZXNSZWFkKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkVycm9yIHJlYWRpbmcgaGVhZGVyIik7CiAgICAgICAgfQogICAgICAgIGlmIChieXRlc1JlYWQgPCByZXQpIHsKICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgwLCBieXRlc1JlYWQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoMCwgcmV0KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnVmZmVyID0gYXdhaXQgdGhpcy5iYW0ucmVhZEZpbGUob3B0cyk7CiAgICAgIH0KICAgICAgY29uc3QgdW5jYmEgPSBhd2FpdCB1bnppcChidWZmZXIpOwogICAgICBpZiAodW5jYmEucmVhZEludDMyTEUoMCkgIT09IEJBTV9NQUdJQykgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTm90IGEgQkFNIGZpbGUiKTsKICAgICAgfQogICAgICBjb25zdCBoZWFkTGVuID0gdW5jYmEucmVhZEludDMyTEUoNCk7CiAgICAgIHRoaXMuaGVhZGVyID0gdW5jYmEudG9TdHJpbmcoInV0ZjgiLCA4LCA4ICsgaGVhZExlbik7CiAgICAgIGNvbnN0IHsgY2hyVG9JbmRleCwgaW5kZXhUb0NociB9ID0gYXdhaXQgdGhpcy5fcmVhZFJlZlNlcXMoaGVhZExlbiArIDgsIDY1NTM1LCBvcHRzKTsKICAgICAgdGhpcy5jaHJUb0luZGV4ID0gY2hyVG9JbmRleDsKICAgICAgdGhpcy5pbmRleFRvQ2hyID0gaW5kZXhUb0NocjsKICAgICAgcmV0dXJuIHBhcnNlSGVhZGVyVGV4dCh0aGlzLmhlYWRlcik7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXJUZXh0KG9wdHMgPSB7fSkgewogICAgICBhd2FpdCB0aGlzLmdldEhlYWRlcihvcHRzKTsKICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyOwogICAgfQogICAgYXN5bmMgX3JlYWRSZWZTZXFzKHN0YXJ0LCByZWZTZXFCeXRlcywgb3B0cyA9IHt9KSB7CiAgICAgIGlmIChzdGFydCA+IHJlZlNlcUJ5dGVzKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRSZWZTZXFzKHN0YXJ0LCByZWZTZXFCeXRlcyAqIDIsIG9wdHMpOwogICAgICB9CiAgICAgIGNvbnN0IHNpemUgPSByZWZTZXFCeXRlcyArIGJsb2NrTGVuOwogICAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmJhbS5yZWFkKGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jKHNpemUpLCAwLCByZWZTZXFCeXRlcywgMCwgb3B0cyk7CiAgICAgIGlmICghYnl0ZXNSZWFkKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJFcnJvciByZWFkaW5nIHJlZnNlcXMgZnJvbSBoZWFkZXIiKTsKICAgICAgfQogICAgICBjb25zdCB1bmNiYSA9IGF3YWl0IHVuemlwKGJ1ZmZlci5zdWJhcnJheSgwLCBNYXRoLm1pbihieXRlc1JlYWQsIHJlZlNlcUJ5dGVzKSkpOwogICAgICBjb25zdCBuUmVmID0gdW5jYmEucmVhZEludDMyTEUoc3RhcnQpOwogICAgICBsZXQgcCA9IHN0YXJ0ICsgNDsKICAgICAgY29uc3QgY2hyVG9JbmRleCA9IHt9OwogICAgICBjb25zdCBpbmRleFRvQ2hyID0gW107CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblJlZjsgaSArPSAxKSB7CiAgICAgICAgY29uc3QgbE5hbWUgPSB1bmNiYS5yZWFkSW50MzJMRShwKTsKICAgICAgICBjb25zdCByZWZOYW1lID0gdGhpcy5yZW5hbWVSZWZTZXEodW5jYmEudG9TdHJpbmcoInV0ZjgiLCBwICsgNCwgcCArIDQgKyBsTmFtZSAtIDEpKTsKICAgICAgICBjb25zdCBsUmVmID0gdW5jYmEucmVhZEludDMyTEUocCArIGxOYW1lICsgNCk7CiAgICAgICAgY2hyVG9JbmRleFtyZWZOYW1lXSA9IGk7CiAgICAgICAgaW5kZXhUb0Noci5wdXNoKHsgcmVmTmFtZSwgbGVuZ3RoOiBsUmVmIH0pOwogICAgICAgIHAgPSBwICsgOCArIGxOYW1lOwogICAgICAgIGlmIChwID4gdW5jYmEubGVuZ3RoKSB7CiAgICAgICAgICBjb25zb2xlLndhcm4oYEJBTSBoZWFkZXIgaXMgdmVyeSBiaWcuICBSZS1mZXRjaGluZyAke3JlZlNlcUJ5dGVzfSBieXRlcy5gKTsKICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkUmVmU2VxcyhzdGFydCwgcmVmU2VxQnl0ZXMgKiAyLCBvcHRzKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgY2hyVG9JbmRleCwgaW5kZXhUb0NociB9OwogICAgfQogICAgYXN5bmMgZ2V0UmVjb3Jkc0ZvclJhbmdlKGNociwgbWluLCBtYXgsIG9wdHMgPSB7CiAgICAgIHZpZXdBc1BhaXJzOiBmYWxzZSwKICAgICAgcGFpckFjcm9zc0NocjogZmFsc2UsCiAgICAgIG1heEluc2VydFNpemU6IDJlNQogICAgfSkgewogICAgICByZXR1cm4gZmxhdChhd2FpdCBnZW4yYXJyYXkodGhpcy5zdHJlYW1SZWNvcmRzRm9yUmFuZ2UoY2hyLCBtaW4sIG1heCwgb3B0cykpKTsKICAgIH0KICAgIGFzeW5jICpzdHJlYW1SZWNvcmRzRm9yUmFuZ2UoY2hyLCBtaW4sIG1heCwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRzOwogICAgICBjb25zdCBjaHJJZCA9IHRoaXMuY2hyVG9JbmRleCAmJiB0aGlzLmNoclRvSW5kZXhbY2hyXTsKICAgICAgbGV0IGNodW5rczsKICAgICAgaWYgKCEoY2hySWQgPj0gMCkpIHsKICAgICAgICBjaHVua3MgPSBbXTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjaHVua3MgPSBhd2FpdCB0aGlzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKGNocklkLCBtaW4gLSAxLCBtYXgsIG9wdHMpOwogICAgICAgIGlmICghY2h1bmtzKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkVycm9yIGluIGluZGV4IGZldGNoIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgYXdhaXQgYWJvcnRCcmVha1BvaW50KHNpZ25hbCk7CiAgICAgICAgY29uc3Qgc2l6ZSA9IGNodW5rc1tpXS5mZXRjaGVkU2l6ZSgpOwogICAgICAgIGlmIChzaXplID4gdGhpcy5jaHVua1NpemVMaW1pdCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbWFueSBCQU0gZmVhdHVyZXMuIEJBTSBjaHVuayBzaXplICR7c2l6ZX0gYnl0ZXMgZXhjZWVkcyBjaHVua1NpemVMaW1pdCBvZiAke3RoaXMuY2h1bmtTaXplTGltaXR9YCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGNodW5rcy5tYXAoKHMpID0+IHMuZmV0Y2hlZFNpemUoKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7CiAgICAgIGlmICh0b3RhbFNpemUgPiB0aGlzLmZldGNoU2l6ZUxpbWl0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkYXRhIHNpemUgb2YgJHt0b3RhbFNpemUudG9Mb2NhbGVTdHJpbmcoKX0gYnl0ZXMgZXhjZWVkZWQgZmV0Y2ggc2l6ZSBsaW1pdCBvZiAke3RoaXMuZmV0Y2hTaXplTGltaXQudG9Mb2NhbGVTdHJpbmcoKX0gYnl0ZXNgKTsKICAgICAgfQogICAgICB5aWVsZCogdGhpcy5fZmV0Y2hDaHVua0ZlYXR1cmVzKGNodW5rcywgY2hySWQsIG1pbiwgbWF4LCBvcHRzKTsKICAgIH0KICAgIGFzeW5jICpfZmV0Y2hDaHVua0ZlYXR1cmVzKGNodW5rcywgY2hySWQsIG1pbiwgbWF4LCBvcHRzKSB7CiAgICAgIGNvbnN0IHsgdmlld0FzUGFpcnMgPSBmYWxzZSB9ID0gb3B0czsKICAgICAgY29uc3QgZmVhdHMgPSBbXTsKICAgICAgbGV0IGRvbmUgPSBmYWxzZTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBjID0gY2h1bmtzW2ldOwogICAgICAgIGNvbnN0IHJlY29yZHMgPSBhd2FpdCB0aGlzLmZlYXR1cmVDYWNoZS5nZXQoYy50b1N0cmluZygpLCB7CiAgICAgICAgICBjaHVuazogYywKICAgICAgICAgIG9wdHMKICAgICAgICB9LCBvcHRzLnNpZ25hbCk7CiAgICAgICAgY29uc3QgcmVjcyA9IFtdOwogICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCByZWNvcmRzLmxlbmd0aDsgaTIgKz0gMSkgewogICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHJlY29yZHNbaTJdOwogICAgICAgICAgaWYgKGZlYXR1cmUuc2VxX2lkKCkgPT09IGNocklkKSB7CiAgICAgICAgICAgIGlmIChmZWF0dXJlLmdldCgic3RhcnQiKSA+PSBtYXgpIHsKICAgICAgICAgICAgICBkb25lID0gdHJ1ZTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLmdldCgiZW5kIikgPj0gbWluKSB7CiAgICAgICAgICAgICAgcmVjcy5wdXNoKGZlYXR1cmUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZlYXRzLnB1c2gocmVjcyk7CiAgICAgICAgeWllbGQgcmVjczsKICAgICAgICBpZiAoZG9uZSkgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpOwogICAgICBpZiAodmlld0FzUGFpcnMpIHsKICAgICAgICB5aWVsZCB0aGlzLmZldGNoUGFpcnMoY2hySWQsIGZlYXRzLCBvcHRzKTsKICAgICAgfQogICAgfQogICAgYXN5bmMgZmV0Y2hQYWlycyhjaHJJZCwgZmVhdHMsIG9wdHMpIHsKICAgICAgY29uc3QgeyBwYWlyQWNyb3NzQ2hyID0gZmFsc2UsIG1heEluc2VydFNpemUgPSAyZTUgfSA9IG9wdHM7CiAgICAgIGNvbnN0IHVubWF0ZWRQYWlycyA9IHt9OwogICAgICBjb25zdCByZWFkSWRzID0ge307CiAgICAgIGZlYXRzLm1hcCgocmV0KSA9PiB7CiAgICAgICAgY29uc3QgcmVhZE5hbWVzID0ge307CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IG5hbWUgPSByZXRbaV0ubmFtZSgpOwogICAgICAgICAgY29uc3QgaWQgPSByZXRbaV0uaWQoKTsKICAgICAgICAgIGlmICghcmVhZE5hbWVzW25hbWVdKSB7CiAgICAgICAgICAgIHJlYWROYW1lc1tuYW1lXSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICByZWFkTmFtZXNbbmFtZV0rKzsKICAgICAgICAgIHJlYWRJZHNbaWRdID0gMTsKICAgICAgICB9CiAgICAgICAgKDAsIGltcG9ydF9vYmplY3QuZGVmYXVsdCkocmVhZE5hbWVzKS5mb3JFYWNoKChbaywgdl0pID0+IHsKICAgICAgICAgIGlmICh2ID09PSAxKSB7CiAgICAgICAgICAgIHVubWF0ZWRQYWlyc1trXSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgICBjb25zdCBtYXRlUHJvbWlzZXMgPSBbXTsKICAgICAgZmVhdHMubWFwKChyZXQpID0+IHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykgewogICAgICAgICAgY29uc3QgZiA9IHJldFtpXTsKICAgICAgICAgIGNvbnN0IG5hbWUgPSBmLm5hbWUoKTsKICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZi5nZXQoInN0YXJ0Iik7CiAgICAgICAgICBjb25zdCBwbmV4dCA9IGYuX25leHRfcG9zKCk7CiAgICAgICAgICBjb25zdCBybmV4dCA9IGYuX25leHRfcmVmaWQoKTsKICAgICAgICAgIGlmICh1bm1hdGVkUGFpcnNbbmFtZV0gJiYgKHBhaXJBY3Jvc3NDaHIgfHwgcm5leHQgPT09IGNocklkICYmIE1hdGguYWJzKHN0YXJ0IC0gcG5leHQpIDwgbWF4SW5zZXJ0U2l6ZSkpIHsKICAgICAgICAgICAgbWF0ZVByb21pc2VzLnB1c2godGhpcy5pbmRleC5ibG9ja3NGb3JSYW5nZShybmV4dCwgcG5leHQsIHBuZXh0ICsgMSwgb3B0cykpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGNvbnN0IG1hdGVDaHVua3MgPSBmbGF0KGF3YWl0IFByb21pc2UuYWxsKG1hdGVQcm9taXNlcykpLnNvcnQoKS5maWx0ZXIoKGl0ZW0sIHBvcywgYXJ5KSA9PiAhcG9zIHx8IGl0ZW0udG9TdHJpbmcoKSAhPT0gYXJ5W3BvcyAtIDFdLnRvU3RyaW5nKCkpOwogICAgICBjb25zdCBtYXRlVG90YWxTaXplID0gbWF0ZUNodW5rcy5tYXAoKHMpID0+IHMuZmV0Y2hlZFNpemUoKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7CiAgICAgIGlmIChtYXRlVG90YWxTaXplID4gdGhpcy5mZXRjaFNpemVMaW1pdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgZGF0YSBzaXplIG9mICR7bWF0ZVRvdGFsU2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlcyBleGNlZWRlZCBmZXRjaCBzaXplIGxpbWl0IG9mICR7dGhpcy5mZXRjaFNpemVMaW1pdC50b0xvY2FsZVN0cmluZygpfSBieXRlc2ApOwogICAgICB9CiAgICAgIGNvbnN0IG1hdGVGZWF0UHJvbWlzZXMgPSBtYXRlQ2h1bmtzLm1hcChhc3luYyAoYykgPT4gewogICAgICAgIGNvbnN0IHsgZGF0YSwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgY2h1bmsgfSA9IGF3YWl0IHRoaXMuX3JlYWRDaHVuayh7CiAgICAgICAgICBjaHVuazogYywKICAgICAgICAgIG9wdHMKICAgICAgICB9KTsKICAgICAgICBjb25zdCBmZWF0czIgPSBhd2FpdCB0aGlzLnJlYWRCYW1GZWF0dXJlcyhkYXRhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuayk7CiAgICAgICAgY29uc3QgbWF0ZVJlY3MgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXRzMi5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXRzMltpXTsKICAgICAgICAgIGlmICh1bm1hdGVkUGFpcnNbZmVhdHVyZS5nZXQoIm5hbWUiKV0gJiYgIXJlYWRJZHNbZmVhdHVyZS5pZCgpXSkgewogICAgICAgICAgICBtYXRlUmVjcy5wdXNoKGZlYXR1cmUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gbWF0ZVJlY3M7CiAgICAgIH0pOwogICAgICByZXR1cm4gZmxhdChhd2FpdCBQcm9taXNlLmFsbChtYXRlRmVhdFByb21pc2VzKSk7CiAgICB9CiAgICBhc3luYyBfcmVhZENodW5rKHsgY2h1bmssIG9wdHMgfSkgewogICAgICBjb25zdCBzaXplID0gY2h1bmsuZmV0Y2hlZFNpemUoKTsKICAgICAgY29uc3QgeyBidWZmZXIsIGJ5dGVzUmVhZCB9ID0gYXdhaXQgdGhpcy5iYW0ucmVhZChpbXBvcnRfYnVmZmVyLkJ1ZmZlci5hbGxvYyhzaXplKSwgMCwgc2l6ZSwgY2h1bmsubWludi5ibG9ja1Bvc2l0aW9uLCBvcHRzKTsKICAgICAgY29uc3QgeyBidWZmZXI6IGRhdGEsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSA9IGF3YWl0IHVuemlwQ2h1bmtTbGljZShidWZmZXIuc3ViYXJyYXkoMCwgTWF0aC5taW4oYnl0ZXNSZWFkLCBzaXplKSksIGNodW5rKTsKICAgICAgcmV0dXJuIHsgZGF0YSwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgY2h1bmsgfTsKICAgIH0KICAgIGFzeW5jIHJlYWRCYW1GZWF0dXJlcyhiYSwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgY2h1bmspIHsKICAgICAgbGV0IGJsb2NrU3RhcnQgPSAwOwogICAgICBjb25zdCBzaW5rID0gW107CiAgICAgIGxldCBwb3MgPSAwOwogICAgICBsZXQgbGFzdCA9ICtEYXRlLm5vdygpOwogICAgICB3aGlsZSAoYmxvY2tTdGFydCArIDQgPCBiYS5sZW5ndGgpIHsKICAgICAgICBjb25zdCBibG9ja1NpemUgPSBiYS5yZWFkSW50MzJMRShibG9ja1N0YXJ0KTsKICAgICAgICBjb25zdCBibG9ja0VuZCA9IGJsb2NrU3RhcnQgKyA0ICsgYmxvY2tTaXplIC0gMTsKICAgICAgICBpZiAoZHBvc2l0aW9ucykgewogICAgICAgICAgd2hpbGUgKGJsb2NrU3RhcnQgKyBjaHVuay5taW52LmRhdGFQb3NpdGlvbiA+PSBkcG9zaXRpb25zW3BvcysrXSkgewogICAgICAgICAgfQogICAgICAgICAgcG9zLS07CiAgICAgICAgfQogICAgICAgIGlmIChibG9ja0VuZCA8IGJhLmxlbmd0aCkgewogICAgICAgICAgY29uc3QgZmVhdHVyZSA9IG5ldyBCYW1SZWNvcmQoewogICAgICAgICAgICBieXRlczogewogICAgICAgICAgICAgIGJ5dGVBcnJheTogYmEsCiAgICAgICAgICAgICAgc3RhcnQ6IGJsb2NrU3RhcnQsCiAgICAgICAgICAgICAgZW5kOiBibG9ja0VuZAogICAgICAgICAgICB9LAogICAgICAgICAgICBmaWxlT2Zmc2V0OiBjcG9zaXRpb25zID8gY3Bvc2l0aW9uc1twb3NdICogKDEgPDwgOCkgKyAoYmxvY2tTdGFydCAtIGRwb3NpdGlvbnNbcG9zXSkgKyBjaHVuay5taW52LmRhdGFQb3NpdGlvbiArIDEgOiBpbXBvcnRfYnVmZmVyX2NyYzMyLmRlZmF1bHQuc2lnbmVkKGJhLnNsaWNlKGJsb2NrU3RhcnQsIGJsb2NrRW5kKSkKICAgICAgICAgIH0pOwogICAgICAgICAgc2luay5wdXNoKGZlYXR1cmUpOwogICAgICAgICAgaWYgKHRoaXMueWllbGRUaHJlYWRUaW1lICYmICtEYXRlLm5vdygpIC0gbGFzdCA+IHRoaXMueWllbGRUaHJlYWRUaW1lKSB7CiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMSk7CiAgICAgICAgICAgIGxhc3QgPSArRGF0ZS5ub3coKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYmxvY2tTdGFydCA9IGJsb2NrRW5kICsgMTsKICAgICAgfQogICAgICByZXR1cm4gc2luazsKICAgIH0KICAgIGFzeW5jIGhhc1JlZlNlcShzZXFOYW1lKSB7CiAgICAgIGNvbnN0IHJlZklkID0gdGhpcy5jaHJUb0luZGV4ICYmIHRoaXMuY2hyVG9JbmRleFtzZXFOYW1lXTsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguaGFzUmVmU2VxKHJlZklkKTsKICAgIH0KICAgIGFzeW5jIGxpbmVDb3VudChzZXFOYW1lKSB7CiAgICAgIGNvbnN0IHJlZklkID0gdGhpcy5jaHJUb0luZGV4ICYmIHRoaXMuY2hyVG9JbmRleFtzZXFOYW1lXTsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGluZUNvdW50KHJlZklkKTsKICAgIH0KICAgIGFzeW5jIGluZGV4Q292KHNlcU5hbWUsIHN0YXJ0LCBlbmQpIHsKICAgICAgYXdhaXQgdGhpcy5pbmRleC5wYXJzZSgpOwogICAgICBjb25zdCBzZXFJZCA9IHRoaXMuY2hyVG9JbmRleCAmJiB0aGlzLmNoclRvSW5kZXhbc2VxTmFtZV07CiAgICAgIHJldHVybiB0aGlzLmluZGV4LmluZGV4Q292KHNlcUlkLCBzdGFydCwgZW5kKTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHNlcU5hbWUsIHN0YXJ0LCBlbmQsIG9wdHMpIHsKICAgICAgYXdhaXQgdGhpcy5pbmRleC5wYXJzZSgpOwogICAgICBjb25zdCBzZXFJZCA9IHRoaXMuY2hyVG9JbmRleCAmJiB0aGlzLmNoclRvSW5kZXhbc2VxTmFtZV07CiAgICAgIHJldHVybiB0aGlzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKHNlcUlkLCBzdGFydCwgZW5kLCBvcHRzKTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9odHNnZXQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9wb2x5ZmlsbCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9icm93c2VyX3BvbHlmaWxsKCkpOwoKICAvLyBub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBRdWlja0xSVTIgPSBjbGFzcyBleHRlbmRzIE1hcCB7CiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgc3VwZXIoKTsKICAgICAgaWYgKCEob3B0aW9ucy5tYXhTaXplICYmIG9wdGlvbnMubWF4U2l6ZSA+IDApKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4QWdlID09PSAibnVtYmVyIiAmJiBvcHRpb25zLm1heEFnZSA9PT0gMCkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhBZ2VgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgfQogICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7CiAgICAgIHRoaXMubWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOwogICAgICB0aGlzLm9uRXZpY3Rpb24gPSBvcHRpb25zLm9uRXZpY3Rpb247CiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgfQogICAgX2VtaXRFdmljdGlvbnMoY2FjaGUpIHsKICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBjYWNoZSkgewogICAgICAgIHRoaXMub25FdmljdGlvbihrZXksIGl0ZW0udmFsdWUpOwogICAgICB9CiAgICB9CiAgICBfZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgewogICAgICBpZiAodHlwZW9mIGl0ZW0uZXhwaXJ5ID09PSAibnVtYmVyIiAmJiBpdGVtLmV4cGlyeSA8PSBEYXRlLm5vdygpKSB7CiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRoaXMub25FdmljdGlvbihrZXksIGl0ZW0udmFsdWUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTsKICAgICAgfQogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBfZ2V0T3JEZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSB7CiAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKTsKICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7CiAgICAgIH0KICAgIH0KICAgIF9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKSB7CiAgICAgIHJldHVybiBpdGVtLmV4cGlyeSA/IHRoaXMuX2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgOiBpdGVtLnZhbHVlOwogICAgfQogICAgX3BlZWsoa2V5LCBjYWNoZSkgewogICAgICBjb25zdCBpdGVtID0gY2FjaGUuZ2V0KGtleSk7CiAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKTsKICAgIH0KICAgIF9zZXQoa2V5LCB2YWx1ZSkgewogICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgdGhpcy5fc2l6ZSsrOwogICAgICBpZiAodGhpcy5fc2l6ZSA+PSB0aGlzLm1heFNpemUpIHsKICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB0aGlzLl9lbWl0RXZpY3Rpb25zKHRoaXMub2xkQ2FjaGUpOwogICAgICAgIHRoaXMub2xkQ2FjaGUgPSB0aGlzLmNhY2hlOwogICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgIH0KICAgIH0KICAgIF9tb3ZlVG9SZWNlbnQoa2V5LCBpdGVtKSB7CiAgICAgIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSk7CiAgICAgIHRoaXMuX3NldChrZXksIGl0ZW0pOwogICAgfQogICAgKl9lbnRyaWVzQXNjZW5kaW5nKCkgewogICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGdldChrZXkpIHsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbVZhbHVlKGtleSwgaXRlbSk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTsKICAgICAgICBpZiAodGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgPT09IGZhbHNlKSB7CiAgICAgICAgICB0aGlzLl9tb3ZlVG9SZWNlbnQoa2V5LCBpdGVtKTsKICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgc2V0KGtleSwgdmFsdWUsIHsgbWF4QWdlID0gdGhpcy5tYXhBZ2UgfSA9IHt9KSB7CiAgICAgIGNvbnN0IGV4cGlyeSA9IHR5cGVvZiBtYXhBZ2UgPT09ICJudW1iZXIiICYmIG1heEFnZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID8gRGF0ZS5ub3coKSArIG1heEFnZSA6IHZvaWQgMDsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHsKICAgICAgICAgIHZhbHVlLAogICAgICAgICAgZXhwaXJ5CiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5fc2V0KGtleSwgeyB2YWx1ZSwgZXhwaXJ5IH0pOwogICAgICB9CiAgICB9CiAgICBoYXMoa2V5KSB7CiAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB0aGlzLmNhY2hlLmdldChrZXkpKTsKICAgICAgfQogICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgIHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5vbGRDYWNoZS5nZXQoa2V5KSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgcGVlayhrZXkpIHsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcGVlayhrZXksIHRoaXMuY2FjaGUpOwogICAgICB9CiAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLm9sZENhY2hlKTsKICAgICAgfQogICAgfQogICAgZGVsZXRlKGtleSkgewogICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgaWYgKGRlbGV0ZWQpIHsKICAgICAgICB0aGlzLl9zaXplLS07CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSkgfHwgZGVsZXRlZDsKICAgIH0KICAgIGNsZWFyKCkgewogICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7CiAgICAgIHRoaXMub2xkQ2FjaGUuY2xlYXIoKTsKICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICB9CiAgICByZXNpemUobmV3U2l6ZSkgewogICAgICBpZiAoIShuZXdTaXplICYmIG5ld1NpemUgPiAwKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgIH0KICAgICAgY29uc3QgaXRlbXMgPSBbLi4udGhpcy5fZW50cmllc0FzY2VuZGluZygpXTsKICAgICAgY29uc3QgcmVtb3ZlQ291bnQgPSBpdGVtcy5sZW5ndGggLSBuZXdTaXplOwogICAgICBpZiAocmVtb3ZlQ291bnQgPCAwKSB7CiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoaXRlbXMpOwogICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgdGhpcy5fc2l6ZSA9IGl0ZW1zLmxlbmd0aDsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAocmVtb3ZlQ291bnQgPiAwKSB7CiAgICAgICAgICB0aGlzLl9lbWl0RXZpY3Rpb25zKGl0ZW1zLnNsaWNlKDAsIHJlbW92ZUNvdW50KSk7CiAgICAgICAgfQogICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKGl0ZW1zLnNsaWNlKHJlbW92ZUNvdW50KSk7CiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgfQogICAgICB0aGlzLm1heFNpemUgPSBuZXdTaXplOwogICAgfQogICAgKmtleXMoKSB7CiAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykgewogICAgICAgIHlpZWxkIGtleTsKICAgICAgfQogICAgfQogICAgKnZhbHVlcygpIHsKICAgICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykgewogICAgICAgIHlpZWxkIHZhbHVlOwogICAgICB9CiAgICB9CiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgeWllbGQgW2tleSwgdmFsdWUudmFsdWVdOwogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgICplbnRyaWVzRGVzY2VuZGluZygpIHsKICAgICAgbGV0IGl0ZW1zID0gWy4uLnRoaXMuY2FjaGVdOwogICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgeWllbGQgW2tleSwgdmFsdWUudmFsdWVdOwogICAgICAgIH0KICAgICAgfQogICAgICBpdGVtcyA9IFsuLi50aGlzLm9sZENhY2hlXTsKICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldOwogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgICplbnRyaWVzQXNjZW5kaW5nKCkgewogICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9lbnRyaWVzQXNjZW5kaW5nKCkpIHsKICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07CiAgICAgIH0KICAgIH0KICAgIGdldCBzaXplKCkgewogICAgICBpZiAoIXRoaXMuX3NpemUpIHsKICAgICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5zaXplOwogICAgICB9CiAgICAgIGxldCBvbGRDYWNoZVNpemUgPSAwOwogICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm9sZENhY2hlLmtleXMoKSkgewogICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgb2xkQ2FjaGVTaXplKys7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLl9zaXplICsgb2xkQ2FjaGVTaXplLCB0aGlzLm1heFNpemUpOwogICAgfQogICAgZW50cmllcygpIHsKICAgICAgcmV0dXJuIHRoaXMuZW50cmllc0FzY2VuZGluZygpOwogICAgfQogICAgZm9yRWFjaChjYWxsYmFja0Z1bmN0aW9uLCB0aGlzQXJndW1lbnQgPSB0aGlzKSB7CiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuZW50cmllc0FzY2VuZGluZygpKSB7CiAgICAgICAgY2FsbGJhY2tGdW5jdGlvbi5jYWxsKHRoaXNBcmd1bWVudCwgdmFsdWUsIGtleSwgdGhpcyk7CiAgICAgIH0KICAgIH0KICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHsKICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFsuLi50aGlzLmVudHJpZXNBc2NlbmRpbmcoKV0pOwogICAgfQogIH07CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhc2NlbmRpbmdfZGVmYXVsdChhLCBiKSB7CiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47CiAgfQoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJpc2VjdG9yX2RlZmF1bHQoZikgewogICAgbGV0IGRlbHRhID0gZjsKICAgIGxldCBjb21wYXJlMiA9IGY7CiAgICBpZiAoZi5sZW5ndGggPT09IDEpIHsKICAgICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7CiAgICAgIGNvbXBhcmUyID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTsKICAgIH0KICAgIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgd2hpbGUgKGxvIDwgaGkpIHsKICAgICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxOwogICAgICAgIGlmIChjb21wYXJlMihhW21pZF0sIHgpIDwgMCkKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgICBlbHNlCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiByaWdodChhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICB3aGlsZSAobG8gPCBoaSkgewogICAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7CiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPiAwKQogICAgICAgICAgaGkgPSBtaWQ7CiAgICAgICAgZWxzZQogICAgICAgICAgbG8gPSBtaWQgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBsbzsKICAgIH0KICAgIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTsKICAgICAgcmV0dXJuIGkgPiBsbyAmJiBkZWx0YShhW2kgLSAxXSwgeCkgPiAtZGVsdGEoYVtpXSwgeCkgPyBpIC0gMSA6IGk7CiAgICB9CiAgICByZXR1cm4geyBsZWZ0LCBjZW50ZXIsIHJpZ2h0IH07CiAgfQogIGZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikgewogICAgcmV0dXJuIChkLCB4KSA9PiBhc2NlbmRpbmdfZGVmYXVsdChmKGQpLCB4KTsKICB9CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3V0aWxzLnRzCiAgdmFyIERhdGFTb3VyY2UgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihmaWxlLCBjaHJvbVNpemVzLCBvcHRpb25zKSB7CiAgICAgIHRoaXMuZmlsZSA9IGZpbGU7CiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7CiAgICAgIHRoaXMuY2hyb21JbmZvID0gc2l6ZXNUb0Nocm9tSW5mbyhjaHJvbVNpemVzKTsKICAgICAgdGhpcy50aWxlc2V0SW5mbyA9IHRpbGVzZXRJbmZvRnJvbUNocm9tSW5mbyh0aGlzLmNocm9tSW5mbyk7CiAgICB9CiAgICBjaHJvbUluZm87CiAgICB0aWxlc2V0SW5mbzsKICB9OwogIHZhciBjaHJvbUluZm9CaXNlY3RvciA9IGJpc2VjdG9yX2RlZmF1bHQoKGQpID0+IGQucG9zKS5sZWZ0OwogIHZhciBjaHJUb0FicyA9IChjaHJvbSwgY2hyb21Qb3MsIGNocm9tSW5mbykgPT4gY2hyb21JbmZvLmNoclBvc2l0aW9uc1tjaHJvbV0ucG9zICsgY2hyb21Qb3M7CiAgdmFyIGFic1RvQ2hyID0gKGFic1Bvc2l0aW9uLCBjaHJvbUluZm8pID0+IHsKICAgIGlmICghY2hyb21JbmZvIHx8ICFjaHJvbUluZm8uY3VtUG9zaXRpb25zIHx8ICFjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGxldCBpbnNlcnRQb2ludCA9IGNocm9tSW5mb0Jpc2VjdG9yKGNocm9tSW5mby5jdW1Qb3NpdGlvbnMsIGFic1Bvc2l0aW9uKTsKICAgIGNvbnN0IGxhc3RDaHIgPSBjaHJvbUluZm8uY3VtUG9zaXRpb25zW2Nocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoIC0gMV0uY2hyOwogICAgY29uc3QgbGFzdExlbmd0aCA9IGNocm9tSW5mby5jaHJvbUxlbmd0aHNbbGFzdENocl07CiAgICBpbnNlcnRQb2ludCAtPSBpbnNlcnRQb2ludCA+IDAgJiYgMTsKICAgIGxldCBjaHJQb3NpdGlvbiA9IE1hdGguZmxvb3IoYWJzUG9zaXRpb24gLSBjaHJvbUluZm8uY3VtUG9zaXRpb25zW2luc2VydFBvaW50XS5wb3MpOwogICAgbGV0IG9mZnNldCA9IDA7CiAgICBpZiAoY2hyUG9zaXRpb24gPCAwKSB7CiAgICAgIG9mZnNldCA9IGNoclBvc2l0aW9uIC0gMTsKICAgICAgY2hyUG9zaXRpb24gPSAxOwogICAgfQogICAgaWYgKGluc2VydFBvaW50ID09PSBjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDEgJiYgY2hyUG9zaXRpb24gPiBsYXN0TGVuZ3RoKSB7CiAgICAgIG9mZnNldCA9IGNoclBvc2l0aW9uIC0gbGFzdExlbmd0aDsKICAgICAgY2hyUG9zaXRpb24gPSBsYXN0TGVuZ3RoOwogICAgfQogICAgcmV0dXJuIFtjaHJvbUluZm8uY3VtUG9zaXRpb25zW2luc2VydFBvaW50XS5jaHIsIGNoclBvc2l0aW9uLCBvZmZzZXQsIGluc2VydFBvaW50XTsKICB9OwogIGZ1bmN0aW9uIHRpbGVzZXRJbmZvRnJvbUNocm9tSW5mbyhjaHJvbUluZm8sIHRpbGVTaXplID0gMTAyNCkgewogICAgcmV0dXJuIHsKICAgICAgdGlsZV9zaXplOiB0aWxlU2l6ZSwKICAgICAgYmluc19wZXJfZGltZW5zaW9uOiB0aWxlU2l6ZSwKICAgICAgbWF4X3pvb206IE1hdGguY2VpbChNYXRoLmxvZyhjaHJvbUluZm8udG90YWxMZW5ndGggLyB0aWxlU2l6ZSkgLyBNYXRoLmxvZygyKSksCiAgICAgIG1heF93aWR0aDogY2hyb21JbmZvLnRvdGFsTGVuZ3RoLAogICAgICBtaW5fcG9zOiBbMF0sCiAgICAgIG1heF9wb3M6IFtjaHJvbUluZm8udG90YWxMZW5ndGhdCiAgICB9OwogIH0KICBmdW5jdGlvbiBzaXplc1RvQ2hyb21JbmZvKHNpemVzKSB7CiAgICBjb25zdCBpbmZvID0gewogICAgICBjdW1Qb3NpdGlvbnM6IFtdLAogICAgICBjaHJvbUxlbmd0aHM6IHt9LAogICAgICBjaHJQb3NpdGlvbnM6IHt9LAogICAgICB0b3RhbExlbmd0aDogMAogICAgfTsKICAgIHNpemVzLmZvckVhY2goKFtjaHIsIGxlbmd0aF0sIGkpID0+IHsKICAgICAgY29uc3QgY2hyUG9zaXRpb24gPSB7IGlkOiBpLCBjaHIsIHBvczogaW5mby50b3RhbExlbmd0aCB9OwogICAgICBpbmZvLmNoclBvc2l0aW9uc1tjaHJdID0gY2hyUG9zaXRpb247CiAgICAgIGluZm8uY2hyb21MZW5ndGhzW2Nocl0gPSBsZW5ndGg7CiAgICAgIGluZm8uY3VtUG9zaXRpb25zLnB1c2goY2hyUG9zaXRpb24pOwogICAgICBpbmZvLnRvdGFsTGVuZ3RoICs9IGxlbmd0aDsKICAgIH0pOwogICAgcmV0dXJuIHsKICAgICAgLi4uaW5mbywKICAgICAgYWJzVG9DaHI6IChhYnNQb3MpID0+IGluZm8uY2hyUG9zaXRpb25zID8gYWJzVG9DaHIoYWJzUG9zLCBpbmZvKSA6IG51bGwsCiAgICAgIGNoclRvQWJzOiAoW2Nock5hbWUsIGNoclBvc10pID0+IGluZm8uY2hyUG9zaXRpb25zID8gY2hyVG9BYnMoY2hyTmFtZSwgY2hyUG9zLCBpbmZvKSA6IG51bGwKICAgIH07CiAgfQogIHZhciBSZW1vdGVGaWxlMiA9IGNsYXNzIGV4dGVuZHMgUmVtb3RlRmlsZSB7CiAgICByZWFkID0gYXN5bmMgKGJ1ZmZlciwgb2Zmc2V0ID0gMCwgbGVuZ3RoLCBwb3NpdGlvbiA9IDAsIG9wdHMgPSB7fSkgPT4gewogICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9uICsgbGVuZ3RofWA7CiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYDsKICAgICAgfQogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMsCiAgICAgICAgaGVhZGVyczogewogICAgICAgICAgLi4uaGVhZGVycywKICAgICAgICAgIC4uLm92ZXJyaWRlcy5oZWFkZXJzLAogICAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMKICAgICAgICB9LAogICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICBzaWduYWwKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke3RoaXMudXJsfWApOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikgewogICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICBjb25zdCByZXMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgiY29udGVudC1yYW5nZSIpOwogICAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cLyhcZCspJC8uZXhlYyhyZXMgfHwgIiIpOwogICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXIgfTsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCk7CiAgICB9OwogIH07CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL2JhbS9iYW0td29ya2VyLnRzP3dvcmtlciZpbmxpbmU/d29ya2VyX2ZpbGUKICBmdW5jdGlvbiBwYXJzZU1EKG1kU3RyaW5nLCB1c2VDb3VudHMpIHsKICAgIGxldCBjdXJyUG9zID0gMDsKICAgIGxldCBjdXJyTnVtID0gMDsKICAgIGxldCBkZWxldGlvbkVuY291bnRlcmVkID0gZmFsc2U7CiAgICBsZXQgYmFtU2VxU2hpZnQgPSAwOwogICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZFN0cmluZy5sZW5ndGg7IGkrKykgewogICAgICBpZiAobWRTdHJpbmdbaV0ubWF0Y2goL1swLTldL2cpKSB7CiAgICAgICAgY3Vyck51bSA9IGN1cnJOdW0gKiAxMCArICttZFN0cmluZ1tpXTsKICAgICAgICBkZWxldGlvbkVuY291bnRlcmVkID0gZmFsc2U7CiAgICAgIH0gZWxzZSBpZiAobWRTdHJpbmdbaV0gPT09ICJeIikgewogICAgICAgIGRlbGV0aW9uRW5jb3VudGVyZWQgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIGN1cnJQb3MgKz0gY3Vyck51bTsKICAgICAgICBpZiAodXNlQ291bnRzKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBsZW5ndGg6IGN1cnJOdW0sCiAgICAgICAgICAgIHR5cGU6IG1kU3RyaW5nW2ldCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKGRlbGV0aW9uRW5jb3VudGVyZWQpIHsKICAgICAgICAgIGJhbVNlcVNoaWZ0IC09IDE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICAgIHBvczogY3VyclBvcywKICAgICAgICAgICAgYmFzZTogbWRTdHJpbmdbaV0sCiAgICAgICAgICAgIGxlbmd0aDogMSwKICAgICAgICAgICAgYmFtU2VxU2hpZnQKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBjdXJyTnVtID0gMDsKICAgICAgICBjdXJyUG9zICs9IDE7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBzdWJzdGl0dXRpb25zOwogIH0KICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb25zKHNlZ21lbnQsIHNlcSkgewogICAgbGV0IHN1YnN0aXR1dGlvbnMgPSBbXTsKICAgIGxldCBzb2Z0Q2xpcHBpbmdBdFJlYWRTdGFydCA9IG51bGw7CiAgICBpZiAoc2VnbWVudC5jaWdhcikgewogICAgICBjb25zdCBjaWdhclN1YnMgPSBwYXJzZU1EKHNlZ21lbnQuY2lnYXIsIHRydWUpOwogICAgICBsZXQgY3VyclBvcyA9IDA7CiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIGNpZ2FyU3VicykgewogICAgICAgIGlmIChzdWIudHlwZSA9PT0gIlgiKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBwb3M6IGN1cnJQb3MsCiAgICAgICAgICAgIGxlbmd0aDogc3ViLmxlbmd0aCwKICAgICAgICAgICAgdHlwZTogIlgiCiAgICAgICAgICB9KTsKICAgICAgICAgIGN1cnJQb3MgKz0gc3ViLmxlbmd0aDsKICAgICAgICB9IGVsc2UgaWYgKHN1Yi50eXBlID09PSAiSSIpIHsKICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICAgIHBvczogY3VyclBvcywKICAgICAgICAgICAgbGVuZ3RoOiBzdWIubGVuZ3RoLAogICAgICAgICAgICB0eXBlOiAiSSIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSBpZiAoc3ViLnR5cGUgPT09ICJEIikgewogICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgICAgcG9zOiBjdXJyUG9zLAogICAgICAgICAgICBsZW5ndGg6IHN1Yi5sZW5ndGgsCiAgICAgICAgICAgIHR5cGU6ICJEIgogICAgICAgICAgfSk7CiAgICAgICAgICBjdXJyUG9zICs9IHN1Yi5sZW5ndGg7CiAgICAgICAgfSBlbHNlIGlmIChzdWIudHlwZSA9PT0gIk4iKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBwb3M6IGN1cnJQb3MsCiAgICAgICAgICAgIGxlbmd0aDogc3ViLmxlbmd0aCwKICAgICAgICAgICAgdHlwZTogIk4iCiAgICAgICAgICB9KTsKICAgICAgICAgIGN1cnJQb3MgKz0gc3ViLmxlbmd0aDsKICAgICAgICB9IGVsc2UgaWYgKHN1Yi50eXBlID09PSAiPSIgfHwgc3ViLnR5cGUgPT09ICJNIikgewogICAgICAgICAgY3VyclBvcyArPSBzdWIubGVuZ3RoOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGZpcnN0U3ViID0gY2lnYXJTdWJzWzBdOwogICAgICBjb25zdCBsYXN0U3ViID0gY2lnYXJTdWJzW2NpZ2FyU3Vicy5sZW5ndGggLSAxXTsKICAgICAgaWYgKGZpcnN0U3ViLnR5cGUgPT09ICJTIikgewogICAgICAgIHNvZnRDbGlwcGluZ0F0UmVhZFN0YXJ0ID0gZmlyc3RTdWI7CiAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgIHBvczogLWZpcnN0U3ViLmxlbmd0aCwKICAgICAgICAgIHR5cGU6ICJTIiwKICAgICAgICAgIGxlbmd0aDogZmlyc3RTdWIubGVuZ3RoCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKGxhc3RTdWIudHlwZSA9PT0gIlMiKSB7CiAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgIHBvczogc2VnbWVudC5lbmQgLSBzZWdtZW50LnN0YXJ0LAogICAgICAgICAgbGVuZ3RoOiBsYXN0U3ViLmxlbmd0aCwKICAgICAgICAgIHR5cGU6ICJTIgogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChmaXJzdFN1Yi50eXBlID09PSAiSCIpIHsKICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgcG9zOiAtZmlyc3RTdWIubGVuZ3RoLAogICAgICAgICAgdHlwZTogIkgiLAogICAgICAgICAgbGVuZ3RoOiBmaXJzdFN1Yi5sZW5ndGgKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAobGFzdFN1Yi50eXBlID09PSAiSCIpIHsKICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgcG9zOiBzZWdtZW50LmVuZCAtIHNlZ21lbnQuc3RhcnQsCiAgICAgICAgICBsZW5ndGg6IGxhc3RTdWIubGVuZ3RoLAogICAgICAgICAgdHlwZTogIkgiCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICAgIGlmIChzZWdtZW50Lm1kKSB7CiAgICAgIGNvbnN0IG1kU3Vic3RpdHV0aW9ucyA9IHBhcnNlTUQoc2VnbWVudC5tZCwgZmFsc2UpOwogICAgICBtZFN1YnN0aXR1dGlvbnMuZm9yRWFjaChmdW5jdGlvbihzdWJzdGl0dXRpb24pIHsKICAgICAgICBsZXQgcG9zU3RhcnQgPSBzdWJzdGl0dXRpb25bInBvcyJdICsgc3Vic3RpdHV0aW9uWyJiYW1TZXFTaGlmdCJdOwogICAgICAgIGxldCBwb3NFbmQgPSBwb3NTdGFydCArIHN1YnN0aXR1dGlvblsibGVuZ3RoIl07CiAgICAgICAgaWYgKHNvZnRDbGlwcGluZ0F0UmVhZFN0YXJ0ICE9PSBudWxsKSB7CiAgICAgICAgICBwb3NTdGFydCArPSBzb2Z0Q2xpcHBpbmdBdFJlYWRTdGFydC5sZW5ndGg7CiAgICAgICAgICBwb3NFbmQgKz0gc29mdENsaXBwaW5nQXRSZWFkU3RhcnQubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBzdWJzdGl0dXRpb25bInZhcmlhbnQiXSA9IHNlcS5zdWJzdHJpbmcocG9zU3RhcnQsIHBvc0VuZCk7CiAgICAgICAgZGVsZXRlIHN1YnN0aXR1dGlvblsiYmFtU2VxU2hpZnQiXTsKICAgICAgfSk7CiAgICAgIHN1YnN0aXR1dGlvbnMgPSBtZFN1YnN0aXR1dGlvbnMuY29uY2F0KHN1YnN0aXR1dGlvbnMpOwogICAgfQogICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7CiAgfQogIHZhciBiYW1SZWNvcmRUb0pzb24gPSAoYmFtUmVjb3JkLCBjaHJOYW1lLCBjaHJPZmZzZXQpID0+IHsKICAgIGNvbnN0IHNlcSA9IGJhbVJlY29yZC5nZXQoInNlcSIpOwogICAgY29uc3Qgc2VnbWVudCA9IHsKICAgICAgaWQ6IGJhbVJlY29yZC5faWQsCiAgICAgIG5hbWU6IGJhbVJlY29yZC5nZXQoIm5hbWUiKSwKICAgICAgc3RhcnQ6ICtiYW1SZWNvcmQuZGF0YS5zdGFydCArIDEgKyBjaHJPZmZzZXQsCiAgICAgIGVuZDogK2JhbVJlY29yZC5kYXRhLmVuZCArIDEgKyBjaHJPZmZzZXQsCiAgICAgIG1kOiBiYW1SZWNvcmQuZ2V0KCJNRCIpLAogICAgICBjaHJOYW1lLAogICAgICBjaHJPZmZzZXQsCiAgICAgIGNpZ2FyOiBiYW1SZWNvcmQuZ2V0KCJjaWdhciIpLAogICAgICBtYXBxOiBiYW1SZWNvcmQuZ2V0KCJtcSIpLAogICAgICBzdHJhbmQ6IGJhbVJlY29yZC5nZXQoInN0cmFuZCIpID09PSAxID8gIisiIDogIi0iCiAgICB9OwogICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2VnbWVudCwgeyBzdWJzdGl0dXRpb25zOiBnZXRTdWJzdGl0dXRpb25zKHNlZ21lbnQsIHNlcSkgfSk7CiAgfTsKICB2YXIgQmFtRmlsZTIgPSBjbGFzcyBleHRlbmRzIEJhbUZpbGUgewogICAgaGVhZGVyUHJvbWlzZTsKICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHsKICAgICAgc3VwZXIoLi4uYXJncyk7CiAgICAgIHRoaXMuaGVhZGVyUHJvbWlzZSA9IHRoaXMuZ2V0SGVhZGVyKCk7CiAgICB9CiAgICBzdGF0aWMgZnJvbVVybCh1cmwsIGluZGV4VXJsLCB1cmxGZXRjaE9wdGlvbnMsIGluZGV4VXJsRmV0Y2hPcHRpb25zKSB7CiAgICAgIHJldHVybiBuZXcgQmFtRmlsZTIoewogICAgICAgIGJhbUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMih1cmwsIHsgb3ZlcnJpZGVzOiB1cmxGZXRjaE9wdGlvbnMgfSksCiAgICAgICAgYmFpRmlsZWhhbmRsZTogbmV3IFJlbW90ZUZpbGUyKGluZGV4VXJsLCB7IG92ZXJyaWRlczogaW5kZXhVcmxGZXRjaE9wdGlvbnMgfSkKICAgICAgfSk7CiAgICB9CiAgICBnZXRDaHJvbU5hbWVzKCkgewogICAgICByZXR1cm4gdGhpcy5pbmRleFRvQ2hyLm1hcCgodikgPT4gdi5yZWZOYW1lKTsKICAgIH0KICB9OwogIHZhciBkYXRhU291cmNlcyA9IG5ldyBNYXAoKTsKICB2YXIgYmFtRmlsZUNhY2hlID0gbmV3IE1hcCgpOwogIHZhciBNQVhfVElMRVMgPSAyMDsKICB2YXIgdGlsZVZhbHVlcyA9IG5ldyBRdWlja0xSVTIoeyBtYXhTaXplOiBNQVhfVElMRVMgfSk7CiAgdmFyIGluaXQgPSBhc3luYyAodWlkLCBiYW0sIGNocm9tU2l6ZXMsIG9wdGlvbnMgPSB7fSkgPT4gewogICAgaWYgKCFiYW1GaWxlQ2FjaGUuaGFzKGJhbS51cmwpKSB7CiAgICAgIGNvbnN0IGJhbUZpbGUyID0gQmFtRmlsZTIuZnJvbVVybChiYW0udXJsLCBiYW0uaW5kZXhVcmwsIG9wdGlvbnMudXJsRmV0Y2hPcHRpb25zLCBvcHRpb25zLmluZGV4VXJsRmV0Y2hPcHRpb25zKTsKICAgICAgYXdhaXQgYmFtRmlsZTIuZ2V0SGVhZGVyKCk7CiAgICAgIGNvbnN0IGZpcnN0Q2hyb21OYW1lSW5IZWFkZXIgPSBiYW1GaWxlMi5nZXRDaHJvbU5hbWVzKClbMF07CiAgICAgIGlmIChmaXJzdENocm9tTmFtZUluSGVhZGVyKSB7CiAgICAgICAgY29uc3QgaGVhZGVySGFzUHJlZml4ID0gZmlyc3RDaHJvbU5hbWVJbkhlYWRlci5pbmNsdWRlcygiY2hyIik7CiAgICAgICAgY29uc3Qgc3BlY0hhc1ByZWZpeCA9IGNocm9tU2l6ZXNbMF0/LlswXS5pbmNsdWRlcygiY2hyIik7CiAgICAgICAgaWYgKGhlYWRlckhhc1ByZWZpeCAmJiAhc3BlY0hhc1ByZWZpeCkgewogICAgICAgICAgY2hyb21TaXplcyA9IGNocm9tU2l6ZXMubWFwKChbcywgbl0pID0+IFtgY2hyJHtzfWAsIG5dKTsKICAgICAgICB9IGVsc2UgaWYgKCFoZWFkZXJIYXNQcmVmaXggJiYgc3BlY0hhc1ByZWZpeCkgewogICAgICAgICAgY2hyb21TaXplcyA9IGNocm9tU2l6ZXMubWFwKChbcywgbl0pID0+IFtzLnJlcGxhY2UoImNociIsICIiKSwgbl0pOwogICAgICAgIH0KICAgICAgfQogICAgICBiYW1GaWxlQ2FjaGUuc2V0KGJhbS51cmwsIGJhbUZpbGUyKTsKICAgIH0KICAgIGNvbnN0IGJhbUZpbGUgPSBiYW1GaWxlQ2FjaGUuZ2V0KGJhbS51cmwpOwogICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBEYXRhU291cmNlKGJhbUZpbGUsIGNocm9tU2l6ZXMsIHsKICAgICAgbG9hZE1hdGVzOiBmYWxzZSwKICAgICAgbWF4SW5zZXJ0U2l6ZTogNWUzLAogICAgICBleHRyYWN0SnVuY3Rpb246IGZhbHNlLAogICAgICBqdW5jdGlvbk1pbkNvdmVyYWdlOiAxLAogICAgICAuLi5vcHRpb25zCiAgICB9KTsKICAgIGRhdGFTb3VyY2VzLnNldCh1aWQsIGRhdGFTb3VyY2UpOwogIH07CiAgdmFyIHRpbGVzZXRJbmZvID0gKHVpZCkgPT4gewogICAgcmV0dXJuIGRhdGFTb3VyY2VzLmdldCh1aWQpLnRpbGVzZXRJbmZvOwogIH07CiAgdmFyIHRpbGUgPSBhc3luYyAodWlkLCB6LCB4KSA9PiB7CiAgICBjb25zdCBNQVhfVElMRV9XSURUSCA9IDJlNTsKICAgIGNvbnN0IGJhbSA9IGRhdGFTb3VyY2VzLmdldCh1aWQpOwogICAgY29uc3QgaW5mbyA9IHRpbGVzZXRJbmZvKHVpZCk7CiAgICBpZiAoISgibWF4X3dpZHRoIiBpbiBpbmZvKSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoInRpbGVzZXRJbmZvIGRvZXMgbm90IGluY2x1ZGUgYG1heF93aWR0aGAsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciB0aGUgR29zbGluZyBCYW1EYXRhRmV0Y2hlci4iKTsKICAgIH0KICAgIGNvbnN0IHRpbGVXaWR0aCA9ICtpbmZvLm1heF93aWR0aCAvIDIgKiogK3o7CiAgICBjb25zdCByZWNvcmRQcm9taXNlcyA9IFtdOwogICAgaWYgKHRpbGVXaWR0aCA+IE1BWF9USUxFX1dJRFRIKSB7CiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShbXSkpOwogICAgfQogICAgbGV0IG1pblggPSBpbmZvLm1pbl9wb3NbMF0gKyB4ICogdGlsZVdpZHRoOwogICAgY29uc3QgbWF4WCA9IGluZm8ubWluX3Bvc1swXSArICh4ICsgMSkgKiB0aWxlV2lkdGg7CiAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBiYW0uY2hyb21JbmZvOwogICAgY29uc3Qgb3B0ID0gewogICAgICB2aWV3QXNQYWlyczogYmFtLm9wdGlvbnMubG9hZE1hdGVzCiAgICB9OwogICAgdGlsZVZhbHVlcy5zZXQoYCR7dWlkfS4ke3p9LiR7eH1gLCBbXSk7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1bVBvc2l0aW9ucy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBjaHJvbU5hbWUgPSBjdW1Qb3NpdGlvbnNbaV0uY2hyOwogICAgICBjb25zdCBjaHJvbVN0YXJ0ID0gY3VtUG9zaXRpb25zW2ldLnBvczsKICAgICAgY29uc3QgY2hyb21FbmQgPSBjdW1Qb3NpdGlvbnNbaV0ucG9zICsgY2hyb21MZW5ndGhzW2Nocm9tTmFtZV07CiAgICAgIGlmIChjaHJvbVN0YXJ0IDw9IG1pblggJiYgbWluWCA8IGNocm9tRW5kKSB7CiAgICAgICAgaWYgKG1heFggPiBjaHJvbUVuZCkgewogICAgICAgICAgcmVjb3JkUHJvbWlzZXMucHVzaChiYW0uZmlsZS5nZXRSZWNvcmRzRm9yUmFuZ2UoY2hyb21OYW1lLCBtaW5YIC0gY2hyb21TdGFydCwgY2hyb21FbmQgLSBjaHJvbVN0YXJ0LCBvcHQpLnRoZW4oKHJlY29yZHMpID0+IHsKICAgICAgICAgICAgY29uc3QgbWFwcGVkUmVjb3JkcyA9IHJlY29yZHMubWFwKChyZWMpID0+IGJhbVJlY29yZFRvSnNvbihyZWMsIGNocm9tTmFtZSwgY3VtUG9zaXRpb25zW2ldLnBvcykpOwogICAgICAgICAgICB0aWxlVmFsdWVzLnNldChgJHt1aWR9LiR7en0uJHt4fWAsIHRpbGVWYWx1ZXMuZ2V0KGAke3VpZH0uJHt6fS4ke3h9YCkuY29uY2F0KG1hcHBlZFJlY29yZHMpKTsKICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfSkpOwogICAgICAgICAgbWluWCA9IGNocm9tRW5kOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBzdGFydFBvcyA9IE1hdGguZmxvb3IobWluWCAtIGNocm9tU3RhcnQpOwogICAgICAgICAgY29uc3QgZW5kUG9zID0gTWF0aC5jZWlsKG1heFggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgIHJlY29yZFByb21pc2VzLnB1c2goYmFtLmZpbGUuZ2V0UmVjb3Jkc0ZvclJhbmdlKGNocm9tTmFtZSwgc3RhcnRQb3MsIGVuZFBvcywgb3B0KS50aGVuKChyZWNvcmRzKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFJlY29yZHMgPSByZWNvcmRzLm1hcCgocmVjKSA9PiBiYW1SZWNvcmRUb0pzb24ocmVjLCBjaHJvbU5hbWUsIGN1bVBvc2l0aW9uc1tpXS5wb3MpKTsKICAgICAgICAgICAgdGlsZVZhbHVlcy5zZXQoYCR7dWlkfS4ke3p9LiR7eH1gLCB0aWxlVmFsdWVzLmdldChgJHt1aWR9LiR7en0uJHt4fWApLmNvbmNhdChtYXBwZWRSZWNvcmRzKSk7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIFByb21pc2UuYWxsKHJlY29yZFByb21pc2VzKS50aGVuKCh2YWx1ZXMpID0+IHsKICAgICAgcmV0dXJuIHZhbHVlcy5mbGF0KCk7CiAgICB9KTsKICB9OwogIHZhciBmZXRjaFRpbGVzRGVib3VuY2VkID0gYXN5bmMgKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgdGlsZXMgPSB7fTsKICAgIGNvbnN0IHZhbGlkVGlsZUlkcyA9IFtdOwogICAgY29uc3QgdGlsZVByb21pc2VzID0gW107CiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiB0aWxlSWRzKSB7CiAgICAgIGNvbnN0IHBhcnRzID0gdGlsZUlkLnNwbGl0KCIuIik7CiAgICAgIGNvbnN0IHogPSBwYXJzZUludChwYXJ0c1swXSwgMTApOwogICAgICBjb25zdCB4ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeikpIHsKICAgICAgICBjb25zb2xlLndhcm4oIkludmFsaWQgdGlsZSB6b29tIG9yIHBvc2l0aW9uOiIsIHosIHgpOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHZhbGlkVGlsZUlkcy5wdXNoKHRpbGVJZCk7CiAgICAgIHRpbGVQcm9taXNlcy5wdXNoKHRpbGUodWlkLCB6LCB4KSk7CiAgICB9CiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGlsZVByb21pc2VzKS50aGVuKCh2YWx1ZXMpID0+IHsKICAgICAgdmFsdWVzLmZvckVhY2goKGQsIGkpID0+IHsKICAgICAgICBjb25zdCB2YWxpZFRpbGVJZCA9IHZhbGlkVGlsZUlkc1tpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0gPSBPYmplY3QuYXNzaWduKGQsIHsgdGlsZVBvc2l0aW9uSWQ6IHZhbGlkVGlsZUlkIH0pOwogICAgICB9KTsKICAgICAgcmV0dXJuIHRpbGVzOwogICAgfSk7CiAgfTsKICB2YXIgZ2V0VGFidWxhckRhdGEgPSAodWlkLCB0aWxlSWRzKSA9PiB7CiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGRhdGFTb3VyY2VzLmdldCh1aWQpOwogICAgY29uc3QgYWxsU2VnbWVudHMgPSB7fTsKICAgIGZvciAoY29uc3QgdGlsZUlkIG9mIHRpbGVJZHMpIHsKICAgICAgY29uc3QgdGlsZVZhbHVlID0gdGlsZVZhbHVlcy5nZXQoYCR7dWlkfS4ke3RpbGVJZH1gKTsKICAgICAgaWYgKCF0aWxlVmFsdWUpIHsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoImVycm9yIiBpbiB0aWxlVmFsdWUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGlsZVZhbHVlLmVycm9yKTsKICAgICAgfQogICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgdGlsZVZhbHVlKSB7CiAgICAgICAgYWxsU2VnbWVudHNbc2VnbWVudC5pZF0gPSB7CiAgICAgICAgICAuLi5zZWdtZW50LAogICAgICAgICAgc3Vic3RpdHV0aW9uczogSlNPTi5zdHJpbmdpZnkoc2VnbWVudC5zdWJzdGl0dXRpb25zKQogICAgICAgIH07CiAgICAgIH0KICAgIH0KICAgIGNvbnN0IHNlZ21lbnRzID0gT2JqZWN0LnZhbHVlcyhhbGxTZWdtZW50cyk7CiAgICBpZiAob3B0aW9ucy5sb2FkTWF0ZXMpIHsKICAgICAgZmluZE1hdGVzKHNlZ21lbnRzLCBvcHRpb25zLm1heEluc2VydFNpemUpOwogICAgfQogICAgbGV0IG91dHB1dDsKICAgIGlmIChvcHRpb25zLmV4dHJhY3RKdW5jdGlvbikgewogICAgICBvdXRwdXQgPSBmaW5kSnVuY3Rpb25zKHNlZ21lbnRzLCBvcHRpb25zLmp1bmN0aW9uTWluQ292ZXJhZ2UpOwogICAgfSBlbHNlIHsKICAgICAgb3V0cHV0ID0gc2VnbWVudHM7CiAgICB9CiAgICBjb25zdCBidWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkob3V0cHV0KSkuYnVmZmVyOwogICAgcmV0dXJuIFRyYW5zZmVyKGJ1ZmZlciwgW2J1ZmZlcl0pOwogIH07CiAgdmFyIGdyb3VwQnkgPSAoeHMsIGtleSkgPT4geHMucmVkdWNlKChydiwgeCkgPT4gewogICAgKHJ2W3hba2V5XV0gPSBydlt4W2tleV1dIHx8IFtdKS5wdXNoKHgpOwogICAgcmV0dXJuIHJ2OwogIH0sIHt9KTsKICB2YXIgZmluZE1hdGVzID0gKHNlZ21lbnRzLCBtYXhJbnNlcnRTaXplID0gMCkgPT4gewogICAgY29uc3Qgc2VnbWVudHNCeVJlYWROYW1lID0gZ3JvdXBCeShzZWdtZW50cywgIm5hbWUiKTsKICAgIE9iamVjdC52YWx1ZXMoc2VnbWVudHNCeVJlYWROYW1lKS5mb3JFYWNoKChzZWdtZW50R3JvdXApID0+IHsKICAgICAgaWYgKHNlZ21lbnRHcm91cC5sZW5ndGggPT09IDIpIHsKICAgICAgICBjb25zdCByZWFkID0gc2VnbWVudEdyb3VwWzBdOwogICAgICAgIGNvbnN0IG1hdGUgPSBzZWdtZW50R3JvdXBbMV07CiAgICAgICAgcmVhZC5tYXRlSWRzID0gW21hdGUuaWRdOwogICAgICAgIG1hdGUubWF0ZUlkcyA9IFtyZWFkLmlkXTsKICAgICAgICBjb25zdCBbbCwgcl0gPSBbcmVhZCwgbWF0ZV0uc29ydCgoYSwgYikgPT4gK2Euc3RhcnQgLSArYi5zdGFydCk7CiAgICAgICAgY29uc3QgaW5zZXJ0U2l6ZSA9IE1hdGgubWF4KDAsICtyLnN0YXJ0IC0gK2wuZW5kKTsKICAgICAgICBjb25zdCBsYXJnZUluc2VydFNpemUgPSBpbnNlcnRTaXplID49IG1heEluc2VydFNpemU7CiAgICAgICAgbGV0IHN2VHlwZTsKICAgICAgICBpZiAoIWxhcmdlSW5zZXJ0U2l6ZSkgewogICAgICAgICAgc3ZUeXBlID0gIm5vcm1hbCByZWFkIjsKICAgICAgICB9IGVsc2UgaWYgKGwuc3RyYW5kID09PSAiKyIgJiYgci5zdHJhbmQgPT09ICItIikgewogICAgICAgICAgc3ZUeXBlID0gImRlbGV0aW9uICgrLSkiOwogICAgICAgIH0gZWxzZSBpZiAobC5zdHJhbmQgPT09ICIrIiAmJiByLnN0cmFuZCA9PT0gIisiKSB7CiAgICAgICAgICBzdlR5cGUgPSAiaW52ZXJzaW9uICgrKykiOwogICAgICAgIH0gZWxzZSBpZiAobC5zdHJhbmQgPT09ICItIiAmJiByLnN0cmFuZCA9PT0gIi0iKSB7CiAgICAgICAgICBzdlR5cGUgPSAiaW52ZXJzaW9uICgtLSkiOwogICAgICAgIH0gZWxzZSBpZiAobC5zdHJhbmQgPT09ICItIiAmJiByLnN0cmFuZCA9PT0gIisiKSB7CiAgICAgICAgICBzdlR5cGUgPSAiZHVwbGljYXRpb24gKC0rKSI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN2VHlwZSA9IGAoJHtsLnN0cmFuZH0ke3Iuc3RyYW5kfSlgOwogICAgICAgIH0KICAgICAgICBbcmVhZCwgbWF0ZV0uZm9yRWFjaCgoZCkgPT4gewogICAgICAgICAgZC5mb3VuZE1hdGUgPSB0cnVlOwogICAgICAgICAgZC5pbnNlcnRTaXplID0gaW5zZXJ0U2l6ZTsKICAgICAgICAgIGQubGFyZ2VJbnNlcnRTaXplID0gbGFyZ2VJbnNlcnRTaXplOwogICAgICAgICAgZC5zdlR5cGUgPSBzdlR5cGU7CiAgICAgICAgICBkLm51bU1hdGVzID0gMjsKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzZWdtZW50R3JvdXAuZm9yRWFjaCgoZCkgPT4gewogICAgICAgICAgZC5tYXRlSWRzID0gc2VnbWVudEdyb3VwLmZpbHRlcigobWF0ZSkgPT4gbWF0ZS5pZCAhPT0gZC5pZCkubWFwKChtYXRlKSA9PiBtYXRlLmlkKTsKICAgICAgICAgIGQuZm91bmRNYXRlID0gZmFsc2U7CiAgICAgICAgICBkLmluc2VydFNpemUgPSAtMTsKICAgICAgICAgIGQubGFyZ2VJbnNlcnRTaXplID0gZmFsc2U7CiAgICAgICAgICBkLnN2VHlwZSA9IHNlZ21lbnRHcm91cC5sZW5ndGggPT09IDEgPyAibWF0ZXMgbm90IGZvdW5kIHdpdGhpbiBjaHJvbW9zb21lIiA6ICJtb3JlIHRoYW4gdHdvIG1hdGVzIjsKICAgICAgICAgIGQubnVtTWF0ZXMgPSBzZWdtZW50R3JvdXAubGVuZ3RoOwogICAgICAgIH0pOwogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBzZWdtZW50c0J5UmVhZE5hbWU7CiAgfTsKICB2YXIgZmluZEp1bmN0aW9ucyA9IChzZWdtZW50cywgbWluQ292ZXJhZ2UgPSAwKSA9PiB7CiAgICBjb25zdCBqdW5jdGlvbnMgPSBbXTsKICAgIHNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHsKICAgICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IEpTT04ucGFyc2Uoc2VnbWVudC5zdWJzdGl0dXRpb25zKTsKICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKChzdWIpID0+IHsKICAgICAgICBjb25zdCBkb24gPSBzZWdtZW50LnN0YXJ0ICsgc3ViLnBvczsKICAgICAgICBjb25zdCBhY2MgPSBzZWdtZW50LnN0YXJ0ICsgc3ViLnBvcyArIHN1Yi5sZW5ndGg7CiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnQgPCBkb24gJiYgYWNjIDwgc2VnbWVudC5lbmQpIHsKICAgICAgICAgIGNvbnN0IGogPSBqdW5jdGlvbnMuZmluZCgoZCkgPT4gZC5zdGFydCA9PT0gZG9uICYmIGQuZW5kID09PSBhY2MpOwogICAgICAgICAgaWYgKGopIHsKICAgICAgICAgICAgai5zY29yZSArPSAxOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAganVuY3Rpb25zLnB1c2goeyBzdGFydDogZG9uLCBlbmQ6IGFjYywgc2NvcmU6IDEgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgIH0pOwogICAgcmV0dXJuIGp1bmN0aW9ucy5maWx0ZXIoKGQpID0+IGQuc2NvcmUgPj0gbWluQ292ZXJhZ2UpOwogIH07CiAgdmFyIHRpbGVGdW5jdGlvbnMgPSB7CiAgICBpbml0LAogICAgdGlsZXNldEluZm8sCiAgICBmZXRjaFRpbGVzRGVib3VuY2VkLAogICAgdGlsZSwKICAgIGdldFRhYnVsYXJEYXRhCiAgfTsKICBleHBvc2UodGlsZUZ1bmN0aW9ucyk7Cn0pKCk7Ci8qIQogKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4KICoKICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz4KICogQGxpY2Vuc2UgIE1JVAogKi8KLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi8KLyoqCiAqIEBsaWNlbnNlCiAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycwogKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLgogKgogKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKICoKICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogKgogKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgogKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogKgogKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMAogKi8K";
const blob$3 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$3)], { type: "text/javascript;charset=utf-8" });
function Worker$4() {
  const objURL = blob$3 && (window.URL || window.webkitURL).createObjectURL(blob$3);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$3, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$3 = 200;
class BamDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "fetchTimeout");
    __publicField(this, "toFetch");
    __publicField(this, "MAX_TILE_WIDTH", 2e4);
    __publicField(this, "worker");
    // This is set by us but is accessed in `fetchTilesDebounced`
    __publicField(this, "track");
    this.uid = HGC.libraries.slugid.nice();
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$4()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    var _a;
    const { toFetch } = this;
    const thisZoomLevel = tileIds[0].split(".")[0];
    const toFetchZoomLevel = toFetch.size ? [...toFetch][0].split(".")[0] : null;
    if (thisZoomLevel !== toFetchZoomLevel) {
      for (const tileId of this.toFetch) {
        (_a = this.track) == null ? void 0 : _a.fetching.delete(tileId);
      }
      this.toFetch.clear();
    }
    tileIds.forEach((x) => this.toFetch.add(x));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$3);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    return JSON.parse(new TextDecoder().decode(buf));
  }
}
__publicField(BamDataFetcher, "config", { type: "bam" });
const encodedJs$2 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHsKICAgIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSAib2JqZWN0IiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gImZ1bmN0aW9uIikgewogICAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpCiAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSAiZGVmYXVsdCIpCiAgICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pOwogICAgfQogICAgcmV0dXJuIHRhcmdldDsKICB9OwogIHZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHsKICAgIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sICJkZWZhdWx0IiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgImRlZmF1bHQiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcwogIHZhciByZXF1aXJlX2Jhc2U2NF9qcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBleHBvcnRzMi5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKICAgICAgZXhwb3J0czIudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTsKICAgICAgZXhwb3J0czIuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXk7CiAgICAgIHZhciBsb29rdXAgPSBbXTsKICAgICAgdmFyIHJldkxvb2t1cCA9IFtdOwogICAgICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICJ1bmRlZmluZWQiID8gVWludDhBcnJheSA6IEFycmF5OwogICAgICB2YXIgY29kZSA9ICJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIjsKICAgICAgZm9yIChpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogICAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07CiAgICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpOwogICAgICB9CiAgICAgIHZhciBpOwogICAgICB2YXIgbGVuOwogICAgICByZXZMb29rdXBbIi0iLmNoYXJDb2RlQXQoMCldID0gNjI7CiAgICAgIHJldkxvb2t1cFsiXyIuY2hhckNvZGVBdCgwKV0gPSA2MzsKICAgICAgZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHsKICAgICAgICB2YXIgbGVuMiA9IGI2NC5sZW5ndGg7CiAgICAgICAgaWYgKGxlbjIgJSA0ID4gMCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Iik7CiAgICAgICAgfQogICAgICAgIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCI9Iik7CiAgICAgICAgaWYgKHZhbGlkTGVuID09PSAtMSkKICAgICAgICAgIHZhbGlkTGVuID0gbGVuMjsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbjIgPyAwIDogNCAtIHZhbGlkTGVuICUgNDsKICAgICAgICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7CiAgICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7CiAgICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTsKICAgICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikgewogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpOwogICAgICAgIHZhciBjdXJCeXRlID0gMDsKICAgICAgICB2YXIgbGVuMiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjsKICAgICAgICB2YXIgaTI7CiAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuMjsgaTIgKz0gNCkgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDMpXTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldID4+IDQ7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA+PiAyOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYXJyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHsKICAgICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgb3V0cHV0ID0gW107CiAgICAgICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPCBlbmQ7IGkyICs9IDMpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtpMl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAodWludDhbaTIgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kyICsgMl0gJiAyNTUpOwogICAgICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oIiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDgpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW4yID0gdWludDgubGVuZ3RoOwogICAgICAgIHZhciBleHRyYUJ5dGVzID0gbGVuMiAlIDM7CiAgICAgICAgdmFyIHBhcnRzID0gW107CiAgICAgICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7CiAgICAgICAgZm9yICh2YXIgaTIgPSAwLCBsZW4yMiA9IGxlbjIgLSBleHRyYUJ5dGVzOyBpMiA8IGxlbjIyOyBpMiArPSBtYXhDaHVua0xlbmd0aCkgewogICAgICAgICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaTIsIGkyICsgbWF4Q2h1bmtMZW5ndGggPiBsZW4yMiA/IGxlbjIyIDogaTIgKyBtYXhDaHVua0xlbmd0aCkpOwogICAgICAgIH0KICAgICAgICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkgewogICAgICAgICAgdG1wID0gdWludDhbbGVuMiAtIDFdOwogICAgICAgICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgIj09Iik7CiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7CiAgICAgICAgICB0bXAgPSAodWludDhbbGVuMiAtIDJdIDw8IDgpICsgdWludDhbbGVuMiAtIDFdOwogICAgICAgICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDYzXSArIGxvb2t1cFt0bXAgPDwgMiAmIDYzXSArICI9Iik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCIiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcwogIHZhciByZXF1aXJlX2llZWU3NTQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBleHBvcnRzMi5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgbkJpdHMgPSAtNzsKICAgICAgICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7CiAgICAgICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07CiAgICAgICAgaSArPSBkOwogICAgICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgcyA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IGVMZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIGUgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBtTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgaWYgKGUgPT09IDApIHsKICAgICAgICAgIGUgPSAxIC0gZUJpYXM7CiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6IChzID8gLTEgOiAxKSAqIEluZmluaXR5OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgZSA9IGUgLSBlQmlhczsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgICAgICB2YXIgZSwgbSwgYzsKICAgICAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTsKICAgICAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTsKICAgICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7CiAgICAgICAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDA7CiAgICAgICAgdmFyIGkgPSBpc0xFID8gMCA6IG5CeXRlcyAtIDE7CiAgICAgICAgdmFyIGQgPSBpc0xFID8gMSA6IC0xOwogICAgICAgIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDsKICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewogICAgICAgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwOwogICAgICAgICAgZSA9IGVNYXg7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTsKICAgICAgICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHsKICAgICAgICAgICAgZS0tOwogICAgICAgICAgICBjICo9IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7CiAgICAgICAgICAgIGUrKzsKICAgICAgICAgICAgYyAvPSAyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7CiAgICAgICAgICAgIG0gPSAwOwogICAgICAgICAgICBlID0gZU1heDsKICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgICBlID0gZSArIGVCaWFzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgICBlID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDI1NSwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGUgPSBlIDw8IG1MZW4gfCBtOwogICAgICAgIGVMZW4gKz0gbUxlbjsKICAgICAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAyNTUsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkgewogICAgICAgIH0KICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMKICB2YXIgcmVxdWlyZV9idWZmZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGJhc2U2NCA9IHJlcXVpcmVfYmFzZTY0X2pzKCk7CiAgICAgIHZhciBpZWVlNzU0ID0gcmVxdWlyZV9pZWVlNzU0KCk7CiAgICAgIHZhciBjdXN0b21JbnNwZWN0U3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgU3ltYm9sWyJmb3IiXSA9PT0gImZ1bmN0aW9uIiA/IFN5bWJvbFsiZm9yIl0oIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tIikgOiBudWxsOwogICAgICBleHBvcnRzMi5CdWZmZXIgPSBCdWZmZXIxMDsKICAgICAgZXhwb3J0czIuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXI7CiAgICAgIGV4cG9ydHMyLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7CiAgICAgIHZhciBLX01BWF9MRU5HVEggPSAyMTQ3NDgzNjQ3OwogICAgICBleHBvcnRzMi5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIOwogICAgICBCdWZmZXIxMC5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKTsKICAgICAgaWYgKCFCdWZmZXIxMC5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKTsKICAgICAgICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4gNDI7CiAgICAgICAgICB9IH07CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKTsKICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKTsKICAgICAgICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjEwLnByb3RvdHlwZSwgInBhcmVudCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRoaXMpKQogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIxMC5wcm90b3R5cGUsICJvZmZzZXQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcih0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBsZW5ndGggKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMTAucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEJ1ZmZlcjEwKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAic3RyaW5nIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wb29sU2l6ZSA9IDgxOTI7CiAgICAgIGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZzIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHwgdmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gInVuZGVmaW5lZCIgJiYgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKCk7CiAgICAgICAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpOwogICAgICAgIGlmIChiKQogICAgICAgICAgcmV0dXJuIGI7CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCJzdHJpbmciKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgfTsKICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcjEwLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMTAsIFVpbnQ4QXJyYXkpOwogICAgICBmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpOwogICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBzaXplICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgaWYgKHNpemUgPD0gMCkgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZykgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5hbGxvYyA9IGZ1bmN0aW9uKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nMihzdHJpbmcsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gInN0cmluZyIgfHwgZW5jb2RpbmcgPT09ICIiKSB7CiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICB9CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7CiAgICAgICAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpOwogICAgICAgIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKTsKICAgICAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHsKICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUxpa2UoYXJyYXkpIHsKICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7CiAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5VmlldyhhcnJheVZpZXcpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KTsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJvZmZzZXQiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpOwogICAgICAgIH0KICAgICAgICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignImxlbmd0aCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGxldCBidWY7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPT09IHZvaWQgMCAmJiBsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikgewogICAgICAgIGlmIChCdWZmZXIxMC5pc0J1ZmZlcihvYmopKSB7CiAgICAgICAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDsKICAgICAgICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pOwogICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICAgIH0KICAgICAgICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKTsKICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgfQogICAgICAgIGlmIChvYmoubGVuZ3RoICE9PSB2b2lkIDApIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gIm51bWJlciIgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHsKICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iaik7CiAgICAgICAgfQogICAgICAgIGlmIChvYmoudHlwZSA9PT0gIkJ1ZmZlciIgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tlZChsZW5ndGgpIHsKICAgICAgICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgiICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICIgYnl0ZXMiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxlbmd0aCB8IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gU2xvd0J1ZmZlcihsZW5ndGgpIHsKICAgICAgICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBCdWZmZXIxMC5hbGxvYygrbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyMihiKSB7CiAgICAgICAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJiBiICE9PSBCdWZmZXIxMC5wcm90b3R5cGU7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlMihhLCBiKSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpCiAgICAgICAgICBhID0gQnVmZmVyMTAuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKTsKICAgICAgICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkKICAgICAgICAgIGIgPSBCdWZmZXIxMC5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlcjEwLmlzQnVmZmVyKGIpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgImJ1ZjEiLCAiYnVmMiIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKTsKICAgICAgICB9CiAgICAgICAgaWYgKGEgPT09IGIpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgeCA9IGEubGVuZ3RoOwogICAgICAgIGxldCB5ID0gYi5sZW5ndGg7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7CiAgICAgICAgICAgIHggPSBhW2ldOwogICAgICAgICAgICB5ID0gYltpXTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh4IDwgeSkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoeSA8IHgpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcoZW5jb2RpbmcpIHsKICAgICAgICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9OwogICAgICBCdWZmZXIxMC5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobGlzdCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKDApOwogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICAgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlcjEwLmFsbG9jVW5zYWZlKGxlbmd0aCk7CiAgICAgICAgbGV0IHBvcyA9IDA7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGxldCBidWYgPSBsaXN0W2ldOwogICAgICAgICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkgewogICAgICAgICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICAgICAgICBidWYgPSBCdWZmZXIxMC5mcm9tKGJ1Zik7CiAgICAgICAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGJ1ZmZlciwgYnVmLCBwb3MpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihidWYpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTsKICAgICAgICAgIH0KICAgICAgICAgIHBvcyArPSBidWYubGVuZ3RoOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmZmVyOwogICAgICB9OwogICAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAoQnVmZmVyMTAuaXNCdWZmZXIoc3RyaW5nKSkgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBjb25zdCBtdXN0TWF0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWU7CiAgICAgICAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGVuOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gbGVuICogMjsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gbGVuID4+PiAxOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBCdWZmZXIxMC5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKICAgICAgZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDAgfHwgc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPD0gMCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBlbmQgPj4+PSAwOwogICAgICAgIHN0YXJ0ID4+Pj0gMDsKICAgICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGlmICghZW5jb2RpbmcpCiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAiIikudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlOwogICAgICBmdW5jdGlvbiBzd2FwKGIsIG4sIG0pIHsKICAgICAgICBjb25zdCBpID0gYltuXTsKICAgICAgICBiW25dID0gYlttXTsKICAgICAgICBiW21dID0gaTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2KCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSAyICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyKCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSA0ICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0KCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSA4ICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZzIoKSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTsKICAgICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlcjEwLnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFsczIoYikgewogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIik7CiAgICAgICAgaWYgKHRoaXMgPT09IGIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICByZXR1cm4gQnVmZmVyMTAuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkgewogICAgICAgIGxldCBzdHIgPSAiIjsKICAgICAgICBjb25zdCBtYXggPSBleHBvcnRzMi5JTlNQRUNUX01BWF9CWVRFUzsKICAgICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCJoZXgiLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAiJDEgIikudHJpbSgpOwogICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkKICAgICAgICAgIHN0ciArPSAiIC4uLiAiOwogICAgICAgIHJldHVybiAiPEJ1ZmZlciAiICsgc3RyICsgIj4iOwogICAgICB9OwogICAgICBpZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkgewogICAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5pbnNwZWN0OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZTIodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICB0YXJnZXQgPSBCdWZmZXIxMC5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRhcmdldCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAidGFyZ2V0IiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgdGFyZ2V0KTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICB0aGlzU3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc0VuZCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm91dCBvZiByYW5nZSBpbmRleCIpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7CiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA+PSBlbmQpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBzdGFydCA+Pj49IDA7CiAgICAgICAgZW5kID4+Pj0gMDsKICAgICAgICB0aGlzU3RhcnQgPj4+PSAwOwogICAgICAgIHRoaXNFbmQgPj4+PSAwOwogICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7CiAgICAgICAgbGV0IHkgPSBlbmQgLSBzdGFydDsKICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KTsKICAgICAgICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTsKICAgICAgICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkgewogICAgICAgICAgICB4ID0gdGhpc0NvcHlbaV07CiAgICAgICAgICAgIHkgPSB0YXJnZXRDb3B5W2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDIxNDc0ODM2NDcpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAyMTQ3NDgzNjQ3OwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0yMTQ3NDgzNjQ4KSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gLTIxNDc0ODM2NDg7CiAgICAgICAgfQogICAgICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsKICAgICAgICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogYnVmZmVyLmxlbmd0aCAtIDE7CiAgICAgICAgfQogICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCkKICAgICAgICAgIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoZGlyKQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7CiAgICAgICAgICBpZiAoZGlyKQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHZhbCA9IEJ1ZmZlcjEwLmZyb20odmFsLCBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIGlmIChCdWZmZXIxMC5pc0J1ZmZlcih2YWwpKSB7CiAgICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB2YWwgPSB2YWwgJiAyNTU7CiAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgaWYgKGRpcikgewogICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgICAgICAgbGV0IGluZGV4U2l6ZSA9IDE7CiAgICAgICAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGg7CiAgICAgICAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7CiAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDApIHsKICAgICAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgaWYgKGVuY29kaW5nID09PSAidWNzMiIgfHwgZW5jb2RpbmcgPT09ICJ1Y3MtMiIgfHwgZW5jb2RpbmcgPT09ICJ1dGYxNmxlIiB8fCBlbmNvZGluZyA9PT0gInV0Zi0xNmxlIikgewogICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaW5kZXhTaXplID0gMjsKICAgICAgICAgICAgYXJyTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIHZhbExlbmd0aCAvPSAyOwogICAgICAgICAgICBieXRlT2Zmc2V0IC89IDI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJlYWQoYnVmLCBpMikgewogICAgICAgICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkgewogICAgICAgICAgICByZXR1cm4gYnVmW2kyXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkyICogaW5kZXhTaXplKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKGRpcikgewogICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykgewogICAgICAgICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7CiAgICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKQogICAgICAgICAgICAgICAgZm91bmRJbmRleCA9IGk7CiAgICAgICAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKQogICAgICAgICAgICAgICAgaSAtPSBpIC0gZm91bmRJbmRleDsKICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7CiAgICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkgewogICAgICAgICAgICBsZXQgZm91bmQgPSB0cnVlOwogICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkgewogICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZm91bmQpCiAgICAgICAgICAgICAgcmV0dXJuIGk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gaGV4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDsKICAgICAgICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0OwogICAgICAgIGlmICghbGVuZ3RoKSB7CiAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpOwogICAgICAgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykgewogICAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHsKICAgICAgICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTsKICAgICAgICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKQogICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdWNzMldyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwICYmIHR5cGVvZiBvZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBlbmNvZGluZyA9IG9mZnNldDsKICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHsKICAgICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMDsKICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApCiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlbmNvZGluZyA9IGxlbmd0aDsKICAgICAgICAgICAgbGVuZ3RoID0gdm9pZCAwOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkIik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0OwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCB8fCBsZW5ndGggPiByZW1haW5pbmcpCiAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7CiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMiKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9ICgiIiArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHR5cGU6ICJCdWZmZXIiLAogICAgICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApCiAgICAgICAgfTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBjb25zdCByZXMgPSBbXTsKICAgICAgICBsZXQgaSA9IHN0YXJ0OwogICAgICAgIHdoaWxlIChpIDwgZW5kKSB7CiAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV07CiAgICAgICAgICBsZXQgY29kZVBvaW50ID0gbnVsbDsKICAgICAgICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gZmlyc3RCeXRlID4gMjM5ID8gNCA6IGZpcnN0Qnl0ZSA+IDIyMyA/IDMgOiBmaXJzdEJ5dGUgPiAxOTEgPyAyIDogMTsKICAgICAgICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHsKICAgICAgICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7CiAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDEyOCkgewogICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDMxKSA8PCA2IHwgc2Vjb25kQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDEyNykgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDEyIHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgNiB8IHRoaXJkQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDIwNDcgJiYgKHRlbXBDb2RlUG9pbnQgPCA1NTI5NiB8fCB0ZW1wQ29kZVBvaW50ID4gNTczNDMpKSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAoZm91cnRoQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDY1NTM1ICYmIHRlbXBDb2RlUG9pbnQgPCAxMTE0MTEyKSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzOwogICAgICAgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gNjU1MzUpIHsKICAgICAgICAgICAgY29kZVBvaW50IC09IDY1NTM2OwogICAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KTsKICAgICAgICAgICAgY29kZVBvaW50ID0gNTYzMjAgfCBjb2RlUG9pbnQgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpOwogICAgICB9CiAgICAgIHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDQwOTY7CiAgICAgIGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7CiAgICAgICAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkgewogICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTsKICAgICAgICB9CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoaSA8IGxlbikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCByZXQgPSAiIjsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAxMjcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCByZXQgPSAiIjsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGhleFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApCiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pCiAgICAgICAgICBlbmQgPSBsZW47CiAgICAgICAgbGV0IG91dCA9ICIiOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjE2bGVTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHsKICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgc3RhcnQgPSB+fnN0YXJ0OwogICAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gbGVuIDogfn5lbmQ7CiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgewogICAgICAgICAgc3RhcnQgKz0gbGVuOwogICAgICAgICAgaWYgKHN0YXJ0IDwgMCkKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHsKICAgICAgICAgIHN0YXJ0ID0gbGVuOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDwgMCkgewogICAgICAgICAgZW5kICs9IGxlbjsKICAgICAgICAgIGlmIChlbmQgPCAwKQogICAgICAgICAgICBlbmQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7CiAgICAgICAgICBlbmQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCBzdGFydCkKICAgICAgICAgIGVuZCA9IHN0YXJ0OwogICAgICAgIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyMTAucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gbmV3QnVmOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja09mZnNldChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKG9mZnNldCAlIDEgIT09IDAgfHwgb2Zmc2V0IDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJvZmZzZXQgaXMgbm90IHVpbnQiKTsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgiKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnRMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludEJFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIH0KICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB3aGlsZSAoYnl0ZUxlbmd0aDIgPiAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoMl0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludDggPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF07CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiAodGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgKyB0aGlzW29mZnNldCArIDNdICogMTY3NzcyMTY7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gKiAxNjc3NzIxNiArICh0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbG8gPSBmaXJzdCArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDI0OwogICAgICAgIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIGxhc3QgKiAyICoqIDI0OwogICAgICAgIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdDsKICAgICAgICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIG11bCAqPSAxMjg7CiAgICAgICAgaWYgKHZhbCA+PSBtdWwpCiAgICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV07CiAgICAgICAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpOwogICAgICAgIGlmICghKHRoaXNbb2Zmc2V0XSAmIDEyOCkpCiAgICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICAgIHJldHVybiAoMjU1IC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4OwogICAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCB0aGlzW29mZnNldF0gPDwgODsKICAgICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgMjQgfCB0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggKyB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArIChsYXN0IDw8IDI0KTsKICAgICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIGxhc3QpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2hlY2tJbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihidWYpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImJ1ZmZlciIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpOwogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50TEUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG1heEJ5dGVzLCAwKTsKICAgICAgICB9CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG1heEJ5dGVzLCAwKTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50OCA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMjU1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDE2TEUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDMyQkUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDQyOTQ5NjcyOTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldDsKICAgICAgfQogICAgICBmdW5jdGlvbiB3cnRCaWdVSW50NjRCRShidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7CiAgICAgICAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KTsKICAgICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyA3XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNl0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDVdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA0XSA9IGxvOwogICAgICAgIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0ICsgM10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDJdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyAxXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0XSA9IGhpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA4OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoIjB4ZmZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoIjB4ZmZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBsaW1pdCAtIDEsIC1saW1pdCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gMDsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgc3ViID0gMDsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkgewogICAgICAgICAgICBzdWIgPSAxOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyIC0gMSk7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbGltaXQgLSAxLCAtbGltaXQpOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyIC0gMTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgc3ViID0gMDsKICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHsKICAgICAgICAgICAgc3ViID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMTI3LCAtMTI4KTsKICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgdmFsdWUgPSAyNTUgKyB2YWx1ZSArIDE7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpOwogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICB2YWx1ZSA9IDQyOTQ5NjcyOTUgKyB2YWx1ZSArIDE7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgiMHg4MDAwMDAwMDAwMDAwMDAwIiksIEJpZ0ludCgiMHg3ZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgiMHg4MDAwMDAwMDAwMDAwMDAwIiksIEJpZ0ludCgiMHg3ZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICAgIGlmIChvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDM0MDI4MjM0NjYzODUyODg2ZTIyLCAtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpOwogICAgICAgIH0KICAgICAgICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxNzk3NjkzMTM0ODYyMzE1N2UyOTIsIC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpOwogICAgICAgIH0KICAgICAgICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcih0YXJnZXQpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyIik7CiAgICAgICAgaWYgKCFzdGFydCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApCiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkKICAgICAgICAgIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDsKICAgICAgICBpZiAoIXRhcmdldFN0YXJ0KQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwOwogICAgICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigic291cmNlRW5kIG91dCBvZiBib3VuZHMiKTsKICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpCiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHsKICAgICAgICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0OwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0YXJnZXQsIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHRhcmdldFN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gc3RhcnQ7CiAgICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gZW5kOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZyIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgJiYgIUJ1ZmZlcjEwLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gInV0ZjgiICYmIGNvZGUgPCAxMjggfHwgZW5jb2RpbmcgPT09ICJsYXRpbjEiKSB7CiAgICAgICAgICAgICAgdmFsID0gY29kZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJib29sZWFuIikgewogICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk91dCBvZiByYW5nZSBpbmRleCIpOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgc3RhcnQgPSBzdGFydCA+Pj4gMDsKICAgICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwOwogICAgICAgIGlmICghdmFsKQogICAgICAgICAgdmFsID0gMDsKICAgICAgICBsZXQgaTsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgICAgdGhpc1tpXSA9IHZhbDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIxMC5pc0J1ZmZlcih2YWwpID8gdmFsIDogQnVmZmVyMTAuZnJvbSh2YWwsIGVuY29kaW5nKTsKICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDsKICAgICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlICInICsgdmFsICsgJyIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgInZhbHVlIicpOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHsKICAgICAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICB2YXIgZXJyb3JzID0ge307CiAgICAgIGZ1bmN0aW9uIEUoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7CiAgICAgICAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHsKICAgICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgICBzdXBlcigpOwogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgIm1lc3NhZ2UiLCB7CiAgICAgICAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gOwogICAgICAgICAgICB0aGlzLnN0YWNrOwogICAgICAgICAgICBkZWxldGUgdGhpcy5uYW1lOwogICAgICAgICAgfQogICAgICAgICAgZ2V0IGNvZGUoKSB7CiAgICAgICAgICAgIHJldHVybiBzeW07CiAgICAgICAgICB9CiAgICAgICAgICBzZXQgY29kZSh2YWx1ZSkgewogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImNvZGUiLCB7CiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgICAgICAgdmFsdWUsCiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWA7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQogICAgICBFKCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMiLCBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgaWYgKG5hbWUpIHsKICAgICAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgOwogICAgICAgIH0KICAgICAgICByZXR1cm4gIkF0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMiOwogICAgICB9LCBSYW5nZUVycm9yKTsKICAgICAgRSgiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCBmdW5jdGlvbihuYW1lLCBhY3R1YWwpIHsKICAgICAgICByZXR1cm4gYFRoZSAiJHtuYW1lfSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YDsKICAgICAgfSwgVHlwZUVycm9yKTsKICAgICAgRSgiRVJSX09VVF9PRl9SQU5HRSIsIGZ1bmN0aW9uKHN0ciwgcmFuZ2UsIGlucHV0KSB7CiAgICAgICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgIiR7c3RyfSIgaXMgb3V0IG9mIHJhbmdlLmA7CiAgICAgICAgbGV0IHJlY2VpdmVkID0gaW5wdXQ7CiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHsKICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAiYmlnaW50IikgewogICAgICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpOwogICAgICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkgewogICAgICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZCk7CiAgICAgICAgICB9CiAgICAgICAgICByZWNlaXZlZCArPSAibiI7CiAgICAgICAgfQogICAgICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YDsKICAgICAgICByZXR1cm4gbXNnOwogICAgICB9LCBSYW5nZUVycm9yKTsKICAgICAgZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHZhbCkgewogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBsZXQgaSA9IHZhbC5sZW5ndGg7CiAgICAgICAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICItIiA/IDEgOiAwOwogICAgICAgIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7CiAgICAgICAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKSB7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgaWYgKGJ1ZltvZmZzZXRdID09PSB2b2lkIDAgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGgyXSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aDIgKyAxKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHsKICAgICAgICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAiYmlnaW50IiA/ICJuIiA6ICIiOwogICAgICAgICAgbGV0IHJhbmdlOwogICAgICAgICAgaWYgKGJ5dGVMZW5ndGgyID4gMykgewogICAgICAgICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7CiAgICAgICAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDh9JHtufWA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOCAtIDF9JHtufWA7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gOwogICAgICAgICAgfQogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCJ2YWx1ZSIsIHJhbmdlLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIodmFsdWUsIG5hbWUpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAibnVtYmVyIiwgdmFsdWUpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBib3VuZHNFcnJvcih2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7CiAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkgewogICAgICAgICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpOwogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgIm9mZnNldCIsICJhbiBpbnRlZ2VyIiwgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAobGVuZ3RoIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgIm9mZnNldCIsIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsIHZhbHVlKTsKICAgICAgfQogICAgICB2YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nOwogICAgICBmdW5jdGlvbiBiYXNlNjRjbGVhbihzdHIpIHsKICAgICAgICBzdHIgPSBzdHIuc3BsaXQoIj0iKVswXTsKICAgICAgICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICIiKTsKICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDIpCiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7CiAgICAgICAgICBzdHIgPSBzdHIgKyAiPSI7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzdHI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyaW5nLCB1bml0cykgewogICAgICAgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7CiAgICAgICAgbGV0IGNvZGVQb2ludDsKICAgICAgICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICBjb25zdCBieXRlcyA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU1Mjk1ICYmIGNvZGVQb2ludCA8IDU3MzQ0KSB7CiAgICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkgewogICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NjMxOSkgewogICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgNTYzMjApIHsKICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSA1NTI5NiA8PCAxMCB8IGNvZGVQb2ludCAtIDU2MzIwKSArIDY1NTM2OwogICAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgfQogICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7CiAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMTI4KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDIwNDgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDYgfCAxOTIsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgNjU1MzYpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDEyIHwgMjI0LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDExMTQxMTIpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDE4IHwgMjQwLCBjb2RlUG9pbnQgPj4gMTIgJiA2MyB8IDEyOCwgY29kZVBvaW50ID4+IDYgJiA2MyB8IDEyOCwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGNvZGUgcG9pbnQiKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhzdHIpIHsKICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAyNTUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKHN0ciwgdW5pdHMpIHsKICAgICAgICBsZXQgYywgaGksIGxvOwogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBoaSA9IGMgPj4gODsKICAgICAgICAgIGxvID0gYyAlIDI1NjsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGxvKTsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGhpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikgewogICAgICAgIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBsZXQgaTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmIChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGggfHwgaSA+PSBzcmMubGVuZ3RoKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNJbnN0YW5jZShvYmosIHR5cGUpIHsKICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fCBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbnVtYmVySXNOYU4ob2JqKSB7CiAgICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqOwogICAgICB9CiAgICAgIHZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgY29uc3QgYWxwaGFiZXQgPSAiMDEyMzQ1Njc4OWFiY2RlZiI7CiAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHsKICAgICAgICAgIGNvbnN0IGkxNiA9IGkgKiAxNjsKICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikgewogICAgICAgICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0YWJsZTsKICAgICAgfSgpOwogICAgICBmdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QoZm4pIHsKICAgICAgICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gInVuZGVmaW5lZCIgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkJpZ0ludCBub3Qgc3VwcG9ydGVkIik7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gc3JjL2FsaWFzL2J1ZmZlci1zaGltLmpzCiAgdmFyIGltcG9ydF9idWZmZXI7CiAgdmFyIGluaXRfYnVmZmVyX3NoaW0gPSBfX2VzbSh7CiAgICAic3JjL2FsaWFzL2J1ZmZlci1zaGltLmpzIigpIHsKICAgICAgaW1wb3J0X2J1ZmZlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9janNfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvY2pzLXBvbnlmaWxsLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikKICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsKICAgICAgICBpZiAocHJvdG9Qcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7CiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAiZnVuY3Rpb24iICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgewogICAgICAgICAgY29uc3RydWN0b3I6IHsKICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCAicHJvdG90eXBlIiwgewogICAgICAgICAgd3JpdGFibGU6IGZhbHNlCiAgICAgICAgfSk7CiAgICAgICAgaWYgKHN1cGVyQ2xhc3MpCiAgICAgICAgICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7CiAgICAgICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZjIobzIpIHsKICAgICAgICAgIHJldHVybiBvMi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8yKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsKICAgICAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mMihvMiwgcDIpIHsKICAgICAgICAgIG8yLl9fcHJvdG9fXyA9IHAyOwogICAgICAgICAgcmV0dXJuIG8yOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgewogICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB0cnkgewogICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHsKICAgICAgICAgIH0pKTsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmMikgewogICAgICAgIGlmIChzZWxmMiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc2VsZjI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZjIsIGNhbGwpIHsKICAgICAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09ICJvYmplY3QiIHx8IHR5cGVvZiBjYWxsID09PSAiZnVuY3Rpb24iKSkgewogICAgICAgICAgcmV0dXJuIGNhbGw7CiAgICAgICAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgewogICAgICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsKICAgICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OwogICAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsKICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsKICAgICAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgewogICAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7CiAgICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKQogICAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iamVjdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBfZ2V0KCkgewogICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gInVuZGVmaW5lZCIgJiYgUmVmbGVjdC5nZXQpIHsKICAgICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0Mih0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgewogICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOwogICAgICAgICAgICBpZiAoIWJhc2UpCiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOwogICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHsKICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTsKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH0KICAgICAgdmFyIEVtaXR0ZXIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gRW1pdHRlcjIoKSB7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1pdHRlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJsaXN0ZW5lcnMiLCB7CiAgICAgICAgICAgIHZhbHVlOiB7fSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhFbWl0dGVyMiwgW3sKICAgICAgICAgIGtleTogImFkZEV2ZW50TGlzdGVuZXIiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsKICAgICAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHsKICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goewogICAgICAgICAgICAgIGNhbGxiYWNrLAogICAgICAgICAgICAgIG9wdGlvbnMKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFjay5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICBpZiAoc3RhY2tbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7CiAgICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZGlzcGF0Y2hFdmVudCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkgewogICAgICAgICAgICBpZiAoIShldmVudC50eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXTsKICAgICAgICAgICAgdmFyIHN0YWNrVG9DYWxsID0gc3RhY2suc2xpY2UoKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFja1RvQ2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBzdGFja1RvQ2FsbFtpXTsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub3B0aW9ucyAmJiBsaXN0ZW5lci5vcHRpb25zLm9uY2UpIHsKICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudC50eXBlLCBsaXN0ZW5lci5jYWxsYmFjayk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEVtaXR0ZXIyOwogICAgICB9KCk7CiAgICAgIHZhciBBYm9ydFNpZ25hbCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfRW1pdHRlcikgewogICAgICAgIF9pbmhlcml0cyhBYm9ydFNpZ25hbDIsIF9FbWl0dGVyKTsKICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFib3J0U2lnbmFsMik7CiAgICAgICAgZnVuY3Rpb24gQWJvcnRTaWduYWwyKCkgewogICAgICAgICAgdmFyIF90aGlzOwogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0U2lnbmFsMik7CiAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOwogICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnMpIHsKICAgICAgICAgICAgRW1pdHRlci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsKICAgICAgICAgIH0KICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgImFib3J0ZWQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICJvbmFib3J0IiwgewogICAgICAgICAgICB2YWx1ZTogbnVsbCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICJyZWFzb24iLCB7CiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDAsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIF90aGlzOwogICAgICAgIH0KICAgICAgICBfY3JlYXRlQ2xhc3MoQWJvcnRTaWduYWwyLCBbewogICAgICAgICAga2V5OiAidG9TdHJpbmciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nMigpIHsKICAgICAgICAgICAgcmV0dXJuICJbb2JqZWN0IEFib3J0U2lnbmFsXSI7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZGlzcGF0Y2hFdmVudCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkgewogICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gImFib3J0IikgewogICAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uYWJvcnQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICAgIHRoaXMub25hYm9ydC5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQWJvcnRTaWduYWwyLnByb3RvdHlwZSksICJkaXNwYXRjaEV2ZW50IiwgdGhpcykuY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBBYm9ydFNpZ25hbDI7CiAgICAgIH0oRW1pdHRlcik7CiAgICAgIHZhciBBYm9ydENvbnRyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gQWJvcnRDb250cm9sbGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm9ydENvbnRyb2xsZXIyKTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAic2lnbmFsIiwgewogICAgICAgICAgICB2YWx1ZTogbmV3IEFib3J0U2lnbmFsKCksCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBfY3JlYXRlQ2xhc3MoQWJvcnRDb250cm9sbGVyMiwgW3sKICAgICAgICAgIGtleTogImFib3J0IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHsKICAgICAgICAgICAgdmFyIGV2ZW50OwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KCJhYm9ydCIpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpOwogICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gImFib3J0IjsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoIkV2ZW50Iik7CiAgICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgiYWJvcnQiLCBmYWxzZSwgZmFsc2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBldmVudCA9IHsKICAgICAgICAgICAgICAgICAgdHlwZTogImFib3J0IiwKICAgICAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsCiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc2lnbmFsUmVhc29uID0gcmVhc29uOwogICAgICAgICAgICBpZiAoc2lnbmFsUmVhc29uID09PSB2b2lkIDApIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAidW5kZWZpbmVkIikgewogICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IEVycm9yKCJUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCIpOwogICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uLm5hbWUgPSAiQWJvcnRFcnJvciI7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBET01FeGNlcHRpb24oInNpZ25hbCBpcyBhYm9ydGVkIHdpdGhvdXQgcmVhc29uIik7CiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IEVycm9yKCJUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCIpOwogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5zaWduYWwucmVhc29uID0gc2lnbmFsUmVhc29uOwogICAgICAgICAgICB0aGlzLnNpZ25hbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcyKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRDb250cm9sbGVyXSI7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBBYm9ydENvbnRyb2xsZXIyOwogICAgICB9KCk7CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHsKICAgICAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAiQWJvcnRDb250cm9sbGVyIjsKICAgICAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydFNpZ25hbCI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9seWZpbGxOZWVkZWQoc2VsZjIpIHsKICAgICAgICBpZiAoc2VsZjIuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgY29uc29sZS5sb2coIl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCIpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZjIuUmVxdWVzdCA9PT0gImZ1bmN0aW9uIiAmJiAhc2VsZjIuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoInNpZ25hbCIpIHx8ICFzZWxmMi5BYm9ydENvbnRyb2xsZXI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3IocGF0Y2hUYXJnZXRzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRjaFRhcmdldHMgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHBhdGNoVGFyZ2V0cyA9IHsKICAgICAgICAgICAgZmV0Y2g6IHBhdGNoVGFyZ2V0cwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIF9wYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMsIGZldGNoID0gX3BhdGNoVGFyZ2V0cy5mZXRjaCwgX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cy5SZXF1ZXN0LCBOYXRpdmVSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID09PSB2b2lkIDAgPyBmZXRjaC5SZXF1ZXN0IDogX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0LCBOYXRpdmVBYm9ydENvbnRyb2xsZXIgPSBfcGF0Y2hUYXJnZXRzLkFib3J0Q29udHJvbGxlciwgX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID0gX3BhdGNoVGFyZ2V0cy5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMLCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMID0gX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXRjaFRhcmdldHMkX19GT1JDRTsKICAgICAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHsKICAgICAgICAgIGZldGNoLAogICAgICAgICAgUmVxdWVzdDogTmF0aXZlUmVxdWVzdCwKICAgICAgICAgIEFib3J0Q29udHJvbGxlcjogTmF0aXZlQWJvcnRDb250cm9sbGVyLAogICAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTAogICAgICAgIH0pKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBmZXRjaCwKICAgICAgICAgICAgUmVxdWVzdAogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIFJlcXVlc3QgPSBOYXRpdmVSZXF1ZXN0OwogICAgICAgIGlmIChSZXF1ZXN0ICYmICFSZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3QyKGlucHV0LCBpbml0MikgewogICAgICAgICAgICB2YXIgc2lnbmFsOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgc2lnbmFsID0gaW5pdDIuc2lnbmFsOwogICAgICAgICAgICAgIGRlbGV0ZSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgTmF0aXZlUmVxdWVzdChpbnB1dCwgaW5pdDIpOwogICAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICJzaWduYWwiLCB7CiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVxdWVzdDsKICAgICAgICAgIH07CiAgICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlOwogICAgICAgIH0KICAgICAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2g7CiAgICAgICAgdmFyIGFib3J0YWJsZUZldGNoID0gZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2gyKGlucHV0LCBpbml0MikgewogICAgICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0MiA/IGluaXQyLnNpZ25hbCA6IHZvaWQgMDsKICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgdmFyIGFib3J0RXJyb3I7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IEVycm9yKCJBYm9ydGVkIik7CiAgICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgY2FuY2VsbGF0aW9uID0gbmV3IFByb21pc2UoZnVuY3Rpb24oXywgcmVqZWN0KSB7CiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICAgIH0sIHsKICAgICAgICAgICAgICAgIG9uY2U6IHRydWUKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0MildKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZWFsRmV0Y2goaW5wdXQsIGluaXQyKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBmZXRjaDogYWJvcnRhYmxlRmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIGV4cG9ydHMyLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICAgIGV4cG9ydHMyLmFib3J0YWJsZUZldGNoID0gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3I7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vYWJvcnRjb250cm9sbGVyLXBvbnlmaWxsLmpzCiAgdmFyIHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSB2b2lkIDA7CiAgICAgIHZhciBjanNfcG9ueWZpbGxfMSA9IHJlcXVpcmVfY2pzX3BvbnlmaWxsKCk7CiAgICAgIHZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gc2VsZjsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gd2luZG93OwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBnbG9iYWw7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Iik7CiAgICAgIH07CiAgICAgIHZhciBBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyID09PSAidW5kZWZpbmVkIiA/IGNqc19wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlciA6IGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0czIuQWJvcnRDb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyOwogICAgICB2YXIgQWJvcnRTaWduYWwgPSB0eXBlb2YgZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyID09PSAidW5kZWZpbmVkIiA/IGNqc19wb255ZmlsbF8xLkFib3J0U2lnbmFsIDogZ2V0R2xvYmFsKCkuQWJvcnRTaWduYWw7CiAgICAgIGV4cG9ydHMyLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlQWJvcnRDb250cm9sbGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIE51bGxTaWduYWwgPSBjbGFzcyB7CiAgICAgIH07CiAgICAgIHZhciBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICB0aGlzLnNpZ25hbHMgPSBuZXcgU2V0KCk7CiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMS5BYm9ydENvbnRyb2xsZXIoKTsKICAgICAgICB9CiAgICAgICAgYWRkU2lnbmFsKHNpZ25hbCA9IG5ldyBOdWxsU2lnbmFsKCkpIHsKICAgICAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGFkZCBhIHNpZ25hbCwgYWxyZWFkeSBhYm9ydGVkISIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5zaWduYWxzLmFkZChzaWduYWwpOwogICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgIHRoaXMuaGFuZGxlQWJvcnRlZChzaWduYWwpOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgKCkgPT4gewogICAgICAgICAgICAgIHRoaXMuaGFuZGxlQWJvcnRlZChzaWduYWwpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaGFuZGxlQWJvcnRlZChzaWduYWwpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscy5kZWxldGUoc2lnbmFsKTsKICAgICAgICAgIGlmICh0aGlzLnNpZ25hbHMuc2l6ZSA9PT0gMCkgewogICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQgc2lnbmFsKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbDsKICAgICAgICB9CiAgICAgICAgYWJvcnQoKSB7CiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBTZXQoKTsKICAgICAgICB9CiAgICAgICAgYWRkQ2FsbGJhY2soY2FsbGJhY2sgPSAoKSA9PiB7CiAgICAgICAgfSkgewogICAgICAgICAgdGhpcy5jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY3VycmVudE1lc3NhZ2UpOwogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhtZXNzYWdlKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGVsdCkgPT4gewogICAgICAgICAgICBlbHQobWVzc2FnZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BYm9ydGFibGVQcm9taXNlQ2FjaGUuanMKICB2YXIgcmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMSA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcigpKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcigpKTsKICAgICAgdmFyIEFib3J0YWJsZVByb21pc2VDYWNoZTIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoeyBmaWxsLCBjYWNoZSB9KSB7CiAgICAgICAgICBpZiAodHlwZW9mIGZpbGwgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgZmlsbCBmdW5jdGlvbiIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBjYWNoZSAhPT0gIm9iamVjdCIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgY2FjaGUgb2JqZWN0Iik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlLmdldCAhPT0gImZ1bmN0aW9uIiB8fCB0eXBlb2YgY2FjaGUuc2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5kZWxldGUgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FjaGUgbXVzdCBpbXBsZW1lbnQgZ2V0KGtleSksIHNldChrZXksIHZhbCksIGFuZCBhbmQgZGVsZXRlKGtleSkiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTsKICAgICAgICAgIHRoaXMuZmlsbENhbGxiYWNrID0gZmlsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGlzQWJvcnRFeGNlcHRpb24oZXhjZXB0aW9uKSB7CiAgICAgICAgICByZXR1cm4gZXhjZXB0aW9uLm5hbWUgPT09ICJBYm9ydEVycm9yIiB8fCBleGNlcHRpb24uY29kZSA9PT0gIkVSUl9BQk9SVEVEIiB8fCBleGNlcHRpb24ubWVzc2FnZSA9PT0gIkFib3J0RXJyb3I6IGFib3J0ZWQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiRXJyb3I6IGFib3J0ZWQiOwogICAgICAgIH0KICAgICAgICBldmljdChrZXksIGVudHJ5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5nZXQoa2V5KSA9PT0gZW50cnkpIHsKICAgICAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spIHsKICAgICAgICAgIGNvbnN0IGFib3J0ZXIgPSBuZXcgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyXzEuZGVmYXVsdCgpOwogICAgICAgICAgY29uc3Qgc3RhdHVzUmVwb3J0ZXIgPSBuZXcgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBzdGF0dXNSZXBvcnRlci5hZGRDYWxsYmFjayhzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IHsKICAgICAgICAgICAgYWJvcnRlciwKICAgICAgICAgICAgcHJvbWlzZTogdGhpcy5maWxsQ2FsbGJhY2soZGF0YSwgYWJvcnRlci5zaWduYWwsIChtZXNzYWdlKSA9PiB7CiAgICAgICAgICAgICAgc3RhdHVzUmVwb3J0ZXIuY2FsbGJhY2sobWVzc2FnZSk7CiAgICAgICAgICAgIH0pLAogICAgICAgICAgICBzZXR0bGVkOiBmYWxzZSwKICAgICAgICAgICAgc3RhdHVzUmVwb3J0ZXIsCiAgICAgICAgICAgIGdldCBhYm9ydGVkKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmFib3J0ZXIuc2lnbmFsLmFib3J0ZWQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLmFkZFNpZ25hbChzaWduYWwpOwogICAgICAgICAgbmV3RW50cnkuYWJvcnRlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgIGlmICghbmV3RW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgbmV3RW50cnkucHJvbWlzZS50aGVuKCgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgIG5ld0VudHJ5LnNldHRsZWQgPSB0cnVlOwogICAgICAgICAgICB0aGlzLmV2aWN0KGtleSwgbmV3RW50cnkpOwogICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTsKICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgIH0pOwogICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBjaGVja1NpbmdsZVByb21pc2UocHJvbWlzZSwgc2lnbmFsKSB7CiAgICAgICAgICBmdW5jdGlvbiBjaGVja0ZvclNpbmdsZUFib3J0KCkgewogICAgICAgICAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoImFib3J0ZWQiKSwgeyBjb2RlOiAiRVJSX0FCT1JURUQiIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgICAgfSwgKGVycm9yKSA9PiB7CiAgICAgICAgICAgIGNoZWNrRm9yU2luZ2xlQWJvcnQoKTsKICAgICAgICAgICAgdGhyb3cgZXJyb3I7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgaGFzKGtleSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIGdldChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spIHsKICAgICAgICAgIGlmICghc2lnbmFsICYmIGRhdGEgaW5zdGFuY2VvZiBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMS5BYm9ydFNpZ25hbCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJzZWNvbmQgZ2V0IGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYW4gQWJvcnRTaWduYWwsIHBlcmhhcHMgeW91IG1lYW50IHRvIHBhc3MgYG51bGxgIGZvciB0aGUgZmlsbCBkYXRhPyIpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVFbnRyeSkgewogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5hYm9ydGVkICYmICFjYWNoZUVudHJ5LnNldHRsZWQpIHsKICAgICAgICAgICAgICB0aGlzLmV2aWN0KGtleSwgY2FjaGVFbnRyeSk7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FjaGVFbnRyeS5hYm9ydGVyLmFkZFNpZ25hbChzaWduYWwpOwogICAgICAgICAgICBjYWNoZUVudHJ5LnN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgcmV0dXJuIEFib3J0YWJsZVByb21pc2VDYWNoZTIuY2hlY2tTaW5nbGVQcm9taXNlKGNhY2hlRW50cnkucHJvbWlzZSwgc2lnbmFsKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgcmV0dXJuIEFib3J0YWJsZVByb21pc2VDYWNoZTIuY2hlY2tTaW5nbGVQcm9taXNlKHRoaXMuY2FjaGUuZ2V0KGtleSkucHJvbWlzZSwgc2lnbmFsKTsKICAgICAgICB9CiAgICAgICAgZGVsZXRlKGtleSkgewogICAgICAgICAgY29uc3QgY2FjaGVkRW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgaWYgKGNhY2hlZEVudHJ5KSB7CiAgICAgICAgICAgIGlmICghY2FjaGVkRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIGNhY2hlZEVudHJ5LmFib3J0ZXIuYWJvcnQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjbGVhcigpIHsKICAgICAgICAgIGNvbnN0IGtleUl0ZXIgPSB0aGlzLmNhY2hlLmtleXMoKTsKICAgICAgICAgIGxldCBkZWxldGVDb3VudCA9IDA7CiAgICAgICAgICBmb3IgKGxldCByZXN1bHQgPSBrZXlJdGVyLm5leHQoKTsgIXJlc3VsdC5kb25lOyByZXN1bHQgPSBrZXlJdGVyLm5leHQoKSkgewogICAgICAgICAgICB0aGlzLmRlbGV0ZShyZXN1bHQudmFsdWUpOwogICAgICAgICAgICBkZWxldGVDb3VudCArPSAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGRlbGV0ZUNvdW50OwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFib3J0YWJsZVByb21pc2VDYWNoZTI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMKICB2YXIgcmVxdWlyZV9lc20gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIEFib3J0YWJsZVByb21pc2VDYWNoZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWJvcnRhYmxlUHJvbWlzZUNhY2hlKCkpOwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWJvcnRhYmxlUHJvbWlzZUNhY2hlXzEuZGVmYXVsdDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9xdWlja19scnUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBRdWlja0xSVSA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgICAgIGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplOwogICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgX3NldChrZXksIHZhbHVlKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIHRoaXMuX3NpemUrKzsKICAgICAgICAgIGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkgewogICAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7CiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldChrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIGhhcyhrZXkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMub2xkQ2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIHBlZWsoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIGlmIChkZWxldGVkKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUtLTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgICprZXlzKCkgewogICAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIGtleTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKnZhbHVlcygpIHsKICAgICAgICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQgdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgICAgICBjb25zdCBba2V5XSA9IGl0ZW07CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpemUoKSB7CiAgICAgICAgICBsZXQgb2xkQ2FjaGVTaXplID0gMDsKICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIG9sZENhY2hlU2l6ZSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSArIG9sZENhY2hlU2l6ZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFF1aWNrTFJVOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2xvY2FsRmlsZQogIHZhciByZXF1aXJlX2xvY2FsRmlsZSA9IF9fY29tbW9uSlMoewogICAgIihkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vbG9jYWxGaWxlIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBUWVBFRF9PSyA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgVWludDE2QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAidW5kZWZpbmVkIjsKICAgICAgZnVuY3Rpb24gX2hhcyhvYmosIGtleSkgewogICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmFzc2lnbiA9IGZ1bmN0aW9uKG9iaikgewogICAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgICAgICAgICBpZiAoIXNvdXJjZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICJtdXN0IGJlIG5vbi1vYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHsKICAgICAgICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfTsKICAgICAgZXhwb3J0czIuc2hyaW5rQnVmID0gZnVuY3Rpb24oYnVmLCBzaXplKSB7CiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsKICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgfQogICAgICAgIGlmIChidWYuc3ViYXJyYXkpIHsKICAgICAgICAgIHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7CiAgICAgICAgfQogICAgICAgIGJ1Zi5sZW5ndGggPSBzaXplOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIHZhciBmblR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7CiAgICAgICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0OwogICAgICAgICAgbGVuID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTsKICAgICAgICAgIHBvcyA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBjaHVuayA9IGNodW5rc1tpXTsKICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTsKICAgICAgICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgZm5VbnR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5zZXRUeXBlZCA9IGZ1bmN0aW9uKG9uKSB7CiAgICAgICAgaWYgKG9uKSB7CiAgICAgICAgICBleHBvcnRzMi5CdWY4ID0gVWludDhBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjE2ID0gVWludDE2QXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYzMiA9IEludDMyQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5hc3NpZ24oZXhwb3J0czIsIGZuVHlwZWQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBleHBvcnRzMi5CdWY4ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYxNiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMzIgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLmFzc2lnbihleHBvcnRzMiwgZm5VbnR5cGVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNldFR5cGVkKFRZUEVEX09LKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMKICB2YXIgcmVxdWlyZV90cmVlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIFpfRklYRUQgPSA0OwogICAgICB2YXIgWl9CSU5BUlkgPSAwOwogICAgICB2YXIgWl9URVhUID0gMTsKICAgICAgdmFyIFpfVU5LTk9XTiA9IDI7CiAgICAgIGZ1bmN0aW9uIHplcm8oYnVmKSB7CiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHsKICAgICAgICAgIGJ1ZltsZW5dID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIFNUT1JFRF9CTE9DSyA9IDA7CiAgICAgIHZhciBTVEFUSUNfVFJFRVMgPSAxOwogICAgICB2YXIgRFlOX1RSRUVTID0gMjsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBMRU5HVEhfQ09ERVMgPSAyOTsKICAgICAgdmFyIExJVEVSQUxTID0gMjU2OwogICAgICB2YXIgTF9DT0RFUyA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUzsKICAgICAgdmFyIERfQ09ERVMgPSAzMDsKICAgICAgdmFyIEJMX0NPREVTID0gMTk7CiAgICAgIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7CiAgICAgIHZhciBNQVhfQklUUyA9IDE1OwogICAgICB2YXIgQnVmX3NpemUgPSAxNjsKICAgICAgdmFyIE1BWF9CTF9CSVRTID0gNzsKICAgICAgdmFyIEVORF9CTE9DSyA9IDI1NjsKICAgICAgdmFyIFJFUF8zXzYgPSAxNjsKICAgICAgdmFyIFJFUFpfM18xMCA9IDE3OwogICAgICB2YXIgUkVQWl8xMV8xMzggPSAxODsKICAgICAgdmFyIGV4dHJhX2xiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDBdOwogICAgICB2YXIgZXh0cmFfZGJpdHMgPSBbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzXTsKICAgICAgdmFyIGV4dHJhX2JsYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XTsKICAgICAgdmFyIGJsX29yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICB2YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsKICAgICAgdmFyIHN0YXRpY19sdHJlZSA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7CiAgICAgIHplcm8oc3RhdGljX2x0cmVlKTsKICAgICAgdmFyIHN0YXRpY19kdHJlZSA9IG5ldyBBcnJheShEX0NPREVTICogMik7CiAgICAgIHplcm8oc3RhdGljX2R0cmVlKTsKICAgICAgdmFyIF9kaXN0X2NvZGUgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7CiAgICAgIHplcm8oX2Rpc3RfY29kZSk7CiAgICAgIHZhciBfbGVuZ3RoX2NvZGUgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7CiAgICAgIHplcm8oX2xlbmd0aF9jb2RlKTsKICAgICAgdmFyIGJhc2VfbGVuZ3RoID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9sZW5ndGgpOwogICAgICB2YXIgYmFzZV9kaXN0ID0gbmV3IEFycmF5KERfQ09ERVMpOwogICAgICB6ZXJvKGJhc2VfZGlzdCk7CiAgICAgIGZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkgewogICAgICAgIHRoaXMuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTsKICAgICAgICB0aGlzLmV4dHJhX2JpdHMgPSBleHRyYV9iaXRzOwogICAgICAgIHRoaXMuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7CiAgICAgICAgdGhpcy5lbGVtcyA9IGVsZW1zOwogICAgICAgIHRoaXMubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7CiAgICAgICAgdGhpcy5oYXNfc3RyZWUgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19sX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfZF9kZXNjOwogICAgICB2YXIgc3RhdGljX2JsX2Rlc2M7CiAgICAgIGZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHsKICAgICAgICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7CiAgICAgICAgdGhpcy5tYXhfY29kZSA9IDA7CiAgICAgICAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHsKICAgICAgICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSB3ID4+PiA4ICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiBCdWZfc2l6ZSAtIGxlbmd0aCkgewogICAgICAgICAgcy5iaV9idWYgfD0gdmFsdWUgPDwgcy5iaV92YWxpZCAmIDY1NTM1OwogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gQnVmX3NpemUgLSBzLmJpX3ZhbGlkOwogICAgICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5iaV9idWYgfD0gdmFsdWUgPDwgcy5iaV92YWxpZCAmIDY1NTM1OwogICAgICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLCB0cmVlW2MgKiAyICsgMV0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7CiAgICAgICAgdmFyIHJlcyA9IDA7CiAgICAgICAgZG8gewogICAgICAgICAgcmVzIHw9IGNvZGUgJiAxOwogICAgICAgICAgY29kZSA+Pj49IDE7CiAgICAgICAgICByZXMgPDw9IDE7CiAgICAgICAgfSB3aGlsZSAoLS1sZW4gPiAwKTsKICAgICAgICByZXR1cm4gcmVzID4+PiAxOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkgewogICAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDI1NTsKICAgICAgICAgIHMuYmlfYnVmID4+PSA4OwogICAgICAgICAgcy5iaV92YWxpZCAtPSA4OwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIG1heF9jb2RlID0gZGVzYy5tYXhfY29kZTsKICAgICAgICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTsKICAgICAgICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgICAgIHZhciBleHRyYSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7CiAgICAgICAgdmFyIGJhc2UgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlOwogICAgICAgIHZhciBtYXhfbGVuZ3RoID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDsKICAgICAgICB2YXIgaDsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgeGJpdHM7CiAgICAgICAgdmFyIGY7CiAgICAgICAgdmFyIG92ZXJmbG93ID0gMDsKICAgICAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIHMuYmxfY291bnRbYml0c10gPSAwOwogICAgICAgIH0KICAgICAgICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXSA9IDA7CiAgICAgICAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykgewogICAgICAgICAgbiA9IHMuaGVhcFtoXTsKICAgICAgICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXSAqIDIgKyAxXSArIDE7CiAgICAgICAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHsKICAgICAgICAgICAgYml0cyA9IG1heF9sZW5ndGg7CiAgICAgICAgICAgIG92ZXJmbG93Kys7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSBiaXRzOwogICAgICAgICAgaWYgKG4gPiBtYXhfY29kZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHMuYmxfY291bnRbYml0c10rKzsKICAgICAgICAgIHhiaXRzID0gMDsKICAgICAgICAgIGlmIChuID49IGJhc2UpIHsKICAgICAgICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07CiAgICAgICAgICB9CiAgICAgICAgICBmID0gdHJlZVtuICogMl07CiAgICAgICAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpOwogICAgICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdICsgeGJpdHMpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3ZlcmZsb3cgPT09IDApIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgYml0cyA9IG1heF9sZW5ndGggLSAxOwogICAgICAgICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsKICAgICAgICAgICAgYml0cy0tOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXS0tOwogICAgICAgICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsKICAgICAgICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTsKICAgICAgICAgIG92ZXJmbG93IC09IDI7CiAgICAgICAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTsKICAgICAgICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHsKICAgICAgICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdOwogICAgICAgICAgd2hpbGUgKG4gIT09IDApIHsKICAgICAgICAgICAgbSA9IHMuaGVhcFstLWhdOwogICAgICAgICAgICBpZiAobSA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXSAhPT0gYml0cykgewogICAgICAgICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSkgKiB0cmVlW20gKiAyXTsKICAgICAgICAgICAgICB0cmVlW20gKiAyICsgMV0gPSBiaXRzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG4tLTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgewogICAgICAgIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICB2YXIgY29kZSA9IDA7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSA8PCAxOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV07CiAgICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgdHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBsZW5ndGg7CiAgICAgICAgdmFyIGNvZGU7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7CiAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2xiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7CiAgICAgICAgZGlzdCA9IDA7CiAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9kYml0c1tjb2RlXTsgbisrKSB7CiAgICAgICAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRpc3QgPj49IDc7CiAgICAgICAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNzsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdIC0gNzsgbisrKSB7CiAgICAgICAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgYmxfY291bnRbYml0c10gPSAwOwogICAgICAgIH0KICAgICAgICBuID0gMDsKICAgICAgICB3aGlsZSAobiA8PSAxNDMpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gODsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzhdKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI1NSkgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA5OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOV0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjc5KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDc7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs3XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyODcpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gODsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzhdKys7CiAgICAgICAgfQogICAgICAgIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykgewogICAgICAgICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0gPSA1OwogICAgICAgICAgc3RhdGljX2R0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobiwgNSk7CiAgICAgICAgfQogICAgICAgIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7CiAgICAgICAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCBEX0NPREVTLCBNQVhfQklUUyk7CiAgICAgICAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5keW5fbHRyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5keW5fZHRyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuYmxfdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXSA9IDE7CiAgICAgICAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDsKICAgICAgICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV93aW5kdXAocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID4gOCkgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmOwogICAgICAgIH0KICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKSB7CiAgICAgICAgYmlfd2luZHVwKHMpOwogICAgICAgIGlmIChoZWFkZXIpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBsZW4pOwogICAgICAgICAgcHV0X3Nob3J0KHMsIH5sZW4pOwogICAgICAgIH0KICAgICAgICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7CiAgICAgICAgcy5wZW5kaW5nICs9IGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7CiAgICAgICAgdmFyIF9uMiA9IG4gKiAyOwogICAgICAgIHZhciBfbTIgPSBtICogMjsKICAgICAgICByZXR1cm4gdHJlZVtfbjJdIDwgdHJlZVtfbTJdIHx8IHRyZWVbX24yXSA9PT0gdHJlZVtfbTJdICYmIGRlcHRoW25dIDw9IGRlcHRoW21dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaykgewogICAgICAgIHZhciB2ID0gcy5oZWFwW2tdOwogICAgICAgIHZhciBqID0gayA8PCAxOwogICAgICAgIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHsKICAgICAgICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsKICAgICAgICAgICAgaisrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTsKICAgICAgICAgIGsgPSBqOwogICAgICAgICAgaiA8PD0gMTsKICAgICAgICB9CiAgICAgICAgcy5oZWFwW2tdID0gdjsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgbGM7CiAgICAgICAgdmFyIGx4ID0gMDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZXh0cmE7CiAgICAgICAgaWYgKHMubGFzdF9saXQgIT09IDApIHsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZGlzdCA9IHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCB8IHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdOwogICAgICAgICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTsKICAgICAgICAgICAgbHgrKzsKICAgICAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOwogICAgICAgICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07CiAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7CiAgICAgICAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTsKICAgICAgICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkaXN0LS07CiAgICAgICAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOwogICAgICAgICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07CiAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7CiAgICAgICAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTsKICAgICAgICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpOwogICAgICAgIH0KICAgICAgICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKSB7CiAgICAgICAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGVsZW1zID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7CiAgICAgICAgdmFyIG4sIG07CiAgICAgICAgdmFyIG1heF9jb2RlID0gLTE7CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgcy5oZWFwX21heCA9IEhFQVBfU0laRTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykgewogICAgICAgICAgaWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuOwogICAgICAgICAgICBzLmRlcHRoW25dID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHdoaWxlIChzLmhlYXBfbGVuIDwgMikgewogICAgICAgICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7CiAgICAgICAgICB0cmVlW25vZGUgKiAyXSA9IDE7CiAgICAgICAgICBzLmRlcHRoW25vZGVdID0gMDsKICAgICAgICAgIHMub3B0X2xlbi0tOwogICAgICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlOwogICAgICAgIGZvciAobiA9IHMuaGVhcF9sZW4gPj4gMTsgbiA+PSAxOyBuLS0pIHsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgbik7CiAgICAgICAgfQogICAgICAgIG5vZGUgPSBlbGVtczsKICAgICAgICBkbyB7CiAgICAgICAgICBuID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEpOwogICAgICAgICAgbSA9IHMuaGVhcFsxXTsKICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsKICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gdHJlZVtuICogMl0gKyB0cmVlW20gKiAyXTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTsKICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IHRyZWVbbSAqIDIgKyAxXSA9IG5vZGU7CiAgICAgICAgICBzLmhlYXBbMV0gPSBub2RlKys7CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEpOwogICAgICAgIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7CiAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMV07CiAgICAgICAgZ2VuX2JpdGxlbihzLCBkZXNjKTsKICAgICAgICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdID0gNjU1MzU7CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICBjdXJsZW4gPSBuZXh0bGVuOwogICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTsKICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHsKICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdICs9IGNvdW50OwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHsKICAgICAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0rKzsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdKys7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXSsrOwogICAgICAgICAgfQogICAgICAgICAgY291bnQgPSAwOwogICAgICAgICAgcHJldmxlbiA9IGN1cmxlbjsKICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtYXhfY291bnQgPSA3OwogICAgICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgcHJldmxlbiA9IC0xOwogICAgICAgIHZhciBjdXJsZW47CiAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsKICAgICAgICB2YXIgbWluX2NvdW50ID0gNDsKICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICBjdXJsZW4gPSBuZXh0bGVuOwogICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTsKICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tY291bnQgIT09IDApOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHsKICAgICAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7CiAgICAgICAgICAgICAgY291bnQtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykgewogICAgICAgIHZhciBtYXhfYmxpbmRleDsKICAgICAgICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTsKICAgICAgICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTsKICAgICAgICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7CiAgICAgICAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkgewogICAgICAgICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7CiAgICAgICAgcmV0dXJuIG1heF9ibGluZGV4OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSB7CiAgICAgICAgdmFyIHJhbms7CiAgICAgICAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsIDUpOwogICAgICAgIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgNCk7CiAgICAgICAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykgewogICAgICAgICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXSwgMyk7CiAgICAgICAgfQogICAgICAgIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHsKICAgICAgICB2YXIgYmxhY2tfbWFzayA9IDQwOTM2MjQ0NDc7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkgewogICAgICAgICAgaWYgKGJsYWNrX21hc2sgJiAxICYmIHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLmR5bl9sdHJlZVs5ICogMl0gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMyAqIDJdICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHsKICAgICAgICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIFpfQklOQVJZOwogICAgICB9CiAgICAgIHZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7CiAgICAgIGZ1bmN0aW9uIF90cl9pbml0KHMpIHsKICAgICAgICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHsKICAgICAgICAgIHRyX3N0YXRpY19pbml0KCk7CiAgICAgICAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcy5sX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpOwogICAgICAgIHMuZF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTsKICAgICAgICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7CiAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIGluaXRfYmxvY2socyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpIHsKICAgICAgICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX2FsaWduKHMpIHsKICAgICAgICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpOwogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7CiAgICAgICAgYmlfZmx1c2gocyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7CiAgICAgICAgdmFyIG1heF9ibGluZGV4ID0gMDsKICAgICAgICBpZiAocy5sZXZlbCA+IDApIHsKICAgICAgICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHsKICAgICAgICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7CiAgICAgICAgICB9CiAgICAgICAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTsKICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpOwogICAgICAgICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpOwogICAgICAgICAgb3B0X2xlbmIgPSBzLm9wdF9sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIHN0YXRpY19sZW5iID0gcy5zdGF0aWNfbGVuICsgMyArIDcgPj4+IDM7CiAgICAgICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsKICAgICAgICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OwogICAgICAgIH0KICAgICAgICBpZiAoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIgJiYgYnVmICE9PSAtMSkgewogICAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpOwogICAgICAgIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpOwogICAgICAgICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTsKICAgICAgICB9CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgICBpZiAobGFzdCkgewogICAgICAgICAgYmlfd2luZHVwKHMpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gPSBkaXN0ID4+PiA4ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAyNTU7CiAgICAgICAgcy5sYXN0X2xpdCsrOwogICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtsYyAqIDJdKys7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHMubWF0Y2hlcysrOwogICAgICAgICAgZGlzdC0tOwogICAgICAgICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0rKzsKICAgICAgICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdKys7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMTsKICAgICAgfQogICAgICBleHBvcnRzMi5fdHJfaW5pdCA9IF90cl9pbml0OwogICAgICBleHBvcnRzMi5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jazsKICAgICAgZXhwb3J0czIuX3RyX2ZsdXNoX2Jsb2NrID0gX3RyX2ZsdXNoX2Jsb2NrOwogICAgICBleHBvcnRzMi5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7CiAgICAgIGV4cG9ydHMyLl90cl9hbGlnbiA9IF90cl9hbGlnbjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcwogIHZhciByZXF1aXJlX2FkbGVyMzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykgewogICAgICAgIHZhciBzMSA9IGFkbGVyICYgNjU1MzUgfCAwLCBzMiA9IGFkbGVyID4+PiAxNiAmIDY1NTM1IHwgMCwgbiA9IDA7CiAgICAgICAgd2hpbGUgKGxlbiAhPT0gMCkgewogICAgICAgICAgbiA9IGxlbiA+IDJlMyA/IDJlMyA6IGxlbjsKICAgICAgICAgIGxlbiAtPSBuOwogICAgICAgICAgZG8gewogICAgICAgICAgICBzMSA9IHMxICsgYnVmW3BvcysrXSB8IDA7CiAgICAgICAgICAgIHMyID0gczIgKyBzMSB8IDA7CiAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgczEgJT0gNjU1MjE7CiAgICAgICAgICBzMiAlPSA2NTUyMTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMxIHwgczIgPDwgMTYgfCAwOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGFkbGVyMzI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzCiAgdmFyIHJlcXVpcmVfY3JjMzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIG1ha2VUYWJsZSgpIHsKICAgICAgICB2YXIgYywgdGFibGUgPSBbXTsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7CiAgICAgICAgICBjID0gbjsKICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7CiAgICAgICAgICAgIGMgPSBjICYgMSA/IDM5ODgyOTIzODQgXiBjID4+PiAxIDogYyA+Pj4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRhYmxlW25dID0gYzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9CiAgICAgIHZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpOwogICAgICBmdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHsKICAgICAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47CiAgICAgICAgY3JjIF49IC0xOwogICAgICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykgewogICAgICAgICAgY3JjID0gY3JjID4+PiA4IF4gdFsoY3JjIF4gYnVmW2ldKSAmIDI1NV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmMgXiAtMTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBjcmMzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gewogICAgICAgIDI6ICJuZWVkIGRpY3Rpb25hcnkiLAogICAgICAgIDE6ICJzdHJlYW0gZW5kIiwKICAgICAgICAwOiAiIiwKICAgICAgICAiLTEiOiAiZmlsZSBlcnJvciIsCiAgICAgICAgIi0yIjogInN0cmVhbSBlcnJvciIsCiAgICAgICAgIi0zIjogImRhdGEgZXJyb3IiLAogICAgICAgICItNCI6ICJpbnN1ZmZpY2llbnQgbWVtb3J5IiwKICAgICAgICAiLTUiOiAiYnVmZmVyIGVycm9yIiwKICAgICAgICAiLTYiOiAiaW5jb21wYXRpYmxlIHZlcnNpb24iCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciB0cmVlcyA9IHJlcXVpcmVfdHJlZXMoKTsKICAgICAgdmFyIGFkbGVyMzIgPSByZXF1aXJlX2FkbGVyMzIoKTsKICAgICAgdmFyIGNyYzMyID0gcmVxdWlyZV9jcmMzMigpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlcygpOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX1BBUlRJQUxfRkxVU0ggPSAxOwogICAgICB2YXIgWl9GVUxMX0ZMVVNIID0gMzsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9TVFJFQU1fRVJST1IgPSAtMjsKICAgICAgdmFyIFpfREFUQV9FUlJPUiA9IC0zOwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9GSUxURVJFRCA9IDE7CiAgICAgIHZhciBaX0hVRkZNQU5fT05MWSA9IDI7CiAgICAgIHZhciBaX1JMRSA9IDM7CiAgICAgIHZhciBaX0ZJWEVEID0gNDsKICAgICAgdmFyIFpfREVGQVVMVF9TVFJBVEVHWSA9IDA7CiAgICAgIHZhciBaX1VOS05PV04gPSAyOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIHZhciBNQVhfTUVNX0xFVkVMID0gOTsKICAgICAgdmFyIE1BWF9XQklUUyA9IDE1OwogICAgICB2YXIgREVGX01FTV9MRVZFTCA9IDg7CiAgICAgIHZhciBMRU5HVEhfQ09ERVMgPSAyOTsKICAgICAgdmFyIExJVEVSQUxTID0gMjU2OwogICAgICB2YXIgTF9DT0RFUyA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUzsKICAgICAgdmFyIERfQ09ERVMgPSAzMDsKICAgICAgdmFyIEJMX0NPREVTID0gMTk7CiAgICAgIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7CiAgICAgIHZhciBNQVhfQklUUyA9IDE1OwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIE1JTl9MT09LQUhFQUQgPSBNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxOwogICAgICB2YXIgUFJFU0VUX0RJQ1QgPSAzMjsKICAgICAgdmFyIElOSVRfU1RBVEUgPSA0MjsKICAgICAgdmFyIEVYVFJBX1NUQVRFID0gNjk7CiAgICAgIHZhciBOQU1FX1NUQVRFID0gNzM7CiAgICAgIHZhciBDT01NRU5UX1NUQVRFID0gOTE7CiAgICAgIHZhciBIQ1JDX1NUQVRFID0gMTAzOwogICAgICB2YXIgQlVTWV9TVEFURSA9IDExMzsKICAgICAgdmFyIEZJTklTSF9TVEFURSA9IDY2NjsKICAgICAgdmFyIEJTX05FRURfTU9SRSA9IDE7CiAgICAgIHZhciBCU19CTE9DS19ET05FID0gMjsKICAgICAgdmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsKICAgICAgdmFyIEJTX0ZJTklTSF9ET05FID0gNDsKICAgICAgdmFyIE9TX0NPREUgPSAzOwogICAgICBmdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7CiAgICAgICAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTsKICAgICAgICByZXR1cm4gZXJyb3JDb2RlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJhbmsoZikgewogICAgICAgIHJldHVybiAoZiA8PCAxKSAtIChmID4gNCA/IDkgOiAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB6ZXJvKGJ1ZikgewogICAgICAgIHZhciBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSB7CiAgICAgICAgICBidWZbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkgewogICAgICAgIHZhciBzID0gc3RybS5zdGF0ZTsKICAgICAgICB2YXIgbGVuID0gcy5wZW5kaW5nOwogICAgICAgIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkgewogICAgICAgICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgfQogICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7CiAgICAgICAgc3RybS5uZXh0X291dCArPSBsZW47CiAgICAgICAgcy5wZW5kaW5nX291dCArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gbGVuOwogICAgICAgIHN0cm0uYXZhaWxfb3V0IC09IGxlbjsKICAgICAgICBzLnBlbmRpbmcgLT0gbGVuOwogICAgICAgIGlmIChzLnBlbmRpbmcgPT09IDApIHsKICAgICAgICAgIHMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHsKICAgICAgICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgcy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgZmx1c2hfcGVuZGluZyhzLnN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiA+Pj4gOCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgewogICAgICAgIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luOwogICAgICAgIGlmIChsZW4gPiBzaXplKSB7CiAgICAgICAgICBsZW4gPSBzaXplOwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgc3RybS5hdmFpbF9pbiAtPSBsZW47CiAgICAgICAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpOwogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfSBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gKz0gbGVuOwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gbGVuOwogICAgICAgIHJldHVybiBsZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHsKICAgICAgICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOwogICAgICAgIHZhciBzY2FuID0gcy5zdHJzdGFydDsKICAgICAgICB2YXIgbWF0Y2g7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOwogICAgICAgIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOwogICAgICAgIHZhciBsaW1pdCA9IHMuc3Ryc3RhcnQgPiBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQgPyBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwOwogICAgICAgIHZhciBfd2luID0gcy53aW5kb3c7CiAgICAgICAgdmFyIHdtYXNrID0gcy53X21hc2s7CiAgICAgICAgdmFyIHByZXYgPSBzLnByZXY7CiAgICAgICAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7CiAgICAgICAgdmFyIHNjYW5fZW5kMSA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07CiAgICAgICAgdmFyIHNjYW5fZW5kID0gX3dpbltzY2FuICsgYmVzdF9sZW5dOwogICAgICAgIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkgewogICAgICAgICAgY2hhaW5fbGVuZ3RoID4+PSAyOwogICAgICAgIH0KICAgICAgICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7CiAgICAgICAgICBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7CiAgICAgICAgfQogICAgICAgIGRvIHsKICAgICAgICAgIG1hdGNoID0gY3VyX21hdGNoOwogICAgICAgICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gIT09IHNjYW5fZW5kIHx8IF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHwgX3dpblttYXRjaF0gIT09IF93aW5bc2Nhbl0gfHwgX3dpblsrK21hdGNoXSAhPT0gX3dpbltzY2FuICsgMV0pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBzY2FuICs9IDI7CiAgICAgICAgICBtYXRjaCsrOwogICAgICAgICAgZG8gewogICAgICAgICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7CiAgICAgICAgICBpZiAobGVuID4gYmVzdF9sZW4pIHsKICAgICAgICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDsKICAgICAgICAgICAgYmVzdF9sZW4gPSBsZW47CiAgICAgICAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNjYW5fZW5kMSA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07CiAgICAgICAgICAgIHNjYW5fZW5kID0gX3dpbltzY2FuICsgYmVzdF9sZW5dOwogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7CiAgICAgICAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7CiAgICAgICAgICByZXR1cm4gYmVzdF9sZW47CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLmxvb2thaGVhZDsKICAgICAgfQogICAgICBmdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7CiAgICAgICAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTsKICAgICAgICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyOwogICAgICAgIGRvIHsKICAgICAgICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0OwogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTsKICAgICAgICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgbiA9IHMuaGFzaF9zaXplOwogICAgICAgICAgICBwID0gbjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIG0gPSBzLmhlYWRbLS1wXTsKICAgICAgICAgICAgICBzLmhlYWRbcF0gPSBtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICAgIG4gPSBfd19zaXplOwogICAgICAgICAgICBwID0gbjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIG0gPSBzLnByZXZbLS1wXTsKICAgICAgICAgICAgICBzLnByZXZbcF0gPSBtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICAgIG1vcmUgKz0gX3dfc2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTsKICAgICAgICAgIHMubG9va2FoZWFkICs9IG47CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0OwogICAgICAgICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICB3aGlsZSAocy5pbnNlcnQpIHsKICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7CiAgICAgICAgICAgICAgc3RyKys7CiAgICAgICAgICAgICAgcy5pbnNlcnQtLTsKICAgICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHsKICAgICAgICB2YXIgbWF4X2Jsb2NrX3NpemUgPSA2NTUzNTsKICAgICAgICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7CiAgICAgICAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7CiAgICAgICAgfQogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7CiAgICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplOwogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHsKICAgICAgICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0OwogICAgICAgICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0OwogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkgewogICAgICAgIHZhciBoYXNoX2hlYWQ7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYXNoX2hlYWQgPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpOwogICAgICAgICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2ggJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApOwogICAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07CiAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHsKICAgICAgICB2YXIgaGFzaF9oZWFkOwogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgdmFyIG1heF9pbnNlcnQ7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaGFzaF9oZWFkID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICB9CiAgICAgICAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0OwogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJiBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiYgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgcy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYpKSB7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkgewogICAgICAgICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIOwogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpOwogICAgICAgICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTsKICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7CiAgICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTsKICAgICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTsKICAgICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTsKICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICB2YXIgcHJldjsKICAgICAgICB2YXIgc2Nhbiwgc3RyZW5kOwogICAgICAgIHZhciBfd2luID0gcy53aW5kb3c7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkgewogICAgICAgICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7CiAgICAgICAgICAgIHByZXYgPSBfd2luW3NjYW5dOwogICAgICAgICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHsKICAgICAgICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHNjYW4gPCBzdHJlbmQpOwogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7CiAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpOwogICAgICAgICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykgewogICAgICAgIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDsKICAgICAgICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7CiAgICAgICAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoOwogICAgICAgIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluOwogICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7CiAgICAgIH0KICAgICAgdmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7CiAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGUgPSBbCiAgICAgICAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpCiAgICAgIF07CiAgICAgIGZ1bmN0aW9uIGxtX2luaXQocykgewogICAgICAgIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7CiAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5OwogICAgICAgIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7CiAgICAgICAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDsKICAgICAgICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjsKICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHMuaW5zX2ggPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLnN0cm0gPSBudWxsOwogICAgICAgIHRoaXMuc3RhdHVzID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsKICAgICAgICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOwogICAgICAgIHRoaXMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIHRoaXMucGVuZGluZyA9IDA7CiAgICAgICAgdGhpcy53cmFwID0gMDsKICAgICAgICB0aGlzLmd6aGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy5nemluZGV4ID0gMDsKICAgICAgICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7CiAgICAgICAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgdGhpcy53X3NpemUgPSAwOwogICAgICAgIHRoaXMud19iaXRzID0gMDsKICAgICAgICB0aGlzLndfbWFzayA9IDA7CiAgICAgICAgdGhpcy53aW5kb3cgPSBudWxsOwogICAgICAgIHRoaXMud2luZG93X3NpemUgPSAwOwogICAgICAgIHRoaXMucHJldiA9IG51bGw7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLmluc19oID0gMDsKICAgICAgICB0aGlzLmhhc2hfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5oYXNoX2JpdHMgPSAwOwogICAgICAgIHRoaXMuaGFzaF9tYXNrID0gMDsKICAgICAgICB0aGlzLmhhc2hfc2hpZnQgPSAwOwogICAgICAgIHRoaXMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLnByZXZfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICB0aGlzLnN0cnN0YXJ0ID0gMDsKICAgICAgICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsKICAgICAgICB0aGlzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDsKICAgICAgICB0aGlzLmxldmVsID0gMDsKICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gMDsKICAgICAgICB0aGlzLmdvb2RfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubmljZV9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5keW5fbHRyZWUgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7CiAgICAgICAgdGhpcy5keW5fZHRyZWUgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTsKICAgICAgICB0aGlzLmJsX3RyZWUgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7CiAgICAgICAgemVybyh0aGlzLmR5bl9sdHJlZSk7CiAgICAgICAgemVybyh0aGlzLmR5bl9kdHJlZSk7CiAgICAgICAgemVybyh0aGlzLmJsX3RyZWUpOwogICAgICAgIHRoaXMubF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmRfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5ibF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7CiAgICAgICAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7CiAgICAgICAgemVybyh0aGlzLmhlYXApOwogICAgICAgIHRoaXMuaGVhcF9sZW4gPSAwOwogICAgICAgIHRoaXMuaGVhcF9tYXggPSAwOwogICAgICAgIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsKICAgICAgICB6ZXJvKHRoaXMuZGVwdGgpOwogICAgICAgIHRoaXMubF9idWYgPSAwOwogICAgICAgIHRoaXMubGl0X2J1ZnNpemUgPSAwOwogICAgICAgIHRoaXMubGFzdF9saXQgPSAwOwogICAgICAgIHRoaXMuZF9idWYgPSAwOwogICAgICAgIHRoaXMub3B0X2xlbiA9IDA7CiAgICAgICAgdGhpcy5zdGF0aWNfbGVuID0gMDsKICAgICAgICB0aGlzLm1hdGNoZXMgPSAwOwogICAgICAgIHRoaXMuaW5zZXJ0ID0gMDsKICAgICAgICB0aGlzLmJpX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5iaV92YWxpZCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHM7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDsKICAgICAgICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjsKICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICBzLnBlbmRpbmcgPSAwOwogICAgICAgIHMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIGlmIChzLndyYXAgPCAwKSB7CiAgICAgICAgICBzLndyYXAgPSAtcy53cmFwOwogICAgICAgIH0KICAgICAgICBzLnN0YXR1cyA9IHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFOwogICAgICAgIHN0cm0uYWRsZXIgPSBzLndyYXAgPT09IDIgPyAwIDogMTsKICAgICAgICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIOwogICAgICAgIHRyZWVzLl90cl9pbml0KHMpOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7CiAgICAgICAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7CiAgICAgICAgaWYgKHJldCA9PT0gWl9PSykgewogICAgICAgICAgbG1faW5pdChzdHJtLnN0YXRlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkgewogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICB2YXIgd3JhcCA9IDE7CiAgICAgICAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHsKICAgICAgICAgIGxldmVsID0gNjsKICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7CiAgICAgICAgICB3cmFwID0gMDsKICAgICAgICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0czsKICAgICAgICB9IGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkgewogICAgICAgICAgd3JhcCA9IDI7CiAgICAgICAgICB3aW5kb3dCaXRzIC09IDE2OwogICAgICAgIH0KICAgICAgICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHwgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHwgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzID09PSA4KSB7CiAgICAgICAgICB3aW5kb3dCaXRzID0gOTsKICAgICAgICB9CiAgICAgICAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7CiAgICAgICAgc3RybS5zdGF0ZSA9IHM7CiAgICAgICAgcy5zdHJtID0gc3RybTsKICAgICAgICBzLndyYXAgPSB3cmFwOwogICAgICAgIHMuZ3poZWFkID0gbnVsbDsKICAgICAgICBzLndfYml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzOwogICAgICAgIHMud19tYXNrID0gcy53X3NpemUgLSAxOwogICAgICAgIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3OwogICAgICAgIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0czsKICAgICAgICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTsKICAgICAgICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7CiAgICAgICAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpOwogICAgICAgIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7CiAgICAgICAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTsKICAgICAgICBzLmxpdF9idWZzaXplID0gMSA8PCBtZW1MZXZlbCArIDY7CiAgICAgICAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7CiAgICAgICAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7CiAgICAgICAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplOwogICAgICAgIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTsKICAgICAgICBzLmxldmVsID0gbGV2ZWw7CiAgICAgICAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5OwogICAgICAgIHMubWV0aG9kID0gbWV0aG9kOwogICAgICAgIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHsKICAgICAgICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkgewogICAgICAgIHZhciBvbGRfZmx1c2gsIHM7CiAgICAgICAgdmFyIGJlZywgdmFsOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7CiAgICAgICAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtLm91dHB1dCB8fCAhc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIHN0cm0uYXZhaWxfb3V0ID09PSAwID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHMuc3RybSA9IHN0cm07CiAgICAgICAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoOwogICAgICAgIHMubGFzdF9mbHVzaCA9IGZsdXNoOwogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkgewogICAgICAgICAgaWYgKHMud3JhcCA9PT0gMikgewogICAgICAgICAgICBzdHJtLmFkbGVyID0gMDsKICAgICAgICAgICAgcHV0X2J5dGUocywgMzEpOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAxMzkpOwogICAgICAgICAgICBwdXRfYnl0ZShzLCA4KTsKICAgICAgICAgICAgaWYgKCFzLmd6aGVhZCkgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDogcy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/IDQgOiAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgKyAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgKyAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgKyAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gMTYgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gMjQgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDogcy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/IDQgOiAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDI1NSk7CiAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMjU1KTsKICAgICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHsKICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBaX0RFRkxBVEVEICsgKHMud19iaXRzIC0gOCA8PCA0KSA8PCA4OwogICAgICAgICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTsKICAgICAgICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDA7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDE7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyIHw9IGxldmVsX2ZsYWdzIDw8IDY7CiAgICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7CiAgICAgICAgICAgICAgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlYWRlciArPSAzMSAtIGhlYWRlciAlIDMxOwogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7CiAgICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc3RybS5hZGxlciA9IDE7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAyNTUpOwogICAgICAgICAgICAgIHMuZ3ppbmRleCsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQubmFtZSkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5jb21tZW50KSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIHZhbCA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAyNTU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkgewogICAgICAgICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7CiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fCBmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSB7CiAgICAgICAgICB2YXIgYnN0YXRlID0gcy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDogcy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOiBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpOwogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkgewogICAgICAgICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkgewogICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkgewogICAgICAgICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgewogICAgICAgICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpOwogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgIH0KICAgICAgICBpZiAocy53cmFwIDw9IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAyNCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gOCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDE2ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMjQgJiAyNTUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgNjU1MzUpOwogICAgICAgIH0KICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgIGlmIChzLndyYXAgPiAwKSB7CiAgICAgICAgICBzLndyYXAgPSAtcy53cmFwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHsKICAgICAgICB2YXIgc3RhdHVzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1czsKICAgICAgICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiYgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJiBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiYgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgczsKICAgICAgICB2YXIgc3RyLCBuOwogICAgICAgIHZhciB3cmFwOwogICAgICAgIHZhciBhdmFpbDsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgaW5wdXQ7CiAgICAgICAgdmFyIHRtcERpY3Q7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHdyYXAgPSBzLndyYXA7CiAgICAgICAgaWYgKHdyYXAgPT09IDIgfHwgd3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSB8fCBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAod3JhcCA9PT0gMSkgewogICAgICAgICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7CiAgICAgICAgfQogICAgICAgIHMud3JhcCA9IDA7CiAgICAgICAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHsKICAgICAgICAgIGlmICh3cmFwID09PSAwKSB7CiAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpOwogICAgICAgICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7CiAgICAgICAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDsKICAgICAgICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTsKICAgICAgICB9CiAgICAgICAgYXZhaWwgPSBzdHJtLmF2YWlsX2luOwogICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7CiAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgc3RyID0gcy5zdHJzdGFydDsKICAgICAgICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7CiAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgIHMuc3Ryc3RhcnQgPSBzdHI7CiAgICAgICAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDsKICAgICAgICBzLmluc2VydCA9IHMubG9va2FoZWFkOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgIHN0cm0uaW5wdXQgPSBpbnB1dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gYXZhaWw7CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzMi5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0OwogICAgICBleHBvcnRzMi5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyOwogICAgICBleHBvcnRzMi5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbmZvID0gInBha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcwogIHZhciByZXF1aXJlX3N0cmluZ3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBTVFJfQVBQTFlfT0sgPSB0cnVlOwogICAgICB2YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbMF0pOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7CiAgICAgIGZvciAocSA9IDA7IHEgPCAyNTY7IHErKykgewogICAgICAgIF91dGY4bGVuW3FdID0gcSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMTsKICAgICAgfQogICAgICB2YXIgcTsKICAgICAgX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOwogICAgICBleHBvcnRzMi5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7CiAgICAgICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgbV9wb3MgKyAxIDwgc3RyX2xlbikgewogICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgICAgIGlmICgoYzIgJiA2NDUxMikgPT09IDU2MzIwKSB7CiAgICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgLSA1NTI5NiA8PCAxMCkgKyAoYzIgLSA1NjMyMCk7CiAgICAgICAgICAgICAgbV9wb3MrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnVmX2xlbiArPSBjIDwgMTI4ID8gMSA6IGMgPCAyMDQ4ID8gMiA6IGMgPCA2NTUzNiA/IDMgOiA0OwogICAgICAgIH0KICAgICAgICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTsKICAgICAgICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDEyOCkgewogICAgICAgICAgICBidWZbaSsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTkyIHwgYyA+Pj4gNjsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCA2NTUzNikgewogICAgICAgICAgICBidWZbaSsrXSA9IDIyNCB8IGMgPj4+IDEyOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDYgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWZbaSsrXSA9IDI0MCB8IGMgPj4+IDE4OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDEyICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikgewogICAgICAgIGlmIChsZW4gPCA2NTUzNCkgewogICAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LIHx8ICFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSB7CiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBleHBvcnRzMi5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24oYnVmKSB7CiAgICAgICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTsKICAgICAgfTsKICAgICAgZXhwb3J0czIuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTsKICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZXhwb3J0czIuYnVmMnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIGksIG91dCwgYywgY19sZW47CiAgICAgICAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTsKICAgICAgICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOyApIHsKICAgICAgICAgIGMgPSBidWZbaSsrXTsKICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTsKICAgICAgICAgIGlmIChjX2xlbiA+IDQpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNjU1MzM7CiAgICAgICAgICAgIGkgKz0gY19sZW4gLSAxOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAzMSA6IGNfbGVuID09PSAzID8gMTUgOiA3OwogICAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7CiAgICAgICAgICAgIGMgPSBjIDw8IDYgfCBidWZbaSsrXSAmIDYzOwogICAgICAgICAgICBjX2xlbi0tOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNfbGVuID4gMSkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjIC09IDY1NTM2OwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NTI5NiB8IGMgPj4gMTAgJiAxMDIzOwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NjMyMCB8IGMgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTsKICAgICAgfTsKICAgICAgZXhwb3J0czIudXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIHBvczsKICAgICAgICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDsKICAgICAgICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgewogICAgICAgICAgbWF4ID0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcG9zID0gbWF4IC0gMTsKICAgICAgICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICBwb3MtLTsKICAgICAgICB9CiAgICAgICAgaWYgKHBvcyA8IDApIHsKICAgICAgICAgIHJldHVybiBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPT09IDApIHsKICAgICAgICAgIHJldHVybiBtYXg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXggPyBwb3MgOiBtYXg7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMKICB2YXIgcmVxdWlyZV96c3RyZWFtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIFpTdHJlYW0oKSB7CiAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7CiAgICAgICAgdGhpcy5uZXh0X2luID0gMDsKICAgICAgICB0aGlzLmF2YWlsX2luID0gMDsKICAgICAgICB0aGlzLnRvdGFsX2luID0gMDsKICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7CiAgICAgICAgdGhpcy5uZXh0X291dCA9IDA7CiAgICAgICAgdGhpcy5hdmFpbF9vdXQgPSAwOwogICAgICAgIHRoaXMudG90YWxfb3V0ID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuc3RhdGUgPSBudWxsOwogICAgICAgIHRoaXMuZGF0YV90eXBlID0gMjsKICAgICAgICB0aGlzLmFkbGVyID0gMDsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBaU3RyZWFtOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZV9kZWZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBzdHJpbmdzID0gcmVxdWlyZV9zdHJpbmdzKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaU3RyZWFtID0gcmVxdWlyZV96c3RyZWFtKCk7CiAgICAgIHZhciB0b1N0cmluZzIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NZTkNfRkxVU0gyID0gMjsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpCiAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sCiAgICAgICAgICBtZXRob2Q6IFpfREVGTEFURUQsCiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMTUsCiAgICAgICAgICBtZW1MZXZlbDogOCwKICAgICAgICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID4gMCkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmIChvcHQuZ3ppcCAmJiBvcHQud2luZG93Qml0cyA+IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQubGV2ZWwsIG9wdC5tZXRob2QsIG9wdC53aW5kb3dCaXRzLCBvcHQubWVtTGV2ZWwsIG9wdC5zdHJhdGVneSk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5oZWFkZXIpIHsKICAgICAgICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgdmFyIGRpY3Q7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcyLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTsKICAgICAgICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHsKICAgICAgICB2YXIgc3RybSA9IHRoaXMuc3RybTsKICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTsKICAgICAgICB2YXIgc3RhdHVzLCBfbW9kZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIOwogICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7CiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZzIuY2FsbChkYXRhKSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gZGF0YTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CiAgICAgICAgZG8gewogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTsKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IDA7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gyKSkgewogICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTsKICAgICAgICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSDIpIHsKICAgICAgICAgIHRoaXMub25FbmQoWl9PSyk7CiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH07CiAgICAgIERlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGNodW5rKSB7CiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgICAgIH07CiAgICAgIERlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oc3RhdHVzKSB7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gWl9PSykgewogICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCIiKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5lcnIgPSBzdGF0dXM7CiAgICAgICAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogICAgICB9OwogICAgICBmdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7CiAgICAgICAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7CiAgICAgICAgaWYgKGRlZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGVmbGF0b3IucmVzdWx0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICBvcHRpb25zLnJhdyA9IHRydWU7CiAgICAgICAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICBvcHRpb25zLmd6aXAgPSB0cnVlOwogICAgICAgIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBleHBvcnRzMi5EZWZsYXRlID0gRGVmbGF0ZTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZSA9IGRlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3OwogICAgICBleHBvcnRzMi5nemlwID0gZ3ppcDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcwogIHZhciByZXF1aXJlX2luZmZhc3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIF9pbjsKICAgICAgICB2YXIgbGFzdDsKICAgICAgICB2YXIgX291dDsKICAgICAgICB2YXIgYmVnOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGRtYXg7CiAgICAgICAgdmFyIHdzaXplOwogICAgICAgIHZhciB3aGF2ZTsKICAgICAgICB2YXIgd25leHQ7CiAgICAgICAgdmFyIHNfd2luZG93OwogICAgICAgIHZhciBob2xkOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBsY29kZTsKICAgICAgICB2YXIgZGNvZGU7CiAgICAgICAgdmFyIGxtYXNrOwogICAgICAgIHZhciBkbWFzazsKICAgICAgICB2YXIgaGVyZTsKICAgICAgICB2YXIgb3A7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGlucHV0LCBvdXRwdXQ7CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIF9pbiA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7CiAgICAgICAgX291dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTsKICAgICAgICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTsKICAgICAgICBkbWF4ID0gc3RhdGUuZG1heDsKICAgICAgICB3c2l6ZSA9IHN0YXRlLndzaXplOwogICAgICAgIHdoYXZlID0gc3RhdGUud2hhdmU7CiAgICAgICAgd25leHQgPSBzdGF0ZS53bmV4dDsKICAgICAgICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdzsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7CiAgICAgICAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTsKICAgICAgICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTsKICAgICAgICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7CiAgICAgICAgdG9wOgogICAgICAgICAgZG8gewogICAgICAgICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107CiAgICAgICAgICAgIGRvbGVuOgogICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCAmIDE2KSB7CiAgICAgICAgICAgICAgICAgIGxlbiA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgb3AgJj0gMTU7CiAgICAgICAgICAgICAgICAgIGlmIChvcCkgewogICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGxlbiArPSBob2xkICYgKDEgPDwgb3ApIC0gMTsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107CiAgICAgICAgICAgICAgICAgIGRvZGlzdDoKICAgICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCAmIDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKDEgPDwgb3ApIC0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3bmV4dCA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wIC09IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgNjU1MzUpICsgKGhvbGQgJiAoMSA8PCBvcCkgLSAxKV07CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2xlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTsKICAgICAgICBsZW4gPSBiaXRzID4+IDM7CiAgICAgICAgX2luIC09IGxlbjsKICAgICAgICBiaXRzIC09IGxlbiA8PCAzOwogICAgICAgIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IF9pbjsKICAgICAgICBzdHJtLm5leHRfb3V0ID0gX291dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpOwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICByZXR1cm47CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzCiAgdmFyIHJlcXVpcmVfaW5mdHJlZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBNQVhCSVRTID0gMTU7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgbGJhc2UgPSBbCiAgICAgICAgMywKICAgICAgICA0LAogICAgICAgIDUsCiAgICAgICAgNiwKICAgICAgICA3LAogICAgICAgIDgsCiAgICAgICAgOSwKICAgICAgICAxMCwKICAgICAgICAxMSwKICAgICAgICAxMywKICAgICAgICAxNSwKICAgICAgICAxNywKICAgICAgICAxOSwKICAgICAgICAyMywKICAgICAgICAyNywKICAgICAgICAzMSwKICAgICAgICAzNSwKICAgICAgICA0MywKICAgICAgICA1MSwKICAgICAgICA1OSwKICAgICAgICA2NywKICAgICAgICA4MywKICAgICAgICA5OSwKICAgICAgICAxMTUsCiAgICAgICAgMTMxLAogICAgICAgIDE2MywKICAgICAgICAxOTUsCiAgICAgICAgMjI3LAogICAgICAgIDI1OCwKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGxleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMTYsCiAgICAgICAgNzIsCiAgICAgICAgNzgKICAgICAgXTsKICAgICAgdmFyIGRiYXNlID0gWwogICAgICAgIDEsCiAgICAgICAgMiwKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA3LAogICAgICAgIDksCiAgICAgICAgMTMsCiAgICAgICAgMTcsCiAgICAgICAgMjUsCiAgICAgICAgMzMsCiAgICAgICAgNDksCiAgICAgICAgNjUsCiAgICAgICAgOTcsCiAgICAgICAgMTI5LAogICAgICAgIDE5MywKICAgICAgICAyNTcsCiAgICAgICAgMzg1LAogICAgICAgIDUxMywKICAgICAgICA3NjksCiAgICAgICAgMTAyNSwKICAgICAgICAxNTM3LAogICAgICAgIDIwNDksCiAgICAgICAgMzA3MywKICAgICAgICA0MDk3LAogICAgICAgIDYxNDUsCiAgICAgICAgODE5MywKICAgICAgICAxMjI4OSwKICAgICAgICAxNjM4NSwKICAgICAgICAyNDU3NywKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGRleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjIsCiAgICAgICAgMjIsCiAgICAgICAgMjMsCiAgICAgICAgMjMsCiAgICAgICAgMjQsCiAgICAgICAgMjQsCiAgICAgICAgMjUsCiAgICAgICAgMjUsCiAgICAgICAgMjYsCiAgICAgICAgMjYsCiAgICAgICAgMjcsCiAgICAgICAgMjcsCiAgICAgICAgMjgsCiAgICAgICAgMjgsCiAgICAgICAgMjksCiAgICAgICAgMjksCiAgICAgICAgNjQsCiAgICAgICAgNjQKICAgICAgXTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKSB7CiAgICAgICAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgdmFyIGxlbiA9IDA7CiAgICAgICAgdmFyIHN5bSA9IDA7CiAgICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IDA7CiAgICAgICAgdmFyIHJvb3QyID0gMDsKICAgICAgICB2YXIgY3VyciA9IDA7CiAgICAgICAgdmFyIGRyb3AgPSAwOwogICAgICAgIHZhciBsZWZ0ID0gMDsKICAgICAgICB2YXIgdXNlZCA9IDA7CiAgICAgICAgdmFyIGh1ZmYgPSAwOwogICAgICAgIHZhciBpbmNyOwogICAgICAgIHZhciBmaWxsOwogICAgICAgIHZhciBsb3c7CiAgICAgICAgdmFyIG1hc2s7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIGJhc2UgPSBudWxsOwogICAgICAgIHZhciBiYXNlX2luZGV4ID0gMDsKICAgICAgICB2YXIgZW5kOwogICAgICAgIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7CiAgICAgICAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOwogICAgICAgIHZhciBleHRyYSA9IG51bGw7CiAgICAgICAgdmFyIGV4dHJhX2luZGV4ID0gMDsKICAgICAgICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsKICAgICAgICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgY291bnRbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrOwogICAgICAgIH0KICAgICAgICByb290MiA9IGJpdHM7CiAgICAgICAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHsKICAgICAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdDIgPiBtYXgpIHsKICAgICAgICAgIHJvb3QyID0gbWF4OwogICAgICAgIH0KICAgICAgICBpZiAobWF4ID09PSAwKSB7CiAgICAgICAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9IDEgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9IDEgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgICBvcHRzLmJpdHMgPSAxOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykgewogICAgICAgICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyb290MiA8IG1pbikgewogICAgICAgICAgcm9vdDIgPSBtaW47CiAgICAgICAgfQogICAgICAgIGxlZnQgPSAxOwogICAgICAgIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBsZWZ0IDw8PSAxOwogICAgICAgICAgbGVmdCAtPSBjb3VudFtsZW5dOwogICAgICAgICAgaWYgKGxlZnQgPCAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7CiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIG9mZnNbMV0gPSAwOwogICAgICAgIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dOwogICAgICAgIH0KICAgICAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICAgICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHsKICAgICAgICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAodHlwZSA9PT0gQ09ERVMpIHsKICAgICAgICAgIGJhc2UgPSBleHRyYSA9IHdvcms7CiAgICAgICAgICBlbmQgPSAxOTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHsKICAgICAgICAgIGJhc2UgPSBsYmFzZTsKICAgICAgICAgIGJhc2VfaW5kZXggLT0gMjU3OwogICAgICAgICAgZXh0cmEgPSBsZXh0OwogICAgICAgICAgZXh0cmFfaW5kZXggLT0gMjU3OwogICAgICAgICAgZW5kID0gMjU2OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBiYXNlID0gZGJhc2U7CiAgICAgICAgICBleHRyYSA9IGRleHQ7CiAgICAgICAgICBlbmQgPSAtMTsKICAgICAgICB9CiAgICAgICAgaHVmZiA9IDA7CiAgICAgICAgc3ltID0gMDsKICAgICAgICBsZW4gPSBtaW47CiAgICAgICAgbmV4dCA9IHRhYmxlX2luZGV4OwogICAgICAgIGN1cnIgPSByb290MjsKICAgICAgICBkcm9wID0gMDsKICAgICAgICBsb3cgPSAtMTsKICAgICAgICB1c2VkID0gMSA8PCByb290MjsKICAgICAgICBtYXNrID0gdXNlZCAtIDE7CiAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7CiAgICAgICAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAwOwogICAgICAgICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTsKICAgICAgICAgIH0gZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAzMiArIDY0OwogICAgICAgICAgICBoZXJlX3ZhbCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSBkcm9wOwogICAgICAgICAgZmlsbCA9IDEgPDwgY3VycjsKICAgICAgICAgIG1pbiA9IGZpbGw7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGZpbGwgLT0gaW5jcjsKICAgICAgICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSBoZXJlX2JpdHMgPDwgMjQgfCBoZXJlX29wIDw8IDE2IHwgaGVyZV92YWwgfCAwOwogICAgICAgICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSAxOwogICAgICAgICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7CiAgICAgICAgICAgIGluY3IgPj49IDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5jciAhPT0gMCkgewogICAgICAgICAgICBodWZmICY9IGluY3IgLSAxOwogICAgICAgICAgICBodWZmICs9IGluY3I7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBodWZmID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHN5bSsrOwogICAgICAgICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkgewogICAgICAgICAgICBpZiAobGVuID09PSBtYXgpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxlbiA+IHJvb3QyICYmIChodWZmICYgbWFzaykgIT09IGxvdykgewogICAgICAgICAgICBpZiAoZHJvcCA9PT0gMCkgewogICAgICAgICAgICAgIGRyb3AgPSByb290MjsKICAgICAgICAgICAgfQogICAgICAgICAgICBuZXh0ICs9IG1pbjsKICAgICAgICAgICAgY3VyciA9IGxlbiAtIGRyb3A7CiAgICAgICAgICAgIGxlZnQgPSAxIDw8IGN1cnI7CiAgICAgICAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkgewogICAgICAgICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdOwogICAgICAgICAgICAgIGlmIChsZWZ0IDw9IDApIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjdXJyKys7CiAgICAgICAgICAgICAgbGVmdCA8PD0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICB1c2VkICs9IDEgPDwgY3VycjsKICAgICAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBsb3cgPSBodWZmICYgbWFzazsKICAgICAgICAgICAgdGFibGVbbG93XSA9IHJvb3QyIDw8IDI0IHwgY3VyciA8PCAxNiB8IG5leHQgLSB0YWJsZV9pbmRleCB8IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChodWZmICE9PSAwKSB7CiAgICAgICAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgIH0KICAgICAgICBvcHRzLmJpdHMgPSByb290MjsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIGFkbGVyMzIgPSByZXF1aXJlX2FkbGVyMzIoKTsKICAgICAgdmFyIGNyYzMyID0gcmVxdWlyZV9jcmMzMigpOwogICAgICB2YXIgaW5mbGF0ZV9mYXN0ID0gcmVxdWlyZV9pbmZmYXN0KCk7CiAgICAgIHZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZV9pbmZ0cmVlcygpOwogICAgICB2YXIgQ09ERVMgPSAwOwogICAgICB2YXIgTEVOUyA9IDE7CiAgICAgIHZhciBESVNUUyA9IDI7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX0JMT0NLID0gNTsKICAgICAgdmFyIFpfVFJFRVMgPSA2OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9ORUVEX0RJQ1QgPSAyOwogICAgICB2YXIgWl9TVFJFQU1fRVJST1IgPSAtMjsKICAgICAgdmFyIFpfREFUQV9FUlJPUiA9IC0zOwogICAgICB2YXIgWl9NRU1fRVJST1IgPSAtNDsKICAgICAgdmFyIFpfQlVGX0VSUk9SID0gLTU7CiAgICAgIHZhciBaX0RFRkxBVEVEID0gODsKICAgICAgdmFyIEhFQUQgPSAxOwogICAgICB2YXIgRkxBR1MgPSAyOwogICAgICB2YXIgVElNRSA9IDM7CiAgICAgIHZhciBPUyA9IDQ7CiAgICAgIHZhciBFWExFTiA9IDU7CiAgICAgIHZhciBFWFRSQSA9IDY7CiAgICAgIHZhciBOQU1FID0gNzsKICAgICAgdmFyIENPTU1FTlQgPSA4OwogICAgICB2YXIgSENSQyA9IDk7CiAgICAgIHZhciBESUNUSUQgPSAxMDsKICAgICAgdmFyIERJQ1QgPSAxMTsKICAgICAgdmFyIFRZUEUgPSAxMjsKICAgICAgdmFyIFRZUEVETyA9IDEzOwogICAgICB2YXIgU1RPUkVEID0gMTQ7CiAgICAgIHZhciBDT1BZXyA9IDE1OwogICAgICB2YXIgQ09QWSA9IDE2OwogICAgICB2YXIgVEFCTEUgPSAxNzsKICAgICAgdmFyIExFTkxFTlMgPSAxODsKICAgICAgdmFyIENPREVMRU5TID0gMTk7CiAgICAgIHZhciBMRU5fID0gMjA7CiAgICAgIHZhciBMRU4gPSAyMTsKICAgICAgdmFyIExFTkVYVCA9IDIyOwogICAgICB2YXIgRElTVCA9IDIzOwogICAgICB2YXIgRElTVEVYVCA9IDI0OwogICAgICB2YXIgTUFUQ0ggPSAyNTsKICAgICAgdmFyIExJVCA9IDI2OwogICAgICB2YXIgQ0hFQ0sgPSAyNzsKICAgICAgdmFyIExFTkdUSCA9IDI4OwogICAgICB2YXIgRE9ORSA9IDI5OwogICAgICB2YXIgQkFEID0gMzA7CiAgICAgIHZhciBNRU0gPSAzMTsKICAgICAgdmFyIFNZTkMgPSAzMjsKICAgICAgdmFyIEVOT1VHSF9MRU5TID0gODUyOwogICAgICB2YXIgRU5PVUdIX0RJU1RTID0gNTkyOwogICAgICB2YXIgTUFYX1dCSVRTID0gMTU7CiAgICAgIHZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7CiAgICAgIGZ1bmN0aW9uIHpzd2FwMzIocSkgewogICAgICAgIHJldHVybiAocSA+Pj4gMjQgJiAyNTUpICsgKHEgPj4+IDggJiA2NTI4MCkgKyAoKHEgJiA2NTI4MCkgPDwgOCkgKyAoKHEgJiAyNTUpIDw8IDI0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7CiAgICAgICAgdGhpcy5tb2RlID0gMDsKICAgICAgICB0aGlzLmxhc3QgPSBmYWxzZTsKICAgICAgICB0aGlzLndyYXAgPSAwOwogICAgICAgIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsKICAgICAgICB0aGlzLmZsYWdzID0gMDsKICAgICAgICB0aGlzLmRtYXggPSAwOwogICAgICAgIHRoaXMuY2hlY2sgPSAwOwogICAgICAgIHRoaXMudG90YWwgPSAwOwogICAgICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy53Yml0cyA9IDA7CiAgICAgICAgdGhpcy53c2l6ZSA9IDA7CiAgICAgICAgdGhpcy53aGF2ZSA9IDA7CiAgICAgICAgdGhpcy53bmV4dCA9IDA7CiAgICAgICAgdGhpcy53aW5kb3cgPSBudWxsOwogICAgICAgIHRoaXMuaG9sZCA9IDA7CiAgICAgICAgdGhpcy5iaXRzID0gMDsKICAgICAgICB0aGlzLmxlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5vZmZzZXQgPSAwOwogICAgICAgIHRoaXMuZXh0cmEgPSAwOwogICAgICAgIHRoaXMubGVuY29kZSA9IG51bGw7CiAgICAgICAgdGhpcy5kaXN0Y29kZSA9IG51bGw7CiAgICAgICAgdGhpcy5sZW5iaXRzID0gMDsKICAgICAgICB0aGlzLmRpc3RiaXRzID0gMDsKICAgICAgICB0aGlzLm5jb2RlID0gMDsKICAgICAgICB0aGlzLm5sZW4gPSAwOwogICAgICAgIHRoaXMubmRpc3QgPSAwOwogICAgICAgIHRoaXMuaGF2ZSA9IDA7CiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDsKICAgICAgICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsKICAgICAgICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsKICAgICAgICB0aGlzLmxlbmR5biA9IG51bGw7CiAgICAgICAgdGhpcy5kaXN0ZHluID0gbnVsbDsKICAgICAgICB0aGlzLnNhbmUgPSAwOwogICAgICAgIHRoaXMuYmFjayA9IDA7CiAgICAgICAgdGhpcy53YXMgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDsKICAgICAgICBzdHJtLm1zZyA9ICIiOwogICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7CiAgICAgICAgfQogICAgICAgIHN0YXRlLm1vZGUgPSBIRUFEOwogICAgICAgIHN0YXRlLmxhc3QgPSAwOwogICAgICAgIHN0YXRlLmhhdmVkaWN0ID0gMDsKICAgICAgICBzdGF0ZS5kbWF4ID0gMzI3Njg7CiAgICAgICAgc3RhdGUuaGVhZCA9IG51bGw7CiAgICAgICAgc3RhdGUuaG9sZCA9IDA7CiAgICAgICAgc3RhdGUuYml0cyA9IDA7CiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7CiAgICAgICAgc3RhdGUuc2FuZSA9IDE7CiAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RhdGUud3NpemUgPSAwOwogICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7CiAgICAgICAgdmFyIHdyYXA7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7CiAgICAgICAgICB3cmFwID0gMDsKICAgICAgICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0czsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTsKICAgICAgICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHsKICAgICAgICAgICAgd2luZG93Qml0cyAmPSAxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykgewogICAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGUud3JhcCA9IHdyYXA7CiAgICAgICAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzOwogICAgICAgIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgcmV0OwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0pIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7CiAgICAgICAgc3RybS5zdGF0ZSA9IHN0YXRlOwogICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTsKICAgICAgICBpZiAocmV0ICE9PSBaX09LKSB7CiAgICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7CiAgICAgICAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpOwogICAgICB9CiAgICAgIHZhciB2aXJnaW4gPSB0cnVlOwogICAgICB2YXIgbGVuZml4OwogICAgICB2YXIgZGlzdGZpeDsKICAgICAgZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHsKICAgICAgICBpZiAodmlyZ2luKSB7CiAgICAgICAgICB2YXIgc3ltOwogICAgICAgICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7CiAgICAgICAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTsKICAgICAgICAgIHN5bSA9IDA7CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gODsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyNTYpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA5OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI4MCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjg4KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gODsKICAgICAgICAgIH0KICAgICAgICAgIGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTsKICAgICAgICAgIHN5bSA9IDA7CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMzIpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA1OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTsKICAgICAgICAgIHZpcmdpbiA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4OwogICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwogICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDsKICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7CiAgICAgICAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7CiAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICBzdGF0ZS53aGF2ZSA9IDA7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0OwogICAgICAgICAgaWYgKGRpc3QgPiBjb3B5KSB7CiAgICAgICAgICAgIGRpc3QgPSBjb3B5OwogICAgICAgICAgfQogICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTsKICAgICAgICAgIGNvcHkgLT0gZGlzdDsKICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTsKICAgICAgICAgICAgc3RhdGUud25leHQgPSBjb3B5OwogICAgICAgICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3RhdGUud25leHQgKz0gZGlzdDsKICAgICAgICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgICAgIHN0YXRlLndoYXZlICs9IGRpc3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgaW5wdXQsIG91dHB1dDsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgcHV0OwogICAgICAgIHZhciBoYXZlLCBsZWZ0OwogICAgICAgIHZhciBob2xkOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBfaW4sIF9vdXQ7CiAgICAgICAgdmFyIGNvcHk7CiAgICAgICAgdmFyIGZyb207CiAgICAgICAgdmFyIGZyb21fc291cmNlOwogICAgICAgIHZhciBoZXJlID0gMDsKICAgICAgICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsKICAgICAgICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsKICAgICAgICB2YXIgb3B0czsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgb3JkZXIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fCAhc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgewogICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETzsKICAgICAgICB9CiAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDsKICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgX2luID0gaGF2ZTsKICAgICAgICBfb3V0ID0gbGVmdDsKICAgICAgICByZXQgPSBaX09LOwogICAgICAgIGluZl9sZWF2ZToKICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHsKICAgICAgICAgICAgICBjYXNlIEhFQUQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgJiAyICYmIGhvbGQgPT09IDM1NjE1KSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gMDsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgKCgoaG9sZCAmIDI1NSkgPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhvbGQgJiAxNSkgIT09IFpfREVGTEFURUQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgbGVuID0gKGhvbGQgJiAxNSkgKyA4OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIHdpbmRvdyBzaXplIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiA1MTIgPyBESUNUSUQgOiBUWVBFOwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgRkxBR1M6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDsKICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAyNTUpICE9PSBaX0RFRkxBVEVEKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1NzM0NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGhlYWRlciBmbGFncyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9IGhvbGQgPj4gOCAmIDE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTsKICAgICAgICAgICAgICBjYXNlIFRJTUU6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzJdID0gaG9sZCA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbM10gPSBob2xkID4+PiAyNCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE9TOwogICAgICAgICAgICAgIGNhc2UgT1M6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IGhvbGQgPj4gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjsKICAgICAgICAgICAgICBjYXNlIEVYTEVOOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7CiAgICAgICAgICAgICAgY2FzZSBFWFRSQToKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDEwMjQpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgY29weSA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS5oZWFkLmV4dHJhLCBpbnB1dCwgbmV4dCwgY29weSwgbGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FOwogICAgICAgICAgICAgIGNhc2UgTkFNRToKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDIwNDgpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY29weSA9IDA7CiAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiYgc3RhdGUubGVuZ3RoIDwgNjU1MzYpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UOwogICAgICAgICAgICAgIGNhc2UgQ09NTUVOVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDQwOTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY29weSA9IDA7CiAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiYgc3RhdGUubGVuZ3RoIDwgNjU1MzYpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7CiAgICAgICAgICAgICAgY2FzZSBIQ1JDOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiA2NTUzNSkpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJoZWFkZXIgY3JjIG1pc21hdGNoIjsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9IHN0YXRlLmZsYWdzID4+IDkgJiAxOwogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBESUNUSUQ6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7CiAgICAgICAgICAgICAgY2FzZSBESUNUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgIGNhc2UgVFlQRToKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBUWVBFRE86CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGFzdCkgewogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGFzdCA9IGhvbGQgJiAxOwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDE7CiAgICAgICAgICAgICAgICBiaXRzIC09IDE7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhvbGQgJiAzKSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOwogICAgICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBibG9jayB0eXBlIjsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIFNUT1JFRDoKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNzsKICAgICAgICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoaG9sZCAmIDY1NTM1KSAhPT0gKGhvbGQgPj4+IDE2IF4gNjU1MzUpKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiA2NTUzNTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgQ09QWV86CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTsKICAgICAgICAgICAgICBjYXNlIENPUFk6CiAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgY29weSA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7CiAgICAgICAgICAgICAgICAgICAgY29weSA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTsKICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgICAgICAgICAgcHV0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBUQUJMRToKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMzEpICsgMjU3OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMzEpICsgMTsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA1OwogICAgICAgICAgICAgICAgYml0cyAtPSA1OwogICAgICAgICAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDE1KSArIDQ7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNDsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmhhdmUgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7CiAgICAgICAgICAgICAgY2FzZSBMRU5MRU5TOgogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSBob2xkICYgNzsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluOwogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7CiAgICAgICAgICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmhhdmUgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TOwogICAgICAgICAgICAgIGNhc2UgQ09ERUxFTlM6CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkgewogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKDEgPDwgc3RhdGUubGVuYml0cykgLSAxXTsKICAgICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikgewogICAgICAgICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCI7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykgewogICAgICAgICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgbGVuID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiA3KTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAzOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNzsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAxMjcpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDc7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkgewogICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCI7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7CiAgICAgICAgICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7CiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47CiAgICAgICAgICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlcyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOwogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIExFTl86CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgIGNhc2UgTEVOOgogICAgICAgICAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkgewogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTsKICAgICAgICAgICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDsKICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICAgICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICAgICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgICAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICAgICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAwOwogICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAyNDApID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICsgKChob2xkICYgKDEgPDwgbGFzdF9iaXRzICsgbGFzdF9vcCkgLSAxKSA+PiBsYXN0X2JpdHMpXTsKICAgICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfYml0cyArIGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBiaXRzIC09IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExJVDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1OwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDsKICAgICAgICAgICAgICBjYXNlIExFTkVYVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoMSA8PCBzdGF0ZS5leHRyYSkgLSAxOwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDsKICAgICAgICAgICAgICBjYXNlIERJU1Q6CiAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxXTsKICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoaGVyZV9vcCAmIDI0MCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICsgKChob2xkICYgKDEgPDwgbGFzdF9iaXRzICsgbGFzdF9vcCkgLSAxKSA+PiBsYXN0X2JpdHMpXTsKICAgICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfYml0cyArIGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBiaXRzIC09IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1OwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7CiAgICAgICAgICAgICAgY2FzZSBESVNURVhUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgxIDw8IHN0YXRlLmV4dHJhKSAtIDE7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7CiAgICAgICAgICAgICAgY2FzZSBNQVRDSDoKICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdzsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0OwogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBsZWZ0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgTElUOgogICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIGxlZnQtLTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIENIRUNLOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXApIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgX291dCAtPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0OwogICAgICAgICAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0OwogICAgICAgICAgICAgICAgICBpZiAoX291dCkgewogICAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBkYXRhIGNoZWNrIjsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7CiAgICAgICAgICAgICAgY2FzZSBMRU5HVEg6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgNDI5NDk2NzI5NSkpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrIjsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBET05FOwogICAgICAgICAgICAgIGNhc2UgRE9ORToKICAgICAgICAgICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDsKICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICBjYXNlIEJBRDoKICAgICAgICAgICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjsKICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICBjYXNlIE1FTToKICAgICAgICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICAgICAgICBjYXNlIFNZTkM6CiAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgaWYgKHN0YXRlLndzaXplIHx8IF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiYgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7CiAgICAgICAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNRU07CiAgICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgX2luIC09IHN0cm0uYXZhaWxfaW47CiAgICAgICAgX291dCAtPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBzdHJtLnRvdGFsX2luICs9IF9pbjsKICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0OwogICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkgewogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KTsKICAgICAgICB9CiAgICAgICAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICsgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7CiAgICAgICAgaWYgKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykgewogICAgICAgICAgcmV0ID0gWl9CVUZfRVJST1I7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdykgewogICAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUuaGVhZCA9IGhlYWQ7CiAgICAgICAgaGVhZC5kb25lID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkgewogICAgICAgIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBkaWN0aWQ7CiAgICAgICAgdmFyIHJldDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHsKICAgICAgICAgIGRpY3RpZCA9IDE7CiAgICAgICAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7CiAgICAgICAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykgewogICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7CiAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAxOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwOwogICAgICBleHBvcnRzMi5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0OwogICAgICBleHBvcnRzMi5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7CiAgICAgIGV4cG9ydHMyLmluZmxhdGUgPSBpbmZsYXRlOwogICAgICBleHBvcnRzMi5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbmZvID0gInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMKICB2YXIgcmVxdWlyZV9jb25zdGFudHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgWl9OT19GTFVTSDogMCwKICAgICAgICBaX1BBUlRJQUxfRkxVU0g6IDEsCiAgICAgICAgWl9TWU5DX0ZMVVNIOiAyLAogICAgICAgIFpfRlVMTF9GTFVTSDogMywKICAgICAgICBaX0ZJTklTSDogNCwKICAgICAgICBaX0JMT0NLOiA1LAogICAgICAgIFpfVFJFRVM6IDYsCiAgICAgICAgWl9PSzogMCwKICAgICAgICBaX1NUUkVBTV9FTkQ6IDEsCiAgICAgICAgWl9ORUVEX0RJQ1Q6IDIsCiAgICAgICAgWl9FUlJOTzogLTEsCiAgICAgICAgWl9TVFJFQU1fRVJST1I6IC0yLAogICAgICAgIFpfREFUQV9FUlJPUjogLTMsCiAgICAgICAgWl9CVUZfRVJST1I6IC01LAogICAgICAgIFpfTk9fQ09NUFJFU1NJT046IDAsCiAgICAgICAgWl9CRVNUX1NQRUVEOiAxLAogICAgICAgIFpfQkVTVF9DT01QUkVTU0lPTjogOSwKICAgICAgICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IC0xLAogICAgICAgIFpfRklMVEVSRUQ6IDEsCiAgICAgICAgWl9IVUZGTUFOX09OTFk6IDIsCiAgICAgICAgWl9STEU6IDMsCiAgICAgICAgWl9GSVhFRDogNCwKICAgICAgICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsCiAgICAgICAgWl9CSU5BUlk6IDAsCiAgICAgICAgWl9URVhUOiAxLAogICAgICAgIFpfVU5LTk9XTjogMiwKICAgICAgICBaX0RFRkxBVEVEOiA4CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzCiAgdmFyIHJlcXVpcmVfZ3poZWFkZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIEdaaGVhZGVyKCkgewogICAgICAgIHRoaXMudGV4dCA9IDA7CiAgICAgICAgdGhpcy50aW1lID0gMDsKICAgICAgICB0aGlzLnhmbGFncyA9IDA7CiAgICAgICAgdGhpcy5vcyA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IG51bGw7CiAgICAgICAgdGhpcy5leHRyYV9sZW4gPSAwOwogICAgICAgIHRoaXMubmFtZSA9ICIiOwogICAgICAgIHRoaXMuY29tbWVudCA9ICIiOwogICAgICAgIHRoaXMuaGNyYyA9IDA7CiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gR1poZWFkZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlX2luZmxhdGUoKTsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHN0cmluZ3MgPSByZXF1aXJlX3N0cmluZ3MoKTsKICAgICAgdmFyIGMgPSByZXF1aXJlX2NvbnN0YW50cygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlcygpOwogICAgICB2YXIgWlN0cmVhbSA9IHJlcXVpcmVfenN0cmVhbSgpOwogICAgICB2YXIgR1poZWFkZXIgPSByZXF1aXJlX2d6aGVhZGVyKCk7CiAgICAgIHZhciB0b1N0cmluZzIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBmdW5jdGlvbiBJbmZsYXRlMihvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUyKSkKICAgICAgICAgIHJldHVybiBuZXcgSW5mbGF0ZTIob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAwLAogICAgICAgICAgdG86ICIiCiAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7CiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9uczsKICAgICAgICBpZiAob3B0LnJhdyAmJiBvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzOwogICAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLTE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2ICYmICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAzMjsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID4gMTUgJiYgb3B0LndpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyB8PSAxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC53aW5kb3dCaXRzKTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgfQogICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7CiAgICAgICAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nMi5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHQucmF3KSB7CiAgICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBJbmZsYXRlMi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHsKICAgICAgICB2YXIgc3RybSA9IHRoaXMuc3RybTsKICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTsKICAgICAgICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5OwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyOwogICAgICAgIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7CiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgX21vZGUgPSBtb2RlID09PSB+fm1vZGUgPyBtb2RlIDogbW9kZSA9PT0gdHJ1ZSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nMi5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOwogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7CiAgICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7CiAgICAgICAgICAgIHN0YXR1cyA9IGMuWl9PSzsKICAgICAgICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0ubmV4dF9vdXQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkgewogICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTsKICAgICAgICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODsKICAgICAgICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpOwogICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7CiAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7CiAgICAgICAgICAgICAgICBpZiAodGFpbCkgewogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkgewogICAgICAgICAgX21vZGUgPSBjLlpfRklOSVNIOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkgewogICAgICAgICAgdGhpcy5vbkVuZChjLlpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBJbmZsYXRlMi5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oc3RhdHVzKSB7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZTIob3B0aW9ucyk7CiAgICAgICAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7CiAgICAgICAgaWYgKGluZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaW5mbGF0b3IucmVzdWx0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICBvcHRpb25zLnJhdyA9IHRydWU7CiAgICAgICAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLkluZmxhdGUgPSBJbmZsYXRlMjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZSA9IGluZmxhdGU7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3OwogICAgICBleHBvcnRzMi51bmd6aXAgPSBpbmZsYXRlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcwogIHZhciByZXF1aXJlX3Bha28gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBhc3NpZ24gPSByZXF1aXJlX2NvbW1vbigpLmFzc2lnbjsKICAgICAgdmFyIGRlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUyKCk7CiAgICAgIHZhciBpbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlMigpOwogICAgICB2YXIgY29uc3RhbnRzID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIHBha28gPSB7fTsKICAgICAgYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBha287CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzCiAgdmFyIHJlcXVpcmVfbG9uZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IExvbmc0OwogICAgICB2YXIgd2FzbTIgPSBudWxsOwogICAgICB0cnkgewogICAgICAgIHdhc20yID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoWwogICAgICAgICAgMCwKICAgICAgICAgIDk3LAogICAgICAgICAgMTE1LAogICAgICAgICAgMTA5LAogICAgICAgICAgMSwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMywKICAgICAgICAgIDIsCiAgICAgICAgICA5NiwKICAgICAgICAgIDAsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgOTYsCiAgICAgICAgICA0LAogICAgICAgICAgMTI3LAogICAgICAgICAgMTI3LAogICAgICAgICAgMTI3LAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDEyNywKICAgICAgICAgIDMsCiAgICAgICAgICA3LAogICAgICAgICAgNiwKICAgICAgICAgIDAsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDYsCiAgICAgICAgICA2LAogICAgICAgICAgMSwKICAgICAgICAgIDEyNywKICAgICAgICAgIDEsCiAgICAgICAgICA2NSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDcsCiAgICAgICAgICA1MCwKICAgICAgICAgIDYsCiAgICAgICAgICAzLAogICAgICAgICAgMTA5LAogICAgICAgICAgMTE3LAogICAgICAgICAgMTA4LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICA1LAogICAgICAgICAgMTAwLAogICAgICAgICAgMTA1LAogICAgICAgICAgMTE4LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgMiwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICAzLAogICAgICAgICAgNSwKICAgICAgICAgIDExNCwKICAgICAgICAgIDEwMSwKICAgICAgICAgIDEwOSwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE1LAogICAgICAgICAgMCwKICAgICAgICAgIDQsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTcsCiAgICAgICAgICAwLAogICAgICAgICAgNSwKICAgICAgICAgIDgsCiAgICAgICAgICAxMDMsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMTYsCiAgICAgICAgICA5NSwKICAgICAgICAgIDEwNCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwNCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMTAsCiAgICAgICAgICAxOTEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDQsCiAgICAgICAgICAwLAogICAgICAgICAgMzUsCiAgICAgICAgICAwLAogICAgICAgICAgMTEsCiAgICAgICAgICAzNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzIsCiAgICAgICAgICAwLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAxLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDMyLAogICAgICAgICAgMiwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMywKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzNCwKICAgICAgICAgIDQsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM1LAogICAgICAgICAgMTY3LAogICAgICAgICAgMzYsCiAgICAgICAgICAwLAogICAgICAgICAgMzIsCiAgICAgICAgICA0LAogICAgICAgICAgMTY3LAogICAgICAgICAgMTEsCiAgICAgICAgICAzNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzIsCiAgICAgICAgICAwLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAxLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDMyLAogICAgICAgICAgMiwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMywKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAzNCwKICAgICAgICAgIDQsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM1LAogICAgICAgICAgMTY3LAogICAgICAgICAgMzYsCiAgICAgICAgICAwLAogICAgICAgICAgMzIsCiAgICAgICAgICA0LAogICAgICAgICAgMTY3LAogICAgICAgICAgMTEsCiAgICAgICAgICAzNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzIsCiAgICAgICAgICAwLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAxLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDMyLAogICAgICAgICAgMiwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMywKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAxMjgsCiAgICAgICAgICAzNCwKICAgICAgICAgIDQsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM1LAogICAgICAgICAgMTY3LAogICAgICAgICAgMzYsCiAgICAgICAgICAwLAogICAgICAgICAgMzIsCiAgICAgICAgICA0LAogICAgICAgICAgMTY3LAogICAgICAgICAgMTEsCiAgICAgICAgICAzNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzIsCiAgICAgICAgICAwLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAxLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDMyLAogICAgICAgICAgMiwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMywKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAxMjksCiAgICAgICAgICAzNCwKICAgICAgICAgIDQsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM1LAogICAgICAgICAgMTY3LAogICAgICAgICAgMzYsCiAgICAgICAgICAwLAogICAgICAgICAgMzIsCiAgICAgICAgICA0LAogICAgICAgICAgMTY3LAogICAgICAgICAgMTEsCiAgICAgICAgICAzNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzIsCiAgICAgICAgICAwLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAxLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDMyLAogICAgICAgICAgMiwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMywKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAxMzAsCiAgICAgICAgICAzNCwKICAgICAgICAgIDQsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM1LAogICAgICAgICAgMTY3LAogICAgICAgICAgMzYsCiAgICAgICAgICAwLAogICAgICAgICAgMzIsCiAgICAgICAgICA0LAogICAgICAgICAgMTY3LAogICAgICAgICAgMTEKICAgICAgICBdKSksIHt9KS5leHBvcnRzOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gTG9uZzQobG93LCBoaWdoLCB1bnNpZ25lZCkgewogICAgICAgIHRoaXMubG93ID0gbG93IHwgMDsKICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDsKICAgICAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDsKICAgICAgfQogICAgICBMb25nNC5wcm90b3R5cGUuX19pc0xvbmdfXzsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmc0LnByb3RvdHlwZSwgIl9faXNMb25nX18iLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBmdW5jdGlvbiBpc0xvbmcyKG9iaikgewogICAgICAgIHJldHVybiAob2JqICYmIG9ialsiX19pc0xvbmdfXyJdKSA9PT0gdHJ1ZTsKICAgICAgfQogICAgICBMb25nNC5pc0xvbmcgPSBpc0xvbmcyOwogICAgICB2YXIgSU5UX0NBQ0hFMiA9IHt9OwogICAgICB2YXIgVUlOVF9DQUNIRTIgPSB7fTsKICAgICAgZnVuY3Rpb24gZnJvbUludDIodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTsKICAgICAgICBpZiAodW5zaWduZWQpIHsKICAgICAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRTJbdmFsdWVdOwogICAgICAgICAgICBpZiAoY2FjaGVkT2JqKQogICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7CiAgICAgICAgICB9CiAgICAgICAgICBvYmogPSBmcm9tQml0czIodmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIFVJTlRfQ0FDSEUyW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhbHVlIHw9IDA7CiAgICAgICAgICBpZiAoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7CiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRTJbdmFsdWVdOwogICAgICAgICAgICBpZiAoY2FjaGVkT2JqKQogICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7CiAgICAgICAgICB9CiAgICAgICAgICBvYmogPSBmcm9tQml0czIodmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBJTlRfQ0FDSEUyW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfQogICAgICB9CiAgICAgIExvbmc0LmZyb21JbnQgPSBmcm9tSW50MjsKICAgICAgZnVuY3Rpb24gZnJvbU51bWJlcjIodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkKICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPMiA6IFpFUk8yOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgICAgcmV0dXJuIFVaRVJPMjsKICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTDIpCiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUUyOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMMikKICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTI7CiAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMMikKICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTI7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcjIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih2YWx1ZSAlIFRXT19QV1JfMzJfREJMMiB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwyIHwgMCwgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyMjsKICAgICAgZnVuY3Rpb24gZnJvbUJpdHMyKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tQml0cyA9IGZyb21CaXRzMjsKICAgICAgdmFyIHBvd19kYmwyID0gTWF0aC5wb3c7CiAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcyKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7CiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiZW1wdHkgc3RyaW5nIik7CiAgICAgICAgaWYgKHN0ciA9PT0gIk5hTiIgfHwgc3RyID09PSAiSW5maW5pdHkiIHx8IHN0ciA9PT0gIitJbmZpbml0eSIgfHwgc3RyID09PSAiLUluZmluaXR5IikKICAgICAgICAgIHJldHVybiBaRVJPMjsKICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAibnVtYmVyIikgewogICAgICAgICAgcmFkaXggPSB1bnNpZ25lZCwgdW5zaWduZWQgPSBmYWxzZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICAgIH0KICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICAgICAgdmFyIHA7CiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoIi0iKSkgPiAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImludGVyaW9yIGh5cGhlbiIpOwogICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nMihzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcjIocG93X2RibDIocmFkaXgsIDgpKTsKICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTzI7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHsKICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLCB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7CiAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHsKICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcjIocG93X2RibDIocmFkaXgsIHNpemUpKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIyKHZhbHVlKSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcjIodmFsdWUpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBMb25nNC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZzI7CiAgICAgIGZ1bmN0aW9uIGZyb21WYWx1ZTIodmFsLCB1bnNpZ25lZCkgewogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyMih2YWwsIHVuc2lnbmVkKTsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpCiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZzIodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAiYm9vbGVhbiIgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbVZhbHVlID0gZnJvbVZhbHVlMjsKICAgICAgdmFyIFRXT19QV1JfMTZfREJMMiA9IDEgPDwgMTY7CiAgICAgIHZhciBUV09fUFdSXzI0X0RCTDIgPSAxIDw8IDI0OwogICAgICB2YXIgVFdPX1BXUl8zMl9EQkwyID0gVFdPX1BXUl8xNl9EQkwyICogVFdPX1BXUl8xNl9EQkwyOwogICAgICB2YXIgVFdPX1BXUl82NF9EQkwyID0gVFdPX1BXUl8zMl9EQkwyICogVFdPX1BXUl8zMl9EQkwyOwogICAgICB2YXIgVFdPX1BXUl82M19EQkwyID0gVFdPX1BXUl82NF9EQkwyIC8gMjsKICAgICAgdmFyIFRXT19QV1JfMjQyID0gZnJvbUludDIoVFdPX1BXUl8yNF9EQkwyKTsKICAgICAgdmFyIFpFUk8yID0gZnJvbUludDIoMCk7CiAgICAgIExvbmc0LlpFUk8gPSBaRVJPMjsKICAgICAgdmFyIFVaRVJPMiA9IGZyb21JbnQyKDAsIHRydWUpOwogICAgICBMb25nNC5VWkVSTyA9IFVaRVJPMjsKICAgICAgdmFyIE9ORTIgPSBmcm9tSW50MigxKTsKICAgICAgTG9uZzQuT05FID0gT05FMjsKICAgICAgdmFyIFVPTkUyID0gZnJvbUludDIoMSwgdHJ1ZSk7CiAgICAgIExvbmc0LlVPTkUgPSBVT05FMjsKICAgICAgdmFyIE5FR19PTkUyID0gZnJvbUludDIoLTEpOwogICAgICBMb25nNC5ORUdfT05FID0gTkVHX09ORTI7CiAgICAgIHZhciBNQVhfVkFMVUUyID0gZnJvbUJpdHMyKDQyOTQ5NjcyOTUgfCAwLCAyMTQ3NDgzNjQ3IHwgMCwgZmFsc2UpOwogICAgICBMb25nNC5NQVhfVkFMVUUgPSBNQVhfVkFMVUUyOwogICAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFMiA9IGZyb21CaXRzMig0Mjk0OTY3Mjk1IHwgMCwgNDI5NDk2NzI5NSB8IDAsIHRydWUpOwogICAgICBMb25nNC5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUUyOwogICAgICB2YXIgTUlOX1ZBTFVFMiA9IGZyb21CaXRzMigwLCAyMTQ3NDgzNjQ4IHwgMCwgZmFsc2UpOwogICAgICBMb25nNC5NSU5fVkFMVUUgPSBNSU5fVkFMVUUyOwogICAgICB2YXIgTG9uZ1Byb3RvdHlwZTIgPSBMb25nNC5wcm90b3R5cGU7CiAgICAgIExvbmdQcm90b3R5cGUyLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQyKCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcjMoKSB7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTDIgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTDIgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nMihyYWRpeCkgewogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiAiMCI7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUyKSkgewogICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcjIocmFkaXgpLCBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLCByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTsKICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIHJldHVybiAiLSIgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICB9CiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIyKHBvd19kYmwyKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksIHJlbSA9IHRoaXM7CiAgICAgICAgdmFyIHJlc3VsdCA9ICIiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLCBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCwgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICAgIHJlbSA9IHJlbURpdjsKICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpCiAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KQogICAgICAgICAgICAgIGRpZ2l0cyA9ICIwIiArIGRpZ2l0czsKICAgICAgICAgICAgcmVzdWx0ID0gIiIgKyBkaWdpdHMgKyByZXN1bHQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzMigpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZDIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMyKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkMigpIHsKICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzMigpIHsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUyKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7CiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKQogICAgICAgICAgaWYgKCh2YWwgJiAxIDw8IGJpdCkgIT0gMCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8yKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmVxeiA9IExvbmdQcm90b3R5cGUyLmlzWmVybzsKICAgICAgTG9uZ1Byb3RvdHlwZTIuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUyKCkgewogICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZTIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQyKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuMigpIHsKICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFsczIob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZzIob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUyKG90aGVyKTsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJiBvdGhlci5oaWdoID4+PiAzMSA9PT0gMSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmVxID0gTG9uZ1Byb3RvdHlwZTIuZXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlMi5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMyKG90aGVyKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLmVxKG90aGVyKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubmVxID0gTG9uZ1Byb3RvdHlwZTIubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlMi5uZSA9IExvbmdQcm90b3R5cGUyLm5vdEVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbjIob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmx0ID0gTG9uZ1Byb3RvdHlwZTIubGVzc1RoYW47CiAgICAgIExvbmdQcm90b3R5cGUyLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbDIob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5sdGUgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUyLmxlID0gTG9uZ1Byb3RvdHlwZTIubGVzc1RoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlMi5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ3QgPSBMb25nUHJvdG90eXBlMi5ncmVhdGVyVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID49IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmd0ZSA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ2UgPSBMb25nUHJvdG90eXBlMi5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlMihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nMihvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZTIob3RoZXIpOwogICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpOwogICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsKICAgICAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmNvbXAgPSBMb25nUHJvdG90eXBlMi5jb21wYXJlOwogICAgICBMb25nUHJvdG90eXBlMi5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUyKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTI7CiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORTIpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5uZWcgPSBMb25nUHJvdG90eXBlMi5uZWdhdGU7CiAgICAgIExvbmdQcm90b3R5cGUyLmFkZCA9IGZ1bmN0aW9uIGFkZDIoYWRkZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKGFkZGVuZCkpCiAgICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUyKGFkZGVuZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICsgYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICsgYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICsgYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdDIoc3VidHJhaGVuZCkgewogICAgICAgIGlmICghaXNMb25nMihzdWJ0cmFoZW5kKSkKICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUyKHN1YnRyYWhlbmQpOwogICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc3ViID0gTG9uZ1Byb3RvdHlwZTIuc3VidHJhY3Q7CiAgICAgIExvbmdQcm90b3R5cGUyLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkyKG11bHRpcGxpZXIpIHsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiBaRVJPMjsKICAgICAgICBpZiAoIWlzTG9uZzIobXVsdGlwbGllcikpCiAgICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlMihtdWx0aXBsaWVyKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIHZhciBsb3cgPSB3YXNtMi5tdWwodGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGxvdywgd2FzbTIuZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRTIgOiBaRVJPMjsKICAgICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUyKSkKICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUyIDogWkVSTzI7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpOwogICAgICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNDIpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNDIpKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDsKICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjsKICAgICAgICBjMDAgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGExNiAqIGIxNjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgICAgICBjNDggJj0gNjU1MzU7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMihjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm11bCA9IExvbmdQcm90b3R5cGUyLm11bHRpcGx5OwogICAgICBMb25nUHJvdG90eXBlMi5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUyKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlMihkaXZpc29yKTsKICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkKICAgICAgICAgIHRocm93IEVycm9yKCJkaXZpc2lvbiBieSB6ZXJvIik7CiAgICAgICAgaWYgKHdhc20yKSB7CiAgICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoID09PSAtMjE0NzQ4MzY0OCAmJiBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkgewogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20yLmRpdl91IDogd2FzbTIuZGl2X3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3csIHdhc20yLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUyKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUyKSB8fCBkaXZpc29yLmVxKE5FR19PTkUyKSkKICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUyKSkKICAgICAgICAgICAgICByZXR1cm4gT05FMjsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7CiAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTsKICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8yKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FMiA6IE5FR19PTkUyOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTsKICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPMiA6IFpFUk8yOwogICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTsKICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTsKICAgICAgICAgIHJlcyA9IFpFUk8yOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpCiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKQogICAgICAgICAgICByZXR1cm4gVVpFUk8yOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkKICAgICAgICAgICAgcmV0dXJuIFVPTkUyOwogICAgICAgICAgcmVzID0gVVpFUk8yOwogICAgICAgIH0KICAgICAgICByZW0gPSB0aGlzOwogICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7CiAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibDIoMiwgbG9nMiAtIDQ4KSwgYXBwcm94UmVzID0gZnJvbU51bWJlcjIoYXBwcm94KSwgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7CiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTsKICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcjIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpCiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTI7CiAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7CiAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmRpdiA9IExvbmdQcm90b3R5cGUyLmRpdmlkZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvMihkaXZpc29yKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKGRpdmlzb3IpKQogICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZTIoZGl2aXNvcik7CiAgICAgICAgaWYgKHdhc20yKSB7CiAgICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtMi5yZW1fdSA6IHdhc20yLnJlbV9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0czIobG93LCB3YXNtMi5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm1vZCA9IExvbmdQcm90b3R5cGUyLm1vZHVsbzsKICAgICAgTG9uZ1Byb3RvdHlwZTIucmVtID0gTG9uZ1Byb3RvdHlwZTIubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlMi5ub3QgPSBmdW5jdGlvbiBub3QyKCkgewogICAgICAgIHJldHVybiBmcm9tQml0czIofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuYW5kID0gZnVuY3Rpb24gYW5kMihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nMihvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZTIob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5vciA9IGZ1bmN0aW9uIG9yMihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nMihvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZTIob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi54b3IgPSBmdW5jdGlvbiB4b3IyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdDIobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcyKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldHVybiBmcm9tQml0czIoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hsID0gTG9uZ1Byb3RvdHlwZTIuc2hpZnRMZWZ0OwogICAgICBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodDIobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcyKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hyID0gTG9uZ1Byb3RvdHlwZTIuc2hpZnRSaWdodDsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkMihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIG51bUJpdHMgJj0gNjM7CiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoOwogICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7CiAgICAgICAgICAgIHJldHVybiBmcm9tQml0czIobG93ID4+PiBudW1CaXRzIHwgaGlnaCA8PCAzMiAtIG51bUJpdHMsIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMikKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihoaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hydSA9IExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hyX3UgPSBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgICAgIExvbmdQcm90b3R5cGUyLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQyKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZDIoKSB7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlczIobGUpIHsKICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFMigpIHsKICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICAgICAgcmV0dXJuIFsKICAgICAgICAgIGxvICYgMjU1LAogICAgICAgICAgbG8gPj4+IDggJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMjQsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGhpID4+PiA4ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDI0CiAgICAgICAgXTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFMigpIHsKICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICAgICAgcmV0dXJuIFsKICAgICAgICAgIGhpID4+PiAyNCwKICAgICAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGhpID4+PiA4ICYgMjU1LAogICAgICAgICAgaGkgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMjQsCiAgICAgICAgICBsbyA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvICYgMjU1CiAgICAgICAgXTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzMyhieXRlcywgdW5zaWduZWQsIGxlKSB7CiAgICAgICAgcmV0dXJuIGxlID8gTG9uZzQuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmc0LmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmc0LmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUyKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFMihieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pc19vYnNlcnZhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSAodmFsdWUpID0+IHsKICAgICAgICBpZiAoIXZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sLm9ic2VydmFibGUgPT09ICJzeW1ib2wiICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWVbIkBAb2JzZXJ2YWJsZSJdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlWyJAQG9ic2VydmFibGUiXSgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMKICB2YXIgcmVxdWlyZV9zZXJpYWxpemVycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuRGVmYXVsdFNlcmlhbGl6ZXIgPSBleHBvcnRzMi5leHRlbmRTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICBmdW5jdGlvbiBleHRlbmRTZXJpYWxpemVyKGV4dGVuZCwgaW1wbGVtZW50YXRpb24pIHsKICAgICAgICBjb25zdCBmYWxsYmFja0Rlc2VyaWFsaXplciA9IGV4dGVuZC5kZXNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgY29uc3QgZmFsbGJhY2tTZXJpYWxpemVyID0gZXh0ZW5kLnNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLmRlc2VyaWFsaXplKG1lc3NhZ2UsIGZhbGxiYWNrRGVzZXJpYWxpemVyKTsKICAgICAgICAgIH0sCiAgICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLnNlcmlhbGl6ZShpbnB1dCwgZmFsbGJhY2tTZXJpYWxpemVyKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4dGVuZFNlcmlhbGl6ZXIgPSBleHRlbmRTZXJpYWxpemVyOwogICAgICB2YXIgRGVmYXVsdEVycm9yU2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihFcnJvcihtZXNzYWdlLm1lc3NhZ2UpLCB7CiAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSwKICAgICAgICAgICAgc3RhY2s6IG1lc3NhZ2Uuc3RhY2sKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGVycm9yKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBfX2Vycm9yX21hcmtlcjogIiQkZXJyb3IiLAogICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLAogICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLAogICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2sKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgaXNTZXJpYWxpemVkRXJyb3IgPSAodGhpbmcpID0+IHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgIl9fZXJyb3JfbWFya2VyIiBpbiB0aGluZyAmJiB0aGluZy5fX2Vycm9yX21hcmtlciA9PT0gIiQkZXJyb3IiOwogICAgICBleHBvcnRzMi5EZWZhdWx0U2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkRXJyb3IobWVzc2FnZSkpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLnNlcmlhbGl6ZSA9IGV4cG9ydHMyLmRlc2VyaWFsaXplID0gZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgc2VyaWFsaXplcnNfMSA9IHJlcXVpcmVfc2VyaWFsaXplcnMoKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5EZWZhdWx0U2VyaWFsaXplcjsKICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJpYWxpemVyMihzZXJpYWxpemVyKSB7CiAgICAgICAgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLmV4dGVuZFNlcmlhbGl6ZXIocmVnaXN0ZXJlZFNlcmlhbGl6ZXIsIHNlcmlhbGl6ZXIpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHJlZ2lzdGVyU2VyaWFsaXplcjI7CiAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTsKICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuc2VyaWFsaXplID0gc2VyaWFsaXplOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMKICB2YXIgcmVxdWlyZV9zeW1ib2xzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gZXhwb3J0czIuJHRlcm1pbmF0ZSA9IGV4cG9ydHMyLiRldmVudHMgPSBleHBvcnRzMi4kZXJyb3JzID0gdm9pZCAwOwogICAgICBleHBvcnRzMi4kZXJyb3JzID0gU3ltYm9sKCJ0aHJlYWQuZXJyb3JzIik7CiAgICAgIGV4cG9ydHMyLiRldmVudHMgPSBTeW1ib2woInRocmVhZC5ldmVudHMiKTsKICAgICAgZXhwb3J0czIuJHRlcm1pbmF0ZSA9IFN5bWJvbCgidGhyZWFkLnRlcm1pbmF0ZSIpOwogICAgICBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gU3ltYm9sKCJ0aHJlYWQudHJhbnNmZXJhYmxlIik7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBTeW1ib2woInRocmVhZC53b3JrZXIiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMKICB2YXIgcmVxdWlyZV90cmFuc2ZlcmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gdm9pZCAwOwogICAgICB2YXIgc3ltYm9sc18xID0gcmVxdWlyZV9zeW1ib2xzKCk7CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKHRoaW5nKSB7CiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICJvYmplY3QiKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdGhpbmdbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gaXNUcmFuc2ZlckRlc2NyaXB0b3I7CiAgICAgIGZ1bmN0aW9uIFRyYW5zZmVyMihwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgaWYgKCF0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgICBpZiAoIWlzVHJhbnNmZXJhYmxlKHBheWxvYWQpKQogICAgICAgICAgICB0aHJvdyBFcnJvcigpOwogICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IFtwYXlsb2FkXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIFtzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV06IHRydWUsCiAgICAgICAgICBzZW5kOiBwYXlsb2FkLAogICAgICAgICAgdHJhbnNmZXJhYmxlcwogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuVHJhbnNmZXIgPSBUcmFuc2ZlcjI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgPSB2b2lkIDA7CiAgICAgIHZhciBNYXN0ZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKE1hc3Rlck1lc3NhZ2VUeXBlMikgewogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsiY2FuY2VsIl0gPSAiY2FuY2VsIjsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbInJ1biJdID0gInJ1biI7CiAgICAgIH0pKE1hc3Rlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLk1hc3Rlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgICAgdmFyIFdvcmtlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oV29ya2VyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJlcnJvciJdID0gImVycm9yIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImluaXQiXSA9ICJpbml0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJlc3VsdCJdID0gInJlc3VsdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJydW5uaW5nIl0gPSAicnVubmluZyI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJ1bmNhdWdodEVycm9yIl0gPSAidW5jYXVnaHRFcnJvciI7CiAgICAgIH0pKFdvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBpc1dvcmtlclJ1bnRpbWUgPSBmdW5jdGlvbiBpc1dvcmtlclJ1bnRpbWUyKCkgewogICAgICAgIGNvbnN0IGlzV2luZG93Q29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgV2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmIGluc3RhbmNlb2YgV2luZG93OwogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZi5wb3N0TWVzc2FnZSAmJiAhaXNXaW5kb3dDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlOwogICAgICB9OwogICAgICB2YXIgcG9zdE1lc3NhZ2VUb01hc3RlciA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlVG9NYXN0ZXIyKGRhdGEsIHRyYW5zZmVyTGlzdCkgewogICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTsKICAgICAgfTsKICAgICAgdmFyIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMgPSBmdW5jdGlvbiBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzMihvbk1lc3NhZ2UpIHsKICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlRXZlbnQuZGF0YSk7CiAgICAgICAgfTsKICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHsKICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICB9OwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSB7CiAgICAgICAgaXNXb3JrZXJSdW50aW1lLAogICAgICAgIHBvc3RNZXNzYWdlVG9NYXN0ZXIsCiAgICAgICAgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcwogIHZhciByZXF1aXJlX3dvcmtlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9fYXdhaXRlciA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9fYXdhaXRlciB8fCBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHsKICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyJ0aHJvdyJdKHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7CiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOwogICAgICAgICAgfQogICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpOwogICAgICAgIH0pOwogICAgICB9OwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5leHBvc2UgPSBleHBvcnRzMi5pc1dvcmtlclJ1bnRpbWUgPSBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIGlzX29ic2VydmFibGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2lzX29ic2VydmFibGUoKSk7CiAgICAgIHZhciBjb21tb25fMSA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzEgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICB2YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmVfbWVzc2FnZXMyKCk7CiAgICAgIHZhciBpbXBsZW1lbnRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlcigpKTsKICAgICAgdmFyIGNvbW1vbl8yID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgInJlZ2lzdGVyU2VyaWFsaXplciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gY29tbW9uXzIucmVnaXN0ZXJTZXJpYWxpemVyOwogICAgICB9IH0pOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzIgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJUcmFuc2ZlciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzIuVHJhbnNmZXI7CiAgICAgIH0gfSk7CiAgICAgIGV4cG9ydHMyLmlzV29ya2VyUnVudGltZSA9IGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWU7CiAgICAgIHZhciBleHBvc2VDYWxsZWQgPSBmYWxzZTsKICAgICAgdmFyIGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7CiAgICAgIHZhciBpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUuY2FuY2VsOwogICAgICB2YXIgaXNNYXN0ZXJKb2JSdW5NZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLnJ1bjsKICAgICAgdmFyIGlzT2JzZXJ2YWJsZSA9ICh0aGluZykgPT4gaXNfb2JzZXJ2YWJsZV8xLmRlZmF1bHQodGhpbmcpIHx8IGlzWmVuT2JzZXJ2YWJsZSh0aGluZyk7CiAgICAgIGZ1bmN0aW9uIGlzWmVuT2JzZXJ2YWJsZSh0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHR5cGVvZiB0aGluZy5zdWJzY3JpYmUgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjb25zdHJ1Y3RUcmFuc2Zlcih0aGluZykgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMS5pc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgPyB7IHBheWxvYWQ6IHRoaW5nLnNlbmQsIHRyYW5zZmVyYWJsZXM6IHRoaW5nLnRyYW5zZmVyYWJsZXMgfSA6IHsgcGF5bG9hZDogdGhpbmcsIHRyYW5zZmVyYWJsZXM6IHZvaWQgMCB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCkgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAiZnVuY3Rpb24iCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJtb2R1bGUiLAogICAgICAgICAgICBtZXRob2RzOiBtZXRob2ROYW1lcwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JFcnJvck1lc3NhZ2UodWlkLCByYXdFcnJvcikgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZDogZXJyb3IsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmF3RXJyb3IpOwogICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuZXJyb3IsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iUmVzdWx0TWVzc2FnZSh1aWQsIGNvbXBsZXRlZCwgcmVzdWx0VmFsdWUpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmVzdWx0VmFsdWUpOwogICAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJlc3VsdCwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZWQgPyB0cnVlIDogdm9pZCAwLAogICAgICAgICAgcGF5bG9hZAogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIocmVzdWx0TWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlN0YXJ0TWVzc2FnZSh1aWQsIHJlc3VsdFR5cGUpIHsKICAgICAgICBjb25zdCBzdGFydE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJ1bm5pbmcsCiAgICAgICAgICB1aWQsCiAgICAgICAgICByZXN1bHRUeXBlCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihzdGFydE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvcikgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUudW5jYXVnaHRFcnJvciwKICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICAgIH07CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UpOwogICAgICAgIH0gY2F0Y2ggKHN1YkVycm9yKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJOb3QgcmVwb3J0aW5nIHVuY2F1Z2h0IGVycm9yIGJhY2sgdG8gbWFzdGVyIHRocmVhZCBhcyBpdCBvY2N1cmVkIHdoaWxlIHJlcG9ydGluZyBhbiB1bmNhdWdodCBlcnJvciBhbHJlYWR5LlxuTGF0ZXN0IGVycm9yOiIsIHN1YkVycm9yLCAiXG5PcmlnaW5hbCBlcnJvcjoiLCBlcnJvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uKGpvYlVJRCwgZm4sIGFyZ3MpIHsKICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgewogICAgICAgICAgbGV0IHN5bmNSZXN1bHQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzeW5jUmVzdWx0ID0gZm4oLi4uYXJncyk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICByZXR1cm4gcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHJlc3VsdFR5cGUgPSBpc09ic2VydmFibGUoc3luY1Jlc3VsdCkgPyAib2JzZXJ2YWJsZSIgOiAicHJvbWlzZSI7CiAgICAgICAgICBwb3N0Sm9iU3RhcnRNZXNzYWdlKGpvYlVJRCwgcmVzdWx0VHlwZSk7CiAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpKSB7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN5bmNSZXN1bHQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4gcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCBmYWxzZSwgY29tbW9uXzEuc2VyaWFsaXplKHZhbHVlKSksIChlcnJvcikgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5zZXQoam9iVUlELCBzdWJzY3JpcHRpb24pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzeW5jUmVzdWx0OwogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSwgY29tbW9uXzEuc2VyaWFsaXplKHJlc3VsdCkpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV4cG9zZTIoZXhwb3NlZCkgewogICAgICAgIGlmICghaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIGluIHRoZSBtYXN0ZXIgdGhyZWFkLiIpOwogICAgICAgIH0KICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLiBUaGlzIGlzIG5vdCBwb3NzaWJsZS4gUGFzcyBhbiBvYmplY3QgdG8gZXhwb3NlKCkgaWYgeW91IHdhbnQgdG8gZXhwb3NlIG11bHRpcGxlIGZ1bmN0aW9ucy4iKTsKICAgICAgICB9CiAgICAgICAgZXhwb3NlQ2FsbGVkID0gdHJ1ZTsKICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiAhbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gIm9iamVjdCIgJiYgZXhwb3NlZCkgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmIG1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZFttZXNzYWdlRGF0YS5tZXRob2RdLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3NlZCkuZmlsdGVyKChrZXkpID0+IHR5cGVvZiBleHBvc2VkW2tleV0gPT09ICJmdW5jdGlvbiIpOwogICAgICAgICAgcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGV4cG9zZSgpLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCwgZ290OiAke2V4cG9zZWR9YCk7CiAgICAgICAgfQogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgaWYgKGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZShtZXNzYWdlRGF0YSkpIHsKICAgICAgICAgICAgY29uc3Qgam9iVUlEID0gbWVzc2FnZURhdGEudWlkOwogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3RpdmVTdWJzY3JpcHRpb25zLmdldChqb2JVSUQpOwogICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7CiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4cG9zZSA9IGV4cG9zZTI7CiAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHNlbGYuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShldmVudC5lcnJvciB8fCBldmVudCksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJ1bmhhbmRsZWRyZWplY3Rpb24iLCAoZXZlbnQpID0+IHsKICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQucmVhc29uOwogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHByb2Nlc3Mub24oInVuaGFuZGxlZFJlamVjdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdmNmL3ZjZi13b3JrZXIudHM/d29ya2VyJmlubGluZT93b3JrZXJfZmlsZQogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZXNtKCkpOwogIHZhciBpbXBvcnRfcXVpY2tfbHJ1ID0gX190b01vZHVsZShyZXF1aXJlX3F1aWNrX2xydSgpKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjcgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvY2FsRmlsZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb2NhbEZpbGUoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL3JlbW90ZUZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICB2YXIgbXlHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB7IGZldGNoOiB2b2lkIDAgfTsKICB2YXIgUmVtb3RlRmlsZSA9IGNsYXNzIHsKICAgIGFzeW5jIGdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSkgewogICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIHJldHVybiByZXNwb25zZS5idWZmZXIoKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuYXJyYXlCdWZmZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICByZXR1cm4gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmZyb20ocmVzcCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgaGFzIG5vIGJ1ZmZlciBtZXRob2QsIGFuZCBubyBhcnJheUJ1ZmZlciBtZXRob2QiKTsKICAgICAgfQogICAgfQogICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRzID0ge30pIHsKICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0ge307CiAgICAgIHRoaXMudXJsID0gc291cmNlOwogICAgICBjb25zdCBmZXRjaCA9IG9wdHMuZmV0Y2ggfHwgbXlHbG9iYWwuZmV0Y2ggJiYgbXlHbG9iYWwuZmV0Y2guYmluZChteUdsb2JhbCk7CiAgICAgIGlmICghZmV0Y2gpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YCk7CiAgICAgIH0KICAgICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7CiAgICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0gb3B0cy5vdmVycmlkZXM7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2g7CiAgICB9CiAgICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdDIpIHsKICAgICAgbGV0IHJlc3BvbnNlOwogICAgICB0cnkgewogICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCBpbml0Mik7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAoYCR7ZX1gLmluY2x1ZGVzKCJGYWlsZWQgdG8gZmV0Y2giKSkgewogICAgICAgICAgY29uc29sZS53YXJuKGBnZW5lcmljLWZpbGVoYW5kbGU6IHJlZmV0Y2hpbmcgJHtpbnB1dH0gdG8gYXR0ZW1wdCB0byB3b3JrIGFyb3VuZCBjaHJvbWUgQ09SUyBoZWFkZXIgY2FjaGluZyBidWdgKTsKICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCB7CiAgICAgICAgICAgIC4uLmluaXQyLAogICAgICAgICAgICBjYWNoZTogInJlbG9hZCIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICB9CiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0ID0gMCwgbGVuZ3RoLCBwb3NpdGlvbiA9IDAsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9uICsgbGVuZ3RofWA7CiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYDsKICAgICAgfQogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMsCiAgICAgICAgaGVhZGVyczogewogICAgICAgICAgLi4uaGVhZGVycywKICAgICAgICAgIC4uLm92ZXJyaWRlcy5oZWFkZXJzLAogICAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMKICAgICAgICB9LAogICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICBzaWduYWwKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke3RoaXMudXJsfWApOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikgewogICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICBjb25zdCByZXMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgiY29udGVudC1yYW5nZSIpOwogICAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cLyhcZCspJC8uZXhlYyhyZXMgfHwgIiIpOwogICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXIgfTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIiR7dGhpcy51cmx9IGZldGNoIHJldHVybmVkIHN0YXR1cyAyMDAsIGV4cGVjdGVkIDIwNiIpOwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH0KICAgIGFzeW5jIHJlYWRGaWxlKG9wdGlvbnMgPSB7fSkgewogICAgICBsZXQgZW5jb2Rpbmc7CiAgICAgIGxldCBvcHRzOwogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJzdHJpbmciKSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zOwogICAgICAgIG9wdHMgPSB7fTsKICAgICAgfSBlbHNlIHsKICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7CiAgICAgICAgb3B0cyA9IG9wdGlvbnM7CiAgICAgICAgZGVsZXRlIG9wdHMuZW5jb2Rpbmc7CiAgICAgIH0KICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgaGVhZGVycywKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsLAogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiZ2VuZXJpYy1maWxlaGFuZGxlIGZhaWxlZCB0byBmZXRjaCIpOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkgewogICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApLCB7CiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cwogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChlbmNvZGluZyA9PT0gInV0ZjgiKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2VuY29kaW5nfWApOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICB9CiAgICBhc3luYyBzdGF0KCkgewogICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICBjb25zdCBidWYgPSBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuYWxsb2NVbnNhZmUoMTApOwogICAgICAgIGF3YWl0IHRoaXMucmVhZChidWYsIDAsIDEwLCAwKTsKICAgICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgJHt0aGlzLnVybH1gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuX3N0YXQ7CiAgICB9CiAgICBhc3luYyBjbG9zZSgpIHsKICAgICAgcmV0dXJuOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2Jsb2JGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2ZpbGVoYW5kbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9iZ3pGaWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL3VuemlwLXBha28uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXI0ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICB2YXIgaW1wb3J0X3Bha28gPSBfX3RvTW9kdWxlKHJlcXVpcmVfcGFrbygpKTsKICBhc3luYyBmdW5jdGlvbiB1bnppcChpbnB1dERhdGEpIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBsZXQgcG9zID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7CiAgICAgIGxldCBpbmZsYXRvcjsKICAgICAgZG8gewogICAgICAgIGNvbnN0IHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnN1YmFycmF5KHBvcyk7CiAgICAgICAgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGNodW5rc1tpXSA9IGluZmxhdG9yLnJlc3VsdDsKICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICBpICs9IDE7CiAgICAgIH0gd2hpbGUgKHN0cm0uYXZhaWxfaW4pOwogICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpOwogICAgICBmb3IgKGxldCBpMiA9IDAsIG9mZnNldCA9IDA7IGkyIDwgY2h1bmtzLmxlbmd0aDsgaTIrKykgewogICAgICAgIHJlc3VsdC5zZXQoY2h1bmtzW2kyXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQgKz0gY2h1bmtzW2kyXS5sZW5ndGg7CiAgICAgIH0KICAgICAgcmV0dXJuIGltcG9ydF9idWZmZXI0LkJ1ZmZlci5mcm9tKHJlc3VsdCk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIGlmIChgJHtlfWAubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigicHJvYmxlbSBkZWNvbXByZXNzaW5nIGJsb2NrOiBpbmNvcnJlY3QgZ3ppcCBoZWFkZXIgY2hlY2siKTsKICAgICAgfQogICAgICB0aHJvdyBlOwogICAgfQogIH0KICBhc3luYyBmdW5jdGlvbiB1bnppcENodW5rU2xpY2UoaW5wdXREYXRhLCBjaHVuaykgewogICAgdHJ5IHsKICAgICAgbGV0IHN0cm07CiAgICAgIGNvbnN0IHsgbWludiwgbWF4diB9ID0gY2h1bms7CiAgICAgIGxldCBjcG9zID0gbWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBsZXQgZHBvcyA9IG1pbnYuZGF0YVBvc2l0aW9uOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgY29uc3QgY3Bvc2l0aW9ucyA9IFtdOwogICAgICBjb25zdCBkcG9zaXRpb25zID0gW107CiAgICAgIGxldCB0b3RhbFNpemUgPSAwOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGRvIHsKICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zdWJhcnJheShjcG9zIC0gbWludi5ibG9ja1Bvc2l0aW9uKTsKICAgICAgICBjb25zdCBpbmZsYXRvciA9IG5ldyBpbXBvcnRfcGFrby5JbmZsYXRlKCk7CiAgICAgICAgKHsgc3RybSB9ID0gaW5mbGF0b3IpOwogICAgICAgIGluZmxhdG9yLnB1c2gocmVtYWluaW5nSW5wdXQsIGltcG9ydF9wYWtvLlpfU1lOQ19GTFVTSCk7CiAgICAgICAgaWYgKGluZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluZmxhdG9yLm1zZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBpbmZsYXRvci5yZXN1bHQ7CiAgICAgICAgY2h1bmtzLnB1c2goYnVmZmVyMik7CiAgICAgICAgbGV0IGxlbiA9IGJ1ZmZlcjIubGVuZ3RoOwogICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICBkcG9zaXRpb25zLnB1c2goZHBvcyk7CiAgICAgICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEgJiYgbWludi5kYXRhUG9zaXRpb24pIHsKICAgICAgICAgIGNodW5rc1swXSA9IGNodW5rc1swXS5zdWJhcnJheShtaW52LmRhdGFQb3NpdGlvbik7CiAgICAgICAgICBsZW4gPSBjaHVua3NbMF0ubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBjb25zdCBvcmlnQ3BvcyA9IGNwb3M7CiAgICAgICAgY3BvcyArPSBzdHJtLm5leHRfaW47CiAgICAgICAgZHBvcyArPSBsZW47CiAgICAgICAgaWYgKG9yaWdDcG9zID49IG1heHYuYmxvY2tQb3NpdGlvbikgewogICAgICAgICAgY2h1bmtzW2ldID0gY2h1bmtzW2ldLnN1YmFycmF5KDAsIG1heHYuYmxvY2tQb3NpdGlvbiA9PT0gbWludi5ibG9ja1Bvc2l0aW9uID8gbWF4di5kYXRhUG9zaXRpb24gLSBtaW52LmRhdGFQb3NpdGlvbiArIDEgOiBtYXh2LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgY3Bvc2l0aW9ucy5wdXNoKGNwb3MpOwogICAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgaSsrOwogICAgICB9IHdoaWxlIChzdHJtLmF2YWlsX2luKTsKICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTsKICAgICAgZm9yIChsZXQgaTIgPSAwLCBvZmZzZXQgPSAwOyBpMiA8IGNodW5rcy5sZW5ndGg7IGkyKyspIHsKICAgICAgICByZXN1bHQuc2V0KGNodW5rc1tpMl0sIG9mZnNldCk7CiAgICAgICAgb2Zmc2V0ICs9IGNodW5rc1tpMl0ubGVuZ3RoOwogICAgICB9CiAgICAgIGNvbnN0IGJ1ZmZlciA9IGltcG9ydF9idWZmZXI0LkJ1ZmZlci5mcm9tKHJlc3VsdCk7CiAgICAgIHJldHVybiB7IGJ1ZmZlciwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9OwogICAgfSBjYXRjaCAoZSkgewogICAgICBpZiAoYCR7ZX1gLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgIH0KICAgICAgdGhyb3cgZTsKICAgIH0KICB9CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2d6aUluZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL25vZGVfbW9kdWxlcy9sb25nL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciB3YXNtID0gbnVsbDsKICB0cnkgewogICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFsKICAgICAgMCwKICAgICAgOTcsCiAgICAgIDExNSwKICAgICAgMTA5LAogICAgICAxLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAxLAogICAgICAxMywKICAgICAgMiwKICAgICAgOTYsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDEyNywKICAgICAgOTYsCiAgICAgIDQsCiAgICAgIDEyNywKICAgICAgMTI3LAogICAgICAxMjcsCiAgICAgIDEyNywKICAgICAgMSwKICAgICAgMTI3LAogICAgICAzLAogICAgICA3LAogICAgICA2LAogICAgICAwLAogICAgICAxLAogICAgICAxLAogICAgICAxLAogICAgICAxLAogICAgICAxLAogICAgICA2LAogICAgICA2LAogICAgICAxLAogICAgICAxMjcsCiAgICAgIDEsCiAgICAgIDY1LAogICAgICAwLAogICAgICAxMSwKICAgICAgNywKICAgICAgNTAsCiAgICAgIDYsCiAgICAgIDMsCiAgICAgIDEwOSwKICAgICAgMTE3LAogICAgICAxMDgsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDUsCiAgICAgIDEwMCwKICAgICAgMTA1LAogICAgICAxMTgsCiAgICAgIDk1LAogICAgICAxMTUsCiAgICAgIDAsCiAgICAgIDIsCiAgICAgIDUsCiAgICAgIDEwMCwKICAgICAgMTA1LAogICAgICAxMTgsCiAgICAgIDk1LAogICAgICAxMTcsCiAgICAgIDAsCiAgICAgIDMsCiAgICAgIDUsCiAgICAgIDExNCwKICAgICAgMTAxLAogICAgICAxMDksCiAgICAgIDk1LAogICAgICAxMTUsCiAgICAgIDAsCiAgICAgIDQsCiAgICAgIDUsCiAgICAgIDExNCwKICAgICAgMTAxLAogICAgICAxMDksCiAgICAgIDk1LAogICAgICAxMTcsCiAgICAgIDAsCiAgICAgIDUsCiAgICAgIDgsCiAgICAgIDEwMywKICAgICAgMTAxLAogICAgICAxMTYsCiAgICAgIDk1LAogICAgICAxMDQsCiAgICAgIDEwNSwKICAgICAgMTAzLAogICAgICAxMDQsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEwLAogICAgICAxOTEsCiAgICAgIDEsCiAgICAgIDYsCiAgICAgIDQsCiAgICAgIDAsCiAgICAgIDM1LAogICAgICAwLAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTI2LAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMjcsCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEsCiAgICAgIDM2LAogICAgICAxLAogICAgICAxLAogICAgICAxMjYsCiAgICAgIDMyLAogICAgICAwLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAxLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDMyLAogICAgICAyLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAzLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDEyOCwKICAgICAgMzQsCiAgICAgIDQsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM1LAogICAgICAxNjcsCiAgICAgIDM2LAogICAgICAwLAogICAgICAzMiwKICAgICAgNCwKICAgICAgMTY3LAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTI5LAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMzAsCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEKICAgIF0pKSwge30pLmV4cG9ydHM7CiAgfSBjYXRjaCAoZSkgewogIH0KICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHsKICAgIHRoaXMubG93ID0gbG93IHwgMDsKICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgfQogIExvbmcucHJvdG90eXBlLl9faXNMb25nX187CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgZnVuY3Rpb24gaXNMb25nKG9iaikgewogICAgcmV0dXJuIChvYmogJiYgb2JqWyJfX2lzTG9uZ19fIl0pID09PSB0cnVlOwogIH0KICBmdW5jdGlvbiBjdHozMih2YWx1ZSkgewogICAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTsKICAgIHJldHVybiB2YWx1ZSA/IDMxIC0gYyA6IGM7CiAgfQogIExvbmcuaXNMb25nID0gaXNMb25nOwogIHZhciBJTlRfQ0FDSEUgPSB7fTsKICB2YXIgVUlOVF9DQUNIRSA9IHt9OwogIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7CiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdOwogICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICB9CiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTsKICAgICAgaWYgKGNhY2hlKQogICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICByZXR1cm4gb2JqOwogICAgfSBlbHNlIHsKICAgICAgdmFsdWUgfD0gMDsKICAgICAgaWYgKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkgewogICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7CiAgICAgIH0KICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICBpZiAoY2FjaGUpCiAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgcmV0dXJuIG9iajsKICAgIH0KICB9CiAgTG9uZy5mcm9tSW50ID0gZnJvbUludDsKICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkgewogICAgaWYgKGlzTmFOKHZhbHVlKSkKICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpCiAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTsKICAgIH0gZWxzZSB7CiAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpCiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkKICAgICAgICByZXR1cm4gTUFYX1ZBTFVFOwogICAgfQogICAgaWYgKHZhbHVlIDwgMCkKICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7CiAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7CiAgfQogIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7CiAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7CiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICB9CiAgTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzOwogIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7CiAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkgewogICAgaWYgKHN0ci5sZW5ndGggPT09IDApCiAgICAgIHRocm93IEVycm9yKCJlbXB0eSBzdHJpbmciKTsKICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgIHJhZGl4ID0gdW5zaWduZWQ7CiAgICAgIHVuc2lnbmVkID0gZmFsc2U7CiAgICB9IGVsc2UgewogICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICB9CiAgICBpZiAoc3RyID09PSAiTmFOIiB8fCBzdHIgPT09ICJJbmZpbml0eSIgfHwgc3RyID09PSAiK0luZmluaXR5IiB8fCBzdHIgPT09ICItSW5maW5pdHkiKQogICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgdmFyIHA7CiAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgIHRocm93IEVycm9yKCJpbnRlcmlvciBoeXBoZW4iKTsKICAgIGVsc2UgaWYgKHAgPT09IDApIHsKICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTsKICAgIH0KICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTsKICAgIHZhciByZXN1bHQgPSBaRVJPOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHsKICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgaWYgKHNpemUgPCA4KSB7CiAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7CiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7CiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgIH0KICAgIH0KICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkOwogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZzsKICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkgewogICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTsKICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikKICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7CiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gImJvb2xlYW4iID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpOwogIH0KICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsKICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2OwogIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7CiAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDsKICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMOwogIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjsKICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpOwogIHZhciBaRVJPID0gZnJvbUludCgwKTsKICBMb25nLlpFUk8gPSBaRVJPOwogIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7CiAgTG9uZy5VWkVSTyA9IFVaRVJPOwogIHZhciBPTkUgPSBmcm9tSW50KDEpOwogIExvbmcuT05FID0gT05FOwogIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTsKICBMb25nLlVPTkUgPSBVT05FOwogIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7CiAgTG9uZy5ORUdfT05FID0gTkVHX09ORTsKICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoNDI5NDk2NzI5NSB8IDAsIDIxNDc0ODM2NDcgfCAwLCBmYWxzZSk7CiAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7CiAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDQyOTQ5NjcyOTUgfCAwLCA0Mjk0OTY3Mjk1IHwgMCwgdHJ1ZSk7CiAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7CiAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDIxNDc0ODM2NDggfCAwLCBmYWxzZSk7CiAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7CiAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTsKICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7CiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7CiAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICB9OwogIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkgewogICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICByZXR1cm4gIjAiOwogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgfSBlbHNlCiAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgfQogICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLCByZW0gPSB0aGlzOwogICAgdmFyIHJlc3VsdCA9ICIiOwogICAgd2hpbGUgKHRydWUpIHsKICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSwgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7CiAgICAgIHJlbSA9IHJlbURpdjsKICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0OwogICAgICBlbHNlIHsKICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICBkaWdpdHMgPSAiMCIgKyBkaWdpdHM7CiAgICAgICAgcmVzdWx0ID0gIiIgKyBkaWdpdHMgKyByZXN1bHQ7CiAgICAgIH0KICAgIH0KICB9OwogIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkgewogICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7CiAgICByZXR1cm4gdGhpcy5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHsKICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7CiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpCiAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpOwogICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApCiAgICAgICAgYnJlYWs7CiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgfTsKICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvOwogIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7CiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDsKICB9OwogIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7CiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICB9OwogIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHsKICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTsKICB9OwogIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkgewogICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpCiAgICAgIHJldHVybiBmYWxzZTsKICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICB9OwogIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFsczsKICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikgewogICAgcmV0dXJuICF0aGlzLmVxKG90aGVyKTsKICB9OwogIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikgewogICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47CiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogIExvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuOwogIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7CiAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikgewogICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICBpZiAodGhpcy5lcShvdGhlcikpCiAgICAgIHJldHVybiAwOwogICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpCiAgICAgIHJldHVybiAtMTsKICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgcmV0dXJuIDE7CiAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlOwogIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkgewogICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTsKICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHsKICAgIGlmICghaXNMb25nKGFkZGVuZCkpCiAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpOwogICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgNjU1MzU7CiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7CiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICBjMDAgKz0gYTAwICsgYjAwOwogICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICBjMDAgJj0gNjU1MzU7CiAgICBjMTYgKz0gYTE2ICsgYjE2OwogICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICBjMTYgJj0gNjU1MzU7CiAgICBjMzIgKz0gYTMyICsgYjMyOwogICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICBjMzIgJj0gNjU1MzU7CiAgICBjNDggKz0gYTQ4ICsgYjQ4OwogICAgYzQ4ICY9IDY1NTM1OwogICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7CiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSkKICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTsKICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICB9OwogIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDsKICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikgewogICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpCiAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7CiAgICBpZiAod2FzbSkgewogICAgICB2YXIgbG93ID0gd2FzbVsibXVsIl0odGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bImdldF9oaWdoIl0oKSwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkKICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKQogICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpCiAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPOwogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7CiAgICAgIGVsc2UKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKQogICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpOwogICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiA2NTUzNTsKICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgYzAwICs9IGEwMCAqIGIwMDsKICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgYzAwICY9IDY1NTM1OwogICAgYzE2ICs9IGExNiAqIGIwMDsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzMyICs9IGEzMiAqIGIwMDsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzMyICs9IGExNiAqIGIxNjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzMyICs9IGEwMCAqIGIzMjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgIGM0OCAmPSA2NTUzNTsKICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7CiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikgewogICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkKICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgIGlmICh3YXNtKSB7CiAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVsiZGl2X3UiXSA6IHdhc21bImRpdl9zIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtWyJnZXRfaGlnaCJdKCksIHRoaXMudW5zaWduZWQpOwogICAgfQogICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgdmFyIGFwcHJveCwgcmVtLCByZXM7CiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSkKICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIE9ORTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpOwogICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTsKICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHsKICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpOwogICAgICAgICAgICByZXR1cm4gcmVzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7CiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICByZXMgPSBaRVJPOwogICAgfSBlbHNlIHsKICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKQogICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgIHJldHVybiBVT05FOwogICAgICByZXMgPSBVWkVSTzsKICAgIH0KICAgIHJlbSA9IHRoaXM7CiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkgewogICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSwgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICBhcHByb3ggLT0gZGVsdGE7CiAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgIH0KICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICBhcHByb3hSZXMgPSBPTkU7CiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pOwogICAgfQogICAgcmV0dXJuIHJlczsKICB9OwogIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7CiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikgewogICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICBpZiAod2FzbSkgewogICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtWyJyZW1fdSJdIDogd2FzbVsicmVtX3MiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bImdldF9oaWdoIl0oKSwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICB9OwogIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbzsKICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHsKICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50TGVhZGluZ1plcm9zKCkgewogICAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7CiAgfTsKICBMb25nUHJvdG90eXBlLmNseiA9IExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3M7CiAgTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3MoKSB7CiAgICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7CiAgfTsKICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zOwogIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgZWxzZQogICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7CiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgIGVsc2UKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0OwogIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICBpZiAobnVtQml0cyA9PT0gMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gbnVtQml0cyAtIDMyLCAwLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkOwogIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHsKICAgIHZhciBiOwogICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7CiAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgIGIgPSAzMiAtIG51bUJpdHM7CiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLnVuc2lnbmVkKTsKICAgIH0KICAgIG51bUJpdHMgLT0gMzI7CiAgICBiID0gMzIgLSBudW1CaXRzOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IGIsIHRoaXMubG93IDw8IG51bUJpdHMgfCB0aGlzLmhpZ2ggPj4+IGIsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0OwogIExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7CiAgICB2YXIgYjsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzID09PSAzMikKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpOwogICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICBiID0gMzIgLSBudW1CaXRzOwogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBudW1CaXRzIC09IDMyOwogICAgYiA9IDMyIC0gbnVtQml0czsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBiIHwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgYiB8IHRoaXMubG93ID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUucm90ciA9IExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQ7CiAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkgewogICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICByZXR1cm4gdGhpczsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkgewogICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiB0aGlzOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkgewogICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHsKICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgIHJldHVybiBbCiAgICAgIGxvICYgMjU1LAogICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICBsbyA+Pj4gMjQsCiAgICAgIGhpICYgMjU1LAogICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICBoaSA+Pj4gMjQKICAgIF07CiAgfTsKICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHsKICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgIHJldHVybiBbCiAgICAgIGhpID4+PiAyNCwKICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgaGkgJiAyNTUsCiAgICAgIGxvID4+PiAyNCwKICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgbG8gJiAyNTUKICAgIF07CiAgfTsKICBMb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7CiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7CiAgfTsKICBMb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpOwogIH07CiAgTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9nemlJbmRleC5qcwogIHZhciBpbXBvcnRfYnVmZmVyNSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBsb25nVG9OdW1iZXIobG9uZykgewogICAgaWYgKGxvbmcuZ3JlYXRlclRoYW4oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IGxvbmcubGVzc1RoYW4oTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiaW50ZWdlciBvdmVyZmxvdyIpOwogICAgfQogICAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKTsKICB9CiAgdmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHsKICB9OwogIGZ1bmN0aW9uIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKSB7CiAgICBpZiAoIXNpZ25hbCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbigiYWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZSA9IG5ldyBBYm9ydEVycm9yKCJhYm9ydGVkIik7CiAgICAgICAgZS5jb2RlID0gIkVSUl9BQk9SVEVEIjsKICAgICAgICB0aHJvdyBlOwogICAgICB9CiAgICB9CiAgfQogIGZ1bmN0aW9uIGNhbk1lcmdlQmxvY2tzKGNodW5rMSwgY2h1bmsyKSB7CiAgICByZXR1cm4gY2h1bmsyLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5tYXh2LmJsb2NrUG9zaXRpb24gPCA2NWUzICYmIGNodW5rMi5tYXh2LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWludi5ibG9ja1Bvc2l0aW9uIDwgNWU2OwogIH0KICBmdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkgewogICAgY29uc3QgbWVyZ2VkQ2h1bmtzID0gW107CiAgICBsZXQgbGFzdENodW5rID0gbnVsbDsKICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBjaHVua3M7CiAgICB9CiAgICBjaHVua3Muc29ydChmdW5jdGlvbihjMCwgYzEpIHsKICAgICAgY29uc3QgZGlmID0gYzAubWludi5ibG9ja1Bvc2l0aW9uIC0gYzEubWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBpZiAoZGlmICE9PSAwKSB7CiAgICAgICAgcmV0dXJuIGRpZjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYzAubWludi5kYXRhUG9zaXRpb24gLSBjMS5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgfQogICAgfSk7CiAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IHsKICAgICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHsKICAgICAgICBpZiAobGFzdENodW5rID09PSBudWxsKSB7CiAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGNhbk1lcmdlQmxvY2tzKGxhc3RDaHVuaywgY2h1bmspKSB7CiAgICAgICAgICAgIGlmIChjaHVuay5tYXh2LmNvbXBhcmVUbyhsYXN0Q2h1bmsubWF4dikgPiAwKSB7CiAgICAgICAgICAgICAgbGFzdENodW5rLm1heHYgPSBjaHVuay5tYXh2OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YmkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3ZpcnR1YWxPZmZzZXQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIFZpcnR1YWxPZmZzZXQgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihibG9ja1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24pIHsKICAgICAgdGhpcy5ibG9ja1Bvc2l0aW9uID0gYmxvY2tQb3NpdGlvbjsKICAgICAgdGhpcy5kYXRhUG9zaXRpb24gPSBkYXRhUG9zaXRpb247CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIGAke3RoaXMuYmxvY2tQb3NpdGlvbn06JHt0aGlzLmRhdGFQb3NpdGlvbn1gOwogICAgfQogICAgY29tcGFyZVRvKGIpIHsKICAgICAgcmV0dXJuIHRoaXMuYmxvY2tQb3NpdGlvbiAtIGIuYmxvY2tQb3NpdGlvbiB8fCB0aGlzLmRhdGFQb3NpdGlvbiAtIGIuZGF0YVBvc2l0aW9uOwogICAgfQogICAgc3RhdGljIG1pbiguLi5hcmdzKSB7CiAgICAgIGxldCBtaW47CiAgICAgIGxldCBpID0gMDsKICAgICAgZm9yICg7ICFtaW47IGkgKz0gMSkgewogICAgICAgIG1pbiA9IGFyZ3NbaV07CiAgICAgIH0KICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKG1pbi5jb21wYXJlVG8oYXJnc1tpXSkgPiAwKSB7CiAgICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbWluOwogICAgfQogIH07CiAgZnVuY3Rpb24gZnJvbUJ5dGVzMihieXRlcywgb2Zmc2V0ID0gMCwgYmlnZW5kaWFuID0gZmFsc2UpIHsKICAgIGlmIChiaWdlbmRpYW4pIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJiaWctZW5kaWFuIHZpcnR1YWwgZmlsZSBvZmZzZXRzIG5vdCBpbXBsZW1lbnRlZCIpOwogICAgfQogICAgcmV0dXJuIG5ldyBWaXJ0dWFsT2Zmc2V0KGJ5dGVzW29mZnNldCArIDddICogMTA5OTUxMTYyNzc3NiArIGJ5dGVzW29mZnNldCArIDZdICogNDI5NDk2NzI5NiArIGJ5dGVzW29mZnNldCArIDVdICogMTY3NzcyMTYgKyBieXRlc1tvZmZzZXQgKyA0XSAqIDY1NTM2ICsgYnl0ZXNbb2Zmc2V0ICsgM10gKiAyNTYgKyBieXRlc1tvZmZzZXQgKyAyXSwgYnl0ZXNbb2Zmc2V0ICsgMV0gPDwgOCB8IGJ5dGVzW29mZnNldF0pOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9jaHVuay5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgQ2h1bmsgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihtaW52LCBtYXh2LCBiaW4sIGZldGNoZWRTaXplID0gdm9pZCAwKSB7CiAgICAgIHRoaXMubWludiA9IG1pbnY7CiAgICAgIHRoaXMubWF4diA9IG1heHY7CiAgICAgIHRoaXMuYmluID0gYmluOwogICAgICB0aGlzLl9mZXRjaGVkU2l6ZSA9IGZldGNoZWRTaXplOwogICAgfQogICAgdG9VbmlxdWVTdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLm1pbnZ9Li4ke3RoaXMubWF4dn0gKGJpbiAke3RoaXMuYmlufSwgZmV0Y2hlZFNpemUgJHt0aGlzLmZldGNoZWRTaXplKCl9KWA7CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIHRoaXMudG9VbmlxdWVTdHJpbmcoKTsKICAgIH0KICAgIGNvbXBhcmVUbyhiKSB7CiAgICAgIHJldHVybiB0aGlzLm1pbnYuY29tcGFyZVRvKGIubWludikgfHwgdGhpcy5tYXh2LmNvbXBhcmVUbyhiLm1heHYpIHx8IHRoaXMuYmluIC0gYi5iaW47CiAgICB9CiAgICBmZXRjaGVkU2l6ZSgpIHsKICAgICAgaWYgKHRoaXMuX2ZldGNoZWRTaXplICE9PSB2b2lkIDApIHsKICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hlZFNpemU7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMubWF4di5ibG9ja1Bvc2l0aW9uICsgKDEgPDwgMTYpIC0gdGhpcy5taW52LmJsb2NrUG9zaXRpb247CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleEZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIEluZGV4RmlsZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHsgZmlsZWhhbmRsZSwgcmVuYW1lUmVmU2VxcyA9IChuKSA9PiBuIH0pIHsKICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzOwogICAgfQogICAgYXN5bmMgZ2V0TWV0YWRhdGEob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgaW5kaWNlcywgLi4ucmVzdCB9ID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgcmV0dXJuIHJlc3Q7CiAgICB9CiAgICBfZmluZEZpcnN0RGF0YShjdXJyZW50RmRsLCB2aXJ0dWFsT2Zmc2V0KSB7CiAgICAgIGlmIChjdXJyZW50RmRsKSB7CiAgICAgICAgcmV0dXJuIGN1cnJlbnRGZGwuY29tcGFyZVRvKHZpcnR1YWxPZmZzZXQpID4gMCA/IHZpcnR1YWxPZmZzZXQgOiBjdXJyZW50RmRsOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2aXJ0dWFsT2Zmc2V0OwogICAgICB9CiAgICB9CiAgICBhc3luYyBwYXJzZShvcHRzID0ge30pIHsKICAgICAgaWYgKCF0aGlzLnBhcnNlUCkgewogICAgICAgIHRoaXMucGFyc2VQID0gdGhpcy5fcGFyc2Uob3B0cykuY2F0Y2goKGUpID0+IHsKICAgICAgICAgIHRoaXMucGFyc2VQID0gdm9pZCAwOwogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5wYXJzZVA7CiAgICB9CiAgICBhc3luYyBoYXNSZWZTZXEoc2VxSWQsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gISEoKGF3YWl0IHRoaXMucGFyc2Uob3B0cykpLmluZGljZXNbc2VxSWRdIHx8IHt9KS5iaW5JbmRleDsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RiaS5qcwogIHZhciBUQklfTUFHSUMgPSAyMTU3ODMyNDsKICB2YXIgVEFEX0xJRFhfU0hJRlQgPSAxNDsKICBmdW5jdGlvbiByZWcyYmlucyhiZWcsIGVuZCkgewogICAgYmVnICs9IDE7CiAgICBlbmQgLT0gMTsKICAgIHJldHVybiBbCiAgICAgIFswLCAwXSwKICAgICAgWzEgKyAoYmVnID4+IDI2KSwgMSArIChlbmQgPj4gMjYpXSwKICAgICAgWzkgKyAoYmVnID4+IDIzKSwgOSArIChlbmQgPj4gMjMpXSwKICAgICAgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLAogICAgICBbNTg1ICsgKGJlZyA+PiAxNyksIDU4NSArIChlbmQgPj4gMTcpXSwKICAgICAgWzQ2ODEgKyAoYmVnID4+IDE0KSwgNDY4MSArIChlbmQgPj4gMTQpXQogICAgXTsKICB9CiAgdmFyIFRhYml4SW5kZXggPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKTsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB1bnppcChidWYpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSAhPT0gVEJJX01BR0lDKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBUQkkgZmlsZSIpOwogICAgICB9CiAgICAgIGNvbnN0IHJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgIGNvbnN0IGZvcm1hdEZsYWdzID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID0gZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICBjb25zdCBmb3JtYXRPcHRzID0gewogICAgICAgIDA6ICJnZW5lcmljIiwKICAgICAgICAxOiAiU0FNIiwKICAgICAgICAyOiAiVkNGIgogICAgICB9OwogICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRPcHRzW2Zvcm1hdEZsYWdzICYgMTVdOwogICAgICBpZiAoIWZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7Zm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHsKICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKDEyKSwKICAgICAgICBzdGFydDogYnl0ZXMucmVhZEludDMyTEUoMTYpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUoMjApCiAgICAgIH07CiAgICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKDI0KTsKICAgICAgY29uc3QgZGVwdGggPSA1OwogICAgICBjb25zdCBtYXhCaW5OdW1iZXIgPSAoKDEgPDwgKGRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAoMTQgKyBkZXB0aCAqIDMpOwogICAgICBjb25zdCBtZXRhQ2hhciA9IG1ldGFWYWx1ZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUobWV0YVZhbHVlKSA6IG51bGw7CiAgICAgIGNvbnN0IHNraXBMaW5lcyA9IGJ5dGVzLnJlYWRJbnQzMkxFKDI4KTsKICAgICAgY29uc3QgbmFtZVNlY3Rpb25MZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgzMik7CiAgICAgIGNvbnN0IHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH0gPSB0aGlzLl9wYXJzZU5hbWVCeXRlcyhieXRlcy5zbGljZSgzNiwgMzYgKyBuYW1lU2VjdGlvbkxlbmd0aCkpOwogICAgICBsZXQgY3Vyck9mZnNldCA9IDM2ICsgbmFtZVNlY3Rpb25MZW5ndGg7CiAgICAgIGxldCBmaXJzdERhdGFMaW5lOwogICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHJlZkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiB7CiAgICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBsZXQgc3RhdHM7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICBpZiAoYmluID4gbWF4QmluTnVtYmVyICsgMSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInRhYml4IGluZGV4IGNvbnRhaW5zIHRvbyBtYW55IGJpbnMsIHBsZWFzZSB1c2UgYSBDU0kgaW5kZXgiKTsKICAgICAgICAgIH0gZWxzZSBpZiAoYmluID09PSBtYXhCaW5OdW1iZXIgKyAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICBpZiAoY2h1bmtDb3VudCA9PT0gMikgewogICAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNiAqIGNodW5rQ291bnQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgdSk7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgbGluZWFySW5kZXhba10gPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gODsKICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxpbmVhckluZGV4W2tdKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIGxpbmVhckluZGV4LCBzdGF0cyB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIHsKICAgICAgICBpbmRpY2VzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIG1heEJpbk51bWJlciwKICAgICAgICBtYXhSZWZMZW5ndGgsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIGZpcnN0RGF0YUxpbmUsCiAgICAgICAgY29sdW1uTnVtYmVycywKICAgICAgICBjb29yZGluYXRlVHlwZSwKICAgICAgICBmb3JtYXQsCiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2CiAgICAgIH07CiAgICB9CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZzIuZGVmYXVsdC5mcm9tQnl0ZXNMRShieXRlcy5zbGljZShvZmZzZXQgKyAxNiwgb2Zmc2V0ICsgMjQpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXMpIHsKICAgICAgbGV0IGN1cnJSZWZJZCA9IDA7CiAgICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMDsKICAgICAgY29uc3QgcmVmSWRUb05hbWUgPSBbXTsKICAgICAgY29uc3QgcmVmTmFtZVRvSWQgPSB7fTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc0J5dGVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7CiAgICAgICAgICBpZiAoY3Vyck5hbWVTdGFydCA8IGkpIHsKICAgICAgICAgICAgbGV0IHJlZk5hbWUgPSBuYW1lc0J5dGVzLnRvU3RyaW5nKCJ1dGY4IiwgY3Vyck5hbWVTdGFydCwgaSk7CiAgICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKTsKICAgICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWU7CiAgICAgICAgICAgIHJlZk5hbWVUb0lkW3JlZk5hbWVdID0gY3VyclJlZklkOwogICAgICAgICAgfQogICAgICAgICAgY3Vyck5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VyclJlZklkICs9IDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHJlZk5hbWVUb0lkLCByZWZJZFRvTmFtZSB9OwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWJhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IG1pbk9mZnNldCA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aCA/IGJhLmxpbmVhckluZGV4W21pbiA+PiBUQURfTElEWF9TSElGVCA+PSBiYS5saW5lYXJJbmRleC5sZW5ndGggPyBiYS5saW5lYXJJbmRleC5sZW5ndGggLSAxIDogbWluID4+IFRBRF9MSURYX1NISUZUXSA6IG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApOwogICAgICBpZiAoIW1pbk9mZnNldCkgewogICAgICAgIGNvbnNvbGUud2FybigicXVlcnlpbmcgb3V0c2lkZSBvZiBwb3NzaWJsZSB0YWJpeCByYW5nZSIpOwogICAgICB9CiAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDsKICAgICAgbGV0IGxvd2VzdCA9IG51bGw7CiAgICAgIGNvbnN0IG1pbkxpbiA9IE1hdGgubWluKG1pbiA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgY29uc3QgbWF4TGluID0gTWF0aC5taW4obWF4ID4+IDE0LCBuaW50diAtIDEpOwogICAgICBmb3IgKGxldCBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7CiAgICAgICAgY29uc3QgdnAgPSBiYS5saW5lYXJJbmRleFtpXTsKICAgICAgICBpZiAodnApIHsKICAgICAgICAgIGlmICghbG93ZXN0IHx8IHZwLmNvbXBhcmVUbyhsb3dlc3QpIDwgMCkgewogICAgICAgICAgICBsb3dlc3QgPSB2cDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL2NzaS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvbmczID0gX190b01vZHVsZShyZXF1aXJlX2xvbmcoKSk7CiAgdmFyIENTSTFfTUFHSUMgPSAyMTU4MjY1OTsKICB2YXIgQ1NJMl9NQUdJQyA9IDM4MzU5ODc1OwogIGZ1bmN0aW9uIGxzaGlmdChudW0sIGJpdHMpIHsKICAgIHJldHVybiBudW0gKiAyICoqIGJpdHM7CiAgfQogIGZ1bmN0aW9uIHJzaGlmdChudW0sIGJpdHMpIHsKICAgIHJldHVybiBNYXRoLmZsb29yKG51bSAvIDIgKiogYml0cyk7CiAgfQogIHZhciBDU0kgPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7CiAgICAgIHN1cGVyKGFyZ3MpOwogICAgICB0aGlzLm1heEJpbk51bWJlciA9IDA7CiAgICAgIHRoaXMuZGVwdGggPSAwOwogICAgICB0aGlzLm1pblNoaWZ0ID0gMDsKICAgIH0KICAgIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFpZHgpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoc3RhdHMpIHsKICAgICAgICByZXR1cm4gc3RhdHMubGluZUNvdW50OwogICAgICB9CiAgICAgIHJldHVybiAtMTsKICAgIH0KICAgIGFzeW5jIGluZGV4Q292KCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkNTSSBpbmRleGVzIGRvIG5vdCBzdXBwb3J0IGluZGV4Y292Iik7CiAgICB9CiAgICBwYXJzZUF1eERhdGEoYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBmb3JtYXRGbGFncyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCk7CiAgICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID0gZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICBjb25zdCBmb3JtYXQgPSB7IDA6ICJnZW5lcmljIiwgMTogIlNBTSIsIDI6ICJWQ0YiIH1bZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZm9ybWF0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgNCksCiAgICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDgpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTIpCiAgICAgIH07CiAgICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDE2KTsKICAgICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiBudWxsOwogICAgICBjb25zdCBza2lwTGluZXMgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAyMCk7CiAgICAgIGNvbnN0IG5hbWVTZWN0aW9uTGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjQpOwogICAgICBjb25zdCB7IHJlZklkVG9OYW1lLCByZWZOYW1lVG9JZCB9ID0gdGhpcy5fcGFyc2VOYW1lQnl0ZXMoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMjgsIG9mZnNldCArIDI4ICsgbmFtZVNlY3Rpb25MZW5ndGgpKTsKICAgICAgcmV0dXJuIHsKICAgICAgICByZWZJZFRvTmFtZSwKICAgICAgICByZWZOYW1lVG9JZCwKICAgICAgICBza2lwTGluZXMsCiAgICAgICAgbWV0YUNoYXIsCiAgICAgICAgY29sdW1uTnVtYmVycywKICAgICAgICBmb3JtYXQsCiAgICAgICAgY29vcmRpbmF0ZVR5cGUKICAgICAgfTsKICAgIH0KICAgIF9wYXJzZU5hbWVCeXRlcyhuYW1lc0J5dGVzKSB7CiAgICAgIGxldCBjdXJyUmVmSWQgPSAwOwogICAgICBsZXQgY3Vyck5hbWVTdGFydCA9IDA7CiAgICAgIGNvbnN0IHJlZklkVG9OYW1lID0gW107CiAgICAgIGNvbnN0IHJlZk5hbWVUb0lkID0ge307CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmICghbmFtZXNCeXRlc1tpXSkgewogICAgICAgICAgaWYgKGN1cnJOYW1lU3RhcnQgPCBpKSB7CiAgICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygidXRmOCIsIGN1cnJOYW1lU3RhcnQsIGkpOwogICAgICAgICAgICByZWZOYW1lID0gdGhpcy5yZW5hbWVSZWZTZXEocmVmTmFtZSk7CiAgICAgICAgICAgIHJlZklkVG9OYW1lW2N1cnJSZWZJZF0gPSByZWZOYW1lOwogICAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZDsKICAgICAgICAgIH0KICAgICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMTsKICAgICAgICAgIGN1cnJSZWZJZCArPSAxOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfTsKICAgIH0KICAgIGFzeW5jIF9wYXJzZShvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB1bnppcChhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZEZpbGUob3B0cykpOwogICAgICBsZXQgY3NpVmVyc2lvbjsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMV9NQUdJQykgewogICAgICAgIGNzaVZlcnNpb24gPSAxOwogICAgICB9IGVsc2UgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMl9NQUdJQykgewogICAgICAgIGNzaVZlcnNpb24gPSAyOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTm90IGEgQ1NJIGZpbGUiKTsKICAgICAgfQogICAgICB0aGlzLm1pblNoaWZ0ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgIHRoaXMuZGVwdGggPSBieXRlcy5yZWFkSW50MzJMRSg4KTsKICAgICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAoKDEgPDwgKHRoaXMuZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICh0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDMpOwogICAgICBjb25zdCBhdXhMZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgxMik7CiAgICAgIGNvbnN0IGF1eCA9IGF1eExlbmd0aCAmJiBhdXhMZW5ndGggPj0gMzAgPyB0aGlzLnBhcnNlQXV4RGF0YShieXRlcywgMTYpIDogewogICAgICAgIHJlZklkVG9OYW1lOiBbXSwKICAgICAgICByZWZOYW1lVG9JZDoge30sCiAgICAgICAgbWV0YUNoYXI6IG51bGwsCiAgICAgICAgY29sdW1uTnVtYmVyczogeyByZWY6IDAsIHN0YXJ0OiAxLCBlbmQ6IDIgfSwKICAgICAgICBjb29yZGluYXRlVHlwZTogInplcm8tYmFzZWQtaGFsZi1vcGVuIiwKICAgICAgICBmb3JtYXQ6ICJnZW5lcmljIgogICAgICB9OwogICAgICBjb25zdCByZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDE2ICsgYXV4TGVuZ3RoKTsKICAgICAgbGV0IGZpcnN0RGF0YUxpbmU7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gMTYgKyBhdXhMZW5ndGggKyA0OwogICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHJlZkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiB7CiAgICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBsZXQgc3RhdHM7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICBpZiAoYmluID4gdGhpcy5tYXhCaW5OdW1iZXIpIHsKICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNCArIDggKyA0ICsgMTYgKyAxNjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGxvZmZzZXQgPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxvZmZzZXQpOwogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCArIDEyKTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIHN0YXRzIH07CiAgICAgIH0pOwogICAgICByZXR1cm4gewogICAgICAgIC4uLmF1eCwKICAgICAgICBjc2k6IHRydWUsCiAgICAgICAgcmVmQ291bnQsCiAgICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2LAogICAgICAgIGZpcnN0RGF0YUxpbmUsCiAgICAgICAgY3NpVmVyc2lvbiwKICAgICAgICBpbmRpY2VzLAogICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoLAogICAgICAgIG1heEJpbk51bWJlcjogdGhpcy5tYXhCaW5OdW1iZXIsCiAgICAgICAgbWF4UmVmTGVuZ3RoCiAgICAgIH07CiAgICB9CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZzMuZGVmYXVsdC5mcm9tQnl0ZXNMRShieXRlcy5zbGljZShvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMzYpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWJhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHRoaXMucmVnMmJpbnMobWluLCBtYXgpOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2Ygb3ZlcmxhcHBpbmdCaW5zKSB7CiAgICAgICAgZm9yIChsZXQgYmluID0gc3RhcnQ7IGJpbiA8PSBlbmQ7IGJpbisrKSB7CiAgICAgICAgICBpZiAoYmEuYmluSW5kZXhbYmluXSkgewogICAgICAgICAgICBjb25zdCBiaW5DaHVua3MgPSBiYS5iaW5JbmRleFtiaW5dOwogICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykgewogICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBDaHVuayhiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApKTsKICAgIH0KICAgIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICAgIGJlZyAtPSAxOwogICAgICBpZiAoYmVnIDwgMSkgewogICAgICAgIGJlZyA9IDE7CiAgICAgIH0KICAgICAgaWYgKGVuZCA+IDIgKiogNTApIHsKICAgICAgICBlbmQgPSAyICoqIDM0OwogICAgICB9CiAgICAgIGVuZCAtPSAxOwogICAgICBsZXQgbCA9IDA7CiAgICAgIGxldCB0ID0gMDsKICAgICAgbGV0IHMgPSB0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDM7CiAgICAgIGNvbnN0IGJpbnMgPSBbXTsKICAgICAgZm9yICg7IGwgPD0gdGhpcy5kZXB0aDsgcyAtPSAzLCB0ICs9IGxzaGlmdCgxLCBsICogMyksIGwgKz0gMSkgewogICAgICAgIGNvbnN0IGIgPSB0ICsgcnNoaWZ0KGJlZywgcyk7CiAgICAgICAgY29uc3QgZSA9IHQgKyByc2hpZnQoZW5kLCBzKTsKICAgICAgICBpZiAoZSAtIGIgKyBiaW5zLmxlbmd0aCA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHF1ZXJ5ICR7YmVnfS0ke2VuZH0gaXMgdG9vIGxhcmdlIGZvciBjdXJyZW50IGJpbm5pbmcgc2NoZW1lIChzaGlmdCAke3RoaXMubWluU2hpZnR9LCBkZXB0aCAke3RoaXMuZGVwdGh9KSwgdHJ5IGEgc21hbGxlciBxdWVyeSBvciBhIGNvYXJzZXIgaW5kZXggYmlubmluZyBzY2hlbWVgKTsKICAgICAgICB9CiAgICAgICAgYmlucy5wdXNoKFtiLCBlXSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGJpbnM7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgdmFyIGRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICJ1bmRlZmluZWQiID8gbmV3IFRleHREZWNvZGVyKCJ1dGYtOCIpIDogdm9pZCAwOwogIGZ1bmN0aW9uIHRpbWVvdXQodGltZSkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKTsKICB9CiAgdmFyIFRhYml4SW5kZXhlZEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IHBhdGgsIGZpbGVoYW5kbGUsIHRiaVBhdGgsIHRiaUZpbGVoYW5kbGUsIGNzaVBhdGgsIGNzaUZpbGVoYW5kbGUsIHlpZWxkVGltZSA9IDUwMCwgY2h1bmtTaXplTGltaXQgPSA1ZTcsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiwgY2h1bmtDYWNoZVNpemUgPSA1ICogMiAqKiAyMCB9KSB7CiAgICAgIGlmIChmaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChwYXRoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCIpOwogICAgICB9CiAgICAgIGlmICh0YmlGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IHRiaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAoY3NpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHsKICAgICAgICAgIGZpbGVoYW5kbGU6IGNzaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAodGJpUGF0aCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgVGFiaXhJbmRleCh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KHRiaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KGNzaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChgJHtwYXRofS50YmlgKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgb25lIG9mIHRiaUZpbGVoYW5kbGUsIHRiaVBhdGgsIGNzaUZpbGVoYW5kbGUsIG9yIGNzaVBhdGgiKTsKICAgICAgfQogICAgICB0aGlzLmNodW5rU2l6ZUxpbWl0ID0gY2h1bmtTaXplTGltaXQ7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgICAgdGhpcy55aWVsZFRpbWUgPSB5aWVsZFRpbWU7CiAgICAgIHRoaXMuY2h1bmtDYWNoZSA9IG5ldyBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUuZGVmYXVsdCh7CiAgICAgICAgY2FjaGU6IG5ldyBpbXBvcnRfcXVpY2tfbHJ1LmRlZmF1bHQoeyBtYXhTaXplOiBNYXRoLmZsb29yKGNodW5rQ2FjaGVTaXplIC8gKDEgPDwgMTYpKSB9KSwKICAgICAgICBmaWxsOiAoYXJncywgc2lnbmFsKSA9PiB0aGlzLnJlYWRDaHVuayhhcmdzLCB7IHNpZ25hbCB9KQogICAgICB9KTsKICAgIH0KICAgIGFzeW5jIGdldExpbmVzKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdHMpIHsKICAgICAgbGV0IHNpZ25hbDsKICAgICAgbGV0IG9wdGlvbnMgPSB7fTsKICAgICAgbGV0IGNhbGxiYWNrOwogICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIik7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvcHRzOwogICAgICB9IGVsc2UgewogICAgICAgIG9wdGlvbnMgPSBvcHRzOwogICAgICAgIGNhbGxiYWNrID0gb3B0cy5saW5lQ2FsbGJhY2s7CiAgICAgIH0KICAgICAgaWYgKHJlZk5hbWUgPT09IHZvaWQgMCkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm11c3QgcHJvdmlkZSBhIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lIik7CiAgICAgIH0KICAgICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImxpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCIpOwogICAgICB9CiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5pbmRleC5nZXRNZXRhZGF0YShvcHRpb25zKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICBpZiAoIXN0YXJ0KSB7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9CiAgICAgIGlmICghZW5kKSB7CiAgICAgICAgZW5kID0gbWV0YWRhdGEubWF4UmVmTGVuZ3RoOwogICAgICB9CiAgICAgIGlmICghKHN0YXJ0IDw9IGVuZCkpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMuIHN0YXJ0IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGVuZCIpOwogICAgICB9CiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBjb25zdCBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKCk7CiAgICAgICAgaWYgKHNpemUgPiB0aGlzLmNodW5rU2l6ZUxpbWl0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtdWNoIGRhdGEuIENodW5rIHNpemUgJHtzaXplLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzIGV4Y2VlZHMgY2h1bmtTaXplTGltaXQgb2YgJHt0aGlzLmNodW5rU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCl9LmApOwogICAgICAgIH0KICAgICAgfQogICAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7CiAgICAgIGZvciAobGV0IGNodW5rTnVtID0gMDsgY2h1bmtOdW0gPCBjaHVua3MubGVuZ3RoOyBjaHVua051bSArPSAxKSB7CiAgICAgICAgbGV0IHByZXZpb3VzU3RhcnRDb29yZGluYXRlOwogICAgICAgIGNvbnN0IGMgPSBjaHVua3NbY2h1bmtOdW1dOwogICAgICAgIGNvbnN0IHsgYnVmZmVyLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zIH0gPSBhd2FpdCB0aGlzLmNodW5rQ2FjaGUuZ2V0KGMudG9TdHJpbmcoKSwgYyk7CiAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgIGxldCBibG9ja1N0YXJ0ID0gMDsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCA8IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGNvbnN0IG4gPSBidWZmZXIuaW5kZXhPZigiXG4iLCBibG9ja1N0YXJ0KTsKICAgICAgICAgIGlmIChuID09PSAtMSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IGIgPSBidWZmZXIuc2xpY2UoYmxvY2tTdGFydCwgbik7CiAgICAgICAgICBjb25zdCBsaW5lID0gKGRlY29kZXIgPT09IG51bGwgfHwgZGVjb2RlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb2Rlci5kZWNvZGUoYikpIHx8IGIudG9TdHJpbmcoKTsKICAgICAgICAgIGlmIChkcG9zaXRpb25zKSB7CiAgICAgICAgICAgIHdoaWxlIChibG9ja1N0YXJ0ICsgYy5taW52LmRhdGFQb3NpdGlvbiA+PSBkcG9zaXRpb25zW3BvcysrXSkgewogICAgICAgICAgICB9CiAgICAgICAgICAgIHBvcy0tOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgeyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzIH0gPSB0aGlzLmNoZWNrTGluZShtZXRhZGF0YSwgcmVmTmFtZSwgc3RhcnQsIGVuZCwgbGluZSk7CiAgICAgICAgICBpZiAocHJldmlvdXNTdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA+IHN0YXJ0Q29vcmRpbmF0ZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVzIG5vdCBzb3J0ZWQgYnkgc3RhcnQgY29vcmRpbmF0ZSAoJHtwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZX0gPiAke3N0YXJ0Q29vcmRpbmF0ZX0pLCB0aGlzIGZpbGUgaXMgbm90IHVzYWJsZSB3aXRoIFRhYml4LmApOwogICAgICAgICAgfQogICAgICAgICAgcHJldmlvdXNTdGFydENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGU7CiAgICAgICAgICBpZiAob3ZlcmxhcHMpIHsKICAgICAgICAgICAgY2FsbGJhY2sobGluZS50cmltKCksIGNwb3NpdGlvbnNbcG9zXSAqICgxIDw8IDgpICsgKGJsb2NrU3RhcnQgLSBkcG9zaXRpb25zW3Bvc10pICsgYy5taW52LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgfSBlbHNlIGlmIChzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgPj0gZW5kKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLnlpZWxkVGltZSAmJiBsYXN0IC0gRGF0ZS5ub3coKSA+IHRoaXMueWllbGRUaW1lKSB7CiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpOwogICAgICAgICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMSk7CiAgICAgICAgICB9CiAgICAgICAgICBibG9ja1N0YXJ0ID0gbiArIDE7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBhc3luYyBnZXRNZXRhZGF0YShvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0cyk7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXJCdWZmZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgZmlyc3REYXRhTGluZSwgbWV0YUNoYXIsIG1heEJsb2NrU2l6ZSB9ID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGNvbnN0IG1heEZldGNoID0gKChmaXJzdERhdGFMaW5lID09PSBudWxsIHx8IGZpcnN0RGF0YUxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0RGF0YUxpbmUuYmxvY2tQb3NpdGlvbikgfHwgMCkgKyBtYXhCbG9ja1NpemU7CiAgICAgIGxldCBieXRlcyA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oMCwgbWF4RmV0Y2gsIG9wdHMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgdHJ5IHsKICAgICAgICBieXRlcyA9IGF3YWl0IHVuemlwKGJ5dGVzKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBkZWNvbXByZXNzaW5nIGJsb2NrICR7ZS5jb2RlfSBhdCAwIChsZW5ndGggJHttYXhGZXRjaH0pICR7ZX1gKTsKICAgICAgfQogICAgICBpZiAobWV0YUNoYXIpIHsKICAgICAgICBsZXQgbGFzdE5ld2xpbmUgPSAtMTsKICAgICAgICBjb25zdCBuZXdsaW5lQnl0ZSA9ICJcbiIuY2hhckNvZGVBdCgwKTsKICAgICAgICBjb25zdCBtZXRhQnl0ZSA9IG1ldGFDaGFyLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgaWYgKGkgPT09IGxhc3ROZXdsaW5lICsgMSAmJiBieXRlc1tpXSAhPT0gbWV0YUJ5dGUpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnl0ZXNbaV0gPT09IG5ld2xpbmVCeXRlKSB7CiAgICAgICAgICAgIGxhc3ROZXdsaW5lID0gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgwLCBsYXN0TmV3bGluZSArIDEpOwogICAgICB9CiAgICAgIHJldHVybiBieXRlczsKICAgIH0KICAgIGFzeW5jIGdldEhlYWRlcihvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmdldEhlYWRlckJ1ZmZlcihvcHRzKTsKICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCJ1dGY4Iik7CiAgICB9CiAgICBhc3luYyBnZXRSZWZlcmVuY2VTZXF1ZW5jZU5hbWVzKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIHJldHVybiBtZXRhZGF0YS5yZWZJZFRvTmFtZTsKICAgIH0KICAgIGNoZWNrTGluZShtZXRhZGF0YSwgcmVnaW9uUmVmTmFtZSwgcmVnaW9uU3RhcnQsIHJlZ2lvbkVuZCwgbGluZSkgewogICAgICBjb25zdCB7IGNvbHVtbk51bWJlcnMsIG1ldGFDaGFyLCBjb29yZGluYXRlVHlwZSwgZm9ybWF0IH0gPSBtZXRhZGF0YTsKICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBtZXRhQ2hhcikgewogICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICB9CiAgICAgIGxldCB7IHJlZiwgc3RhcnQsIGVuZCB9ID0gY29sdW1uTnVtYmVyczsKICAgICAgaWYgKCFyZWYpIHsKICAgICAgICByZWYgPSAwOwogICAgICB9CiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICBzdGFydCA9IDA7CiAgICAgIH0KICAgICAgaWYgKCFlbmQpIHsKICAgICAgICBlbmQgPSAwOwogICAgICB9CiAgICAgIGlmIChmb3JtYXQgPT09ICJWQ0YiKSB7CiAgICAgICAgZW5kID0gODsKICAgICAgfQogICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChyZWYsIHN0YXJ0LCBlbmQpOwogICAgICBsZXQgY3VycmVudENvbHVtbk51bWJlciA9IDE7CiAgICAgIGxldCBjdXJyZW50Q29sdW1uU3RhcnQgPSAwOwogICAgICBsZXQgcmVmU2VxID0gIiI7CiAgICAgIGxldCBzdGFydENvb3JkaW5hdGUgPSAtSW5maW5pdHk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGggKyAxOyBpICs9IDEpIHsKICAgICAgICBpZiAobGluZVtpXSA9PT0gIgkiIHx8IGkgPT09IGxpbmUubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gcmVmKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnJlbmFtZVJlZlNlcShsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpICE9PSByZWdpb25SZWZOYW1lKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMCk7CiAgICAgICAgICAgIGlmIChjb29yZGluYXRlVHlwZSA9PT0gIjEtYmFzZWQtY2xvc2VkIikgewogICAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSAtPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgPj0gcmVnaW9uRW5kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kID09PSAwIHx8IGVuZCA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlICsgMSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAiVkNGIiAmJiBjdXJyZW50Q29sdW1uTnVtYmVyID09PSA0KSB7CiAgICAgICAgICAgIHJlZlNlcSA9IGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gZW5kKSB7CiAgICAgICAgICAgIGxldCBlbmRDb29yZGluYXRlOwogICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSB0aGlzLl9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlbmRDb29yZGluYXRlIDw9IHJlZ2lvblN0YXJ0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGN1cnJlbnRDb2x1bW5TdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VycmVudENvbHVtbk51bWJlciArPSAxOwogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPiBtYXhDb2x1bW4pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IHRydWUgfTsKICAgIH0KICAgIF9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGluZm8pIHsKICAgICAgbGV0IGVuZENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGUgKyByZWZTZXEubGVuZ3RoOwogICAgICBjb25zdCBpc1RSQSA9IGluZm8uaW5kZXhPZigiU1ZUWVBFPVRSQSIpICE9PSAtMTsKICAgICAgaWYgKGluZm9bMF0gIT09ICIuIiAmJiAhaXNUUkEpIHsKICAgICAgICBsZXQgcHJldkNoYXIgPSAiOyI7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLmxlbmd0aDsgaiArPSAxKSB7CiAgICAgICAgICBpZiAocHJldkNoYXIgPT09ICI7IiAmJiBpbmZvLnNsaWNlKGosIGogKyA0KSA9PT0gIkVORD0iKSB7CiAgICAgICAgICAgIGxldCB2YWx1ZUVuZCA9IGluZm8uaW5kZXhPZigiOyIsIGopOwogICAgICAgICAgICBpZiAodmFsdWVFbmQgPT09IC0xKSB7CiAgICAgICAgICAgICAgdmFsdWVFbmQgPSBpbmZvLmxlbmd0aDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQoaW5mby5zbGljZShqICsgNCwgdmFsdWVFbmQpLCAxMCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcHJldkNoYXIgPSBpbmZvW2pdOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc1RSQSkgewogICAgICAgIHJldHVybiBzdGFydENvb3JkaW5hdGUgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBlbmRDb29yZGluYXRlOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmTmFtZSwgb3B0cyk7CiAgICB9CiAgICBhc3luYyBfcmVhZFJlZ2lvbihwb3MsIHNpemUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBiID0gaW1wb3J0X2J1ZmZlcjcuQnVmZmVyLmFsbG9jKHNpemUpOwogICAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZChiLCAwLCBzaXplLCBwb3MsIG9wdHMpOwogICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzUmVhZCk7CiAgICB9CiAgICBhc3luYyByZWFkQ2h1bmsoYywgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKGMubWludi5ibG9ja1Bvc2l0aW9uLCBjLmZldGNoZWRTaXplKCksIG9wdHMpOwogICAgICB0cnkgewogICAgICAgIHJldHVybiB1bnppcENodW5rU2xpY2UoZGF0YSwgYyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgYyAke2MudG9TdHJpbmcoKX0gJHtlfWApOwogICAgICB9CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3ZjZi9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC92Y2YvZXNtL3BhcnNlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdmNmL2VzbS92Y2ZSZXNlcnZlZC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgdmNmUmVzZXJ2ZWRfZGVmYXVsdCA9IHsKICAgIEluZm9GaWVsZHM6IHsKICAgICAgQUE6IHsgTnVtYmVyOiAxLCBUeXBlOiAiU3RyaW5nIiwgRGVzY3JpcHRpb246ICJBbmNlc3RyYWwgYWxsZWxlIiB9LAogICAgICBBQzogewogICAgICAgIE51bWJlcjogIkEiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkFsbGVsZSBjb3VudCBpbiBnZW5vdHlwZXMsIGZvciBlYWNoIEFMVCBhbGxlbGUsIGluIHRoZSBzYW1lIG9yZGVyIGFzIGxpc3RlZCIKICAgICAgfSwKICAgICAgQUQ6IHsKICAgICAgICBOdW1iZXI6ICJSIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJUb3RhbCByZWFkIGRlcHRoIGZvciBlYWNoIGFsbGVsZSIKICAgICAgfSwKICAgICAgQURGOiB7CiAgICAgICAgTnVtYmVyOiAiUiIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUmVhZCBkZXB0aCBmb3IgZWFjaCBhbGxlbGUgb24gdGhlIGZvcndhcmQgc3RyYW5kIgogICAgICB9LAogICAgICBBRFI6IHsKICAgICAgICBOdW1iZXI6ICJSIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSZWFkIGRlcHRoIGZvciBlYWNoIGFsbGVsZSBvbiB0aGUgcmV2ZXJzZSBzdHJhbmQiCiAgICAgIH0sCiAgICAgIEFGOiB7CiAgICAgICAgTnVtYmVyOiAiQSIsCiAgICAgICAgVHlwZTogIkZsb2F0IiwKICAgICAgICBEZXNjcmlwdGlvbjogIkFsbGVsZSBmcmVxdWVuY3kgZm9yIGVhY2ggQUxUIGFsbGVsZSBpbiB0aGUgc2FtZSBvcmRlciBhcyBsaXN0ZWQgKGVzdGltYXRlZCBmcm9tIHByaW1hcnkgZGF0YSwgbm90IGNhbGxlZCBnZW5vdHlwZXMpIgogICAgICB9LAogICAgICBBTjogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJUb3RhbCBudW1iZXIgb2YgYWxsZWxlcyBpbiBjYWxsZWQgZ2Vub3R5cGVzIgogICAgICB9LAogICAgICBCUTogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiRmxvYXQiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUk1TIGJhc2UgcXVhbGl0eSIKICAgICAgfSwKICAgICAgQ0lHQVI6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkZsb2F0IiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNpZ2FyIHN0cmluZyBkZXNjcmliaW5nIGhvdyB0byBhbGlnbiBhbiBhbHRlcm5hdGUgYWxsZWxlIHRvIHRoZSByZWZlcmVuY2UgYWxsZWxlIgogICAgICB9LAogICAgICBEQjogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJkYlNOUCBtZW1iZXJzaGlwIgogICAgICB9LAogICAgICBEUDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJjb21iaW5lZCBkZXB0aCBhY3Jvc3Mgc2FtcGxlcyIKICAgICAgfSwKICAgICAgRU5EOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkVuZCBwb3NpdGlvbiAoZm9yIHVzZSB3aXRoIHN5bWJvbGljIGFsbGVsZXMpIgogICAgICB9LAogICAgICBIMjogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJIYXBNYXAyIG1lbWJlcnNoaXAiCiAgICAgIH0sCiAgICAgIEgzOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkhhcE1hcDMgbWVtYmVyc2hpcCIKICAgICAgfSwKICAgICAgTVE6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogbnVsbCwKICAgICAgICBEZXNjcmlwdGlvbjogIlJNUyBtYXBwaW5nIHF1YWxpdHkiCiAgICAgIH0sCiAgICAgIE1RMDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJOdW1iZXIgb2YgTUFQUSA9PSAwIHJlYWRzIgogICAgICB9LAogICAgICBOUzogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJOdW1iZXIgb2Ygc2FtcGxlcyB3aXRoIGRhdGEiCiAgICAgIH0sCiAgICAgIFNCOiB7CiAgICAgICAgTnVtYmVyOiA0LAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlN0cmFuZCBiaWFzIgogICAgICB9LAogICAgICBTT01BVElDOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlNvbWF0aWMgbXV0YXRpb24gKGZvciBjYW5jZXIgZ2Vub21pY3MpIgogICAgICB9LAogICAgICBWQUxJREFURUQ6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiVmFsaWRhdGVkIGJ5IGZvbGxvdy11cCBleHBlcmltZW50IgogICAgICB9LAogICAgICAiMTAwMEciOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIjEwMDAgR2Vub21lcyBtZW1iZXJzaGlwIgogICAgICB9LAogICAgICBJTVBSRUNJU0U6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSW1wcmVjaXNlIHN0cnVjdHVyYWwgdmFyaWF0aW9uIgogICAgICB9LAogICAgICBOT1ZFTDogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJbmRpY2F0ZXMgYSBub3ZlbCBzdHJ1Y3R1cmFsIHZhcmlhdGlvbiIKICAgICAgfSwKICAgICAgU1ZUWVBFOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiVHlwZSBvZiBzdHJ1Y3R1cmFsIHZhcmlhbnQiCiAgICAgIH0sCiAgICAgIFNWTEVOOiB7CiAgICAgICAgTnVtYmVyOiBudWxsLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkRpZmZlcmVuY2UgaW4gbGVuZ3RoIGJldHdlZW4gUkVGIGFuZCBBTFQgYWxsZWxlcyIKICAgICAgfSwKICAgICAgQ0lQT1M6IHsKICAgICAgICBOdW1iZXI6IDIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29uZmlkZW5jZSBpbnRlcnZhbCBhcm91bmQgUE9TIGZvciBpbXByZWNpc2UgdmFyaWFudHMiCiAgICAgIH0sCiAgICAgIENJRU5EOiB7CiAgICAgICAgTnVtYmVyOiAyLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvbmZpZGVuY2UgaW50ZXJ2YWwgYXJvdW5kIEVORCBmb3IgaW1wcmVjaXNlIHZhcmlhbnRzIgogICAgICB9LAogICAgICBIT01MRU46IHsKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJMZW5ndGggb2YgYmFzZSBwYWlyIGlkZW50aWNhbCBtaWNyby1ob21vbG9neSBhdCBldmVudCBicmVha3BvaW50cyIKICAgICAgfSwKICAgICAgSE9NU0VROiB7CiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJTZXF1ZW5jZSBvZiBiYXNlIHBhaXIgaWRlbnRpY2FsIG1pY3JvLWhvbW9sb2d5IGF0IGV2ZW50IGJyZWFrcG9pbnRzIgogICAgICB9LAogICAgICBCS1BUSUQ6IHsKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIHRoZSBhc3NlbWJsZWQgYWx0ZXJuYXRlIGFsbGVsZSBpbiB0aGUgYXNzZW1ibHkgZmlsZSIKICAgICAgfSwKICAgICAgTUVJTkZPOiB7CiAgICAgICAgTnVtYmVyOiA0LAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiTW9iaWxlIGVsZW1lbnQgaW5mbyBvZiB0aGUgZm9ybSBOQU1FLFNUQVJULEVORCxQT0xBUklUWSIKICAgICAgfSwKICAgICAgTUVUUkFOUzogewogICAgICAgIE51bWJlcjogNCwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIk1vYmlsZSBlbGVtZW50IHRyYW5zZHVjdGlvbiBpbmZvIG9mIHRoZSBmb3JtIENIUixTVEFSVCxFTkQsUE9MQVJJVFkiCiAgICAgIH0sCiAgICAgIERHVklEOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgdGhpcyBlbGVtZW50IGluIERhdGFiYXNlIG9mIEdlbm9taWMgVmFyaWF0aW9uIgogICAgICB9LAogICAgICBEQlZBUklEOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgdGhpcyBlbGVtZW50IGluIERCVkFSIgogICAgICB9LAogICAgICBEQlJJUElEOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgdGhpcyBlbGVtZW50IGluIERCUklQIgogICAgICB9LAogICAgICBNQVRFSUQ6IHsKICAgICAgICBOdW1iZXI6IG51bGwsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiBtYXRlIGJyZWFrZW5kcyIKICAgICAgfSwKICAgICAgUEFSSUQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiBwYXJ0bmVyIGJyZWFrZW5kIgogICAgICB9LAogICAgICBFVkVOVDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIGV2ZW50IGFzc29jaWF0ZWQgdG8gYnJlYWtlbmQiCiAgICAgIH0sCiAgICAgIENJTEVOOiB7CiAgICAgICAgTnVtYmVyOiAyLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvbmZpZGVuY2UgaW50ZXJ2YWwgYXJvdW5kIHRoZSBpbnNlcnRlZCBtYXRlcmlhbCBiZXR3ZWVuIGJyZWFrZW5kIgogICAgICB9LAogICAgICBEUEFESjogeyBUeXBlOiAiSW50ZWdlciIsIERlc2NyaXB0aW9uOiAiUmVhZCBEZXB0aCBvZiBhZGphY2VuY3kiIH0sCiAgICAgIENOOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvcHkgbnVtYmVyIG9mIHNlZ21lbnQgY29udGFpbmluZyBicmVha2VuZCIKICAgICAgfSwKICAgICAgQ05BREo6IHsKICAgICAgICBOdW1iZXI6IG51bGwsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29weSBudW1iZXIgb2YgYWRqYWNlbmN5IgogICAgICB9LAogICAgICBDSUNOOiB7CiAgICAgICAgTnVtYmVyOiAyLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvbmZpZGVuY2UgaW50ZXJ2YWwgYXJvdW5kIGNvcHkgbnVtYmVyIGZvciB0aGUgc2VnbWVudCIKICAgICAgfSwKICAgICAgQ0lDTkFESjogewogICAgICAgIE51bWJlcjogbnVsbCwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb25maWRlbmNlIGludGVydmFsIGFyb3VuZCBjb3B5IG51bWJlciBmb3IgdGhlIGFkamFjZW5jeSIKICAgICAgfQogICAgfSwKICAgIEdlbm90eXBlRmllbGRzOiB7CiAgICAgIEFEOiB7CiAgICAgICAgTnVtYmVyOiAiUiIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUmVhZCBkZXB0aCBmb3IgZWFjaCBhbGxlbGUiCiAgICAgIH0sCiAgICAgIEFERjogewogICAgICAgIE51bWJlcjogIlIiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJlYWQgZGVwdGggZm9yIGVhY2ggYWxsZWxlIG9uIHRoZSBmb3J3YXJkIHN0cmFuZCIKICAgICAgfSwKICAgICAgQURSOiB7CiAgICAgICAgTnVtYmVyOiAiUiIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUmVhZCBkZXB0aCBmb3IgZWFjaCBhbGxlbGUgb24gdGhlIHJldmVyc2Ugc3RyYW5kIgogICAgICB9LAogICAgICBEUDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSZWFkIGRlcHRoIgogICAgICB9LAogICAgICBFQzogewogICAgICAgIE51bWJlcjogIkEiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkV4cGVjdGVkIGFsdGVybmF0ZSBhbGxlbGUgY291bnRzIgogICAgICB9LAogICAgICBGVDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogJ0ZpbHRlciBpbmRpY2F0aW5nIGlmIHRoaXMgZ2Vub3R5cGUgd2FzICJjYWxsZWQiJwogICAgICB9LAogICAgICBHTDogewogICAgICAgIE51bWJlcjogIkciLAogICAgICAgIFR5cGU6ICJGbG9hdCIsCiAgICAgICAgRGVzY3JpcHRpb246ICJHZW5vdHlwZSBsaWtlbGlob29kcyIKICAgICAgfSwKICAgICAgR1A6IHsKICAgICAgICBOdW1iZXI6ICJHIiwKICAgICAgICBUeXBlOiAiRmxvYXQiLAogICAgICAgIERlc2NyaXB0aW9uOiAiR2Vub3R5cGUgcG9zdGVyaW9yIHByb2JhYmlsaXRpZXMiCiAgICAgIH0sCiAgICAgIEdROiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvbmRpdGlvbmFsIGdlbm90eXBlIHF1YWxpdHkiCiAgICAgIH0sCiAgICAgIEdUOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiR2Vub3R5cGUiCiAgICAgIH0sCiAgICAgIEhROiB7CiAgICAgICAgTnVtYmVyOiAyLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkhhcGxvdHlwZSBxdWFsaXR5IgogICAgICB9LAogICAgICBNUTogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSTVMgbWFwcGluZyBxdWFsaXR5IgogICAgICB9LAogICAgICBQTDogewogICAgICAgIE51bWJlcjogIkciLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlBocmVkLXNjYWxlZCBnZW5vdHlwZSBsaWtlbGlob29kcyByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IGludGVnZXIiCiAgICAgIH0sCiAgICAgIFBROiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlBoYXNpbmcgcXVhbGl0eSIKICAgICAgfSwKICAgICAgUFM6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUGhhc2Ugc2V0IgogICAgICB9CiAgICB9LAogICAgQWx0VHlwZXM6IHsKICAgICAgREVMOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJEZWxldGlvbiByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIgogICAgICB9LAogICAgICBJTlM6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIkluc2VydGlvbiBvZiBub3ZlbCBzZXF1ZW5jZSByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIgogICAgICB9LAogICAgICBEVVA6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIlJlZ2lvbiBvZiBlbGV2YXRlZCBjb3B5IG51bWJlciByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIgogICAgICB9LAogICAgICBJTlY6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIkludmVyc2lvbiBvZiByZWZlcmVuY2Ugc2VxdWVuY2UiCiAgICAgIH0sCiAgICAgIENOVjogewogICAgICAgIERlc2NyaXB0aW9uOiAiQ29weSBudW1iZXIgdmFyaWFibGUgcmVnaW9uIChtYXkgYmUgYm90aCBkZWxldGlvbiBhbmQgZHVwbGljYXRpb24pIgogICAgICB9LAogICAgICAiRFVQOlRBTkRFTSI6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIlRhbmRlbSBkdXBsaWNhdGlvbiIKICAgICAgfSwKICAgICAgIkRFTDpNRSI6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIkRlbGV0aW9uIG9mIG1vYmlsZSBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UiCiAgICAgIH0sCiAgICAgICJJTlM6TUUiOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJJbnNlcnRpb24gb2YgYSBtb2JpbGUgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIgogICAgICB9LAogICAgICBOT05fUkVGOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJSZXByZXNlbnRzIGFueSBwb3NzaWJsZSBhbHRlcm5hdGl2ZSBhbGxlbGUgYXQgdGhpcyBsb2NhdGlvbiIKICAgICAgfSwKICAgICAgIioiOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJSZXByZXNlbnRzIGFueSBwb3NzaWJsZSBhbHRlcm5hdGl2ZSBhbGxlbGUgYXQgdGhpcyBsb2NhdGlvbiIKICAgICAgfQogICAgfSwKICAgIEZpbHRlclR5cGVzOiB7CiAgICAgIFBBU1M6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIlBhc3NlZCBhbGwgZmlsdGVycyIKICAgICAgfQogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC92Y2YvZXNtL3BhcnNlLmpzCiAgZnVuY3Rpb24gVmFyaWFudChzdHVmZikgewogICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzdHVmZik7CiAgfQogIGZ1bmN0aW9uIGRlY29kZVVSSUNvbXBvbmVudE5vVGhyb3codXJpKSB7CiAgICB0cnkgewogICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHVyaSk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHJldHVybiB1cmk7CiAgICB9CiAgfQogIHZhciBWQ0YgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IGhlYWRlciA9ICIiLCBzdHJpY3QgPSB0cnVlIH0pIHsKICAgICAgaWYgKCFoZWFkZXIgfHwgIWhlYWRlci5sZW5ndGgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImVtcHR5IGhlYWRlciByZWNlaXZlZCIpOwogICAgICB9CiAgICAgIGNvbnN0IGhlYWRlckxpbmVzID0gaGVhZGVyLnNwbGl0KC9bXHJcbl0rLykuZmlsdGVyKChsaW5lKSA9PiBsaW5lKTsKICAgICAgaWYgKCFoZWFkZXJMaW5lcy5sZW5ndGgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIm5vIG5vbi1lbXB0eSBoZWFkZXIgbGluZXMgc3BlY2lmaWVkIik7CiAgICAgIH0KICAgICAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7CiAgICAgIHRoaXMubWV0YWRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHsKICAgICAgICBJTkZPOiB2Y2ZSZXNlcnZlZF9kZWZhdWx0LkluZm9GaWVsZHMsCiAgICAgICAgRk9STUFUOiB2Y2ZSZXNlcnZlZF9kZWZhdWx0Lkdlbm90eXBlRmllbGRzLAogICAgICAgIEFMVDogdmNmUmVzZXJ2ZWRfZGVmYXVsdC5BbHRUeXBlcywKICAgICAgICBGSUxURVI6IHZjZlJlc2VydmVkX2RlZmF1bHQuRmlsdGVyVHlwZXMKICAgICAgfSkpOwogICAgICBsZXQgbGFzdExpbmU7CiAgICAgIGhlYWRlckxpbmVzLmZvckVhY2goKGxpbmUpID0+IHsKICAgICAgICBpZiAoIWxpbmUuc3RhcnRzV2l0aCgiIyIpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBsaW5lIGluIGhlYWRlcjoKJHtsaW5lfWApOwogICAgICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKCIjIyIpKSB7CiAgICAgICAgICB0aGlzLl9wYXJzZU1ldGFkYXRhKGxpbmUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsYXN0TGluZSA9IGxpbmU7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKCFsYXN0TGluZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTm8gZm9ybWF0IGxpbmUgZm91bmQgaW4gaGVhZGVyIik7CiAgICAgIH0KICAgICAgY29uc3QgZmllbGRzID0gbGFzdExpbmUudHJpbSgpLnNwbGl0KCIJIik7CiAgICAgIGNvbnN0IHRoaXNIZWFkZXIgPSBmaWVsZHMuc2xpY2UoMCwgOCk7CiAgICAgIGNvbnN0IGNvcnJlY3RIZWFkZXIgPSBbCiAgICAgICAgIiNDSFJPTSIsCiAgICAgICAgIlBPUyIsCiAgICAgICAgIklEIiwKICAgICAgICAiUkVGIiwKICAgICAgICAiQUxUIiwKICAgICAgICAiUVVBTCIsCiAgICAgICAgIkZJTFRFUiIsCiAgICAgICAgIklORk8iCiAgICAgIF07CiAgICAgIGlmIChmaWVsZHMubGVuZ3RoIDwgOCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgVkNGIGhlYWRlciBtaXNzaW5nIGNvbHVtbnM6CiR7bGFzdExpbmV9YCk7CiAgICAgIH0gZWxzZSBpZiAodGhpc0hlYWRlci5sZW5ndGggIT09IGNvcnJlY3RIZWFkZXIubGVuZ3RoIHx8ICF0aGlzSGVhZGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBjb3JyZWN0SGVhZGVyW2luZGV4XSkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZDRiBjb2x1bW4gaGVhZGVycyBub3QgY29ycmVjdDoKJHtsYXN0TGluZX1gKTsKICAgICAgfQogICAgICB0aGlzLnNhbXBsZXMgPSBmaWVsZHMuc2xpY2UoOSk7CiAgICB9CiAgICBfcGFyc2VHZW5vdHlwZXMoZm9ybWF0LCBwcmVyZXN0KSB7CiAgICAgIGNvbnN0IHJlc3QgPSBwcmVyZXN0LnNwbGl0KCIJIik7CiAgICAgIGNvbnN0IGdlbm90eXBlcyA9IHt9OwogICAgICBjb25zdCBmb3JtYXRLZXlzID0gZm9ybWF0ID09PSBudWxsIHx8IGZvcm1hdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0LnNwbGl0KCI6Iik7CiAgICAgIGlmIChmb3JtYXRLZXlzKSB7CiAgICAgICAgdGhpcy5zYW1wbGVzLmZvckVhY2goKHNhbXBsZSwgaW5kZXgpID0+IHsKICAgICAgICAgIGdlbm90eXBlc1tzYW1wbGVdID0ge307CiAgICAgICAgICBmb3JtYXRLZXlzLmZvckVhY2goKGtleSkgPT4gewogICAgICAgICAgICBnZW5vdHlwZXNbc2FtcGxlXVtrZXldID0gbnVsbDsKICAgICAgICAgIH0pOwogICAgICAgICAgcmVzdFtpbmRleF0uc3BsaXQoIjoiKS5maWx0ZXIoKGYpID0+IGYpLmZvckVhY2goKHZhbCwgaW5kZXgyKSA9PiB7CiAgICAgICAgICAgIGxldCB0aGlzVmFsdWU7CiAgICAgICAgICAgIGlmICh2YWwgPT09ICIiIHx8IHZhbCA9PT0gIi4iIHx8IHZhbCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgdGhpc1ZhbHVlID0gbnVsbDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gdmFsLnNwbGl0KCIsIikubWFwKChlbnQpID0+IGVudCA9PT0gIi4iID8gbnVsbCA6IGVudCk7CiAgICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5nZXRNZXRhZGF0YSgiRk9STUFUIiwgZm9ybWF0S2V5c1tpbmRleDJdLCAiVHlwZSIpOwogICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICJJbnRlZ2VyIiB8fCB2YWx1ZVR5cGUgPT09ICJGbG9hdCIpIHsKICAgICAgICAgICAgICAgIHRoaXNWYWx1ZSA9IGVudHJpZXMubWFwKCh2YWwyKSA9PiB2YWwyID8gK3ZhbDIgOiB2YWwyKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpc1ZhbHVlID0gZW50cmllczsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZ2Vub3R5cGVzW3NhbXBsZV1bZm9ybWF0S2V5c1tpbmRleDJdXSA9IHRoaXNWYWx1ZTsKICAgICAgICAgIH0sIHt9KTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gZ2Vub3R5cGVzOwogICAgfQogICAgX3BhcnNlTWV0YWRhdGEobGluZSkgewogICAgICBjb25zdCBtYXRjaCA9IGxpbmUudHJpbSgpLm1hdGNoKC9eIyMoLis/KT0oLiopLyk7CiAgICAgIGlmICghbWF0Y2gpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmUgaXMgbm90IGEgdmFsaWQgbWV0YWRhdGEgbGluZTogJHtsaW5lfWApOwogICAgICB9CiAgICAgIGNvbnN0IFttZXRhS2V5LCBtZXRhVmFsXSA9IG1hdGNoLnNsaWNlKDEsIDMpOwogICAgICBpZiAobWV0YVZhbC5zdGFydHNXaXRoKCI8IikpIHsKICAgICAgICBpZiAoIShtZXRhS2V5IGluIHRoaXMubWV0YWRhdGEpKSB7CiAgICAgICAgICB0aGlzLm1ldGFkYXRhW21ldGFLZXldID0ge307CiAgICAgICAgfQogICAgICAgIGNvbnN0IFtpZCwga2V5VmFsc10gPSB0aGlzLl9wYXJzZVN0cnVjdHVyZWRNZXRhVmFsKG1ldGFWYWwpOwogICAgICAgIHRoaXMubWV0YWRhdGFbbWV0YUtleV1baWRdID0ga2V5VmFsczsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLm1ldGFkYXRhW21ldGFLZXldID0gbWV0YVZhbDsKICAgICAgfQogICAgfQogICAgX3BhcnNlU3RydWN0dXJlZE1ldGFWYWwobWV0YVZhbCkgewogICAgICBjb25zdCBrZXlWYWxzID0gdGhpcy5fcGFyc2VLZXlWYWx1ZShtZXRhVmFsLnJlcGxhY2UoL148fD4kL2csICIiKSwgIiwiKTsKICAgICAgY29uc3QgaWQgPSBrZXlWYWxzLklEOwogICAgICBkZWxldGUga2V5VmFscy5JRDsKICAgICAgaWYgKCJOdW1iZXIiIGluIGtleVZhbHMpIHsKICAgICAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIoa2V5VmFscy5OdW1iZXIpKSkgewogICAgICAgICAga2V5VmFscy5OdW1iZXIgPSBOdW1iZXIoa2V5VmFscy5OdW1iZXIpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gW2lkLCBrZXlWYWxzXTsKICAgIH0KICAgIGdldE1ldGFkYXRhKC4uLmFyZ3MpIHsKICAgICAgbGV0IGZpbHRlcmVkTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBmaWx0ZXJlZE1ldGFkYXRhID0gZmlsdGVyZWRNZXRhZGF0YVthcmdzW2ldXTsKICAgICAgICBpZiAoIWZpbHRlcmVkTWV0YWRhdGEpIHsKICAgICAgICAgIHJldHVybiBmaWx0ZXJlZE1ldGFkYXRhOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gZmlsdGVyZWRNZXRhZGF0YTsKICAgIH0KICAgIF9wYXJzZUtleVZhbHVlKHN0ciwgcGFpclNlcGFyYXRvciA9ICI7IikgewogICAgICBjb25zdCBkYXRhID0ge307CiAgICAgIGxldCBjdXJyS2V5ID0gIiI7CiAgICAgIGxldCBjdXJyVmFsdWUgPSAiIjsKICAgICAgbGV0IHN0YXRlID0gMTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHsKICAgICAgICAgIGlmIChzdHJbaV0gPT09ICI9IikgewogICAgICAgICAgICBzdGF0ZSA9IDI7CiAgICAgICAgICB9IGVsc2UgaWYgKHN0cltpXSAhPT0gcGFpclNlcGFyYXRvcikgewogICAgICAgICAgICBjdXJyS2V5ICs9IHN0cltpXTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VyclZhbHVlID09PSAiIikgewogICAgICAgICAgICBkYXRhW2N1cnJLZXldID0gbnVsbDsKICAgICAgICAgICAgY3VycktleSA9ICIiOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IDIpIHsKICAgICAgICAgIGlmIChzdHJbaV0gPT09IHBhaXJTZXBhcmF0b3IpIHsKICAgICAgICAgICAgZGF0YVtjdXJyS2V5XSA9IGN1cnJWYWx1ZTsKICAgICAgICAgICAgY3VycktleSA9ICIiOwogICAgICAgICAgICBjdXJyVmFsdWUgPSAiIjsKICAgICAgICAgICAgc3RhdGUgPSAxOwogICAgICAgICAgfSBlbHNlIGlmIChzdHJbaV0gPT09ICciJykgewogICAgICAgICAgICBzdGF0ZSA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjdXJyVmFsdWUgKz0gc3RyW2ldOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IDMpIHsKICAgICAgICAgIGlmIChzdHJbaV0gIT09ICciJykgewogICAgICAgICAgICBjdXJyVmFsdWUgKz0gc3RyW2ldOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3RhdGUgPSAyOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoc3RhdGUgPT09IDIgfHwgc3RhdGUgPT09IDMpIHsKICAgICAgICBkYXRhW2N1cnJLZXldID0gY3VyclZhbHVlOwogICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAxKSB7CiAgICAgICAgZGF0YVtjdXJyS2V5XSA9IG51bGw7CiAgICAgIH0KICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CiAgICBwYXJzZUxpbmUobGluZSkgewogICAgICBsaW5lID0gbGluZS50cmltKCk7CiAgICAgIGlmICghbGluZS5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICB9CiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7CiAgICAgIGxldCBjdXJyQ2hhciA9IDA7CiAgICAgIGZvciAobGV0IGN1cnJGaWVsZCA9IDA7IGN1cnJDaGFyIDwgbGluZS5sZW5ndGg7IGN1cnJDaGFyICs9IDEpIHsKICAgICAgICBpZiAobGluZVtjdXJyQ2hhcl0gPT09ICIJIikgewogICAgICAgICAgY3VyckZpZWxkICs9IDE7CiAgICAgICAgfQogICAgICAgIGlmIChjdXJyRmllbGQgPT09IDkpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBmaWVsZHMgPSBsaW5lLnN1YnN0cigwLCBjdXJyQ2hhcikuc3BsaXQoIgkiKTsKICAgICAgY29uc3QgcmVzdCA9IGxpbmUuc3Vic3RyKGN1cnJDaGFyICsgMSk7CiAgICAgIGNvbnN0IFtDSFJPTSwgUE9TLCBJRCwgUkVGLCBBTFQsIFFVQUwsIEZJTFRFUl0gPSBmaWVsZHM7CiAgICAgIGNvbnN0IGNocm9tID0gQ0hST007CiAgICAgIGNvbnN0IHBvcyA9ICtQT1M7CiAgICAgIGNvbnN0IGlkID0gSUQgPT09ICIuIiA/IG51bGwgOiBJRC5zcGxpdCgiOyIpOwogICAgICBjb25zdCByZWYgPSBSRUY7CiAgICAgIGNvbnN0IGFsdCA9IEFMVCA9PT0gIi4iID8gbnVsbCA6IEFMVC5zcGxpdCgiLCIpOwogICAgICBjb25zdCBxdWFsID0gUVVBTCA9PT0gIi4iID8gbnVsbCA6ICtRVUFMOwogICAgICBjb25zdCBmaWx0ZXIgPSBGSUxURVIgPT09ICIuIiA/IG51bGwgOiBGSUxURVIuc3BsaXQoIjsiKTsKICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIGZpZWxkc1s3XSA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJubyBJTkZPIGZpZWxkIHNwZWNpZmllZCwgbXVzdCBjb250YWluIGF0IGxlYXN0IGEgJy4nICh0dXJuIG9mZiBzdHJpY3QgbW9kZSB0byBhbGxvdykiKTsKICAgICAgfQogICAgICBjb25zdCBpbmZvID0gZmllbGRzWzddID09PSB2b2lkIDAgfHwgZmllbGRzWzddID09PSAiLiIgPyB7fSA6IHRoaXMuX3BhcnNlS2V5VmFsdWUoZmllbGRzWzddKTsKICAgICAgT2JqZWN0LmtleXMoaW5mbykuZm9yRWFjaCgoa2V5KSA9PiB7CiAgICAgICAgbGV0IGl0ZW1zOwogICAgICAgIGlmIChpbmZvW2tleV0pIHsKICAgICAgICAgIGl0ZW1zID0gaW5mb1trZXldLnNwbGl0KCIsIikubWFwKCh2YWwpID0+IHZhbCA9PT0gIi4iID8gbnVsbCA6IHZhbCkubWFwKChmKSA9PiBmID8gZGVjb2RlVVJJQ29tcG9uZW50Tm9UaHJvdyhmKSA6IGYpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpdGVtcyA9IGluZm9ba2V5XTsKICAgICAgICB9CiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB0aGlzLmdldE1ldGFkYXRhKCJJTkZPIiwga2V5LCAiVHlwZSIpOwogICAgICAgIGlmIChpdGVtVHlwZSkgewogICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAiSW50ZWdlciIgfHwgaXRlbVR5cGUgPT09ICJGbG9hdCIpIHsKICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5tYXAoKHZhbCkgPT4gewogICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHsKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChpdGVtVHlwZSA9PT0gIkZsYWciKSB7CiAgICAgICAgICAgIGlmIChpbmZvW2tleV0pIHsKICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEluZm8gZmllbGQgJHtrZXl9IGlzIGEgRmxhZyBhbmQgc2hvdWxkIG5vdCBoYXZlIGEgdmFsdWUgKGdvdCB2YWx1ZSAke2luZm9ba2V5XX0pYCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaXRlbXMgPSB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGluZm9ba2V5XSA9IGl0ZW1zOwogICAgICB9KTsKICAgICAgY29uc3QgdmFyaWFudCA9IG5ldyBWYXJpYW50KHsKICAgICAgICBDSFJPTTogY2hyb20sCiAgICAgICAgUE9TOiBwb3MsCiAgICAgICAgQUxUOiBhbHQsCiAgICAgICAgSU5GTzogaW5mbywKICAgICAgICBSRUY6IHJlZiwKICAgICAgICBGSUxURVI6IGZpbHRlciAmJiBmaWx0ZXIubGVuZ3RoID09PSAxICYmIGZpbHRlclswXSA9PT0gIlBBU1MiID8gIlBBU1MiIDogZmlsdGVyLAogICAgICAgIElEOiBpZCwKICAgICAgICBRVUFMOiBxdWFsCiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFyaWFudCwgIlNBTVBMRVMiLCB7CiAgICAgICAgZ2V0KCkgewogICAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHBhcnNlci5fcGFyc2VHZW5vdHlwZXMoZmllbGRzWzhdLCByZXN0KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiU0FNUExFUyIsIHsKICAgICAgICAgICAgdmFsdWU6IHNhbXBsZXMsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIHNhbXBsZXM7CiAgICAgICAgfSwKICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgfSk7CiAgICAgIHJldHVybiB2YXJpYW50OwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC92Y2YvZXNtL2luZGV4LmpzCiAgdmFyIGVzbV9kZWZhdWx0ID0gVkNGOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy93b3JrZXIubWpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfd29ya2VyID0gX190b01vZHVsZShyZXF1aXJlX3dvcmtlcigpKTsKICB2YXIgZXhwb3NlID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LmV4cG9zZTsKICB2YXIgcmVnaXN0ZXJTZXJpYWxpemVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LnJlZ2lzdGVyU2VyaWFsaXplcjsKICB2YXIgVHJhbnNmZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuVHJhbnNmZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbG9kYXNoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsOwogIHZhciBmcmVlR2xvYmFsX2RlZmF1bHQgPSBmcmVlR2xvYmFsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gIm9iamVjdCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsX2RlZmF1bHQgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICB2YXIgcm9vdF9kZWZhdWx0ID0gcm9vdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzCiAgdmFyIFN5bWJvbDIgPSByb290X2RlZmF1bHQuU3ltYm9sOwogIHZhciBTeW1ib2xfZGVmYXVsdCA9IFN5bWJvbDI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5OwogIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nOwogIHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbF9kZWZhdWx0ID8gU3ltYm9sX2RlZmF1bHQudG9TdHJpbmdUYWcgOiB2b2lkIDA7CiAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7CiAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgIHRyeSB7CiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHZvaWQgMDsKICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgIH0KICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTsKICAgIGlmICh1bm1hc2tlZCkgewogICAgICBpZiAoaXNPd24pIHsKICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGdldFJhd1RhZ19kZWZhdWx0ID0gZ2V0UmF3VGFnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8yID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nOwogIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcyLmNhbGwodmFsdWUpOwogIH0KICB2YXIgb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgdmFyIG51bGxUYWcgPSAiW29iamVjdCBOdWxsXSI7CiAgdmFyIHVuZGVmaW5lZFRhZyA9ICJbb2JqZWN0IFVuZGVmaW5lZF0iOwogIHZhciBzeW1Ub1N0cmluZ1RhZzIgPSBTeW1ib2xfZGVmYXVsdCA/IFN5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdm9pZCAwOwogIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHsKICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZzsKICAgIH0KICAgIHJldHVybiBzeW1Ub1N0cmluZ1RhZzIgJiYgc3ltVG9TdHJpbmdUYWcyIGluIE9iamVjdCh2YWx1ZSkgPyBnZXRSYXdUYWdfZGVmYXVsdCh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZ19kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGJhc2VHZXRUYWdfZGVmYXVsdCA9IGJhc2VHZXRUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICJvYmplY3QiOwogIH0KICB2YXIgaXNPYmplY3RMaWtlX2RlZmF1bHQgPSBpc09iamVjdExpa2U7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanMKICB2YXIgc3ltYm9sVGFnID0gIltvYmplY3QgU3ltYm9sXSI7CiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gInN5bWJvbCIgfHwgaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSkgPT0gc3ltYm9sVGFnOwogIH0KICB2YXIgaXNTeW1ib2xfZGVmYXVsdCA9IGlzU3ltYm9sOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlNYXBfZGVmYXVsdCA9IGFycmF5TWFwOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwogIHZhciBpc0FycmF5X2RlZmF1bHQgPSBpc0FycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xzLzsKICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7CiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoOwogICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7CiAgICB9CiAgICByZXR1cm4gaW5kZXg7CiAgfQogIHZhciB0cmltbWVkRW5kSW5kZXhfZGVmYXVsdCA9IHRyaW1tZWRFbmRJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICB2YXIgcmVUcmltU3RhcnQgPSAvXlxzKy87CiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7CiAgICByZXR1cm4gc3RyaW5nID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleF9kZWZhdWx0KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAiIikgOiBzdHJpbmc7CiAgfQogIHZhciBiYXNlVHJpbV9kZWZhdWx0ID0gYmFzZVRyaW07CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gIm9iamVjdCIgfHwgdHlwZSA9PSAiZnVuY3Rpb24iKTsKICB9CiAgdmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIHZhciBOQU4gPSAwIC8gMDsKICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pOwogIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pOwogIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pOwogIHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDsKICBmdW5jdGlvbiB0b051bWJlcjIodmFsdWUpIHsKICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIpIHsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogICAgaWYgKGlzU3ltYm9sX2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBOQU47CiAgICB9CiAgICBpZiAoaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gImZ1bmN0aW9uIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlOwogICAgICB2YWx1ZSA9IGlzT2JqZWN0X2RlZmF1bHQob3RoZXIpID8gb3RoZXIgKyAiIiA6IG90aGVyOwogICAgfQogICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAic3RyaW5nIikgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTsKICAgIH0KICAgIHZhbHVlID0gYmFzZVRyaW1fZGVmYXVsdCh2YWx1ZSk7CiAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpOwogICAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlOwogIH0KICB2YXIgdG9OdW1iZXJfZGVmYXVsdCA9IHRvTnVtYmVyMjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIHZhciBJTkZJTklUWSA9IDEgLyAwOwogIHZhciBNQVhfSU5URUdFUiA9IDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MjsKICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkgewogICAgaWYgKCF2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7CiAgICB9CiAgICB2YWx1ZSA9IHRvTnVtYmVyX2RlZmF1bHQodmFsdWUpOwogICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7CiAgICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxOwogICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSOwogICAgfQogICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDsKICB9CiAgdmFyIHRvRmluaXRlX2RlZmF1bHQgPSB0b0Zpbml0ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0ludGVnZXIuanMKICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHsKICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZV9kZWZhdWx0KHZhbHVlKSwgcmVtYWluZGVyID0gcmVzdWx0ICUgMTsKICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCA6IDA7CiAgfQogIHZhciB0b0ludGVnZXJfZGVmYXVsdCA9IHRvSW50ZWdlcjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBhc3luY1RhZyA9ICJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dIjsKICB2YXIgZnVuY1RhZyA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIGdlblRhZyA9ICJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSI7CiAgdmFyIHByb3h5VGFnID0gIltvYmplY3QgUHJveHldIjsKICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7CiAgICBpZiAoIWlzT2JqZWN0X2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpOwogICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZzsKICB9CiAgdmFyIGlzRnVuY3Rpb25fZGVmYXVsdCA9IGlzRnVuY3Rpb247CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7CiAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07CiAgICB9CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBjb3B5QXJyYXlfZGVmYXVsdCA9IGNvcHlBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXGQqKSQvOwogIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkgewogICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7CiAgICByZXR1cm4gISFsZW5ndGggJiYgKHR5cGUgPT0gIm51bWJlciIgfHwgdHlwZSAhPSAic3ltYm9sIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpOwogIH0KICB2YXIgaXNJbmRleF9kZWZhdWx0ID0gaXNJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHsKICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjsKICB9CiAgdmFyIGVxX2RlZmF1bHQgPSBlcTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIyID0gOTAwNzE5OTI1NDc0MDk5MTsKICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkgewogICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAibnVtYmVyIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVIyOwogIH0KICB2YXIgaXNMZW5ndGhfZGVmYXVsdCA9IGlzTGVuZ3RoOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoX2RlZmF1bHQodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl9kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGlzQXJyYXlMaWtlX2RlZmF1bHQgPSBpc0FycmF5TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkgewogICAgaWYgKCFpc09iamVjdF9kZWZhdWx0KG9iamVjdCkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7CiAgICBpZiAodHlwZSA9PSAibnVtYmVyIiA/IGlzQXJyYXlMaWtlX2RlZmF1bHQob2JqZWN0KSAmJiBpc0luZGV4X2RlZmF1bHQoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSAic3RyaW5nIiAmJiBpbmRleCBpbiBvYmplY3QpIHsKICAgICAgcmV0dXJuIGVxX2RlZmF1bHQob2JqZWN0W2luZGV4XSwgdmFsdWUpOwogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgaXNJdGVyYXRlZUNhbGxfZGVmYXVsdCA9IGlzSXRlcmF0ZWVDYWxsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8zID0gT2JqZWN0LnByb3RvdHlwZTsKICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkgewogICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAiZnVuY3Rpb24iICYmIEN0b3IucHJvdG90eXBlIHx8IG9iamVjdFByb3RvMzsKICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87CiAgfQogIHZhciBpc1Byb3RvdHlwZV9kZWZhdWx0ID0gaXNQcm90b3R5cGU7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkgewogICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG4pOwogICAgd2hpbGUgKCsraW5kZXggPCBuKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYmFzZVRpbWVzX2RlZmF1bHQgPSBiYXNlVGltZXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYXJnc1RhZyA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpID09IGFyZ3NUYWc7CiAgfQogIHZhciBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdCA9IGJhc2VJc0FyZ3VtZW50czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcwogIHZhciBvYmplY3RQcm90bzQgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTIgPSBvYmplY3RQcm90bzQuaGFzT3duUHJvcGVydHk7CiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG80LnByb3BlcnR5SXNFbnVtZXJhYmxlOwogIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50c19kZWZhdWx0KGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIGFyZ3VtZW50czsKICB9KCkpID8gYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQgOiBmdW5jdGlvbih2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eTIuY2FsbCh2YWx1ZSwgImNhbGxlZSIpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAiY2FsbGVlIik7CiAgfTsKICB2YXIgaXNBcmd1bWVudHNfZGVmYXVsdCA9IGlzQXJndW1lbnRzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciBzdHViRmFsc2VfZGVmYXVsdCA9IHN0dWJGYWxzZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcwogIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gIm9iamVjdCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwogIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzOwogIHZhciBCdWZmZXI5ID0gbW9kdWxlRXhwb3J0cyA/IHJvb3RfZGVmYXVsdC5CdWZmZXIgOiB2b2lkIDA7CiAgdmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyOSA/IEJ1ZmZlcjkuaXNCdWZmZXIgOiB2b2lkIDA7CiAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlX2RlZmF1bHQ7CiAgdmFyIGlzQnVmZmVyX2RlZmF1bHQgPSBpc0J1ZmZlcjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcyID0gIltvYmplY3QgQXJndW1lbnRzXSI7CiAgdmFyIGFycmF5VGFnID0gIltvYmplY3QgQXJyYXldIjsKICB2YXIgYm9vbFRhZyA9ICJbb2JqZWN0IEJvb2xlYW5dIjsKICB2YXIgZGF0ZVRhZyA9ICJbb2JqZWN0IERhdGVdIjsKICB2YXIgZXJyb3JUYWcgPSAiW29iamVjdCBFcnJvcl0iOwogIHZhciBmdW5jVGFnMiA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIG1hcFRhZyA9ICJbb2JqZWN0IE1hcF0iOwogIHZhciBudW1iZXJUYWcgPSAiW29iamVjdCBOdW1iZXJdIjsKICB2YXIgb2JqZWN0VGFnID0gIltvYmplY3QgT2JqZWN0XSI7CiAgdmFyIHJlZ2V4cFRhZyA9ICJbb2JqZWN0IFJlZ0V4cF0iOwogIHZhciBzZXRUYWcgPSAiW29iamVjdCBTZXRdIjsKICB2YXIgc3RyaW5nVGFnID0gIltvYmplY3QgU3RyaW5nXSI7CiAgdmFyIHdlYWtNYXBUYWcgPSAiW29iamVjdCBXZWFrTWFwXSI7CiAgdmFyIGFycmF5QnVmZmVyVGFnID0gIltvYmplY3QgQXJyYXlCdWZmZXJdIjsKICB2YXIgZGF0YVZpZXdUYWcgPSAiW29iamVjdCBEYXRhVmlld10iOwogIHZhciBmbG9hdDMyVGFnID0gIltvYmplY3QgRmxvYXQzMkFycmF5XSI7CiAgdmFyIGZsb2F0NjRUYWcgPSAiW29iamVjdCBGbG9hdDY0QXJyYXldIjsKICB2YXIgaW50OFRhZyA9ICJbb2JqZWN0IEludDhBcnJheV0iOwogIHZhciBpbnQxNlRhZyA9ICJbb2JqZWN0IEludDE2QXJyYXldIjsKICB2YXIgaW50MzJUYWcgPSAiW29iamVjdCBJbnQzMkFycmF5XSI7CiAgdmFyIHVpbnQ4VGFnID0gIltvYmplY3QgVWludDhBcnJheV0iOwogIHZhciB1aW50OENsYW1wZWRUYWcgPSAiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iOwogIHZhciB1aW50MTZUYWcgPSAiW29iamVjdCBVaW50MTZBcnJheV0iOwogIHZhciB1aW50MzJUYWcgPSAiW29iamVjdCBVaW50MzJBcnJheV0iOwogIHZhciB0eXBlZEFycmF5VGFncyA9IHt9OwogIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7CiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZzJdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7CiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBpc0xlbmd0aF9kZWZhdWx0KHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpXTsKICB9CiAgdmFyIGJhc2VJc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGJhc2VJc1R5cGVkQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykgewogICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTsKICAgIH07CiAgfQogIHZhciBiYXNlVW5hcnlfZGVmYXVsdCA9IGJhc2VVbmFyeTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVFeHBvcnRzMiA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZTIgPSBmcmVlRXhwb3J0czIgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMyID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMyOwogIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMyICYmIGZyZWVHbG9iYWxfZGVmYXVsdC5wcm9jZXNzOwogIHZhciBub2RlVXRpbCA9IGZ1bmN0aW9uKCkgewogICAgdHJ5IHsKICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIucmVxdWlyZSAmJiBmcmVlTW9kdWxlMi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7CiAgICAgIGlmICh0eXBlcykgewogICAgICAgIHJldHVybiB0eXBlczsKICAgICAgfQogICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCJ1dGlsIik7CiAgICB9IGNhdGNoIChlKSB7CiAgICB9CiAgfSgpOwogIHZhciBub2RlVXRpbF9kZWZhdWx0ID0gbm9kZVV0aWw7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzCiAgdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbF9kZWZhdWx0ICYmIG5vZGVVdGlsX2RlZmF1bHQuaXNUeXBlZEFycmF5OwogIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5X2RlZmF1bHQobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQ7CiAgdmFyIGlzVHlwZWRBcnJheV9kZWZhdWx0ID0gaXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNSA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5MyA9IG9iamVjdFByb3RvNS5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHsKICAgIHZhciBpc0FyciA9IGlzQXJyYXlfZGVmYXVsdCh2YWx1ZSksIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzX2RlZmF1bHQodmFsdWUpLCBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyX2RlZmF1bHQodmFsdWUpLCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5X2RlZmF1bHQodmFsdWUpLCBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzX2RlZmF1bHQodmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7CiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHsKICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkzLmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAibGVuZ3RoIiB8fCBpc0J1ZmYgJiYgKGtleSA9PSAib2Zmc2V0IiB8fCBrZXkgPT0gInBhcmVudCIpIHx8IGlzVHlwZSAmJiAoa2V5ID09ICJidWZmZXIiIHx8IGtleSA9PSAiYnl0ZUxlbmd0aCIgfHwga2V5ID09ICJieXRlT2Zmc2V0IikgfHwgaXNJbmRleF9kZWZhdWx0KGtleSwgbGVuZ3RoKSkpKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGFycmF5TGlrZUtleXNfZGVmYXVsdCA9IGFycmF5TGlrZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7CiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTsKICAgIH07CiAgfQogIHZhciBvdmVyQXJnX2RlZmF1bHQgPSBvdmVyQXJnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgdmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnX2RlZmF1bHQoT2JqZWN0LmtleXMsIE9iamVjdCk7CiAgdmFyIG5hdGl2ZUtleXNfZGVmYXVsdCA9IG5hdGl2ZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNiA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5NCA9IG9iamVjdFByb3RvNi5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHsKICAgIGlmICghaXNQcm90b3R5cGVfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBuYXRpdmVLZXlzX2RlZmF1bHQob2JqZWN0KTsKICAgIH0KICAgIHZhciByZXN1bHQgPSBbXTsKICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgICBpZiAoaGFzT3duUHJvcGVydHk0LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAiY29uc3RydWN0b3IiKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGJhc2VLZXlzX2RlZmF1bHQgPSBiYXNlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzCiAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsKICAgIHJldHVybiBpc0FycmF5TGlrZV9kZWZhdWx0KG9iamVjdCkgPyBhcnJheUxpa2VLZXlzX2RlZmF1bHQob2JqZWN0KSA6IGJhc2VLZXlzX2RlZmF1bHQob2JqZWN0KTsKICB9CiAgdmFyIGtleXNfZGVmYXVsdCA9IGtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbGFtcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHsKICAgIGlmIChudW1iZXIgPT09IG51bWJlcikgewogICAgICBpZiAodXBwZXIgIT09IHZvaWQgMCkgewogICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyOwogICAgICB9CiAgICAgIGlmIChsb3dlciAhPT0gdm9pZCAwKSB7CiAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBudW1iZXI7CiAgfQogIHZhciBiYXNlQ2xhbXBfZGVmYXVsdCA9IGJhc2VDbGFtcDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7CiAgICByZXR1cm4gYXJyYXlNYXBfZGVmYXVsdChwcm9wcywgZnVuY3Rpb24oa2V5KSB7CiAgICAgIHJldHVybiBvYmplY3Rba2V5XTsKICAgIH0pOwogIH0KICB2YXIgYmFzZVZhbHVlc19kZWZhdWx0ID0gYmFzZVZhbHVlczsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXNfZGVmYXVsdChvYmplY3QsIGtleXNfZGVmYXVsdChvYmplY3QpKTsKICB9CiAgdmFyIHZhbHVlc19kZWZhdWx0ID0gdmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3I7CiAgdmFyIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tOwogIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7CiAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpOwogIH0KICB2YXIgYmFzZVJhbmRvbV9kZWZhdWx0ID0gYmFzZVJhbmRvbTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxOwogICAgc2l6ZSA9IHNpemUgPT09IHZvaWQgMCA/IGxlbmd0aCA6IHNpemU7CiAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHsKICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tX2RlZmF1bHQoaW5kZXgsIGxhc3RJbmRleCksIHZhbHVlID0gYXJyYXlbcmFuZF07CiAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdOwogICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTsKICAgIH0KICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBzaHVmZmxlU2VsZl9kZWZhdWx0ID0gc2h1ZmZsZVNlbGY7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2FtcGxlU2l6ZS5qcwogIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikgewogICAgcmV0dXJuIHNodWZmbGVTZWxmX2RlZmF1bHQoY29weUFycmF5X2RlZmF1bHQoYXJyYXkpLCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0ID0gYXJyYXlTYW1wbGVTaXplOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7CiAgICB2YXIgYXJyYXkgPSB2YWx1ZXNfZGVmYXVsdChjb2xsZWN0aW9uKTsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGFycmF5LCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGJhc2VTYW1wbGVTaXplX2RlZmF1bHQgPSBiYXNlU2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkgewogICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGxfZGVmYXVsdChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB2b2lkIDApIHsKICAgICAgbiA9IDE7CiAgICB9IGVsc2UgewogICAgICBuID0gdG9JbnRlZ2VyX2RlZmF1bHQobik7CiAgICB9CiAgICB2YXIgZnVuYyA9IGlzQXJyYXlfZGVmYXVsdChjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0IDogYmFzZVNhbXBsZVNpemVfZGVmYXVsdDsKICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pOwogIH0KICB2YXIgc2FtcGxlU2l6ZV9kZWZhdWx0ID0gc2FtcGxlU2l6ZTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYXNjZW5kaW5nLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGFzY2VuZGluZ19kZWZhdWx0KGEsIGIpIHsKICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjsKICB9CgogIC8vIG5vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmlzZWN0b3JfZGVmYXVsdChmKSB7CiAgICBsZXQgZGVsdGEgPSBmOwogICAgbGV0IGNvbXBhcmUyID0gZjsKICAgIGlmIChmLmxlbmd0aCA9PT0gMSkgewogICAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDsKICAgICAgY29tcGFyZTIgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGYpOwogICAgfQogICAgZnVuY3Rpb24gbGVmdChhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICB3aGlsZSAobG8gPCBoaSkgewogICAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7CiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPCAwKQogICAgICAgICAgbG8gPSBtaWQgKyAxOwogICAgICAgIGVsc2UKICAgICAgICAgIGhpID0gbWlkOwogICAgICB9CiAgICAgIHJldHVybiBsbzsKICAgIH0KICAgIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA+IDApCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgICBlbHNlCiAgICAgICAgICBsbyA9IG1pZCArIDE7CiAgICAgIH0KICAgICAgcmV0dXJuIGxvOwogICAgfQogICAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpOwogICAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTsKICAgIH0KICAgIHJldHVybiB7IGxlZnQsIGNlbnRlciwgcmlnaHQgfTsKICB9CiAgZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7CiAgICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZ19kZWZhdWx0KGYoZCksIHgpOwogIH0KCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICB2YXIgRGF0YVNvdXJjZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGZpbGUsIGNocm9tU2l6ZXMsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5maWxlID0gZmlsZTsKICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGhpcy5jaHJvbUluZm8gPSBzaXplc1RvQ2hyb21JbmZvKGNocm9tU2l6ZXMpOwogICAgICB0aGlzLnRpbGVzZXRJbmZvID0gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKHRoaXMuY2hyb21JbmZvKTsKICAgIH0KICAgIGNocm9tSW5mbzsKICAgIHRpbGVzZXRJbmZvOwogIH07CiAgdmFyIGNocm9tSW5mb0Jpc2VjdG9yID0gYmlzZWN0b3JfZGVmYXVsdCgoZCkgPT4gZC5wb3MpLmxlZnQ7CiAgdmFyIGNoclRvQWJzID0gKGNocm9tLCBjaHJvbVBvcywgY2hyb21JbmZvKSA9PiBjaHJvbUluZm8uY2hyUG9zaXRpb25zW2Nocm9tXS5wb3MgKyBjaHJvbVBvczsKICB2YXIgYWJzVG9DaHIgPSAoYWJzUG9zaXRpb24sIGNocm9tSW5mbykgPT4gewogICAgaWYgKCFjaHJvbUluZm8gfHwgIWNocm9tSW5mby5jdW1Qb3NpdGlvbnMgfHwgIWNocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgbGV0IGluc2VydFBvaW50ID0gY2hyb21JbmZvQmlzZWN0b3IoY2hyb21JbmZvLmN1bVBvc2l0aW9ucywgYWJzUG9zaXRpb24pOwogICAgY29uc3QgbGFzdENociA9IGNocm9tSW5mby5jdW1Qb3NpdGlvbnNbY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxXS5jaHI7CiAgICBjb25zdCBsYXN0TGVuZ3RoID0gY2hyb21JbmZvLmNocm9tTGVuZ3Roc1tsYXN0Q2hyXTsKICAgIGluc2VydFBvaW50IC09IGluc2VydFBvaW50ID4gMCAmJiAxOwogICAgbGV0IGNoclBvc2l0aW9uID0gTWF0aC5mbG9vcihhYnNQb3NpdGlvbiAtIGNocm9tSW5mby5jdW1Qb3NpdGlvbnNbaW5zZXJ0UG9pbnRdLnBvcyk7CiAgICBsZXQgb2Zmc2V0ID0gMDsKICAgIGlmIChjaHJQb3NpdGlvbiA8IDApIHsKICAgICAgb2Zmc2V0ID0gY2hyUG9zaXRpb24gLSAxOwogICAgICBjaHJQb3NpdGlvbiA9IDE7CiAgICB9CiAgICBpZiAoaW5zZXJ0UG9pbnQgPT09IGNocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoIC0gMSAmJiBjaHJQb3NpdGlvbiA+IGxhc3RMZW5ndGgpIHsKICAgICAgb2Zmc2V0ID0gY2hyUG9zaXRpb24gLSBsYXN0TGVuZ3RoOwogICAgICBjaHJQb3NpdGlvbiA9IGxhc3RMZW5ndGg7CiAgICB9CiAgICByZXR1cm4gW2Nocm9tSW5mby5jdW1Qb3NpdGlvbnNbaW5zZXJ0UG9pbnRdLmNociwgY2hyUG9zaXRpb24sIG9mZnNldCwgaW5zZXJ0UG9pbnRdOwogIH07CiAgZnVuY3Rpb24gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKGNocm9tSW5mbywgdGlsZVNpemUgPSAxMDI0KSB7CiAgICByZXR1cm4gewogICAgICB0aWxlX3NpemU6IHRpbGVTaXplLAogICAgICBiaW5zX3Blcl9kaW1lbnNpb246IHRpbGVTaXplLAogICAgICBtYXhfem9vbTogTWF0aC5jZWlsKE1hdGgubG9nKGNocm9tSW5mby50b3RhbExlbmd0aCAvIHRpbGVTaXplKSAvIE1hdGgubG9nKDIpKSwKICAgICAgbWF4X3dpZHRoOiBjaHJvbUluZm8udG90YWxMZW5ndGgsCiAgICAgIG1pbl9wb3M6IFswXSwKICAgICAgbWF4X3BvczogW2Nocm9tSW5mby50b3RhbExlbmd0aF0KICAgIH07CiAgfQogIGZ1bmN0aW9uIHNpemVzVG9DaHJvbUluZm8oc2l6ZXMpIHsKICAgIGNvbnN0IGluZm8gPSB7CiAgICAgIGN1bVBvc2l0aW9uczogW10sCiAgICAgIGNocm9tTGVuZ3Roczoge30sCiAgICAgIGNoclBvc2l0aW9uczoge30sCiAgICAgIHRvdGFsTGVuZ3RoOiAwCiAgICB9OwogICAgc2l6ZXMuZm9yRWFjaCgoW2NociwgbGVuZ3RoXSwgaSkgPT4gewogICAgICBjb25zdCBjaHJQb3NpdGlvbiA9IHsgaWQ6IGksIGNociwgcG9zOiBpbmZvLnRvdGFsTGVuZ3RoIH07CiAgICAgIGluZm8uY2hyUG9zaXRpb25zW2Nocl0gPSBjaHJQb3NpdGlvbjsKICAgICAgaW5mby5jaHJvbUxlbmd0aHNbY2hyXSA9IGxlbmd0aDsKICAgICAgaW5mby5jdW1Qb3NpdGlvbnMucHVzaChjaHJQb3NpdGlvbik7CiAgICAgIGluZm8udG90YWxMZW5ndGggKz0gbGVuZ3RoOwogICAgfSk7CiAgICByZXR1cm4gewogICAgICAuLi5pbmZvLAogICAgICBhYnNUb0NocjogKGFic1BvcykgPT4gaW5mby5jaHJQb3NpdGlvbnMgPyBhYnNUb0NocihhYnNQb3MsIGluZm8pIDogbnVsbCwKICAgICAgY2hyVG9BYnM6IChbY2hyTmFtZSwgY2hyUG9zXSkgPT4gaW5mby5jaHJQb3NpdGlvbnMgPyBjaHJUb0FicyhjaHJOYW1lLCBjaHJQb3MsIGluZm8pIDogbnVsbAogICAgfTsKICB9CiAgdmFyIFJlbW90ZUZpbGUyID0gY2xhc3MgZXh0ZW5kcyBSZW1vdGVGaWxlIHsKICAgIHJlYWQgPSBhc3luYyAoYnVmZmVyLCBvZmZzZXQgPSAwLCBsZW5ndGgsIHBvc2l0aW9uID0gMCwgb3B0cyA9IHt9KSA9PiB7CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBpZiAobGVuZ3RoIDwgSW5maW5pdHkpIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YDsKICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IEluZmluaXR5ICYmIHBvc2l0aW9uICE9PSAwKSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gOwogICAgICB9CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLAogICAgICAgIC4uLm92ZXJyaWRlcywKICAgICAgICBoZWFkZXJzOiB7CiAgICAgICAgICAuLi5oZWFkZXJzLAogICAgICAgICAgLi4ub3ZlcnJpZGVzLmhlYWRlcnMsCiAgICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycwogICAgICAgIH0sCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbAogICAgICB9OwogICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godGhpcy51cmwsIGFyZ3MpOwogICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7dGhpcy51cmx9YCk7CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7CiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gcmVzcG9uc2VEYXRhLmNvcHkoYnVmZmVyLCBvZmZzZXQsIDAsIE1hdGgubWluKGxlbmd0aCwgcmVzcG9uc2VEYXRhLmxlbmd0aCkpOwogICAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgY29uc3Qgc2l6ZU1hdGNoID0gL1wvKFxkKykkLy5leGVjKHJlcyB8fCAiIik7CiAgICAgICAgaWYgKHNpemVNYXRjaCAmJiBzaXplTWF0Y2hbMV0pIHsKICAgICAgICAgIHRoaXMuX3N0YXQgPSB7IHNpemU6IHBhcnNlSW50KHNpemVNYXRjaFsxXSwgMTApIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH07CiAgfTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdmNmL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBnZXRNdXRhdGlvblR5cGUgPSAocmVmLCBhbHQpID0+IHsKICAgIGlmICghYWx0KQogICAgICByZXR1cm4gInVua25vd24iOwogICAgaWYgKHJlZi5sZW5ndGggPT09IGFsdC5sZW5ndGgpCiAgICAgIHJldHVybiAic3Vic3RpdHV0aW9uIjsKICAgIGlmIChyZWYubGVuZ3RoID4gYWx0Lmxlbmd0aCkKICAgICAgcmV0dXJuICJkZWxldGlvbiI7CiAgICBpZiAocmVmLmxlbmd0aCA8IGFsdC5sZW5ndGgpCiAgICAgIHJldHVybiAiaW5zZXJ0aW9uIjsKICAgIHJldHVybiAidW5rbm93biI7CiAgfTsKICB2YXIgZ2V0U3Vic3RpdHV0aW9uVHlwZSA9IChyZWYsIGFsdCkgPT4gewogICAgc3dpdGNoIChyZWYgKyBhbHQpIHsKICAgICAgY2FzZSAiQ0EiOgogICAgICBjYXNlICJHVCI6CiAgICAgICAgcmV0dXJuICJDPkEiOwogICAgICBjYXNlICJDRyI6CiAgICAgIGNhc2UgIkdDIjoKICAgICAgICByZXR1cm4gIkM+RyI7CiAgICAgIGNhc2UgIkNUIjoKICAgICAgY2FzZSAiR0EiOgogICAgICAgIHJldHVybiAiQz5UIjsKICAgICAgY2FzZSAiVEEiOgogICAgICBjYXNlICJBVCI6CiAgICAgICAgcmV0dXJuICJUPkEiOwogICAgICBjYXNlICJUQyI6CiAgICAgIGNhc2UgIkFHIjoKICAgICAgICByZXR1cm4gIlQ+QyI7CiAgICAgIGNhc2UgIlRHIjoKICAgICAgY2FzZSAiQUMiOgogICAgICAgIHJldHVybiAiVD5HIjsKICAgICAgZGVmYXVsdDoKICAgICAgICByZXR1cm4gInVua25vd24iOwogICAgfQogIH07CiAgZnVuY3Rpb24gcmVjb3JkVG9UaWxlKHZjZlJlY29yZCwgY2hyUG9zLCBwcmV2QWJzUG9zKSB7CiAgICBjb25zdCBhYnNQb3MgPSBjaHJQb3MgKyB2Y2ZSZWNvcmQuUE9TICsgMTsKICAgIGxldCBBTFQ7CiAgICBpZiAoQXJyYXkuaXNBcnJheSh2Y2ZSZWNvcmQuQUxUKSAmJiB2Y2ZSZWNvcmQuQUxULmxlbmd0aCA+IDApIHsKICAgICAgQUxUID0gdmNmUmVjb3JkLkFMVFswXTsKICAgIH0KICAgIGNvbnN0IERJU1RQUkVWID0gIXByZXZBYnNQb3MgPyBudWxsIDogYWJzUG9zIC0gcHJldkFic1BvczsKICAgIGNvbnN0IERJU1RQUkVWTE9HRSA9ICFwcmV2QWJzUG9zID8gbnVsbCA6IE1hdGgubG9nKGFic1BvcyAtIHByZXZBYnNQb3MpOwogICAgY29uc3QgTVVUVFlQRSA9IGdldE11dGF0aW9uVHlwZSh2Y2ZSZWNvcmQuUkVGLCBBTFQpOwogICAgY29uc3QgU1VCVFlQRSA9IGdldFN1YnN0aXR1dGlvblR5cGUodmNmUmVjb3JkLlJFRiwgQUxUKTsKICAgIGNvbnN0IFBPU0VORCA9IGFic1BvcyArIHZjZlJlY29yZC5SRUYubGVuZ3RoOwogICAgY29uc3QgZGF0YSA9IHsKICAgICAgLi4udmNmUmVjb3JkLAogICAgICBBTFQsCiAgICAgIE1VVFRZUEUsCiAgICAgIFNVQlRZUEUsCiAgICAgIElORk86IEpTT04uc3RyaW5naWZ5KHZjZlJlY29yZC5JTkZPKSwKICAgICAgT1JJR0lOQUxQT1M6IHZjZlJlY29yZC5QT1MsCiAgICAgIFBPUzogYWJzUG9zLAogICAgICBQT1NFTkQsCiAgICAgIERJU1RQUkVWLAogICAgICBESVNUUFJFVkxPR0UKICAgIH07CiAgICBPYmplY3Qua2V5cyh2Y2ZSZWNvcmQuSU5GTykuZm9yRWFjaCgoa2V5KSA9PiB7CiAgICAgIGNvbnN0IHZhbCA9IHZjZlJlY29yZC5JTkZPW2tleV07CiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHsKICAgICAgICBkYXRhW2tleV0gPSB2YWwuam9pbigiLCAiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBkYXRhW2tleV0gPSB2YWw7CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIGRhdGE7CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy92Y2YvdmNmLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgdmFyIHZjZkZpbGVzID0gbmV3IE1hcCgpOwogIHZhciBWY2ZGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IodGJpLCB1aWQpIHsKICAgICAgdGhpcy50YmkgPSB0Ymk7CiAgICAgIHRoaXMuI3VpZCA9IHVpZDsKICAgIH0KICAgICNwYXJzZXI7CiAgICAjdWlkOwogICAgc3RhdGljIGZyb21VcmwodXJsLCBpbmRleFVybCwgdWlkLCB1cmxGZXRjaE9wdGlvbnMsIGluZGV4VXJsRmV0Y2hPcHRpb25zKSB7CiAgICAgIGNvbnN0IHRiaSA9IG5ldyBUYWJpeEluZGV4ZWRGaWxlKHsKICAgICAgICBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZTIodXJsLCB7IG92ZXJyaWRlczogdXJsRmV0Y2hPcHRpb25zIH0pLAogICAgICAgIHRiaUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMihpbmRleFVybCwgeyBvdmVycmlkZXM6IGluZGV4VXJsRmV0Y2hPcHRpb25zIH0pCiAgICAgIH0pOwogICAgICByZXR1cm4gbmV3IFZjZkZpbGUodGJpLCB1aWQpOwogICAgfQogICAgYXN5bmMgZ2V0UGFyc2VyKCkgewogICAgICBpZiAoIXRoaXMuI3BhcnNlcikgewogICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudGJpLmdldEhlYWRlcigpOwogICAgICAgIHRoaXMuI3BhcnNlciA9IG5ldyBlc21fZGVmYXVsdCh7IGhlYWRlciB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy4jcGFyc2VyOwogICAgfQogICAgYXN5bmMgZ2V0VGlsZURhdGEobWluWCwgbWF4WCkgewogICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgY29uc3QgcGFyc2VyID0gYXdhaXQgdGhpcy5nZXRQYXJzZXIoKTsKICAgICAgbGV0IGN1ck1pblggPSBtaW5YOwogICAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBzb3VyY2UuY2hyb21JbmZvOwogICAgICBjb25zdCByZWNvcmRQcm9taXNlcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IGN1bVBvcyBvZiBjdW1Qb3NpdGlvbnMpIHsKICAgICAgICBjb25zdCBjaHJvbU5hbWUgPSBjdW1Qb3MuY2hyOwogICAgICAgIGNvbnN0IGNocm9tU3RhcnQgPSBjdW1Qb3MucG9zOwogICAgICAgIGNvbnN0IGNocm9tRW5kID0gY3VtUG9zLnBvcyArIGNocm9tTGVuZ3Roc1tjaHJvbU5hbWVdOwogICAgICAgIGxldCBzdGFydFBvcywgZW5kUG9zOwogICAgICAgIGlmIChjaHJvbVN0YXJ0ID4gY3VyTWluWCB8fCBjdXJNaW5YID49IGNocm9tRW5kKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgbGV0IHByZXZQT1M7CiAgICAgICAgY29uc3QgdGlsZXNQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIGNvbnN0IHRpbGVzID0gW107CiAgICAgICAgICBjb25zdCBsaW5lQ2FsbGJhY2sgPSAobGluZSkgPT4gewogICAgICAgICAgICBjb25zdCB2Y2ZSZWNvcmQgPSBwYXJzZXIucGFyc2VMaW5lKGxpbmUpOwogICAgICAgICAgICBjb25zdCB2Y2ZUaWxlID0gcmVjb3JkVG9UaWxlKHZjZlJlY29yZCwgY2hyb21TdGFydCwgcHJldlBPUyk7CiAgICAgICAgICAgIHByZXZQT1MgPSB2Y2ZUaWxlLlBPUzsKICAgICAgICAgICAgdGlsZXMucHVzaCh2Y2ZUaWxlKTsKICAgICAgICAgIH07CiAgICAgICAgICBpZiAobWF4WCA+IGNocm9tRW5kKSB7CiAgICAgICAgICAgIHN0YXJ0UG9zID0gY3VyTWluWCAtIGNocm9tU3RhcnQ7CiAgICAgICAgICAgIGVuZFBvcyA9IGNocm9tRW5kIC0gY2hyb21TdGFydDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXJ0UG9zID0gTWF0aC5mbG9vcihjdXJNaW5YIC0gY2hyb21TdGFydCk7CiAgICAgICAgICAgIGVuZFBvcyA9IE1hdGguY2VpbChtYXhYIC0gY2hyb21TdGFydCk7CiAgICAgICAgICB9CiAgICAgICAgICBzb3VyY2UuZmlsZS50YmkuZ2V0TGluZXMoY2hyb21OYW1lLCBzdGFydFBvcywgZW5kUG9zLCBsaW5lQ2FsbGJhY2spLnRoZW4oKCkgPT4gewogICAgICAgICAgICByZXNvbHZlKHRpbGVzKTsKICAgICAgICAgIH0pOwogICAgICAgIH0pOwogICAgICAgIHJlY29yZFByb21pc2VzLnB1c2godGlsZXNQcm9taXNlKTsKICAgICAgICBpZiAobWF4WCA8PSBjaHJvbUVuZCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQogICAgICAgIGN1ck1pblggPSBjaHJvbUVuZDsKICAgICAgfQogICAgICBjb25zdCB0aWxlQXJyYXlzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVjb3JkUHJvbWlzZXMpOwogICAgICByZXR1cm4gdGlsZUFycmF5cy5mbGF0KCk7CiAgICB9CiAgfTsKICB2YXIgdGlsZVZhbHVlcyA9IHt9OwogIHZhciBkYXRhU291cmNlcyA9IG5ldyBNYXAoKTsKICBmdW5jdGlvbiBpbml0KHVpZCwgdmNmLCBjaHJvbVNpemVzLCBvcHRpb25zID0ge30pIHsKICAgIGxldCB2Y2ZGaWxlID0gdmNmRmlsZXMuZ2V0KHZjZi51cmwpOwogICAgaWYgKCF2Y2ZGaWxlKSB7CiAgICAgIHZjZkZpbGUgPSBWY2ZGaWxlLmZyb21VcmwodmNmLnVybCwgdmNmLmluZGV4VXJsLCB1aWQsIG9wdGlvbnMudXJsRmV0Y2hPcHRpb25zLCBvcHRpb25zLmluZGV4VXJsRmV0Y2hPcHRpb25zKTsKICAgIH0KICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZSh2Y2ZGaWxlLCBjaHJvbVNpemVzLCB7CiAgICAgIHNhbXBsZUxlbmd0aDogMWUzLAogICAgICAuLi5vcHRpb25zCiAgICB9KTsKICAgIGRhdGFTb3VyY2VzLnNldCh1aWQsIGRhdGFTb3VyY2UpOwogIH0KICB2YXIgdGlsZXNldEluZm8gPSAodWlkKSA9PiB7CiAgICByZXR1cm4gZGF0YVNvdXJjZXMuZ2V0KHVpZCkudGlsZXNldEluZm87CiAgfTsKICB2YXIgdGlsZSA9IGFzeW5jICh1aWQsIHosIHgpID0+IHsKICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh1aWQpOwogICAgY29uc3QgQ0FDSEVfS0VZID0gYCR7dWlkfS4ke3p9LiR7eH1gOwogICAgdGlsZVZhbHVlc1tDQUNIRV9LRVldID0gW107CiAgICBjb25zdCB0aWxlV2lkdGggPSArc291cmNlLnRpbGVzZXRJbmZvLm1heF93aWR0aCAvIDIgKiogK3o7CiAgICBjb25zdCBtaW5YID0gc291cmNlLnRpbGVzZXRJbmZvLm1pbl9wb3NbMF0gKyB4ICogdGlsZVdpZHRoOwogICAgY29uc3QgbWF4WCA9IHNvdXJjZS50aWxlc2V0SW5mby5taW5fcG9zWzBdICsgKHggKyAxKSAqIHRpbGVXaWR0aDsKICAgIHRpbGVWYWx1ZXNbQ0FDSEVfS0VZXSA9IGF3YWl0IHNvdXJjZS5maWxlLmdldFRpbGVEYXRhKG1pblgsIG1heFgpOwogICAgcmV0dXJuIHRpbGVWYWx1ZXNbQ0FDSEVfS0VZXTsKICB9OwogIHZhciBmZXRjaFRpbGVzRGVib3VuY2VkID0gYXN5bmMgKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgdGlsZXMgPSB7fTsKICAgIGNvbnN0IHZhbGlkVGlsZUlkcyA9IFtdOwogICAgY29uc3QgdGlsZVByb21pc2VzID0gW107CiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiB0aWxlSWRzKSB7CiAgICAgIGNvbnN0IHBhcnRzID0gdGlsZUlkLnNwbGl0KCIuIik7CiAgICAgIGNvbnN0IHogPSBwYXJzZUludChwYXJ0c1swXSwgMTApOwogICAgICBjb25zdCB4ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeikpIHsKICAgICAgICBjb25zb2xlLndhcm4oIkludmFsaWQgdGlsZSB6b29tIG9yIHBvc2l0aW9uOiIsIHosIHgpOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHZhbGlkVGlsZUlkcy5wdXNoKHRpbGVJZCk7CiAgICAgIHRpbGVQcm9taXNlcy5wdXNoKHRpbGUodWlkLCB6LCB4KSk7CiAgICB9CiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGlsZVByb21pc2VzKS50aGVuKCh2YWx1ZXMyKSA9PiB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzMi5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IHZhbGlkVGlsZUlkID0gdmFsaWRUaWxlSWRzW2ldOwogICAgICAgIHRpbGVzW3ZhbGlkVGlsZUlkXSA9IHZhbHVlczJbaV07CiAgICAgICAgdGlsZXNbdmFsaWRUaWxlSWRdLnRpbGVQb3NpdGlvbklkID0gdmFsaWRUaWxlSWQ7CiAgICAgIH0KICAgICAgcmV0dXJuIHRpbGVzOwogICAgfSk7CiAgfTsKICB2YXIgZ2V0VGFidWxhckRhdGEgPSAodWlkLCB0aWxlSWRzKSA9PiB7CiAgICBjb25zdCBkYXRhID0gW107CiAgICB0aWxlSWRzLmZvckVhY2goKHRpbGVJZCkgPT4gewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGNvbnN0IHRpbGVWYWx1ZSA9IHRpbGVWYWx1ZXNbYCR7dWlkfS4ke3p9LiR7eH1gXTsKICAgICAgaWYgKCF0aWxlVmFsdWUpIHsKICAgICAgICBjb25zb2xlLndhcm4oYE5vIHRpbGUgZGF0YSBjb25zdHJ1Y3RlZCAoJHt0aWxlSWR9KWApOwogICAgICB9CiAgICAgIGRhdGEucHVzaCh0aWxlVmFsdWUpOwogICAgfSk7CiAgICBsZXQgb3V0cHV0ID0gT2JqZWN0LnZhbHVlcyhkYXRhKS5mbGF0KCk7CiAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBkYXRhU291cmNlcy5nZXQodWlkKS5vcHRpb25zLnNhbXBsZUxlbmd0aDsKICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNhbXBsZUxlbmd0aCkgewogICAgICBjb25zdCBoaWdoUHJpb3JpdHkgPSBvdXRwdXQuc29ydCgoYSwgYikgPT4gLShhLkRJU1RQUkVWID8/IDApICsgKGIuRElTVFBSRVYgPz8gMCkpLnNsaWNlKDAsIHNhbXBsZUxlbmd0aCAvIDIpOwogICAgICBvdXRwdXQgPSBzYW1wbGVTaXplX2RlZmF1bHQob3V0cHV0LCBzYW1wbGVMZW5ndGggLyAyKS5jb25jYXQoaGlnaFByaW9yaXR5KTsKICAgIH0KICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShKU09OLnN0cmluZ2lmeShvdXRwdXQpKS5idWZmZXI7CiAgICByZXR1cm4gVHJhbnNmZXIoYnVmZmVyLCBbYnVmZmVyXSk7CiAgfTsKICB2YXIgdGlsZUZ1bmN0aW9ucyA9IHsKICAgIGluaXQsCiAgICB0aWxlc2V0SW5mbywKICAgIGZldGNoVGlsZXNEZWJvdW5jZWQsCiAgICB0aWxlLAogICAgZ2V0VGFidWxhckRhdGEKICB9OwogIGV4cG9zZSh0aWxlRnVuY3Rpb25zKTsKfSkoKTsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwovKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqLwovKioKICogQGxpY2Vuc2UKICogQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzCiAqIENvcHlyaWdodCAyMDIwIERhbmllbCBXaXJ0eiAvIFRoZSBsb25nLmpzIEF1dGhvcnMuCiAqCiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwogKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAogKgogKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiAqCiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiAqCiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wCiAqLwovKioKICogQGxpY2Vuc2UKICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPgogKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9ImVzIiAtbyAuL2AKICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPgogKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+CiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+CiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9ycwogKi8K";
const blob$2 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$2)], { type: "text/javascript;charset=utf-8" });
function Worker$3() {
  const objURL = blob$2 && (window.URL || window.webkitURL).createObjectURL(blob$2);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$2, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$2 = 200;
class VcfDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "prevRequestTime");
    __publicField(this, "track");
    __publicField(this, "toFetch");
    __publicField(this, "fetchTimeout");
    __publicField(this, "worker");
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$3()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$2);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    return JSON.parse(new TextDecoder().decode(buf));
  }
}
__publicField(VcfDataFetcher, "config", { type: "vcf" });
const BigInt32 = BigInt(32);
function getBigInt64(dataView, byteOffset, littleEndian) {
  const littleEndianMask = Number(!!littleEndian);
  const bigEndianMask = Number(!littleEndian);
  return BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask + dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) << BigInt32 | BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask + dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask);
}
function getBigUint64(dataView, byteOffset, littleEndian) {
  const a = dataView.getUint32(byteOffset, littleEndian);
  const b = dataView.getUint32(byteOffset + 4, littleEndian);
  const littleEndianMask = Number(!!littleEndian);
  const bigEndianMask = Number(!littleEndian);
  return BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32 | BigInt(a * littleEndianMask + b * bigEndianMask);
}
function setBigInt64(dataView, byteOffset, value, littleEndian) {
  const hi = Number(value >> BigInt32);
  const lo = Number(value & BigInt(4294967295));
  if (littleEndian) {
    dataView.setInt32(byteOffset + 4, hi, littleEndian);
    dataView.setUint32(byteOffset, lo, littleEndian);
  } else {
    dataView.setInt32(byteOffset, hi, littleEndian);
    dataView.setUint32(byteOffset + 4, lo, littleEndian);
  }
}
function setBigUint64(dataView, byteOffset, value, littleEndian) {
  const hi = Number(value >> BigInt32);
  const lo = Number(value & BigInt(4294967295));
  if (littleEndian) {
    dataView.setUint32(byteOffset + 4, hi, littleEndian);
    dataView.setUint32(byteOffset, lo, littleEndian);
  } else {
    dataView.setUint32(byteOffset, hi, littleEndian);
    dataView.setUint32(byteOffset + 4, lo, littleEndian);
  }
}
if (!("getBigInt64" in DataView)) {
  DataView.prototype.getBigInt64 = function(byteOffset, littleEndian) {
    return getBigInt64(this, byteOffset, littleEndian);
  };
}
if (!("getBigUint64" in DataView)) {
  DataView.prototype.getBigUint64 = function(byteOffset, littleEndian) {
    return getBigUint64(this, byteOffset, littleEndian);
  };
}
if (!("setBigInt64" in DataView)) {
  DataView.prototype.setBigInt64 = function(byteOffset, value, littleEndian) {
    setBigInt64(this, byteOffset, value, littleEndian);
  };
}
if (!("setBigUint64" in DataView)) {
  DataView.prototype.setBigUint64 = function(byteOffset, value, littleEndian) {
    setBigUint64(this, byteOffset, value, littleEndian);
  };
}
class Context {
  constructor(importPath, useContextVariables) {
    this.code = "";
    this.scopes = [["vars"]];
    this.bitFields = [];
    this.tmpVariableCount = 0;
    this.references = /* @__PURE__ */ new Map();
    this.imports = [];
    this.reverseImports = /* @__PURE__ */ new Map();
    this.useContextVariables = false;
    this.importPath = importPath;
    this.useContextVariables = useContextVariables;
  }
  generateVariable(name2) {
    const scopes = [...this.scopes[this.scopes.length - 1]];
    if (name2) {
      scopes.push(name2);
    }
    return scopes.join(".");
  }
  generateOption(val) {
    switch (typeof val) {
      case "number":
        return val.toString();
      case "string":
        return this.generateVariable(val);
      case "function":
        return `${this.addImport(val)}.call(${this.generateVariable()}, vars)`;
    }
  }
  generateError(err2) {
    this.pushCode(`throw new Error(${err2});`);
  }
  generateTmpVariable() {
    return "$tmp" + this.tmpVariableCount++;
  }
  pushCode(code) {
    this.code += code + "\n";
  }
  pushPath(name2) {
    if (name2) {
      this.scopes[this.scopes.length - 1].push(name2);
    }
  }
  popPath(name2) {
    if (name2) {
      this.scopes[this.scopes.length - 1].pop();
    }
  }
  pushScope(name2) {
    this.scopes.push([name2]);
  }
  popScope() {
    this.scopes.pop();
  }
  addImport(im) {
    if (!this.importPath)
      return `(${im})`;
    let id = this.reverseImports.get(im);
    if (!id) {
      id = this.imports.push(im) - 1;
      this.reverseImports.set(im, id);
    }
    return `${this.importPath}[${id}]`;
  }
  addReference(alias) {
    if (!this.references.has(alias)) {
      this.references.set(alias, { resolved: false, requested: false });
    }
  }
  markResolved(alias) {
    const reference = this.references.get(alias);
    if (reference) {
      reference.resolved = true;
    }
  }
  markRequested(aliasList) {
    aliasList.forEach((alias) => {
      const reference = this.references.get(alias);
      if (reference) {
        reference.requested = true;
      }
    });
  }
  getUnresolvedReferences() {
    return Array.from(this.references).filter(([_, reference]) => !reference.resolved && !reference.requested).map(([alias, _]) => alias);
  }
}
const aliasRegistry = /* @__PURE__ */ new Map();
const FUNCTION_PREFIX = "___parser_";
const PRIMITIVE_SIZES = {
  uint8: 1,
  uint16le: 2,
  uint16be: 2,
  uint32le: 4,
  uint32be: 4,
  int8: 1,
  int16le: 2,
  int16be: 2,
  int32le: 4,
  int32be: 4,
  int64be: 8,
  int64le: 8,
  uint64be: 8,
  uint64le: 8,
  floatle: 4,
  floatbe: 4,
  doublele: 8,
  doublebe: 8
};
const PRIMITIVE_NAMES = {
  uint8: "Uint8",
  uint16le: "Uint16",
  uint16be: "Uint16",
  uint32le: "Uint32",
  uint32be: "Uint32",
  int8: "Int8",
  int16le: "Int16",
  int16be: "Int16",
  int32le: "Int32",
  int32be: "Int32",
  int64be: "BigInt64",
  int64le: "BigInt64",
  uint64be: "BigUint64",
  uint64le: "BigUint64",
  floatle: "Float32",
  floatbe: "Float32",
  doublele: "Float64",
  doublebe: "Float64"
};
const PRIMITIVE_LITTLE_ENDIANS = {
  uint8: false,
  uint16le: true,
  uint16be: false,
  uint32le: true,
  uint32be: false,
  int8: false,
  int16le: true,
  int16be: false,
  int32le: true,
  int32be: false,
  int64be: false,
  int64le: true,
  uint64be: false,
  uint64le: true,
  floatle: true,
  floatbe: false,
  doublele: true,
  doublebe: false
};
class Parser {
  constructor() {
    this.varName = "";
    this.type = "";
    this.options = {};
    this.endian = "be";
    this.useContextVariables = false;
  }
  static start() {
    return new Parser();
  }
  primitiveGenerateN(type2, ctx) {
    const typeName = PRIMITIVE_NAMES[type2];
    const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
    ctx.pushCode(`${ctx.generateVariable(this.varName)} = dataView.get${typeName}(offset, ${littleEndian});`);
    ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]};`);
  }
  primitiveN(type2, varName, options) {
    return this.setNextParser(type2, varName, options);
  }
  useThisEndian(type2) {
    return type2 + this.endian.toLowerCase();
  }
  uint8(varName, options = {}) {
    return this.primitiveN("uint8", varName, options);
  }
  uint16(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("uint16"), varName, options);
  }
  uint16le(varName, options = {}) {
    return this.primitiveN("uint16le", varName, options);
  }
  uint16be(varName, options = {}) {
    return this.primitiveN("uint16be", varName, options);
  }
  uint32(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("uint32"), varName, options);
  }
  uint32le(varName, options = {}) {
    return this.primitiveN("uint32le", varName, options);
  }
  uint32be(varName, options = {}) {
    return this.primitiveN("uint32be", varName, options);
  }
  int8(varName, options = {}) {
    return this.primitiveN("int8", varName, options);
  }
  int16(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("int16"), varName, options);
  }
  int16le(varName, options = {}) {
    return this.primitiveN("int16le", varName, options);
  }
  int16be(varName, options = {}) {
    return this.primitiveN("int16be", varName, options);
  }
  int32(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("int32"), varName, options);
  }
  int32le(varName, options = {}) {
    return this.primitiveN("int32le", varName, options);
  }
  int32be(varName, options = {}) {
    return this.primitiveN("int32be", varName, options);
  }
  bigIntVersionCheck() {
    if (!DataView.prototype.getBigInt64)
      throw new Error("BigInt64 is unsupported on this runtime");
  }
  int64(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN(this.useThisEndian("int64"), varName, options);
  }
  int64be(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("int64be", varName, options);
  }
  int64le(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("int64le", varName, options);
  }
  uint64(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN(this.useThisEndian("uint64"), varName, options);
  }
  uint64be(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("uint64be", varName, options);
  }
  uint64le(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("uint64le", varName, options);
  }
  floatle(varName, options = {}) {
    return this.primitiveN("floatle", varName, options);
  }
  floatbe(varName, options = {}) {
    return this.primitiveN("floatbe", varName, options);
  }
  doublele(varName, options = {}) {
    return this.primitiveN("doublele", varName, options);
  }
  doublebe(varName, options = {}) {
    return this.primitiveN("doublebe", varName, options);
  }
  bitN(size, varName, options) {
    options.length = size;
    return this.setNextParser("bit", varName, options);
  }
  bit1(varName, options = {}) {
    return this.bitN(1, varName, options);
  }
  bit2(varName, options = {}) {
    return this.bitN(2, varName, options);
  }
  bit3(varName, options = {}) {
    return this.bitN(3, varName, options);
  }
  bit4(varName, options = {}) {
    return this.bitN(4, varName, options);
  }
  bit5(varName, options = {}) {
    return this.bitN(5, varName, options);
  }
  bit6(varName, options = {}) {
    return this.bitN(6, varName, options);
  }
  bit7(varName, options = {}) {
    return this.bitN(7, varName, options);
  }
  bit8(varName, options = {}) {
    return this.bitN(8, varName, options);
  }
  bit9(varName, options = {}) {
    return this.bitN(9, varName, options);
  }
  bit10(varName, options = {}) {
    return this.bitN(10, varName, options);
  }
  bit11(varName, options = {}) {
    return this.bitN(11, varName, options);
  }
  bit12(varName, options = {}) {
    return this.bitN(12, varName, options);
  }
  bit13(varName, options = {}) {
    return this.bitN(13, varName, options);
  }
  bit14(varName, options = {}) {
    return this.bitN(14, varName, options);
  }
  bit15(varName, options = {}) {
    return this.bitN(15, varName, options);
  }
  bit16(varName, options = {}) {
    return this.bitN(16, varName, options);
  }
  bit17(varName, options = {}) {
    return this.bitN(17, varName, options);
  }
  bit18(varName, options = {}) {
    return this.bitN(18, varName, options);
  }
  bit19(varName, options = {}) {
    return this.bitN(19, varName, options);
  }
  bit20(varName, options = {}) {
    return this.bitN(20, varName, options);
  }
  bit21(varName, options = {}) {
    return this.bitN(21, varName, options);
  }
  bit22(varName, options = {}) {
    return this.bitN(22, varName, options);
  }
  bit23(varName, options = {}) {
    return this.bitN(23, varName, options);
  }
  bit24(varName, options = {}) {
    return this.bitN(24, varName, options);
  }
  bit25(varName, options = {}) {
    return this.bitN(25, varName, options);
  }
  bit26(varName, options = {}) {
    return this.bitN(26, varName, options);
  }
  bit27(varName, options = {}) {
    return this.bitN(27, varName, options);
  }
  bit28(varName, options = {}) {
    return this.bitN(28, varName, options);
  }
  bit29(varName, options = {}) {
    return this.bitN(29, varName, options);
  }
  bit30(varName, options = {}) {
    return this.bitN(30, varName, options);
  }
  bit31(varName, options = {}) {
    return this.bitN(31, varName, options);
  }
  bit32(varName, options = {}) {
    return this.bitN(32, varName, options);
  }
  namely(alias) {
    aliasRegistry.set(alias, this);
    this.alias = alias;
    return this;
  }
  skip(length, options = {}) {
    return this.seek(length, options);
  }
  seek(relOffset, options = {}) {
    if (options.assert) {
      throw new Error("assert option on seek is not allowed.");
    }
    return this.setNextParser("seek", "", { length: relOffset });
  }
  string(varName, options) {
    if (!options.zeroTerminated && !options.length && !options.greedy) {
      throw new Error("One of length, zeroTerminated, or greedy must be defined for string.");
    }
    if ((options.zeroTerminated || options.length) && options.greedy) {
      throw new Error("greedy is mutually exclusive with length and zeroTerminated for string.");
    }
    if (options.stripNull && !(options.length || options.greedy)) {
      throw new Error("length or greedy must be defined if stripNull is enabled.");
    }
    options.encoding = options.encoding || "utf8";
    return this.setNextParser("string", varName, options);
  }
  buffer(varName, options) {
    if (!options.length && !options.readUntil) {
      throw new Error("length or readUntil must be defined for buffer.");
    }
    return this.setNextParser("buffer", varName, options);
  }
  wrapped(varName, options) {
    if (typeof options !== "object" && typeof varName === "object") {
      options = varName;
      varName = "";
    }
    if (!options || !options.wrapper || !options.type) {
      throw new Error("Both wrapper and type must be defined for wrapped.");
    }
    if (!options.length && !options.readUntil) {
      throw new Error("length or readUntil must be defined for wrapped.");
    }
    return this.setNextParser("wrapper", varName, options);
  }
  array(varName, options) {
    if (!options.readUntil && !options.length && !options.lengthInBytes) {
      throw new Error("One of readUntil, length and lengthInBytes must be defined for array.");
    }
    if (!options.type) {
      throw new Error("type is required for array.");
    }
    if (typeof options.type === "string" && !aliasRegistry.has(options.type) && !(options.type in PRIMITIVE_SIZES)) {
      throw new Error(`Array element type "${options.type}" is unkown.`);
    }
    return this.setNextParser("array", varName, options);
  }
  choice(varName, options) {
    if (typeof options !== "object" && typeof varName === "object") {
      options = varName;
      varName = "";
    }
    if (!options) {
      throw new Error("tag and choices are are required for choice.");
    }
    if (!options.tag) {
      throw new Error("tag is requird for choice.");
    }
    if (!options.choices) {
      throw new Error("choices is required for choice.");
    }
    for (const keyString in options.choices) {
      const key = parseInt(keyString, 10);
      const value = options.choices[key];
      if (isNaN(key)) {
        throw new Error(`Choice key "${keyString}" is not a number.`);
      }
      if (typeof value === "string" && !aliasRegistry.has(value) && !(value in PRIMITIVE_SIZES)) {
        throw new Error(`Choice type "${value}" is unkown.`);
      }
    }
    return this.setNextParser("choice", varName, options);
  }
  nest(varName, options) {
    if (typeof options !== "object" && typeof varName === "object") {
      options = varName;
      varName = "";
    }
    if (!options || !options.type) {
      throw new Error("type is required for nest.");
    }
    if (!(options.type instanceof Parser) && !aliasRegistry.has(options.type)) {
      throw new Error("type must be a known parser name or a Parser object.");
    }
    if (!(options.type instanceof Parser) && !varName) {
      throw new Error("type must be a Parser object if the variable name is omitted.");
    }
    return this.setNextParser("nest", varName, options);
  }
  pointer(varName, options) {
    if (!options.offset) {
      throw new Error("offset is required for pointer.");
    }
    if (!options.type) {
      throw new Error("type is required for pointer.");
    }
    if (typeof options.type === "string" && !(options.type in PRIMITIVE_SIZES) && !aliasRegistry.has(options.type)) {
      throw new Error(`Pointer type "${options.type}" is unkown.`);
    }
    return this.setNextParser("pointer", varName, options);
  }
  saveOffset(varName, options = {}) {
    return this.setNextParser("saveOffset", varName, options);
  }
  endianness(endianness) {
    switch (endianness.toLowerCase()) {
      case "little":
        this.endian = "le";
        break;
      case "big":
        this.endian = "be";
        break;
      default:
        throw new Error('endianness must be one of "little" or "big"');
    }
    return this;
  }
  endianess(endianess) {
    return this.endianness(endianess);
  }
  useContextVars(useContextVariables = true) {
    this.useContextVariables = useContextVariables;
    return this;
  }
  create(constructorFn) {
    if (!(constructorFn instanceof Function)) {
      throw new Error("Constructor must be a Function object.");
    }
    this.constructorFn = constructorFn;
    return this;
  }
  getContext(importPath) {
    const ctx = new Context(importPath, this.useContextVariables);
    ctx.pushCode("var dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);");
    if (!this.alias) {
      this.addRawCode(ctx);
    } else {
      this.addAliasedCode(ctx);
      ctx.pushCode(`return ${FUNCTION_PREFIX + this.alias}(0).result;`);
    }
    return ctx;
  }
  getCode() {
    const importPath = "imports";
    return this.getContext(importPath).code;
  }
  addRawCode(ctx) {
    ctx.pushCode("var offset = 0;");
    ctx.pushCode(`var vars = ${this.constructorFn ? "new constructorFn()" : "{}"};`);
    ctx.pushCode("vars.$parent = null;");
    ctx.pushCode("vars.$root = vars;");
    this.generate(ctx);
    this.resolveReferences(ctx);
    ctx.pushCode("delete vars.$parent;");
    ctx.pushCode("delete vars.$root;");
    ctx.pushCode("return vars;");
  }
  addAliasedCode(ctx) {
    ctx.pushCode(`function ${FUNCTION_PREFIX + this.alias}(offset, context) {`);
    ctx.pushCode(`var vars = ${this.constructorFn ? "new constructorFn()" : "{}"};`);
    ctx.pushCode("var ctx = Object.assign({$parent: null, $root: vars}, context || {});");
    ctx.pushCode(`vars = Object.assign(vars, ctx);`);
    this.generate(ctx);
    ctx.markResolved(this.alias);
    this.resolveReferences(ctx);
    ctx.pushCode("Object.keys(ctx).forEach(function (item) { delete vars[item]; });");
    ctx.pushCode("return { offset: offset, result: vars };");
    ctx.pushCode("}");
    return ctx;
  }
  resolveReferences(ctx) {
    const references = ctx.getUnresolvedReferences();
    ctx.markRequested(references);
    references.forEach((alias) => {
      var _a;
      (_a = aliasRegistry.get(alias)) === null || _a === void 0 ? void 0 : _a.addAliasedCode(ctx);
    });
  }
  compile() {
    const importPath = "imports";
    const ctx = this.getContext(importPath);
    this.compiled = new Function(importPath, "TextDecoder", `return function (buffer, constructorFn) { ${ctx.code} };`)(ctx.imports, TextDecoder);
  }
  sizeOf() {
    let size = NaN;
    if (Object.keys(PRIMITIVE_SIZES).indexOf(this.type) >= 0) {
      size = PRIMITIVE_SIZES[this.type];
    } else if (this.type === "string" && typeof this.options.length === "number") {
      size = this.options.length;
    } else if (this.type === "buffer" && typeof this.options.length === "number") {
      size = this.options.length;
    } else if (this.type === "array" && typeof this.options.length === "number") {
      let elementSize = NaN;
      if (typeof this.options.type === "string") {
        elementSize = PRIMITIVE_SIZES[this.options.type];
      } else if (this.options.type instanceof Parser) {
        elementSize = this.options.type.sizeOf();
      }
      size = this.options.length * elementSize;
    } else if (this.type === "seek") {
      size = this.options.length;
    } else if (this.type === "nest") {
      size = this.options.type.sizeOf();
    } else if (!this.type) {
      size = 0;
    }
    if (this.next) {
      size += this.next.sizeOf();
    }
    return size;
  }
  // Follow the parser chain till the root and start parsing from there
  parse(buffer) {
    if (!this.compiled) {
      this.compile();
    }
    return this.compiled(buffer, this.constructorFn);
  }
  setNextParser(type2, varName, options) {
    const parser = new Parser();
    parser.type = type2;
    parser.varName = varName;
    parser.options = options;
    parser.endian = this.endian;
    if (this.head) {
      this.head.next = parser;
    } else {
      this.next = parser;
    }
    this.head = parser;
    return this;
  }
  // Call code generator for this parser
  generate(ctx) {
    if (this.type) {
      switch (this.type) {
        case "uint8":
        case "uint16le":
        case "uint16be":
        case "uint32le":
        case "uint32be":
        case "int8":
        case "int16le":
        case "int16be":
        case "int32le":
        case "int32be":
        case "int64be":
        case "int64le":
        case "uint64be":
        case "uint64le":
        case "floatle":
        case "floatbe":
        case "doublele":
        case "doublebe":
          this.primitiveGenerateN(this.type, ctx);
          break;
        case "bit":
          this.generateBit(ctx);
          break;
        case "string":
          this.generateString(ctx);
          break;
        case "buffer":
          this.generateBuffer(ctx);
          break;
        case "seek":
          this.generateSeek(ctx);
          break;
        case "nest":
          this.generateNest(ctx);
          break;
        case "array":
          this.generateArray(ctx);
          break;
        case "choice":
          this.generateChoice(ctx);
          break;
        case "pointer":
          this.generatePointer(ctx);
          break;
        case "saveOffset":
          this.generateSaveOffset(ctx);
          break;
        case "wrapper":
          this.generateWrapper(ctx);
          break;
      }
      if (this.type !== "bit")
        this.generateAssert(ctx);
    }
    const varName = ctx.generateVariable(this.varName);
    if (this.options.formatter && this.type !== "bit") {
      this.generateFormatter(ctx, varName, this.options.formatter);
    }
    return this.generateNext(ctx);
  }
  generateAssert(ctx) {
    if (!this.options.assert) {
      return;
    }
    const varName = ctx.generateVariable(this.varName);
    switch (typeof this.options.assert) {
      case "function":
        {
          const func = ctx.addImport(this.options.assert);
          ctx.pushCode(`if (!${func}.call(vars, ${varName})) {`);
        }
        break;
      case "number":
        ctx.pushCode(`if (${this.options.assert} !== ${varName}) {`);
        break;
      case "string":
        ctx.pushCode(`if (${JSON.stringify(this.options.assert)} !== ${varName}) {`);
        break;
      default:
        throw new Error("assert option must be a string, number or a function.");
    }
    ctx.generateError(`"Assertion error: ${varName} is " + ${JSON.stringify(this.options.assert.toString())}`);
    ctx.pushCode("}");
  }
  // Recursively call code generators and append results
  generateNext(ctx) {
    if (this.next) {
      ctx = this.next.generate(ctx);
    }
    return ctx;
  }
  generateBit(ctx) {
    const parser = JSON.parse(JSON.stringify(this));
    parser.options = this.options;
    parser.generateAssert = this.generateAssert.bind(this);
    parser.generateFormatter = this.generateFormatter.bind(this);
    parser.varName = ctx.generateVariable(parser.varName);
    ctx.bitFields.push(parser);
    if (!this.next || this.next && ["bit", "nest"].indexOf(this.next.type) < 0) {
      const val = ctx.generateTmpVariable();
      ctx.pushCode(`var ${val} = 0;`);
      const getMaxBits = (from = 0) => {
        let sum3 = 0;
        for (let i = from; i < ctx.bitFields.length; i++) {
          const length = ctx.bitFields[i].options.length;
          if (sum3 + length > 32)
            break;
          sum3 += length;
        }
        return sum3;
      };
      const getBytes = (sum3) => {
        if (sum3 <= 8) {
          ctx.pushCode(`${val} = dataView.getUint8(offset);`);
          sum3 = 8;
        } else if (sum3 <= 16) {
          ctx.pushCode(`${val} = dataView.getUint16(offset);`);
          sum3 = 16;
        } else if (sum3 <= 24) {
          ctx.pushCode(`${val} = (dataView.getUint16(offset) << 8) | dataView.getUint8(offset + 2);`);
          sum3 = 24;
        } else {
          ctx.pushCode(`${val} = dataView.getUint32(offset);`);
          sum3 = 32;
        }
        ctx.pushCode(`offset += ${sum3 / 8};`);
        return sum3;
      };
      let bitOffset = 0;
      const isBigEndian = this.endian === "be";
      let sum2 = 0;
      let rem = 0;
      ctx.bitFields.forEach((parser2, i) => {
        let length = parser2.options.length;
        if (length > rem) {
          if (rem) {
            const mask2 = -1 >>> 32 - rem;
            ctx.pushCode(`${parser2.varName} = (${val} & 0x${mask2.toString(16)}) << ${length - rem};`);
            length -= rem;
          }
          bitOffset = 0;
          rem = sum2 = getBytes(getMaxBits(i) - rem);
        }
        const offset = isBigEndian ? sum2 - bitOffset - length : bitOffset;
        const mask = -1 >>> 32 - length;
        ctx.pushCode(`${parser2.varName} ${length < parser2.options.length ? "|=" : "="} ${val} >> ${offset} & 0x${mask.toString(16)};`);
        if (parser2.options.length === 32) {
          ctx.pushCode(`${parser2.varName} >>>= 0`);
        }
        if (parser2.options.assert) {
          parser2.generateAssert(ctx);
        }
        if (parser2.options.formatter) {
          parser2.generateFormatter(ctx, parser2.varName, parser2.options.formatter);
        }
        bitOffset += length;
        rem -= length;
      });
      ctx.bitFields = [];
    }
  }
  generateSeek(ctx) {
    const length = ctx.generateOption(this.options.length);
    ctx.pushCode(`offset += ${length};`);
  }
  generateString(ctx) {
    const name2 = ctx.generateVariable(this.varName);
    const start = ctx.generateTmpVariable();
    const encoding = this.options.encoding;
    const isHex = encoding.toLowerCase() === "hex";
    const toHex = 'b => b.toString(16).padStart(2, "0")';
    if (this.options.length && this.options.zeroTerminated) {
      const len = this.options.length;
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode(`while(dataView.getUint8(offset++) !== 0 && offset - ${start} < ${len});`);
      const end = `offset - ${start} < ${len} ? offset - 1 : offset`;
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(${start}, ${end}), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, ${end}));`);
    } else if (this.options.length) {
      const len = ctx.generateOption(this.options.length);
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(offset, offset + ${len}), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(offset, offset + ${len}));`);
      ctx.pushCode(`offset += ${len};`);
    } else if (this.options.zeroTerminated) {
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode("while(dataView.getUint8(offset++) !== 0);");
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(${start}, offset - 1), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, offset - 1));`);
    } else if (this.options.greedy) {
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode("while(buffer.length > offset++);");
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(${start}, offset), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, offset));`);
    }
    if (this.options.stripNull) {
      ctx.pushCode(`${name2} = ${name2}.replace(/\\x00+$/g, '')`);
    }
  }
  generateBuffer(ctx) {
    const varName = ctx.generateVariable(this.varName);
    if (typeof this.options.readUntil === "function") {
      const pred = this.options.readUntil;
      const start = ctx.generateTmpVariable();
      const cur = ctx.generateTmpVariable();
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode(`var ${cur} = 0;`);
      ctx.pushCode(`while (offset < buffer.length) {`);
      ctx.pushCode(`${cur} = dataView.getUint8(offset);`);
      const func = ctx.addImport(pred);
      ctx.pushCode(`if (${func}.call(${ctx.generateVariable()}, ${cur}, buffer.subarray(offset))) break;`);
      ctx.pushCode(`offset += 1;`);
      ctx.pushCode(`}`);
      ctx.pushCode(`${varName} = buffer.subarray(${start}, offset);`);
    } else if (this.options.readUntil === "eof") {
      ctx.pushCode(`${varName} = buffer.subarray(offset);`);
    } else {
      const len = ctx.generateOption(this.options.length);
      ctx.pushCode(`${varName} = buffer.subarray(offset, offset + ${len});`);
      ctx.pushCode(`offset += ${len};`);
    }
    if (this.options.clone) {
      ctx.pushCode(`${varName} = buffer.constructor.from(${varName});`);
    }
  }
  generateArray(ctx) {
    const length = ctx.generateOption(this.options.length);
    const lengthInBytes = ctx.generateOption(this.options.lengthInBytes);
    const type2 = this.options.type;
    const counter = ctx.generateTmpVariable();
    const lhs = ctx.generateVariable(this.varName);
    const item = ctx.generateTmpVariable();
    const key = this.options.key;
    const isHash = typeof key === "string";
    if (isHash) {
      ctx.pushCode(`${lhs} = {};`);
    } else {
      ctx.pushCode(`${lhs} = [];`);
    }
    if (typeof this.options.readUntil === "function") {
      ctx.pushCode("do {");
    } else if (this.options.readUntil === "eof") {
      ctx.pushCode(`for (var ${counter} = 0; offset < buffer.length; ${counter}++) {`);
    } else if (lengthInBytes !== void 0) {
      ctx.pushCode(`for (var ${counter} = offset + ${lengthInBytes}; offset < ${counter}; ) {`);
    } else {
      ctx.pushCode(`for (var ${counter} = ${length}; ${counter} > 0; ${counter}--) {`);
    }
    if (typeof type2 === "string") {
      if (!aliasRegistry.get(type2)) {
        const typeName = PRIMITIVE_NAMES[type2];
        const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
        ctx.pushCode(`var ${item} = dataView.get${typeName}(offset, ${littleEndian});`);
        ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]};`);
      } else {
        const tempVar = ctx.generateTmpVariable();
        ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + type2}(offset, {`);
        if (ctx.useContextVariables) {
          const parentVar = ctx.generateVariable();
          ctx.pushCode(`$parent: ${parentVar},`);
          ctx.pushCode(`$root: ${parentVar}.$root,`);
          if (!this.options.readUntil && lengthInBytes === void 0) {
            ctx.pushCode(`$index: ${length} - ${counter},`);
          }
        }
        ctx.pushCode(`});`);
        ctx.pushCode(`var ${item} = ${tempVar}.result; offset = ${tempVar}.offset;`);
        if (type2 !== this.alias)
          ctx.addReference(type2);
      }
    } else if (type2 instanceof Parser) {
      ctx.pushCode(`var ${item} = {};`);
      const parentVar = ctx.generateVariable();
      ctx.pushScope(item);
      if (ctx.useContextVariables) {
        ctx.pushCode(`${item}.$parent = ${parentVar};`);
        ctx.pushCode(`${item}.$root = ${parentVar}.$root;`);
        if (!this.options.readUntil && lengthInBytes === void 0) {
          ctx.pushCode(`${item}.$index = ${length} - ${counter};`);
        }
      }
      type2.generate(ctx);
      if (ctx.useContextVariables) {
        ctx.pushCode(`delete ${item}.$parent;`);
        ctx.pushCode(`delete ${item}.$root;`);
        ctx.pushCode(`delete ${item}.$index;`);
      }
      ctx.popScope();
    }
    if (isHash) {
      ctx.pushCode(`${lhs}[${item}.${key}] = ${item};`);
    } else {
      ctx.pushCode(`${lhs}.push(${item});`);
    }
    ctx.pushCode("}");
    if (typeof this.options.readUntil === "function") {
      const pred = this.options.readUntil;
      const func = ctx.addImport(pred);
      ctx.pushCode(`while (!${func}.call(${ctx.generateVariable()}, ${item}, buffer.subarray(offset)));`);
    }
  }
  generateChoiceCase(ctx, varName, type2) {
    if (typeof type2 === "string") {
      const varName2 = ctx.generateVariable(this.varName);
      if (!aliasRegistry.has(type2)) {
        const typeName = PRIMITIVE_NAMES[type2];
        const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
        ctx.pushCode(`${varName2} = dataView.get${typeName}(offset, ${littleEndian});`);
        ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]}`);
      } else {
        const tempVar = ctx.generateTmpVariable();
        ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + type2}(offset, {`);
        if (ctx.useContextVariables) {
          ctx.pushCode(`$parent: ${varName2}.$parent,`);
          ctx.pushCode(`$root: ${varName2}.$root,`);
        }
        ctx.pushCode(`});`);
        ctx.pushCode(`${varName2} = ${tempVar}.result; offset = ${tempVar}.offset;`);
        if (type2 !== this.alias)
          ctx.addReference(type2);
      }
    } else if (type2 instanceof Parser) {
      ctx.pushPath(varName);
      type2.generate(ctx);
      ctx.popPath(varName);
    }
  }
  generateChoice(ctx) {
    const tag = ctx.generateOption(this.options.tag);
    const nestVar = ctx.generateVariable(this.varName);
    if (this.varName) {
      ctx.pushCode(`${nestVar} = {};`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
        ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
      }
    }
    ctx.pushCode(`switch(${tag}) {`);
    for (const tagString in this.options.choices) {
      const tag2 = parseInt(tagString, 10);
      const type2 = this.options.choices[tag2];
      ctx.pushCode(`case ${tag2}:`);
      this.generateChoiceCase(ctx, this.varName, type2);
      ctx.pushCode("break;");
    }
    ctx.pushCode("default:");
    if (this.options.defaultChoice) {
      this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);
    } else {
      ctx.generateError(`"Met undefined tag value " + ${tag} + " at choice"`);
    }
    ctx.pushCode("}");
    if (this.varName && ctx.useContextVariables) {
      ctx.pushCode(`delete ${nestVar}.$parent;`);
      ctx.pushCode(`delete ${nestVar}.$root;`);
    }
  }
  generateNest(ctx) {
    const nestVar = ctx.generateVariable(this.varName);
    if (this.options.type instanceof Parser) {
      if (this.varName) {
        ctx.pushCode(`${nestVar} = {};`);
        if (ctx.useContextVariables) {
          const parentVar = ctx.generateVariable();
          ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
          ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
        }
      }
      ctx.pushPath(this.varName);
      this.options.type.generate(ctx);
      ctx.popPath(this.varName);
      if (this.varName && ctx.useContextVariables) {
        if (ctx.useContextVariables) {
          ctx.pushCode(`delete ${nestVar}.$parent;`);
          ctx.pushCode(`delete ${nestVar}.$root;`);
        }
      }
    } else if (aliasRegistry.has(this.options.type)) {
      const tempVar = ctx.generateTmpVariable();
      ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(offset, {`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`$parent: ${parentVar},`);
        ctx.pushCode(`$root: ${parentVar}.$root,`);
      }
      ctx.pushCode(`});`);
      ctx.pushCode(`${nestVar} = ${tempVar}.result; offset = ${tempVar}.offset;`);
      if (this.options.type !== this.alias) {
        ctx.addReference(this.options.type);
      }
    }
  }
  generateWrapper(ctx) {
    const wrapperVar = ctx.generateVariable(this.varName);
    const wrappedBuf = ctx.generateTmpVariable();
    if (typeof this.options.readUntil === "function") {
      const pred = this.options.readUntil;
      const start = ctx.generateTmpVariable();
      const cur = ctx.generateTmpVariable();
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode(`var ${cur} = 0;`);
      ctx.pushCode(`while (offset < buffer.length) {`);
      ctx.pushCode(`${cur} = dataView.getUint8(offset);`);
      const func2 = ctx.addImport(pred);
      ctx.pushCode(`if (${func2}.call(${ctx.generateVariable()}, ${cur}, buffer.subarray(offset))) break;`);
      ctx.pushCode(`offset += 1;`);
      ctx.pushCode(`}`);
      ctx.pushCode(`${wrappedBuf} = buffer.subarray(${start}, offset);`);
    } else if (this.options.readUntil === "eof") {
      ctx.pushCode(`${wrappedBuf} = buffer.subarray(offset);`);
    } else {
      const len = ctx.generateOption(this.options.length);
      ctx.pushCode(`${wrappedBuf} = buffer.subarray(offset, offset + ${len});`);
      ctx.pushCode(`offset += ${len};`);
    }
    if (this.options.clone) {
      ctx.pushCode(`${wrappedBuf} = buffer.constructor.from(${wrappedBuf});`);
    }
    const tempBuf = ctx.generateTmpVariable();
    const tempOff = ctx.generateTmpVariable();
    const tempView = ctx.generateTmpVariable();
    const func = ctx.addImport(this.options.wrapper);
    ctx.pushCode(`${wrappedBuf} = ${func}.call(this, ${wrappedBuf}).subarray(0);`);
    ctx.pushCode(`var ${tempBuf} = buffer;`);
    ctx.pushCode(`var ${tempOff} = offset;`);
    ctx.pushCode(`var ${tempView} = dataView;`);
    ctx.pushCode(`buffer = ${wrappedBuf};`);
    ctx.pushCode(`offset = 0;`);
    ctx.pushCode(`dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);`);
    if (this.options.type instanceof Parser) {
      if (this.varName) {
        ctx.pushCode(`${wrapperVar} = {};`);
      }
      ctx.pushPath(this.varName);
      this.options.type.generate(ctx);
      ctx.popPath(this.varName);
    } else if (aliasRegistry.has(this.options.type)) {
      const tempVar = ctx.generateTmpVariable();
      ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(0);`);
      ctx.pushCode(`${wrapperVar} = ${tempVar}.result;`);
      if (this.options.type !== this.alias) {
        ctx.addReference(this.options.type);
      }
    }
    ctx.pushCode(`buffer = ${tempBuf};`);
    ctx.pushCode(`dataView = ${tempView};`);
    ctx.pushCode(`offset = ${tempOff};`);
  }
  generateFormatter(ctx, varName, formatter) {
    if (typeof formatter === "function") {
      const func = ctx.addImport(formatter);
      ctx.pushCode(`${varName} = ${func}.call(${ctx.generateVariable()}, ${varName});`);
    }
  }
  generatePointer(ctx) {
    const type2 = this.options.type;
    const offset = ctx.generateOption(this.options.offset);
    const tempVar = ctx.generateTmpVariable();
    const nestVar = ctx.generateVariable(this.varName);
    ctx.pushCode(`var ${tempVar} = offset;`);
    ctx.pushCode(`offset = ${offset};`);
    if (this.options.type instanceof Parser) {
      ctx.pushCode(`${nestVar} = {};`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
        ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
      }
      ctx.pushPath(this.varName);
      this.options.type.generate(ctx);
      ctx.popPath(this.varName);
      if (ctx.useContextVariables) {
        ctx.pushCode(`delete ${nestVar}.$parent;`);
        ctx.pushCode(`delete ${nestVar}.$root;`);
      }
    } else if (aliasRegistry.has(this.options.type)) {
      const tempVar2 = ctx.generateTmpVariable();
      ctx.pushCode(`var ${tempVar2} = ${FUNCTION_PREFIX + this.options.type}(offset, {`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`$parent: ${parentVar},`);
        ctx.pushCode(`$root: ${parentVar}.$root,`);
      }
      ctx.pushCode(`});`);
      ctx.pushCode(`${nestVar} = ${tempVar2}.result; offset = ${tempVar2}.offset;`);
      if (this.options.type !== this.alias) {
        ctx.addReference(this.options.type);
      }
    } else if (Object.keys(PRIMITIVE_SIZES).indexOf(this.options.type) >= 0) {
      const typeName = PRIMITIVE_NAMES[type2];
      const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
      ctx.pushCode(`${nestVar} = dataView.get${typeName}(offset, ${littleEndian});`);
      ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]};`);
    }
    ctx.pushCode(`offset = ${tempVar};`);
  }
  generateSaveOffset(ctx) {
    const varName = ctx.generateVariable(this.varName);
    ctx.pushCode(`${varName} = offset`);
  }
}
var esm = {};
var AbortablePromiseCache$1 = {};
var abortcontrollerPonyfill = {};
var cjsPonyfill = {};
Object.defineProperty(cjsPonyfill, "__esModule", { value: true });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var Emitter = /* @__PURE__ */ function() {
  function Emitter2() {
    _classCallCheck(this, Emitter2);
    Object.defineProperty(this, "listeners", {
      value: {},
      writable: true,
      configurable: true
    });
  }
  _createClass(Emitter2, [{
    key: "addEventListener",
    value: function addEventListener(type2, callback, options) {
      if (!(type2 in this.listeners)) {
        this.listeners[type2] = [];
      }
      this.listeners[type2].push({
        callback,
        options
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type2, callback) {
      if (!(type2 in this.listeners)) {
        return;
      }
      var stack = this.listeners[type2];
      for (var i = 0, l = stack.length; i < l; i++) {
        if (stack[i].callback === callback) {
          stack.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (!(event.type in this.listeners)) {
        return;
      }
      var stack = this.listeners[event.type];
      var stackToCall = stack.slice();
      for (var i = 0, l = stackToCall.length; i < l; i++) {
        var listener = stackToCall[i];
        try {
          listener.callback.call(this, event);
        } catch (e) {
          Promise.resolve().then(function() {
            throw e;
          });
        }
        if (listener.options && listener.options.once) {
          this.removeEventListener(event.type, listener.callback);
        }
      }
      return !event.defaultPrevented;
    }
  }]);
  return Emitter2;
}();
var AbortSignal$1 = /* @__PURE__ */ function(_Emitter) {
  _inherits(AbortSignal2, _Emitter);
  var _super = _createSuper(AbortSignal2);
  function AbortSignal2() {
    var _this;
    _classCallCheck(this, AbortSignal2);
    _this = _super.call(this);
    if (!_this.listeners) {
      Emitter.call(_assertThisInitialized(_this));
    }
    Object.defineProperty(_assertThisInitialized(_this), "aborted", {
      value: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), "onabort", {
      value: null,
      writable: true,
      configurable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), "reason", {
      value: void 0,
      writable: true,
      configurable: true
    });
    return _this;
  }
  _createClass(AbortSignal2, [{
    key: "toString",
    value: function toString2() {
      return "[object AbortSignal]";
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (event.type === "abort") {
        this.aborted = true;
        if (typeof this.onabort === "function") {
          this.onabort.call(this, event);
        }
      }
      _get(_getPrototypeOf(AbortSignal2.prototype), "dispatchEvent", this).call(this, event);
    }
  }]);
  return AbortSignal2;
}(Emitter);
var AbortController$1 = /* @__PURE__ */ function() {
  function AbortController2() {
    _classCallCheck(this, AbortController2);
    Object.defineProperty(this, "signal", {
      value: new AbortSignal$1(),
      writable: true,
      configurable: true
    });
  }
  _createClass(AbortController2, [{
    key: "abort",
    value: function abort(reason) {
      var event;
      try {
        event = new Event("abort");
      } catch (e) {
        if (typeof document !== "undefined") {
          if (!document.createEvent) {
            event = document.createEventObject();
            event.type = "abort";
          } else {
            event = document.createEvent("Event");
            event.initEvent("abort", false, false);
          }
        } else {
          event = {
            type: "abort",
            bubbles: false,
            cancelable: false
          };
        }
      }
      var signalReason = reason;
      if (signalReason === void 0) {
        if (typeof document === "undefined") {
          signalReason = new Error("This operation was aborted");
          signalReason.name = "AbortError";
        } else {
          try {
            signalReason = new DOMException("signal is aborted without reason");
          } catch (err2) {
            signalReason = new Error("This operation was aborted");
            signalReason.name = "AbortError";
          }
        }
      }
      this.signal.reason = signalReason;
      this.signal.dispatchEvent(event);
    }
  }, {
    key: "toString",
    value: function toString2() {
      return "[object AbortController]";
    }
  }]);
  return AbortController2;
}();
if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
  AbortController$1.prototype[Symbol.toStringTag] = "AbortController";
  AbortSignal$1.prototype[Symbol.toStringTag] = "AbortSignal";
}
function polyfillNeeded(self2) {
  if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
    console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
    return true;
  }
  return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
}
function abortableFetchDecorator(patchTargets) {
  if ("function" === typeof patchTargets) {
    patchTargets = {
      fetch: patchTargets
    };
  }
  var _patchTargets = patchTargets, fetch = _patchTargets.fetch, _patchTargets$Request = _patchTargets.Request, NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request, NativeAbortController = _patchTargets.AbortController, _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;
  if (!polyfillNeeded({
    fetch,
    Request: NativeRequest,
    AbortController: NativeAbortController,
    __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
  })) {
    return {
      fetch,
      Request
    };
  }
  var Request = NativeRequest;
  if (Request && !Request.prototype.hasOwnProperty("signal") || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
    Request = function Request2(input, init2) {
      var signal;
      if (init2 && init2.signal) {
        signal = init2.signal;
        delete init2.signal;
      }
      var request = new NativeRequest(input, init2);
      if (signal) {
        Object.defineProperty(request, "signal", {
          writable: false,
          enumerable: false,
          configurable: true,
          value: signal
        });
      }
      return request;
    };
    Request.prototype = NativeRequest.prototype;
  }
  var realFetch = fetch;
  var abortableFetch = function abortableFetch2(input, init2) {
    var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init2 ? init2.signal : void 0;
    if (signal) {
      var abortError;
      try {
        abortError = new DOMException("Aborted", "AbortError");
      } catch (err2) {
        abortError = new Error("Aborted");
        abortError.name = "AbortError";
      }
      if (signal.aborted) {
        return Promise.reject(abortError);
      }
      var cancellation = new Promise(function(_, reject) {
        signal.addEventListener("abort", function() {
          return reject(abortError);
        }, {
          once: true
        });
      });
      if (init2 && init2.signal) {
        delete init2.signal;
      }
      return Promise.race([cancellation, realFetch(input, init2)]);
    }
    return realFetch(input, init2);
  };
  return {
    fetch: abortableFetch,
    Request
  };
}
cjsPonyfill.AbortController = AbortController$1;
cjsPonyfill.AbortSignal = AbortSignal$1;
cjsPonyfill.abortableFetch = abortableFetchDecorator;
Object.defineProperty(abortcontrollerPonyfill, "__esModule", { value: true });
abortcontrollerPonyfill.AbortSignal = abortcontrollerPonyfill.AbortController = void 0;
const cjs_ponyfill_1 = cjsPonyfill;
var getGlobal = function() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof commonjsGlobal !== "undefined") {
    return commonjsGlobal;
  }
  throw new Error("unable to locate global object");
};
let AbortController = typeof getGlobal().AbortController === "undefined" ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;
abortcontrollerPonyfill.AbortController = AbortController;
let AbortSignal = typeof getGlobal().AbortController === "undefined" ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;
abortcontrollerPonyfill.AbortSignal = AbortSignal;
var AggregateAbortController$1 = {};
Object.defineProperty(AggregateAbortController$1, "__esModule", { value: true });
const abortcontroller_ponyfill_1$1 = abortcontrollerPonyfill;
class NullSignal {
}
class AggregateAbortController {
  constructor() {
    this.signals = /* @__PURE__ */ new Set();
    this.abortController = new abortcontroller_ponyfill_1$1.AbortController();
  }
  /**
   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,
   *  will be treated as a null-signal, and this abortcontroller will no
   *  longer be abortable.
   */
  //@ts-ignore
  addSignal(signal = new NullSignal()) {
    if (this.signal.aborted) {
      throw new Error("cannot add a signal, already aborted!");
    }
    this.signals.add(signal);
    if (signal.aborted) {
      this.handleAborted(signal);
    } else if (typeof signal.addEventListener === "function") {
      signal.addEventListener("abort", () => {
        this.handleAborted(signal);
      });
    }
  }
  handleAborted(signal) {
    this.signals.delete(signal);
    if (this.signals.size === 0) {
      this.abortController.abort();
    }
  }
  get signal() {
    return this.abortController.signal;
  }
  abort() {
    this.abortController.abort();
  }
}
AggregateAbortController$1.default = AggregateAbortController;
var AggregateStatusReporter$1 = {};
Object.defineProperty(AggregateStatusReporter$1, "__esModule", { value: true });
class AggregateStatusReporter {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
  }
  addCallback(callback = () => {
  }) {
    this.callbacks.add(callback);
    callback(this.currentMessage);
  }
  callback(message) {
    this.currentMessage = message;
    this.callbacks.forEach((elt) => {
      elt(message);
    });
  }
}
AggregateStatusReporter$1.default = AggregateStatusReporter;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(AbortablePromiseCache$1, "__esModule", { value: true });
const abortcontroller_ponyfill_1 = abortcontrollerPonyfill;
const AggregateAbortController_1 = __importDefault$1(AggregateAbortController$1);
const AggregateStatusReporter_1 = __importDefault$1(AggregateStatusReporter$1);
class AbortablePromiseCache {
  constructor({ fill, cache: cache2 }) {
    if (typeof fill !== "function") {
      throw new TypeError("must pass a fill function");
    }
    if (typeof cache2 !== "object") {
      throw new TypeError("must pass a cache object");
    }
    if (typeof cache2.get !== "function" || typeof cache2.set !== "function" || typeof cache2.delete !== "function") {
      throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");
    }
    this.cache = cache2;
    this.fillCallback = fill;
  }
  static isAbortException(exception) {
    return (
      // DOMException
      exception.name === "AbortError" || // standard-ish non-DOM abort exception
      //@ts-ignore
      exception.code === "ERR_ABORTED" || // stringified DOMException
      exception.message === "AbortError: aborted" || // stringified standard-ish exception
      exception.message === "Error: aborted"
    );
  }
  evict(key, entry) {
    if (this.cache.get(key) === entry) {
      this.cache.delete(key);
    }
  }
  fill(key, data2, signal, statusCallback) {
    const aborter = new AggregateAbortController_1.default();
    const statusReporter = new AggregateStatusReporter_1.default();
    statusReporter.addCallback(statusCallback);
    const newEntry = {
      aborter,
      promise: this.fillCallback(data2, aborter.signal, (message) => {
        statusReporter.callback(message);
      }),
      settled: false,
      statusReporter,
      get aborted() {
        return this.aborter.signal.aborted;
      }
    };
    newEntry.aborter.addSignal(signal);
    newEntry.aborter.signal.addEventListener("abort", () => {
      if (!newEntry.settled) {
        this.evict(key, newEntry);
      }
    });
    newEntry.promise.then(() => {
      newEntry.settled = true;
    }, () => {
      newEntry.settled = true;
      this.evict(key, newEntry);
    }).catch((e) => {
      console.error(e);
      throw e;
    });
    this.cache.set(key, newEntry);
  }
  static checkSinglePromise(promise, signal) {
    function checkForSingleAbort() {
      if (signal && signal.aborted) {
        throw Object.assign(new Error("aborted"), { code: "ERR_ABORTED" });
      }
    }
    return promise.then((result) => {
      checkForSingleAbort();
      return result;
    }, (error) => {
      checkForSingleAbort();
      throw error;
    });
  }
  has(key) {
    return this.cache.has(key);
  }
  /**
   * Callback for getting status of the pending async
   *
   * @callback statusCallback
   * @param {any} status, current status string or message object
   */
  /**
   * @param {any} key cache key to use for this request
   * @param {any} data data passed as the first argument to the fill callback
   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request
   * @param {statusCallback} a callback to get the current status of a pending async operation
   */
  get(key, data2, signal, statusCallback) {
    if (!signal && data2 instanceof abortcontroller_ponyfill_1.AbortSignal) {
      throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");
    }
    const cacheEntry = this.cache.get(key);
    if (cacheEntry) {
      if (cacheEntry.aborted && !cacheEntry.settled) {
        this.evict(key, cacheEntry);
        return this.get(key, data2, signal, statusCallback);
      }
      if (cacheEntry.settled) {
        return cacheEntry.promise;
      }
      cacheEntry.aborter.addSignal(signal);
      cacheEntry.statusReporter.addCallback(statusCallback);
      return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);
    }
    this.fill(key, data2, signal, statusCallback);
    return AbortablePromiseCache.checkSinglePromise(
      //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-
      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.cache.get(key).promise,
      signal
    );
  }
  /**
   * delete the given entry from the cache. if it exists and its fill request has
   * not yet settled, the fill will be signaled to abort.
   *
   * @param {any} key
   */
  delete(key) {
    const cachedEntry = this.cache.get(key);
    if (cachedEntry) {
      if (!cachedEntry.settled) {
        cachedEntry.aborter.abort();
      }
      this.cache.delete(key);
    }
  }
  /**
   * Clear all requests from the cache. Aborts any that have not settled.
   * @returns {number} count of entries deleted
   */
  clear() {
    const keyIter = this.cache.keys();
    let deleteCount = 0;
    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {
      this.delete(result.value);
      deleteCount += 1;
    }
    return deleteCount;
  }
}
AbortablePromiseCache$1.default = AbortablePromiseCache;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(esm, "__esModule", { value: true });
const AbortablePromiseCache_1 = __importDefault(AbortablePromiseCache$1);
var _default = esm.default = AbortablePromiseCache_1.default;
class Range {
  constructor(arg1, arg2) {
    this.ranges = arguments.length === 2 ? [{ min: arg1, max: arg2 }] : 0 in arg1 ? Object.assign({}, arg1) : [arg1];
  }
  min() {
    return this.ranges[0].min;
  }
  max() {
    return this.ranges[this.ranges.length - 1].max;
  }
  contains(pos) {
    for (let s = 0; s < this.ranges.length; s += 1) {
      const r = this.ranges[s];
      if (r.min <= pos && r.max >= pos) {
        return true;
      }
    }
    return false;
  }
  isContiguous() {
    return this.ranges.length > 1;
  }
  getRanges() {
    return this.ranges.map((r) => new Range(r.min, r.max));
  }
  toString() {
    return this.ranges.map((r) => `[${r.min}-${r.max}]`).join(",");
  }
  union(s1) {
    const ranges = this.getRanges().concat(s1.getRanges()).sort(this.rangeOrder);
    const oranges = [];
    let current = ranges[0];
    for (let i = 1; i < ranges.length; i += 1) {
      const nxt = ranges[i];
      if (nxt.min() > current.max() + 1) {
        oranges.push(current);
        current = nxt;
      } else if (nxt.max() > current.max()) {
        current = new Range(current.min(), nxt.max());
      }
    }
    oranges.push(current);
    if (oranges.length === 1) {
      return oranges[0];
    }
    return new Range(oranges);
  }
  intersection(arg) {
    let s0 = this;
    let s1 = arg;
    const r0 = this.ranges();
    const r1 = s1.ranges();
    const l0 = r0.length;
    const l1 = r1.length;
    let i0 = 0;
    let i1 = 0;
    const or = [];
    while (i0 < l0 && i1 < l1) {
      s0 = r0[i0];
      s1 = r1[i1];
      const lapMin = Math.max(s0.min(), s1.min());
      const lapMax = Math.min(s0.max(), s1.max());
      if (lapMax >= lapMin) {
        or.push(new Range(lapMin, lapMax));
      }
      if (s0.max() > s1.max()) {
        i1 += 1;
      } else {
        i0 += 1;
      }
    }
    if (or.length === 0) {
      throw new Error("found range of length 0");
    }
    if (or.length === 1) {
      return or[0];
    }
    return new Range(or);
  }
  coverage() {
    let tot = 0;
    const rl = this.ranges();
    for (let ri = 0; ri < rl.length; ri += 1) {
      const r = rl[ri];
      tot += r.max() - r.min() + 1;
    }
    return tot;
  }
  rangeOrder(tmpa, tmpb) {
    let a = tmpa;
    let b = tmpb;
    if (arguments.length < 2) {
      b = a;
      a = this;
    }
    if (a.min() < b.min()) {
      return -1;
    }
    if (a.min() > b.min()) {
      return 1;
    }
    if (a.max() < b.max()) {
      return -1;
    }
    if (b.max() > a.max()) {
      return 1;
    }
    return 0;
  }
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m2;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m2 = s.heap[--h];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m2, depth) => {
  const _n2 = n * 2;
  const _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
};
const pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m2;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m2;
    tree[node * 2] = tree[n * 2] + tree[m2 * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m2] ? s.depth[n] : s.depth[m2]) + 1;
    tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s) => {
  let n, m2;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m2 = s.head[--p];
    s.head[p] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m2 = s.prev[--p];
    s.prev[p] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data2) => (prev << s.hash_shift ^ data2) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  const len = max2 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max2));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data2 === "string") {
    strm.input = strings.string2buf(data2);
  } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min2 = 0, max2 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type2 === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$2 = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString$2.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflateRaw_1 = inflateRaw;
function unzip(input) {
  return inflateRaw_1(input.subarray(2));
}
class AbortError extends Error {
  constructor(message) {
    super(message);
    this.code = "ERR_ABORTED";
  }
}
function groupBlocks(blocks) {
  blocks.sort((b0, b1) => Number(b0.offset) - Number(b1.offset));
  const blockGroups = [];
  let lastBlock;
  let lastBlockEnd;
  for (let i = 0; i < blocks.length; i += 1) {
    if (lastBlock && lastBlockEnd && Number(blocks[i].offset) - lastBlockEnd <= 2e3) {
      lastBlock.length = BigInt(Number(lastBlock.length) + Number(blocks[i].length) - lastBlockEnd + Number(blocks[i].offset));
      lastBlock.blocks.push(blocks[i]);
    } else {
      blockGroups.push(lastBlock = {
        blocks: [blocks[i]],
        length: blocks[i].length,
        offset: blocks[i].offset
      });
    }
    lastBlockEnd = Number(lastBlock.offset) + Number(lastBlock.length);
  }
  return blockGroups;
}
function checkAbortSignal(signal) {
  if (!signal) {
    return;
  }
  if (signal.aborted) {
    if (typeof DOMException !== "undefined") {
      throw new DOMException("aborted", "AbortError");
    } else {
      const e = new AbortError("aborted");
      e.code = "ERR_ABORTED";
      throw e;
    }
  }
}
const BIG_WIG_TYPE_GRAPH = 1;
const BIG_WIG_TYPE_VSTEP = 2;
const BIG_WIG_TYPE_FSTEP = 3;
function coordFilter(s1, e1, s2, e2) {
  return s1 < e2 && e1 >= s2;
}
function getParsers$1(isBigEndian) {
  const le = isBigEndian ? "big" : "little";
  const summaryParser = new Parser().endianess(le).uint32("chromId").uint32("start").uint32("end").uint32("validCnt").floatle("minScore").floatle("maxScore").floatle("sumData").floatle("sumSqData").saveOffset("offset");
  const leafParser = new Parser().endianess(le).uint8("isLeaf").skip(1).uint16("cnt").choice({
    tag: "isLeaf",
    choices: {
      1: new Parser().endianess(le).array("blocksToFetch", {
        length: "cnt",
        type: new Parser().endianess(le).uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").uint64("blockSize").saveOffset("offset")
      }),
      0: new Parser().array("recurOffsets", {
        length: "cnt",
        type: new Parser().endianess(le).uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").saveOffset("offset")
      })
    }
  });
  const bigBedParser = new Parser().endianess(le).uint32("chromId").int32("start").int32("end").string("rest", {
    zeroTerminated: true
  }).saveOffset("offset");
  const bigWigParser = new Parser().endianess(le).skip(4).int32("blockStart").skip(4).uint32("itemStep").uint32("itemSpan").uint8("blockType").skip(1).uint16("itemCount").choice({
    tag: "blockType",
    choices: {
      [BIG_WIG_TYPE_FSTEP]: new Parser().array("items", {
        length: "itemCount",
        type: new Parser().floatle("score")
      }),
      [BIG_WIG_TYPE_VSTEP]: new Parser().array("items", {
        length: "itemCount",
        type: new Parser().endianess(le).int32("start").floatle("score")
      }),
      [BIG_WIG_TYPE_GRAPH]: new Parser().array("items", {
        length: "itemCount",
        type: new Parser().endianess(le).int32("start").int32("end").floatle("score")
      })
    }
  });
  return {
    bigWigParser,
    bigBedParser,
    summaryParser,
    leafParser
  };
}
class BlockView {
  constructor(bbi, refsByName, cirTreeOffset, isBigEndian, isCompressed, blockType) {
    this.bbi = bbi;
    this.refsByName = refsByName;
    this.cirTreeOffset = cirTreeOffset;
    this.isBigEndian = isBigEndian;
    this.isCompressed = isCompressed;
    this.blockType = blockType;
    this.featureCache = new _default({
      cache: new QuickLRU({ maxSize: 1e3 }),
      fill: async (requestData, signal) => {
        const len = Number(requestData.length);
        const off = Number(requestData.offset);
        const { buffer } = await this.bbi.read(Buffer2.alloc(len), 0, len, off, {
          signal
        });
        return buffer;
      }
    });
    if (!(cirTreeOffset >= 0)) {
      throw new Error("invalid cirTreeOffset!");
    }
    const parsers = getParsers$1(isBigEndian);
    this.leafParser = parsers.leafParser;
    this.bigBedParser = parsers.bigBedParser;
  }
  async readWigData(chrName, start, end, observer, opts) {
    try {
      const { refsByName, bbi, cirTreeOffset, isBigEndian } = this;
      const chrId = refsByName[chrName];
      if (chrId === void 0) {
        observer.complete();
      }
      const request = { chrId, start, end };
      if (!this.cirTreePromise) {
        this.cirTreePromise = bbi.read(Buffer2.alloc(48), 0, 48, Number(cirTreeOffset), opts);
      }
      const { buffer } = await this.cirTreePromise;
      const cirBlockSize = isBigEndian ? buffer.readUInt32BE(4) : buffer.readUInt32LE(4);
      let blocksToFetch = [];
      let outstanding = 0;
      const cirFobRecur2 = (cirBlockData, offset, level) => {
        try {
          const data2 = cirBlockData.subarray(offset);
          const p = this.leafParser.parse(data2);
          if (p.blocksToFetch) {
            blocksToFetch = blocksToFetch.concat(p.blocksToFetch.filter(filterFeats).map((l) => ({
              offset: l.blockOffset,
              length: l.blockSize
            })));
          }
          if (p.recurOffsets) {
            const recurOffsets = p.recurOffsets.filter(filterFeats).map((l) => Number(l.blockOffset));
            if (recurOffsets.length > 0) {
              cirFobRecur(recurOffsets, level + 1);
            }
          }
        } catch (e) {
          observer.error(e);
        }
      };
      const filterFeats = (b) => {
        const { startChrom, startBase, endChrom, endBase } = b;
        return (startChrom < chrId || startChrom === chrId && startBase <= end) && (endChrom > chrId || endChrom === chrId && endBase >= start);
      };
      const cirFobStartFetch = async (off, fr, level) => {
        try {
          const length = fr.max() - fr.min();
          const offset = fr.min();
          const resultBuffer = await this.featureCache.get(`${length}_${offset}`, { length, offset }, opts.signal);
          for (let i = 0; i < off.length; i += 1) {
            if (fr.contains(off[i])) {
              cirFobRecur2(resultBuffer, off[i] - offset, level);
              outstanding -= 1;
              if (outstanding === 0) {
                this.readFeatures(observer, blocksToFetch, { ...opts, request });
              }
            }
          }
        } catch (e) {
          observer.error(e);
        }
      };
      const cirFobRecur = (offset, level) => {
        try {
          outstanding += offset.length;
          const maxCirBlockSpan = 4 + Number(cirBlockSize) * 32;
          let spans = new Range(offset[0], offset[0] + maxCirBlockSpan);
          for (let i = 1; i < offset.length; i += 1) {
            const blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans.union(blockSpan);
          }
          spans.getRanges().map((fr) => cirFobStartFetch(offset, fr, level));
        } catch (e) {
          observer.error(e);
        }
      };
      return cirFobRecur([Number(cirTreeOffset) + 48], 1);
    } catch (e) {
      observer.error(e);
    }
  }
  parseSummaryBlock(buffer, startOffset, request) {
    const features = [];
    let offset = startOffset;
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);
    while (offset < buffer.byteLength) {
      const chromId = dataView.getUint32(offset, true);
      offset += 4;
      const start = dataView.getUint32(offset, true);
      offset += 4;
      const end = dataView.getUint32(offset, true);
      offset += 4;
      const validCnt = dataView.getUint32(offset, true);
      offset += 4;
      const minScore = dataView.getFloat32(offset, true);
      offset += 4;
      const maxScore = dataView.getFloat32(offset, true);
      offset += 4;
      const sumData = dataView.getFloat32(offset, true);
      offset += 4;
      offset += 4;
      if (request ? chromId === request.chrId && coordFilter(start, end, request.start, request.end) : true) {
        features.push({
          start,
          end,
          maxScore,
          minScore,
          summary: true,
          score: sumData / (validCnt || 1)
        });
      }
    }
    return features;
  }
  parseBigBedBlock(data2, startOffset, offset, request) {
    const items2 = [];
    let currOffset = startOffset;
    while (currOffset < data2.byteLength) {
      const res = this.bigBedParser.parse(data2.subarray(currOffset));
      items2.push({ ...res, uniqueId: `bb-${offset + currOffset}` });
      currOffset += res.offset;
    }
    return request ? items2.filter((f) => coordFilter(f.start, f.end, request.start, request.end)) : items2;
  }
  parseBigWigBlock(buffer, startOffset, request) {
    const b = buffer.subarray(startOffset);
    const dataView = new DataView(b.buffer, b.byteOffset, b.length);
    let offset = 0;
    offset += 4;
    const blockStart = dataView.getInt32(offset, true);
    offset += 8;
    const itemStep = dataView.getUint32(offset, true);
    offset += 4;
    const itemSpan = dataView.getUint32(offset, true);
    offset += 4;
    const blockType = dataView.getUint8(offset);
    offset += 2;
    const itemCount = dataView.getUint16(offset, true);
    offset += 2;
    const items2 = new Array(itemCount);
    switch (blockType) {
      case 1:
        for (let i = 0; i < itemCount; i++) {
          const start = dataView.getInt32(offset, true);
          offset += 4;
          const end = dataView.getInt32(offset, true);
          offset += 4;
          const score = dataView.getFloat32(offset, true);
          offset += 4;
          items2[i] = { start, end, score };
        }
        break;
      case 2:
        for (let i = 0; i < itemCount; i++) {
          const start = dataView.getInt32(offset, true);
          offset += 4;
          const score = dataView.getFloat32(offset, true);
          offset += 4;
          items2[i] = { score, start, end: start + itemSpan };
        }
        break;
      case 3:
        for (let i = 0; i < itemCount; i++) {
          const score = dataView.getFloat32(offset, true);
          offset += 4;
          const start = blockStart + i * itemStep;
          items2[i] = { score, start, end: start + itemSpan };
        }
        break;
    }
    return request ? items2.filter((f) => coordFilter(f.start, f.end, request.start, request.end)) : items2;
  }
  async readFeatures(observer, blocks, opts = {}) {
    try {
      const { blockType, isCompressed } = this;
      const { signal, request } = opts;
      const blockGroupsToFetch = groupBlocks(blocks);
      checkAbortSignal(signal);
      await Promise.all(blockGroupsToFetch.map(async (blockGroup) => {
        checkAbortSignal(signal);
        const { length, offset } = blockGroup;
        const data2 = await this.featureCache.get(`${length}_${offset}`, blockGroup, signal);
        blockGroup.blocks.forEach((block) => {
          checkAbortSignal(signal);
          let blockOffset = Number(block.offset) - Number(blockGroup.offset);
          let resultData = data2;
          if (isCompressed) {
            resultData = unzip(data2.subarray(blockOffset));
            blockOffset = 0;
          }
          checkAbortSignal(signal);
          switch (blockType) {
            case "summary":
              observer.next(this.parseSummaryBlock(resultData, blockOffset, request));
              break;
            case "bigwig":
              observer.next(this.parseBigWigBlock(resultData, blockOffset, request));
              break;
            case "bigbed":
              observer.next(this.parseBigBedBlock(resultData, blockOffset, Number(block.offset) * (1 << 8), request));
              break;
            default:
              console.warn(`Don't know what to do with ${blockType}`);
          }
        });
      }));
      observer.complete();
    } catch (e) {
      observer.error(e);
    }
  }
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err2, i) {
      return i + 1 + ") " + err2.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err2) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err2 instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err2.errors));
              } else {
                errors.push(err2);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$2 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err2) {
  timeoutProvider.setTimeout(function() {
    {
      throw err2;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err2) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err2);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err2) {
    try {
      this.destination.error(err2);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err2) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err2);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err2);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config$2.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err2) {
  throw err2;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe2) {
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err2) {
      sink.error(err2);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err2) {
            reject(err2);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err2) {
        return reject(err2);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$2.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err2) {
          this.error(err2);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err2) {
        destination.error(err2);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err2) {
      try {
        onError(err2);
      } catch (err3) {
        destination.error(err3);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve2(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
function reduce(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}
var arrReducer = function(arr, value) {
  return arr.push(value), arr;
};
function toArray() {
  return operate(function(source, subscriber) {
    reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
const BIG_WIG_MAGIC = -2003829722;
const BIG_BED_MAGIC = -2021002517;
function toString(arr) {
  return new TextDecoder().decode(arr);
}
function getParsers(isBE) {
  const le = isBE ? "big" : "little";
  const headerParser = new Parser().endianess(le).int32("magic").uint16("version").uint16("numZoomLevels").uint64("chromTreeOffset").uint64("unzoomedDataOffset").uint64("unzoomedIndexOffset").uint16("fieldCount").uint16("definedFieldCount").uint64("asOffset").uint64("totalSummaryOffset").uint32("uncompressBufSize").uint64("extHeaderOffset").array("zoomLevels", {
    length: "numZoomLevels",
    type: new Parser().endianess(le).uint32("reductionLevel").uint32("reserved").uint64("dataOffset").uint64("indexOffset")
  });
  const totalSummaryParser = new Parser().endianess(le).uint64("basesCovered").doublele("scoreMin").doublele("scoreMax").doublele("scoreSum").doublele("scoreSumSquares");
  const chromTreeParser = new Parser().endianess(le).uint32("magic").uint32("blockSize").uint32("keySize").uint32("valSize").uint64("itemCount");
  const isLeafNode = new Parser().endianess(le).uint8("isLeafNode").skip(1).uint16("cnt").saveOffset("offset");
  return {
    chromTreeParser,
    totalSummaryParser,
    headerParser,
    isLeafNode
  };
}
class BBI {
  /* fetch and parse header information from a bigwig or bigbed file
   * @param abortSignal - abort the operation, can be null
   * @return a Header object
   */
  getHeader(opts = {}) {
    const options = "aborted" in opts ? { signal: opts } : opts;
    if (!this.headerP) {
      this.headerP = this._getHeader(options).catch((e) => {
        this.headerP = void 0;
        throw e;
      });
    }
    return this.headerP;
  }
  /*
   * @param filehandle - a filehandle from generic-filehandle or implementing something similar to the node10 fs.promises API
   * @param path - a Local file path as a string
   * @param url - a URL string
   * @param renameRefSeqs - an optional method to rename the internal reference sequences using a mapping function
   */
  constructor(options = {}) {
    const { filehandle, renameRefSeqs = (s) => s, path, url } = options;
    this.renameRefSeqs = renameRefSeqs;
    if (filehandle) {
      this.bbi = filehandle;
    } else if (url) {
      this.bbi = new RemoteFile$1(url);
    } else if (path) {
      this.bbi = new LocalFile(path);
    } else {
      throw new Error("no file given");
    }
  }
  async _getHeader(opts) {
    const header = await this._getMainHeader(opts);
    const chroms = await this._readChromTree(header, opts);
    return { ...header, ...chroms };
  }
  async _getMainHeader(opts, requestSize = 2e3) {
    const { buffer } = await this.bbi.read(Buffer2.alloc(requestSize), 0, requestSize, 0, opts);
    const isBigEndian = this._isBigEndian(buffer);
    const ret = getParsers(isBigEndian);
    const header = ret.headerParser.parse(buffer);
    const { magic, asOffset, totalSummaryOffset } = header;
    header.fileType = magic === BIG_BED_MAGIC ? "bigbed" : "bigwig";
    if (asOffset > requestSize || totalSummaryOffset > requestSize) {
      return this._getMainHeader(opts, requestSize * 2);
    }
    if (asOffset) {
      const off = Number(header.asOffset);
      header.autoSql = toString(buffer.subarray(off, buffer.indexOf(0, off)));
    }
    if (header.totalSummaryOffset > requestSize) {
      return this._getMainHeader(opts, requestSize * 2);
    }
    if (header.totalSummaryOffset) {
      const tail = buffer.subarray(Number(header.totalSummaryOffset));
      const sum2 = ret.totalSummaryParser.parse(tail);
      header.totalSummary = { ...sum2, basesCovered: Number(sum2.basesCovered) };
    }
    return { ...header, isBigEndian };
  }
  _isBigEndian(buffer) {
    let ret = buffer.readInt32LE(0);
    if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
      return false;
    }
    ret = buffer.readInt32BE(0);
    if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
      return true;
    }
    throw new Error("not a BigWig/BigBed file");
  }
  // todo: add progress if long running
  async _readChromTree(header, opts) {
    const isBE = header.isBigEndian;
    const le = isBE ? "big" : "little";
    const refsByNumber = [];
    const refsByName = {};
    let unzoomedDataOffset = Number(header.unzoomedDataOffset);
    const chromTreeOffset = Number(header.chromTreeOffset);
    while (unzoomedDataOffset % 4 !== 0) {
      unzoomedDataOffset += 1;
    }
    const off = unzoomedDataOffset - chromTreeOffset;
    const { buffer } = await this.bbi.read(Buffer2.alloc(off), 0, off, Number(chromTreeOffset), opts);
    const p = getParsers(isBE);
    const { keySize } = p.chromTreeParser.parse(buffer);
    const leafNodeParser = new Parser().endianess(le).string("key", { stripNull: true, length: keySize }).uint32("refId").uint32("refSize").saveOffset("offset");
    const nonleafNodeParser = new Parser().endianess(le).skip(keySize).uint64("childOffset").saveOffset("offset");
    const rootNodeOffset = 32;
    const bptReadNode = async (currentOffset) => {
      let offset = currentOffset;
      if (offset >= buffer.length) {
        throw new Error("reading beyond end of buffer");
      }
      const ret = p.isLeafNode.parse(buffer.subarray(offset));
      const { isLeafNode, cnt } = ret;
      offset += ret.offset;
      if (isLeafNode) {
        for (let n = 0; n < cnt; n += 1) {
          const leafRet = leafNodeParser.parse(buffer.subarray(offset));
          offset += leafRet.offset;
          const { key, refId, refSize } = leafRet;
          const refRec = { name: key, id: refId, length: refSize };
          refsByName[this.renameRefSeqs(key)] = refId;
          refsByNumber[refId] = refRec;
        }
      } else {
        const nextNodes = [];
        for (let n = 0; n < cnt; n += 1) {
          const nonleafRet = nonleafNodeParser.parse(buffer.subarray(offset));
          const { childOffset } = nonleafRet;
          offset += nonleafRet.offset;
          nextNodes.push(bptReadNode(Number(childOffset) - Number(chromTreeOffset)));
        }
        await Promise.all(nextNodes);
      }
    };
    await bptReadNode(rootNodeOffset);
    return {
      refsByName,
      refsByNumber
    };
  }
  /*
   * fetches the "unzoomed" view of the bigwig data. this is the default for bigbed
   * @param abortSignal - a signal to optionally abort this operation
   */
  async getUnzoomedView(opts) {
    const { unzoomedIndexOffset, refsByName, uncompressBufSize, isBigEndian, fileType } = await this.getHeader(opts);
    return new BlockView(this.bbi, refsByName, unzoomedIndexOffset, isBigEndian, uncompressBufSize > 0, fileType);
  }
  /**
   * Gets features from a BigWig file
   *
   * @param refName - The chromosome name
   * @param start - The start of a region
   * @param end - The end of a region
   * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
   */
  async getFeatureStream(refName, start, end, opts = {
    scale: 1
  }) {
    await this.getHeader(opts);
    const chrName = this.renameRefSeqs(refName);
    let view;
    if (opts.basesPerSpan) {
      view = await this.getView(1 / opts.basesPerSpan, opts);
    } else if (opts.scale) {
      view = await this.getView(opts.scale, opts);
    } else {
      view = await this.getView(1, opts);
    }
    if (!view) {
      throw new Error("unable to get block view for data");
    }
    return new Observable((observer) => {
      view.readWigData(chrName, start, end, observer, opts);
    });
  }
  async getFeatures(refName, start, end, opts = {
    scale: 1
  }) {
    const ob = await this.getFeatureStream(refName, start, end, opts);
    const ret = await firstValueFrom(ob.pipe(toArray()));
    return ret.flat();
  }
}
class BigWig extends BBI {
  /**
   * Retrieves a BlockView of a specific zoomLevel
   *
   * @param scale - number
   * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
   */
  async getView(scale, opts) {
    const { zoomLevels, refsByName, fileSize, isBigEndian, uncompressBufSize } = await this.getHeader(opts);
    const basesPerPx = 1 / scale;
    let maxLevel = zoomLevels.length;
    if (!fileSize) {
      maxLevel -= 1;
    }
    for (let i = maxLevel; i >= 0; i -= 1) {
      const zh = zoomLevels[i];
      if (zh && zh.reductionLevel <= 2 * basesPerPx) {
        const indexOffset = Number(zh.indexOffset);
        return new BlockView(this.bbi, refsByName, indexOffset, isBigEndian, uncompressBufSize > 0, "summary");
      }
    }
    return this.getUnzoomedView(opts);
  }
}
function filterUsingGenoPos(data2, [minX, maxX], config2) {
  const { x, xe, x1, x1e } = config2;
  const definedXFields = [x, xe, x1, x1e].filter((f) => f);
  return data2.filter((d) => {
    if (definedXFields.length === 0) {
      return true;
    } else if (definedXFields.length === 1) {
      const value = +d[definedXFields[0]];
      return typeof value === "number" && minX < value && value <= maxX;
    } else {
      const values = definedXFields.map((f) => +d[f]).filter((v) => !isNaN(v));
      const minValue = Math.min(...values);
      const maxValue = Math.max(...values);
      return minX <= maxValue && minValue <= maxX;
    }
  });
}
bisector((d) => d.pos).left;
function sanitizeChrName(chrName, assembly, chromosomePrefix) {
  if (Array.isArray(assembly)) {
    return chrName;
  }
  if (chromosomePrefix) {
    chrName = chrName.replace(chromosomePrefix, "chr");
  } else if (!chrName.includes("chr")) {
    chrName = `chr${chrName}`;
  }
  return chrName;
}
class RemoteFile extends RemoteFile$1 {
  constructor() {
    super(...arguments);
    // Overrides `read` to eagerly read 200 or 206 response
    // from https://github.com/GMOD/generic-filehandle/blob/0e8209be25e3097307bd15e964edd8c017e808d7/src/remoteFile.ts#L100-L162
    __publicField(this, "read", async (buffer, offset = 0, length, position = 0, opts = {}) => {
      const { headers = {}, signal, overrides = {} } = opts;
      if (length < Infinity) {
        headers.range = `bytes=${position}-${position + length}`;
      } else if (length === Infinity && position !== 0) {
        headers.range = `bytes=${position}-`;
      }
      const args = {
        // @ts-expect-error private property
        ...this.baseOverrides,
        ...overrides,
        headers: {
          ...headers,
          ...overrides.headers,
          // @ts-expect-error private property
          ...this.baseOverrides.headers
        },
        method: "GET",
        redirect: "follow",
        mode: "cors",
        signal
      };
      const response = await this.fetch(this.url, args);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} ${response.statusText} ${this.url}`);
      }
      if (response.status === 200 || response.status === 206) {
        const responseData = await this.getBufferFromResponse(response);
        const bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length));
        const res = response.headers.get("content-range");
        const sizeMatch = /\/(\d+)$/.exec(res || "");
        if (sizeMatch && sizeMatch[1]) {
          this._stat = { size: parseInt(sizeMatch[1], 10) };
        }
        return { bytesRead: bytesCopied, buffer };
      }
      throw new Error(`HTTP ${response.status} fetching ${this.url}`);
    });
  }
}
function BigWigDataFetcher(HGC, dataConfig) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  const cls = class BigWigDataFetcherClass {
    constructor() {
      __publicField(this, "dataConfig");
      __publicField(this, "bwFileHeader");
      __publicField(this, "bwFile");
      __publicField(this, "TILE_SIZE");
      __publicField(this, "errorTxt");
      __publicField(this, "dataPromises");
      __publicField(this, "chromSizes");
      __publicField(this, "assembly");
      __publicField(this, "tilesetInfoLoading");
      this.dataConfig = dataConfig;
      this.assembly = this.dataConfig.assembly;
      this.bwFileHeader = null;
      this.bwFile = null;
      this.TILE_SIZE = 1024;
      this.errorTxt = "";
      this.dataPromises = [];
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      this.dataPromises.push(this.loadBBI(dataConfig));
    }
    async loadBBI(dataConfig2) {
      if (dataConfig2.url) {
        this.bwFile = new BigWig({
          filehandle: new RemoteFile(dataConfig2.url, { overrides: dataConfig2.urlFetchOptions })
        });
        return this.bwFile.getHeader().then((h) => {
          this.bwFileHeader = h;
        });
      } else {
        console.error('Please enter a "url" field to the data config');
        return null;
      }
    }
    tilesetInfo(callback) {
      this.tilesetInfoLoading = true;
      return Promise.all(this.dataPromises).then(() => {
        this.tilesetInfoLoading = false;
        const totalLength = this.chromSizes.totalLength;
        const retVal = {
          tile_size: this.TILE_SIZE,
          max_zoom: Math.ceil(Math.log(totalLength / this.TILE_SIZE) / Math.log(2)),
          max_width: 2 ** Math.ceil(Math.log(totalLength) / Math.log(2)),
          min_pos: [0],
          max_pos: [totalLength]
        };
        if (callback) {
          callback(retVal);
        }
        return retVal;
      }).catch((err2) => {
        this.tilesetInfoLoading = false;
        console.error(err2);
        if (callback) {
          callback({
            error: `Error parsing bigwig: ${err2}`
          });
        }
        return null;
      });
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("Invalid tile zoom or position:", z, x);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x));
      }
      Promise.all(tilePromises).then((values) => {
        for (let i = 0; i < values.length; i++) {
          const validTileId = validTileIds[i];
          tiles[validTileId] = values[i];
          tiles[validTileId].tilePositionId = validTileId;
        }
        receivedTiles(tiles);
      });
      return tiles;
    }
    async tile(z, x) {
      const tsInfo = await this.tilesetInfo();
      const tileWidth = +tsInfo.max_width / 2 ** +z;
      const recordPromises = [];
      const tile = {
        tilePos: [x],
        tileId: `bigwig.${z}.${x}`,
        zoomLevel: z
      };
      const minXOriginal = tsInfo.min_pos[0] + x * tileWidth;
      let minX = minXOriginal;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
      const basesPerPixel = this.determineScale(minX, maxX);
      const basesPerBin = (maxX - minX) / this.TILE_SIZE;
      const binStarts = [];
      for (let i = 0; i < this.TILE_SIZE; i++) {
        binStarts.push(minX + i * basesPerBin);
      }
      const { chromLengths, cumPositions } = this.chromSizes;
      cumPositions.forEach((cumPos) => {
        const chromName = cumPos.chr;
        const chromStart = cumPos.pos;
        const chromEnd = cumPos.pos + chromLengths[chromName];
        let startPos, endPos;
        if (chromStart <= minX && minX < chromEnd) {
          if (maxX > chromEnd) {
            startPos = minX - chromStart;
            endPos = chromEnd - chromStart;
            recordPromises.push(
              this.bwFile.getFeatures(chromName, startPos, endPos, {
                scale: 1 / basesPerPixel
              }).then((values) => {
                values.forEach((v) => {
                  v["startAbs"] = HGC.utils.chrToAbs(chromName, v.start, this.chromSizes);
                  v["endAbs"] = HGC.utils.chrToAbs(chromName, v.end, this.chromSizes);
                });
                return values;
              })
            );
            minX = chromEnd;
          } else {
            startPos = Math.floor(minX - chromStart);
            endPos = Math.ceil(maxX - chromStart);
            if (!this.bwFile)
              return;
            recordPromises.push(
              this.bwFile.getFeatures(chromName, startPos, endPos, {
                scale: 1 / basesPerPixel
              }).then((values) => {
                values.forEach((v) => {
                  v["startAbs"] = HGC.utils.chrToAbs(chromName, v.start, this.chromSizes);
                  v["endAbs"] = HGC.utils.chrToAbs(chromName, v.end, this.chromSizes);
                });
                return values;
              })
            );
            return;
          }
        }
      });
      return Promise.all(recordPromises).then((v) => {
        const values = v.flat();
        const dense = [];
        for (let i = 0; i < this.TILE_SIZE; i++) {
          dense.push(null);
        }
        binStarts.forEach((curStart, index) => {
          if (curStart < minXOriginal || curStart > maxX) {
            return;
          }
          const filtered = values.filter((v2) => {
            return curStart >= v2.startAbs && curStart < v2.endAbs;
          }).map((v2) => v2.score);
          dense[index] = filtered.length > 0 ? filtered[0] : null;
        });
        const dde = new HGC.utils.DenseDataExtrema1D(dense);
        tile.min_value = Math.min(...dense);
        tile.max_value = Math.max(...dense);
        tile.dense = dense;
        tile.denseDataExtrema = dde;
        tile.minNonZero = dde.minNonZeroInTile;
        tile.maxNonZero = dde.maxNonZeroInTile;
        return tile;
      });
    }
    // We never want to request more than 1024 * 20 elements from the file.
    determineScale(minX, maxX) {
      const reductionLevels = [1];
      const numRequestedElements = maxX - minX;
      if (!this.bwFileHeader) {
        throw Error("no bigwig header");
      }
      this.bwFileHeader.zoomLevels.forEach((z) => {
        reductionLevels.push(z.reductionLevel);
      });
      let level;
      reductionLevels.forEach((rl) => {
        if (level)
          return;
        const numElementsFromFile = numRequestedElements / rl;
        if (numElementsFromFile <= this.TILE_SIZE * 20) {
          level = rl;
        }
      });
      return level || reductionLevels.slice(-1)[0];
    }
  };
  return new cls();
}
BigWigDataFetcher.config = {
  type: "bigwig"
};
function filterData(filter, data2) {
  const { field, not: not2 } = filter;
  let output = Array.from(data2);
  if (IsOneOfFilter(filter)) {
    const { oneOf: oneOf2 } = filter;
    output = output.filter((d) => {
      return not2 ? oneOf2.indexOf(d[field]) === -1 : oneOf2.indexOf(d[field]) !== -1;
    });
  } else if (IsRangeFilter(filter)) {
    const { inRange } = filter;
    output = output.filter((d) => {
      const value = +d[field];
      return not2 ? !(inRange[0] <= value && value <= inRange[1]) : inRange[0] <= value && value <= inRange[1];
    });
  } else if (IsIncludeFilter(filter)) {
    const { include } = filter;
    output = output.filter((d) => {
      return not2 ? `${d[field]}`.includes(include) : !`${d[field]}`.includes(include);
    });
  }
  return output;
}
function concatString(concat, data2) {
  const { fields, separator, newField } = concat;
  let output = Array.from(data2);
  output = output.map((d) => {
    const strs = fields.map((f) => d[f]);
    d[newField] = strs.join(separator);
    return d;
  });
  return output;
}
function replaceString(_, data2) {
  const { field, replace, newField } = _;
  let output = Array.from(data2);
  output = output.map((d) => {
    d[newField] = d[field];
    replace.forEach((r) => {
      const { from, to } = r;
      d[newField] = d[newField].toString().replaceAll(from, to);
    });
    return d;
  });
  return output;
}
function calculateData(log, data2) {
  const { field, base, newField } = log;
  let output = Array.from(data2);
  output = output.map((d) => {
    if (+d[field]) {
      if (base === "e") {
        d[newField != null ? newField : field] = Math.log(+d[field]);
      } else {
        d[newField != null ? newField : field] = Math.log(+d[field]) / Math.log(base != null ? base : 10);
      }
    }
    return d;
  });
  return output;
}
function calculateGenomicLength(_, data2) {
  const { startField, endField, newField } = _;
  const output = Array.from(data2);
  output.forEach((d) => {
    const s = d[startField];
    const e = d[endField];
    if (!s || !e) {
      return;
    }
    d[newField] = Math.abs(+e - +s);
  });
  return output;
}
function inferSvType(_, data2) {
  const { firstBp, secondBp, newField } = _;
  const output = Array.from(data2);
  const [DUP, TRA, DEL, t2tINV, h2hINV] = ["DUP", "TRA", "DEL", "t2tINV", "h2hINV"];
  output.forEach((d) => {
    const chr1 = d[firstBp.chrField];
    const chr2 = d[secondBp.chrField];
    if (chr1 !== chr2) {
      d[newField] = TRA;
      return;
    }
    let pos1 = d[firstBp.posField];
    let pos2 = d[secondBp.posField];
    let strand1 = d[firstBp.strandField];
    let strand2 = d[secondBp.strandField];
    if (pos1 > pos2) {
      const _pos = pos1;
      const _strand = strand1;
      pos1 = pos2;
      strand1 = strand2;
      pos2 = _pos;
      strand2 = _strand;
    }
    switch (`${strand1}${strand2}`) {
      case "+-":
        d[newField] = DEL;
        break;
      case "--":
        d[newField] = t2tINV;
        break;
      case "++":
        d[newField] = h2hINV;
        break;
      case "-+":
        d[newField] = DUP;
        break;
      default:
        d[newField] = "unknown";
    }
  });
  return output;
}
function aggregateCoverage(_, data2, scale) {
  const { startField, endField, newField, groupField } = _;
  const coverage = {};
  const binSize = 1;
  data2.forEach((d) => {
    const curStart = scale(d[startField]);
    const curEnd = scale(d[endField]);
    const group2 = groupField ? d[groupField] : "__NO_GROUP__";
    const adjustedStart = Math.floor(curStart);
    for (let i = adjustedStart; i < curEnd; i += binSize) {
      if (!coverage[group2]) {
        coverage[group2] = {};
      }
      if (!coverage[group2][i]) {
        coverage[group2][i] = 0;
      }
      coverage[group2][i]++;
    }
  });
  const output = Object.entries(coverage).flatMap((group2) => {
    const [groupName, coverageRecords] = group2;
    return Object.entries(coverageRecords).map((entry) => {
      const [key, value] = entry;
      return {
        [startField]: scale.invert(+key),
        [endField]: scale.invert(+key + binSize),
        [newField != null ? newField : "coverage"]: value,
        [groupField != null ? groupField : "group"]: groupName
      };
    });
  });
  return output;
}
function displace(t, data2, scale) {
  const { boundingBox, method, newField } = t;
  const { startField, endField, groupField } = boundingBox;
  let paddingInBp = 0;
  if (boundingBox.padding && scale && !boundingBox.isPaddingBP) {
    paddingInBp = Math.abs(scale.invert(boundingBox.padding) - scale.invert(0));
  } else if (boundingBox.padding && boundingBox.isPaddingBP) {
    paddingInBp = boundingBox.padding;
  }
  const base = Array.from(data2);
  if (base && base.length > 0) {
    if (!Object.keys(base[0]).find((d) => d === startField) || !Object.keys(base[0]).find((d) => d === endField)) {
      return base;
    }
  }
  if (method === "pile") {
    const { maxRows } = t;
    const occupiedSpaceInRows = {};
    const sorted = base.sort((a, b) => a[startField] - b[startField]);
    sorted.forEach((d) => {
      const start = +d[startField] - paddingInBp;
      const end = +d[endField] + paddingInBp;
      const group2 = groupField ? d[groupField] : "__NO_GROUP__";
      if (!occupiedSpaceInRows[group2]) {
        occupiedSpaceInRows[group2] = [];
      }
      let rowIndex = occupiedSpaceInRows[group2].findIndex((d2) => {
        if (end < d2.start) {
          d2.start = start;
          return true;
        } else if (d2.end < start) {
          d2.end = end;
          return true;
        }
        return false;
      });
      if (rowIndex === -1) {
        occupiedSpaceInRows[group2].push({ start, end });
        rowIndex = occupiedSpaceInRows[group2].length - 1;
      }
      d[newField] = `${maxRows && maxRows <= rowIndex ? maxRows - 1 : rowIndex}`;
    });
  } else if (method === "spread") {
    const boundingBoxes = [];
    base.sort((a, b) => a[startField] - b[startField]).forEach((d) => {
      let start = d[startField] - paddingInBp;
      let end = d[endField] + paddingInBp;
      let overlapped = boundingBoxes.filter(
        (box) => box.start === start && end === box.end || box.start < start && start < box.end || box.start < end && end < box.end || start < box.start && box.end < end
      );
      if (overlapped.length > 0) {
        let trial = 0;
        do {
          overlapped = boundingBoxes.filter(
            (box) => box.start === start && end === box.end || box.start < start && start < box.end || box.start < end && end < box.end || start < box.start && box.end < end
          );
          if (overlapped.length > 0) {
            if (trial % 2 === 0) {
              start += paddingInBp * trial;
              end += paddingInBp * trial;
            } else {
              start -= paddingInBp * trial;
              end -= paddingInBp * trial;
            }
          }
          trial++;
        } while (overlapped.length > 0 && trial < 1e3);
      }
      d[`${newField}Start`] = `${start + paddingInBp}`;
      d[`${newField}Etart`] = `${end - paddingInBp}`;
      boundingBoxes.push({ start, end });
    });
  }
  return base;
}
function splitExon(split, data2, assembly = "hg38") {
  const { separator, fields, flag } = split;
  let output = Array.from(data2);
  output = output.map((d) => {
    const newRows = [];
    fields.forEach((f) => {
      const { field, type: type2, newField, chrField } = f;
      const splitted = d[field].toString().split(separator);
      splitted.forEach((s, i) => {
        let newValue = s;
        if (type2 === "genomic") {
          newValue = computeChromSizes(assembly).interval[d[chrField]][0] + +s;
        }
        if (!newRows[i]) {
          newRows[i] = Object.assign(JSON.parse(JSON.stringify(d)), {
            [newField]: newValue,
            [flag.field]: flag.value
          });
        } else {
          newRows[i][newField] = newValue;
        }
      });
    });
    return [d, ...newRows];
  }).reduce((a, b) => a.concat(b), []);
  return output;
}
function parseSubJSON(_, data2) {
  const { field, genomicField, baseGenomicField, genomicLengthField } = _;
  let output = Array.from(data2);
  output = output.map((d) => {
    let newRows = JSON.parse(d[field]);
    newRows = newRows.map((row) => {
      var _a, _b;
      if (row[genomicField] && d[baseGenomicField]) {
        row[`${genomicField}_start`] = +row[genomicField] + +d[baseGenomicField];
        row[`${genomicField}_end`] = +row[genomicField] + +d[baseGenomicField] + +row[genomicLengthField];
      }
      return Object.assign(JSON.parse(JSON.stringify(d)), {
        ...row,
        [`${genomicField}_start`]: row[`${genomicField}_start`],
        [`${genomicField}_end`]: row[`${genomicField}_end`],
        type: (_b = (_a = row.type) != null ? _a : row.variant) != null ? _b : null,
        isParsedRow: "yes"
      });
    });
    return [d, ...newRows];
  }).reduce((a, b) => a.concat(b), []);
  return output;
}
function aggregateData(spec, data2) {
  if (getChannelKeysByAggregateFnc(spec).length === 0) {
    return data2;
  }
  const nChannelKeys = getChannelKeysByType(spec, "nominal");
  if (nChannelKeys.length !== 1) {
    console.warn("Currently, we only support aggregating datasets with single nominal field.");
    return data2;
  }
  const nFieldSpec = spec[nChannelKeys[0]];
  if (!IsChannelDeep(nFieldSpec)) {
    return data2;
  }
  const nField = nFieldSpec.field;
  if (!nField) {
    return data2;
  }
  const qChannelKeys = [...getChannelKeysByType(spec, "quantitative"), ...getChannelKeysByType(spec, "genomic")];
  const aggregated = [];
  const uniqueCategories = Array.from(new Set(data2.map((d) => d[nField])));
  let failed = false;
  uniqueCategories.forEach((c) => {
    const datum = {};
    datum[nField] = c;
    qChannelKeys.forEach((q) => {
      const qFieldSpec = spec[q];
      if (!IsChannelDeep(qFieldSpec)) {
        failed = true;
        return;
      }
      const { field: qField } = qFieldSpec;
      if (!qField || !("aggregate" in qFieldSpec)) {
        failed = true;
        return;
      }
      datum[qField] = qFieldSpec.aggregate === "max" ? Math.max(...data2.filter((d) => d[nField] === c).map((d) => +d[qField])) : Math.min(...data2.filter((d) => d[nField] === c).map((d) => +d[qField]));
    });
    aggregated.push(datum);
  });
  return !failed ? aggregated : data2;
}
class CsvDataFetcherClass {
  constructor(dataConfig) {
    /**
     * Fetches CSV file from url, parses it, and sets this.#parsedData
     */
    __privateAdd(this, _fetchCsv);
    /**
     * Function passed into DSV parser to process each row
     * @param row An object which contains the row information. The keys are the column names
     * @param genomicFieldsToConvert From data config
     * @param chromosomeField From data config
     * @param genomicFields From data config
     * @returns The processed row
     */
    __privateAdd(this, _processCsvRow);
    /**
     * Calculates the cumulative chromosome position based on the chromosome name and position
     * @param chromName A string, the name of the chromosome
     * @param chromPosition A string, the position within the chromosome
     */
    __privateAdd(this, _calcCumulativePos);
    /**
     * Called by this.tilesetInfo() to call a callback function with tileset info.
     */
    __privateAdd(this, _generateTilesetInfo);
    /**
     * Creates an object to associate a tile position with the corresponding data
     * @param z An integer, the z coordinate of the tile
     * @param x An integer, the x coordinate of the tile
     * @param y An integer, the y coordinate of the tile
     * @returns A promise of an object with tile coordinates and data
     */
    __privateAdd(this, _tile);
    /**
     * This function calculates chromosome position and size based on the assembly (this.#assembly)
     * @returns An object containing chromosome information and a way to calculate absolute position
     */
    __privateAdd(this, _generateChomSizeInfo);
    __publicField(this, "dataConfig");
    // @ts-ignore
    __publicField(this, "tilesetInfoLoading");
    // Used in TiledPixiTrack
    __privateAdd(this, _dataPromise, void 0);
    __privateAdd(this, _chromSizes, void 0);
    __privateAdd(this, _parsedData, void 0);
    // Either set in the constructor or in #fetchCsv()
    __privateAdd(this, _assembly, void 0);
    __privateAdd(this, _filter, void 0);
    __privateAdd(this, _file, void 0);
    this.dataConfig = dataConfig;
    this.tilesetInfoLoading = false;
    __privateSet(this, _assembly, this.dataConfig.assembly);
    __privateSet(this, _filter, this.dataConfig.filter);
    if (!dataConfig.url) {
      console.error("Please provide the `url` of the data");
    }
    const { urlFetchOptions, url } = dataConfig;
    __privateSet(this, _file, new RemoteFile(url, { overrides: urlFetchOptions }));
    __privateSet(this, _chromSizes, __privateMethod(this, _generateChomSizeInfo, generateChomSizeInfo_fn).call(this));
    __privateSet(this, _dataPromise, __privateMethod(this, _fetchCsv, fetchCsv_fn).call(this));
  }
  /**
   * Called in TiledPixiTrack
   */
  tilesetInfo(callback) {
    if (!__privateGet(this, _dataPromise)) {
      return;
    }
    this.tilesetInfoLoading = true;
    return __privateGet(this, _dataPromise).then(() => __privateMethod(this, _generateTilesetInfo, generateTilesetInfo_fn).call(this, callback)).catch((err2) => {
      this.tilesetInfoLoading = false;
      console.error("[Gosling Data Fetcher] Error parsing data:", err2);
    });
  }
  /**
   * Called in TiledPixiTrack.
   * @param receivedTiles A function from TiledPixiTrack which takes in all the loaded tiles
   * @param tileIds An array of tile IDs. Ex. ['1.0', '1.1']
   */
  fetchTilesDebounced(receivedTiles, tileIds) {
    const tiles = {};
    const validTileIds = [];
    const tilePromises = [];
    for (const tileId of tileIds) {
      const parts = tileId.split(".");
      const z = parseInt(parts[0], 10);
      const x = parseInt(parts[1], 10);
      const y = parseInt(parts[2], 10);
      if (Number.isNaN(x) || Number.isNaN(z)) {
        console.warn("[Gosling Data Fetcher] Invalid tile zoom or position:", z, x, y);
        continue;
      }
      validTileIds.push(tileId);
      tilePromises.push(__privateMethod(this, _tile, tile_fn).call(this, z, x, y));
    }
    Promise.all(tilePromises).then((tileInfo) => {
      tileInfo.forEach((tileInfo2, i) => {
        if (tileInfo2) {
          const validTileId = validTileIds[i];
          tiles[validTileId] = tileInfo2;
          tiles[validTileId].tilePositionId = validTileId;
        }
      });
      receivedTiles(tiles);
    });
  }
}
_dataPromise = new WeakMap();
_chromSizes = new WeakMap();
_parsedData = new WeakMap();
_assembly = new WeakMap();
_filter = new WeakMap();
_file = new WeakMap();
_fetchCsv = new WeakSet();
fetchCsv_fn = async function() {
  var _a, _b;
  const { chromosomeField, genomicFields, headerNames, longToWideId, genomicFieldsToConvert } = this.dataConfig;
  const separator = (_a = this.dataConfig.separator) != null ? _a : ",";
  try {
    const buffer = await __privateGet(this, _file).readFile();
    const text = buffer.toString();
    const textWithHeader = headerNames ? `${headerNames.join(separator)}
${text}` : text;
    const parsedCSV = dsvFormat(separator).parse(
      textWithHeader,
      (row) => __privateMethod(this, _processCsvRow, processCsvRow_fn).call(this, row, genomicFieldsToConvert, chromosomeField, genomicFields)
    );
    if (longToWideId && ((_b = parsedCSV[0]) == null ? void 0 : _b[longToWideId])) {
      const columnNames = Object.keys(parsedCSV[0]);
      const newJson = {};
      parsedCSV.forEach((row) => {
        if (!newJson[row[longToWideId]]) {
          newJson[row[longToWideId]] = JSON.parse(JSON.stringify(row));
        } else {
          columnNames.forEach((colName) => {
            newJson[row[longToWideId]][`${colName}_2`] = row[colName];
          });
        }
      });
      __privateSet(this, _parsedData, Object.keys(newJson).map((k_3) => newJson[k_3]));
    } else {
      __privateSet(this, _parsedData, parsedCSV);
    }
  } catch (error) {
    console.error("[Gosling Data Fetcher] Error fetching data", error);
  }
};
_processCsvRow = new WeakSet();
processCsvRow_fn = function(row, genomicFieldsToConvert, chromosomeField, genomicFields) {
  try {
    if (genomicFieldsToConvert) {
      genomicFieldsToConvert.forEach((chromMap) => {
        const genomicFields_1 = chromMap.genomicFields;
        const chromName = row[chromMap.chromosomeField];
        genomicFields_1.forEach((positionCol) => {
          const chromPosition = row[positionCol];
          row[positionCol] = String(__privateMethod(this, _calcCumulativePos, calcCumulativePos_fn).call(this, chromName, chromPosition));
        });
      });
    } else if (chromosomeField && genomicFields) {
      genomicFields.forEach((positionCol_1) => {
        const chromPosition_1 = row[positionCol_1];
        const chromName_1 = row[chromosomeField];
        row[positionCol_1] = String(__privateMethod(this, _calcCumulativePos, calcCumulativePos_fn).call(this, chromName_1, chromPosition_1));
      });
    }
    return row;
  } catch (e) {
    return void 0;
  }
};
_calcCumulativePos = new WeakSet();
calcCumulativePos_fn = function(chromName, chromPosition) {
  if (__privateGet(this, _assembly) !== "unknown") {
    const chrName = sanitizeChrName(chromName, __privateGet(this, _assembly), this.dataConfig.chromosomePrefix);
    return computeChromSizes(__privateGet(this, _assembly)).interval[chrName][0] + +chromPosition;
  } else {
    return chromPosition;
  }
};
_generateTilesetInfo = new WeakSet();
generateTilesetInfo_fn = function(callback) {
  this.tilesetInfoLoading = false;
  const TILE_SIZE = 1024;
  const totalLength = __privateGet(this, _chromSizes).totalLength;
  const retVal = {
    tile_size: TILE_SIZE,
    max_zoom: Math.ceil(Math.log(totalLength / TILE_SIZE) / Math.log(2)),
    max_width: totalLength,
    min_pos: [0, 0],
    max_pos: [totalLength, totalLength]
  };
  if (callback) {
    callback(retVal);
  }
  return retVal;
};
_tile = new WeakSet();
tile_fn = async function(z, x, y) {
  var _a, _b;
  const tilesetInfo = await this.tilesetInfo();
  if (!tilesetInfo)
    return;
  const tileWidth = +tilesetInfo.max_width / 2 ** +z;
  const minX = tilesetInfo.min_pos[0] + x * tileWidth;
  const maxX = tilesetInfo.min_pos[0] + (x + 1) * tileWidth;
  let tabularData = filterUsingGenoPos(__privateGet(this, _parsedData), [minX, maxX], this.dataConfig);
  (_a = __privateGet(this, _filter)) == null ? void 0 : _a.forEach((f) => {
    tabularData = filterData(f, tabularData);
  });
  const sizeLimit = (_b = this.dataConfig.sampleLength) != null ? _b : 1e3;
  return {
    // sample the data to make it managable for visualization components
    tabularData: tabularData.length > sizeLimit ? sampleSize(tabularData, sizeLimit) : tabularData,
    server: null,
    tilePos: [x, y],
    zoomLevel: z
  };
};
_generateChomSizeInfo = new WeakSet();
generateChomSizeInfo_fn = function() {
  const chromosomeSizes = computeChromSizes(__privateGet(this, _assembly)).size;
  const chromosomeCumPositions = [];
  const chromosomePositions = {};
  let prevEndPosition = 0;
  Object.keys(chromosomeSizes).forEach((chrStr, i) => {
    const positionInfo = {
      id: i,
      chr: chrStr,
      pos: prevEndPosition
    };
    chromosomeCumPositions.push(positionInfo);
    chromosomePositions[chrStr] = positionInfo;
    prevEndPosition += chromosomeSizes[chrStr];
  });
  return {
    chrToAbs: (chrom, chromPos) => __privateGet(this, _chromSizes).chrPositions[chrom].pos + chromPos,
    cumPositions: chromosomeCumPositions,
    chrPositions: chromosomePositions,
    totalLength: prevEndPosition,
    chromLengths: chromosomeSizes
  };
};
function CsvDataFetcher(_HGC, dataConfig, _pubsub) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  return new CsvDataFetcherClass(dataConfig);
}
CsvDataFetcher.config = {
  type: "csv"
};
function JsonDataFetcher(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class JsonDataFetcherClass {
    constructor(params) {
      __publicField(this, "dataConfig");
      // @ts-ignore
      __publicField(this, "tilesetInfoLoading");
      __publicField(this, "chromSizes");
      __publicField(this, "values");
      __publicField(this, "assembly");
      const [dataConfig] = params;
      this.dataConfig = dataConfig;
      this.tilesetInfoLoading = false;
      this.assembly = this.dataConfig.assembly;
      if (!dataConfig.values) {
        console.error("Please provide `values` of the JSON data");
        return;
      }
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      const { chromosomeField, genomicFields, genomicFieldsToConvert } = this.dataConfig;
      this.values = dataConfig.values.map((row) => {
        try {
          if (genomicFieldsToConvert) {
            genomicFieldsToConvert.forEach((chromMap) => {
              const genomicFields2 = chromMap.genomicFields;
              const chromName = sanitizeChrName(row[chromMap.chromosomeField], this.assembly);
              genomicFields2.forEach((positionCol) => {
                const chromPosition = row[positionCol];
                row[positionCol] = String(this.chromSizes.chrToAbs(chromName, chromPosition));
              });
            });
          } else if (chromosomeField && genomicFields) {
            genomicFields.forEach((positionCol) => {
              const chromPosition = row[positionCol];
              const chromName = sanitizeChrName(row[chromosomeField], this.assembly);
              row[positionCol] = String(this.chromSizes.chrToAbs(chromName, chromPosition));
            });
          }
          return row;
        } catch (e) {
          return void 0;
        }
      });
    }
    tilesetInfo(callback) {
      this.tilesetInfoLoading = false;
      const TILE_SIZE = 1024;
      const totalLength = this.chromSizes.totalLength;
      const retVal = {
        tile_size: TILE_SIZE,
        max_zoom: Math.ceil(Math.log(totalLength / TILE_SIZE) / Math.log(2)),
        max_width: totalLength,
        min_pos: [0, 0],
        max_pos: [totalLength, totalLength]
      };
      if (callback) {
        callback(retVal);
      }
      return retVal;
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        const y = parseInt(parts[2], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("[Gosling Data Fetcher] Invalid tile zoom or position:", z, x, y);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x, y));
      }
      Promise.all(tilePromises).then((values) => {
        values.forEach((value, i) => {
          const validTileId = validTileIds[i];
          tiles[validTileId] = value;
          tiles[validTileId].tilePositionId = validTileId;
        });
        receivedTiles(tiles);
      });
      return tiles;
    }
    tile(z, x, y) {
      var _a;
      const tsInfo = this.tilesetInfo();
      const tileWidth = +tsInfo.max_width / 2 ** +z;
      const minX = tsInfo.min_pos[0] + x * tileWidth;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
      let tabularData = filterUsingGenoPos(this.values, [minX, maxX], this.dataConfig);
      const sizeLimit = (_a = this.dataConfig.sampleLength) != null ? _a : 1e3;
      if (sizeLimit < tabularData.length) {
        tabularData = sampleSize(tabularData, sizeLimit);
      }
      return {
        tabularData,
        server: null,
        tilePos: [x, y],
        zoomLevel: z
      };
    }
  }
  return new JsonDataFetcherClass(args);
}
JsonDataFetcher.config = {
  type: "json"
};
const encodedJs$1 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHsKICAgIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7CiAgICBmb3IgKHZhciBuYW1lIGluIGFsbCkKICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTsKICB9OwogIHZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4gewogICAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09ICJvYmplY3QiIHx8IHR5cGVvZiBtb2R1bGUyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSkKICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09ICJkZWZhdWx0IikKICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdGFyZ2V0OwogIH07CiAgdmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4gewogICAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgImRlZmF1bHQiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiAiZGVmYXVsdCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYmFzZTY0X2pzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGV4cG9ydHMyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBleHBvcnRzMi50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5OwogICAgICBleHBvcnRzMi5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTsKICAgICAgdmFyIGxvb2t1cCA9IFtdOwogICAgICB2YXIgcmV2TG9va3VwID0gW107CiAgICAgIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgPyBVaW50OEFycmF5IDogQXJyYXk7CiAgICAgIHZhciBjb2RlID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iOwogICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgbG9va3VwW2ldID0gY29kZVtpXTsKICAgICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7CiAgICAgIH0KICAgICAgdmFyIGk7CiAgICAgIHZhciBsZW47CiAgICAgIHJldkxvb2t1cFsiLSIuY2hhckNvZGVBdCgwKV0gPSA2MjsKICAgICAgcmV2TG9va3VwWyJfIi5jaGFyQ29kZUF0KDApXSA9IDYzOwogICAgICBmdW5jdGlvbiBnZXRMZW5zKGI2NCkgewogICAgICAgIHZhciBsZW4yID0gYjY0Lmxlbmd0aDsKICAgICAgICBpZiAobGVuMiAlIDQgPiAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQiKTsKICAgICAgICB9CiAgICAgICAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoIj0iKTsKICAgICAgICBpZiAodmFsaWRMZW4gPT09IC0xKQogICAgICAgICAgdmFsaWRMZW4gPSBsZW4yOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuMiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0OwogICAgICAgIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpIHsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7CiAgICAgICAgdmFyIGN1ckJ5dGUgPSAwOwogICAgICAgIHZhciBsZW4yID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuOwogICAgICAgIHZhciBpMjsKICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW4yOyBpMiArPSA0KSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMyldOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gMTYgJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPj4gNDsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildID4+IDI7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkgewogICAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBvdXRwdXQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpMiA9IHN0YXJ0OyBpMiA8IGVuZDsgaTIgKz0gMykgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2kyXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpMiArIDFdIDw8IDggJiA2NTI4MCkgKyAodWludDhbaTIgKyAyXSAmIDI1NSk7CiAgICAgICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXRwdXQuam9pbigiIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7CiAgICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMzsKICAgICAgICB2YXIgcGFydHMgPSBbXTsKICAgICAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsKICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpMiwgaTIgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIyID8gbGVuMjIgOiBpMiArIG1heENodW5rTGVuZ3RoKSk7CiAgICAgICAgfQogICAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICAgICAgICB0bXAgPSB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiA2M10gKyAiPT0iKTsKICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtsZW4yIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgIj0iKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oIiIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfaWVlZTc1NCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGV4cG9ydHMyLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgICAgICAgdmFyIGUsIG07CiAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CiAgICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7CiAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgICAgIHZhciBuQml0cyA9IC03OwogICAgICAgIHZhciBpID0gaXNMRSA/IG5CeXRlcyAtIDEgOiAwOwogICAgICAgIHZhciBkID0gaXNMRSA/IC0xIDogMTsKICAgICAgICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsKICAgICAgICBpICs9IGQ7CiAgICAgICAgZSA9IHMgJiAoMSA8PCAtbkJpdHMpIC0gMTsKICAgICAgICBzID4+PSAtbkJpdHM7CiAgICAgICAgbkJpdHMgKz0gZUxlbjsKICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgZSA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IG1MZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBpZiAoZSA9PT0gMCkgewogICAgICAgICAgZSA9IDEgLSBlQmlhczsKICAgICAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKICAgICAgICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICBlID0gZSAtIGVCaWFzOwogICAgICAgIH0KICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTsKICAgICAgfTsKICAgICAgZXhwb3J0czIud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtLCBjOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMDsKICAgICAgICB2YXIgaSA9IGlzTEUgPyAwIDogbkJ5dGVzIC0gMTsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7CiAgICAgICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwOwogICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpOwogICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7CiAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7CiAgICAgICAgICBlID0gZU1heDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpOwogICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkgewogICAgICAgICAgICBlLS07CiAgICAgICAgICAgIGMgKj0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKICAgICAgICAgICAgZSsrOwogICAgICAgICAgICBjIC89IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgICAgICAgbSA9IDA7CiAgICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMjU1LCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgZSA9IGUgPDwgbUxlbiB8IG07CiAgICAgICAgZUxlbiArPSBtTGVuOwogICAgICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDI1NSwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcwogIHZhciByZXF1aXJlX2J1ZmZlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYmFzZTY0ID0gcmVxdWlyZV9iYXNlNjRfanMoKTsKICAgICAgdmFyIGllZWU3NTQgPSByZXF1aXJlX2llZWU3NTQoKTsKICAgICAgdmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBTeW1ib2xbImZvciJdID09PSAiZnVuY3Rpb24iID8gU3ltYm9sWyJmb3IiXSgibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20iKSA6IG51bGw7CiAgICAgIGV4cG9ydHMyLkJ1ZmZlciA9IEJ1ZmZlcjEwOwogICAgICBleHBvcnRzMi5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjsKICAgICAgZXhwb3J0czIuSU5TUEVDVF9NQVhfQllURVMgPSA1MDsKICAgICAgdmFyIEtfTUFYX0xFTkdUSCA9IDIxNDc0ODM2NDc7CiAgICAgIGV4cG9ydHMyLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7CiAgICAgIEJ1ZmZlcjEwLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpOwogICAgICBpZiAoIUJ1ZmZlcjEwLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IGBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpOwogICAgICAgICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiA0MjsKICAgICAgICAgIH0gfTsKICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pOwogICAgICAgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDI7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMTAucHJvdG90eXBlLCAicGFyZW50IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjEwLnByb3RvdHlwZSwgIm9mZnNldCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRoaXMpKQogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIobGVuZ3RoKSB7CiAgICAgICAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIGxlbmd0aCArICciIGlzIGludmFsaWQgZm9yIG9wdGlvbiAic2l6ZSInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyMTAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnBvb2xTaXplID0gODE5MjsKICAgICAgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nMih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAidW5kZWZpbmVkIiAmJiAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ2YWx1ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKTsKICAgICAgICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSk7CiAgICAgICAgaWYgKGIpCiAgICAgICAgICByZXR1cm4gYjsKICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIxMC5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oInN0cmluZyIpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5mcm9tID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9OwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMTAucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSk7CiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIxMCwgVWludDhBcnJheSk7CiAgICAgIGZ1bmN0aW9uIGFzc2VydFNpemUoc2l6ZSkgewogICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfSBlbHNlIGlmIChzaXplIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHNpemUgKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICBpZiAoc2l6ZSA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKSA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmFsbG9jID0gZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcyKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDsKICAgICAgICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpOwogICAgICAgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkgewogICAgICAgICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheSkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDsKICAgICAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlWaWV3KGFycmF5VmlldykgewogICAgICAgIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHsKICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpOwogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignIm9mZnNldCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcibGVuZ3RoIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgbGV0IGJ1ZjsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdm9pZCAwICYmIGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSk7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMTAucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKCtsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIyKGIpIHsKICAgICAgICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIgIT09IEJ1ZmZlcjEwLnByb3RvdHlwZTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKGEsIGIpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkKICAgICAgICAgIGEgPSBCdWZmZXIxMC5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYiA9IEJ1ZmZlcjEwLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyMTAuaXNCdWZmZXIoYikpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAiYnVmMSIsICJidWYyIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpOwogICAgICAgIH0KICAgICAgICBpZiAoYSA9PT0gYikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gYS5sZW5ndGg7CiAgICAgICAgbGV0IHkgPSBiLmxlbmd0aDsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgICAgICAgeCA9IGFbaV07CiAgICAgICAgICAgIHkgPSBiW2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZykgewogICAgICAgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7CiAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChsaXN0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuYWxsb2MoMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyMTAuYWxsb2NVbnNhZmUobGVuZ3RoKTsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICAgICAgbGV0IGJ1ZiA9IGxpc3RbaV07CiAgICAgICAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlcjEwLmZyb20oYnVmKTsKICAgICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoYnVmZmVyLCBidWYsIHBvcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwogICAgICAgICAgfQogICAgICAgICAgcG9zICs9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWZmZXI7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgewogICAgICAgIGlmIChCdWZmZXIxMC5pc0J1ZmZlcihzdHJpbmcpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGNvbnN0IG11c3RNYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZTsKICAgICAgICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsZW47CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gKiAyOwogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gPj4+IDE7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCB8fCBzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICIiKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7CiAgICAgIGZ1bmN0aW9uIHN3YXAoYiwgbiwgbSkgewogICAgICAgIGNvbnN0IGkgPSBiW25dOwogICAgICAgIGJbbl0gPSBiW21dOwogICAgICAgIGJbbV0gPSBpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDIgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDggIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nMigpIHsKICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpOwogICAgICAgIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyMTAucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzMihiKSB7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihiKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAodGhpcyA9PT0gYikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBCdWZmZXIxMC5jb21wYXJlKHRoaXMsIGIpID09PSAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7CiAgICAgICAgbGV0IHN0ciA9ICIiOwogICAgICAgIGNvbnN0IG1heCA9IGV4cG9ydHMyLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoImhleCIsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICIkMSAiKS50cmltKCk7CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KQogICAgICAgICAgc3RyICs9ICIgLi4uICI7CiAgICAgICAgcmV0dXJuICI8QnVmZmVyICIgKyBzdHIgKyAiPiI7CiAgICAgIH07CiAgICAgIGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7CiAgICAgICAgQnVmZmVyMTAucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyMTAucHJvdG90eXBlLmluc3BlY3Q7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlMih0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkgewogICAgICAgIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHsKICAgICAgICAgIHRhcmdldCA9IEJ1ZmZlcjEwLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGFyZ2V0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ0YXJnZXQiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB0YXJnZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNTdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzRW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID4+Pj0gMDsKICAgICAgICBlbmQgPj4+PSAwOwogICAgICAgIHRoaXNTdGFydCA+Pj49IDA7CiAgICAgICAgdGhpc0VuZCA+Pj49IDA7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDsKICAgICAgICBsZXQgeSA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpOwogICAgICAgIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpOwogICAgICAgIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7CiAgICAgICAgICAgIHggPSB0aGlzQ29weVtpXTsKICAgICAgICAgICAgeSA9IHRhcmdldENvcHlbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0OwogICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMjE0NzQ4MzY0NykgewogICAgICAgICAgYnl0ZU9mZnNldCA9IDIxNDc0ODM2NDc7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTIxNDc0ODM2NDgpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAtMjE0NzQ4MzY0ODsKICAgICAgICB9CiAgICAgICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OwogICAgICAgIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiBidWZmZXIubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKQogICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0OwogICAgICAgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgdmFsID0gQnVmZmVyMTAuZnJvbSh2YWwsIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKHZhbCkpIHsKICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBsZXQgaW5kZXhTaXplID0gMTsKICAgICAgICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDsKICAgICAgICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDsKICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1Y3MyIiB8fCBlbmNvZGluZyA9PT0gInVjcy0yIiB8fCBlbmNvZGluZyA9PT0gInV0ZjE2bGUiIHx8IGVuY29kaW5nID09PSAidXRmLTE2bGUiKSB7CiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpbmRleFNpemUgPSAyOwogICAgICAgICAgICBhcnJMZW5ndGggLz0gMjsKICAgICAgICAgICAgdmFsTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIGJ5dGVPZmZzZXQgLz0gMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVhZChidWYsIGkyKSB7CiAgICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7CiAgICAgICAgICAgIHJldHVybiBidWZbaTJdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpCiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaTsKICAgICAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpCiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpCiAgICAgICAgICAgICAgICBpIC09IGkgLSBmb3VuZEluZGV4OwogICAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7CiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChmb3VuZCkKICAgICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBoZXhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwOwogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKCFsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7CiAgICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpOwogICAgICAgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpCiAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDAgJiYgdHlwZW9mIG9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0OwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkgewogICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gbGVuZ3RoOwogICAgICAgICAgICBsZW5ndGggPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwIHx8IGxlbmd0aCA+IHJlbWFpbmluZykKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogIkJ1ZmZlciIsCiAgICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMCkKICAgICAgICB9OwogICAgICB9OwogICAgICBmdW5jdGlvbiBiYXNlNjRTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGNvbnN0IHJlcyA9IFtdOwogICAgICAgIGxldCBpID0gc3RhcnQ7CiAgICAgICAgd2hpbGUgKGkgPCBlbmQpIHsKICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXTsKICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBudWxsOwogICAgICAgICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSBmaXJzdEJ5dGUgPiAyMzkgPyA0IDogZmlyc3RCeXRlID4gMjIzID8gMyA6IGZpcnN0Qnl0ZSA+IDE5MSA/IDIgOiAxOwogICAgICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkgewogICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHsKICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMTI4KSB7CiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMTI3KSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMjA0NyAmJiAodGVtcENvZGVQb2ludCA8IDU1Mjk2IHx8IHRlbXBDb2RlUG9pbnQgPiA1NzM0MykpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmIChmb3VydGhCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDE4IHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgMTIgfCAodGhpcmRCeXRlICYgNjMpIDw8IDYgfCBmb3VydGhCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHsKICAgICAgICAgICAgY29kZVBvaW50ID0gNjU1MzM7CiAgICAgICAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkgewogICAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7CiAgICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpOwogICAgICAgICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgaSArPSBieXRlc1BlclNlcXVlbmNlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcyk7CiAgICAgIH0KICAgICAgdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gNDA5NjsKICAgICAgZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpIHsKICAgICAgICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDsKICAgICAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7CiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpOwogICAgICAgIH0KICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlIChpIDwgbGVuKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDEyNyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGF0aW4xU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaGV4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICBsZXQgb3V0ID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpOwogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBzdGFydCA9IH5+c3RhcnQ7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyBsZW4gOiB+fmVuZDsKICAgICAgICBpZiAoc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCArPSBsZW47CiAgICAgICAgICBpZiAoc3RhcnQgPCAwKQogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgICAgICAgc3RhcnQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCAwKSB7CiAgICAgICAgICBlbmQgKz0gbGVuOwogICAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICAgIGVuZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBuZXdCdWY7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0KG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICAgICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm9mZnNldCBpcyBub3QgdWludCIpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludExFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHdoaWxlIChieXRlTGVuZ3RoMiA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50OCA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAxNjc3NzIxNjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsbyA9IGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQ7CiAgICAgICAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgbGFzdCAqIDIgKiogMjQ7CiAgICAgICAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0OwogICAgICAgIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDI7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTsKICAgICAgICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgaWYgKCEodGhpc1tvZmZzZXRdICYgMTI4KSkKICAgICAgICAgIHJldHVybiB0aGlzW29mZnNldF07CiAgICAgICAgcmV0dXJuICgyNTUgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4OwogICAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICsgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICsgKGxhc3QgPDwgMjQpOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQoZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdCk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJ2YWx1ZSIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyIC0gMTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAyNTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDE2QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0TEUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDddID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA2XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNV0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDRdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyAzXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDFdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXRdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBsaW1pdCAtIDEsIC1saW1pdCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBzdWIgPSAxOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAxMjcsIC0xMjgpOwogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICB2YWx1ZSA9IDI1NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gNDI5NDk2NzI5NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIC0zNDAyODIzNDY2Mzg1Mjg4NmUyMik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwgLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRhcmdldCkpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAoIXN0YXJ0KQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kICYmIGVuZCAhPT0gMCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoOwogICAgICAgIGlmICghdGFyZ2V0U3RhcnQpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IDA7CiAgICAgICAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBpZiAoZW5kID09PSBzdGFydCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCwgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSwgdGFyZ2V0U3RhcnQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykgewogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDsKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmQ7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDAgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiAmJiAhQnVmZmVyMTAuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTsKICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAidXRmOCIgJiYgY29kZSA8IDEyOCB8fCBlbmNvZGluZyA9PT0gImxhdGluMSIpIHsKICAgICAgICAgICAgICB2YWwgPSBjb2RlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gImJvb2xlYW4iKSB7CiAgICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiT3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBzdGFydCA9IHN0YXJ0ID4+PiAwOwogICAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7CiAgICAgICAgaWYgKCF2YWwpCiAgICAgICAgICB2YWwgPSAwOwogICAgICAgIGxldCBpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2ldID0gdmFsOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBieXRlcyA9IEJ1ZmZlcjEwLmlzQnVmZmVyKHZhbCkgPyB2YWwgOiBCdWZmZXIxMC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgIicgKyB2YWwgKyAnIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAidmFsdWUiJyk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIHZhciBlcnJvcnMgPSB7fTsKICAgICAgZnVuY3Rpb24gRShzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHsKICAgICAgICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2UgewogICAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAibWVzc2FnZSIsIHsKICAgICAgICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWA7CiAgICAgICAgICAgIHRoaXMuc3RhY2s7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWU7CiAgICAgICAgICB9CiAgICAgICAgICBnZXQgY29kZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHN5bTsKICAgICAgICAgIH0KICAgICAgICAgIHNldCBjb2RlKHZhbHVlKSB7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiY29kZSIsIHsKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICB2YWx1ZSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIEUoIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICBpZiAobmFtZSkgewogICAgICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7CiAgICAgICAgfQogICAgICAgIHJldHVybiAiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcyI7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBFKCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIGZ1bmN0aW9uKG5hbWUsIGFjdHVhbCkgewogICAgICAgIHJldHVybiBgVGhlICIke25hbWV9IiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBFKCJFUlJfT1VUX09GX1JBTkdFIiwgZnVuY3Rpb24oc3RyLCByYW5nZSwgaW5wdXQpIHsKICAgICAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiAiJHtzdHJ9IiBpcyBvdXQgb2YgcmFuZ2UuYDsKICAgICAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dDsKICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikgewogICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICJiaWdpbnQiKSB7CiAgICAgICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dCk7CiAgICAgICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7CiAgICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlY2VpdmVkICs9ICJuIjsKICAgICAgICB9CiAgICAgICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gOwogICAgICAgIHJldHVybiBtc2c7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBmdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gdmFsLmxlbmd0aDsKICAgICAgICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gIi0iID8gMSA6IDA7CiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHsKICAgICAgICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBpZiAoYnVmW29mZnNldF0gPT09IHZvaWQgMCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aDJdID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoMiArIDEpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgewogICAgICAgICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICJiaWdpbnQiID8gIm4iIDogIiI7CiAgICAgICAgICBsZXQgcmFuZ2U7CiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aDIgPiAzKSB7CiAgICAgICAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOH0ke259YDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259YDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWA7CiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoInZhbHVlIiwgcmFuZ2UsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICJudW1iZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJvdW5kc0Vycm9yKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHsKICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7CiAgICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSk7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgImFuIGludGVnZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChsZW5ndGggPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCwgdmFsdWUpOwogICAgICB9CiAgICAgIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2c7CiAgICAgIGZ1bmN0aW9uIGJhc2U2NGNsZWFuKHN0cikgewogICAgICAgIHN0ciA9IHN0ci5zcGxpdCgiPSIpWzBdOwogICAgICAgIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgIiIpOwogICAgICAgIGlmIChzdHIubGVuZ3RoIDwgMikKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgICAgICAgIHN0ciA9IHN0ciArICI9IjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7CiAgICAgICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTsKICAgICAgICBsZXQgY29kZVBvaW50OwogICAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgIGNvbnN0IGJ5dGVzID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHsKICAgICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU2MzE5KSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCA1NjMyMCkgewogICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDU1Mjk2IDw8IDEwIHwgY29kZVBvaW50IC0gNTYzMjApICsgNjU1MzY7CiAgICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICB9CiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCA2NTUzNikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTIgfCAyMjQsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTggfCAyNDAsIGNvZGVQb2ludCA+PiAxMiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29kZSBwb2ludCIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikgewogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDI1NSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLCB1bml0cykgewogICAgICAgIGxldCBjLCBoaSwgbG87CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGhpID0gYyA+PiA4OwogICAgICAgICAgbG8gPSBjICUgMjU2OwogICAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pOwogICAgICAgICAgYnl0ZUFycmF5LnB1c2goaGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7CiAgICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG9iaiwgdHlwZSkgewogICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBudW1iZXJJc05hTihvYmopIHsKICAgICAgICByZXR1cm4gb2JqICE9PSBvYmo7CiAgICAgIH0KICAgICAgdmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBjb25zdCBhbHBoYWJldCA9ICIwMTIzNDU2Nzg5YWJjZGVmIjsKICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkgewogICAgICAgICAgY29uc3QgaTE2ID0gaSAqIDE2OwogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7CiAgICAgICAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9KCk7CiAgICAgIGZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZChmbikgewogICAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAidW5kZWZpbmVkIiA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQmlnSW50IG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMKICB2YXIgaW1wb3J0X2J1ZmZlcjsKICB2YXIgaW5pdF9idWZmZXJfc2hpbSA9IF9fZXNtKHsKICAgICJzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMiKCkgewogICAgICBpbXBvcnRfYnVmZmVyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Nqc19wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAidW5kZWZpbmVkIiAmJiBSZWZsZWN0LmdldCkgewogICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgInJlYXNvbiIsIHsKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbDIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcyKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRTaWduYWxdIjsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAiYWJvcnQiKSB7CiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25hYm9ydCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgdGhpcy5vbmFib3J0LmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbDIucHJvdG90eXBlKSwgImRpc3BhdGNoRXZlbnQiLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0U2lnbmFsMjsKICAgICAgfShFbWl0dGVyKTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIyKCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0Q29udHJvbGxlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJzaWduYWwiLCB7CiAgICAgICAgICAgIHZhbHVlOiBuZXcgQWJvcnRTaWduYWwoKSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydENvbnRyb2xsZXIyLCBbewogICAgICAgICAga2V5OiAiYWJvcnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHJlYXNvbikgewogICAgICAgICAgICB2YXIgZXZlbnQ7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoImFib3J0Iik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7CiAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSAiYWJvcnQiOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgiRXZlbnQiKTsKICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCJhYm9ydCIsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGV2ZW50ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAiYWJvcnQiLAogICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzaWduYWxSZWFzb24gPSByZWFzb247CiAgICAgICAgICAgIGlmIChzaWduYWxSZWFzb24gPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IERPTUV4Y2VwdGlvbigic2lnbmFsIGlzIGFib3J0ZWQgd2l0aG91dCByZWFzb24iKTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSBzaWduYWxSZWFzb247CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZzIoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydENvbnRyb2xsZXJdIjsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjI7CiAgICAgIH0oKTsKICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1N0cmluZ1RhZykgewogICAgICAgIEFib3J0Q29udHJvbGxlci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydENvbnRyb2xsZXIiOwogICAgICAgIEFib3J0U2lnbmFsLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gIkFib3J0U2lnbmFsIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmMikgewogICAgICAgIGlmIChzZWxmMi5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTD10cnVlIGlzIHNldCwgd2lsbCBmb3JjZSBpbnN0YWxsIHBvbHlmaWxsIik7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmMi5SZXF1ZXN0ID09PSAiZnVuY3Rpb24iICYmICFzZWxmMi5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgIXNlbGYyLkFib3J0Q29udHJvbGxlcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHsKICAgICAgICBpZiAodHlwZW9mIHBhdGNoVGFyZ2V0cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcGF0Y2hUYXJnZXRzID0gewogICAgICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgX3BhdGNoVGFyZ2V0cyA9IHBhdGNoVGFyZ2V0cywgZmV0Y2ggPSBfcGF0Y2hUYXJnZXRzLmZldGNoLCBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QgPSBfcGF0Y2hUYXJnZXRzLlJlcXVlc3QsIE5hdGl2ZVJlcXVlc3QgPSBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QgPT09IHZvaWQgMCA/IGZldGNoLlJlcXVlc3QgOiBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QsIE5hdGl2ZUFib3J0Q29udHJvbGxlciA9IF9wYXRjaFRhcmdldHMuQWJvcnRDb250cm9sbGVyLCBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0UgPSBfcGF0Y2hUYXJnZXRzLl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwsIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgPSBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFOwogICAgICAgIGlmICghcG9seWZpbGxOZWVkZWQoewogICAgICAgICAgZmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0OiBOYXRpdmVSZXF1ZXN0LAogICAgICAgICAgQWJvcnRDb250cm9sbGVyOiBOYXRpdmVBYm9ydENvbnRyb2xsZXIsCiAgICAgICAgICBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMCiAgICAgICAgfSkpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGZldGNoLAogICAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgUmVxdWVzdCA9IE5hdGl2ZVJlcXVlc3Q7CiAgICAgICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCJzaWduYWwiKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICAgIHZhciBzaWduYWw7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBzaWduYWwgPSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0Mik7CiAgICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwgInNpZ25hbCIsIHsKICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0OwogICAgICAgICAgfTsKICAgICAgICAgIFJlcXVlc3QucHJvdG90eXBlID0gTmF0aXZlUmVxdWVzdC5wcm90b3R5cGU7CiAgICAgICAgfQogICAgICAgIHZhciByZWFsRmV0Y2ggPSBmZXRjaDsKICAgICAgICB2YXIgYWJvcnRhYmxlRmV0Y2ggPSBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICB2YXIgc2lnbmFsID0gUmVxdWVzdCAmJiBSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSA/IGlucHV0LnNpZ25hbCA6IGluaXQyID8gaW5pdDIuc2lnbmFsIDogdm9pZCAwOwogICAgICAgICAgaWYgKHNpZ25hbCkgewogICAgICAgICAgICB2YXIgYWJvcnRFcnJvcjsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IERPTUV4Y2VwdGlvbigiQWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgIGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoIkFib3J0ZWQiKTsKICAgICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAiQWJvcnRFcnJvciI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBjYW5jZWxsYXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihfLCByZWplY3QpIHsKICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYWJvcnRFcnJvcik7CiAgICAgICAgICAgICAgfSwgewogICAgICAgICAgICAgICAgb25jZTogdHJ1ZQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgaWYgKGluaXQyICYmIGluaXQyLnNpZ25hbCkgewogICAgICAgICAgICAgIGRlbGV0ZSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uLCByZWFsRmV0Y2goaW5wdXQsIGluaXQyKV0pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlYWxGZXRjaChpbnB1dCwgaW5pdDIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGZldGNoOiBhYm9ydGFibGVGZXRjaCwKICAgICAgICAgIFJlcXVlc3QKICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0czIuYWJvcnRhYmxlRmV0Y2ggPSBhYm9ydGFibGVGZXRjaERlY29yYXRvcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5BYm9ydFNpZ25hbCA9IGV4cG9ydHMyLkFib3J0Q29udHJvbGxlciA9IHZvaWQgMDsKICAgICAgdmFyIGNqc19wb255ZmlsbF8xID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBzZWxmOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3c7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIGdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QiKTsKICAgICAgfTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIHZhciBBYm9ydFNpZ25hbCA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRTaWduYWwgOiBnZXRHbG9iYWwoKS5BYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIuanMKICB2YXIgcmVxdWlyZV9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEgPSByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCgpOwogICAgICB2YXIgTnVsbFNpZ25hbCA9IGNsYXNzIHsKICAgICAgfTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscyA9IG5ldyBTZXQoKTsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlcigpOwogICAgICAgIH0KICAgICAgICBhZGRTaWduYWwoc2lnbmFsID0gbmV3IE51bGxTaWduYWwoKSkgewogICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgYWRkIGEgc2lnbmFsLCBhbHJlYWR5IGFib3J0ZWQhIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnNpZ25hbHMuYWRkKHNpZ25hbCk7CiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBoYW5kbGVBYm9ydGVkKHNpZ25hbCkgewogICAgICAgICAgdGhpcy5zaWduYWxzLmRlbGV0ZShzaWduYWwpOwogICAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5zaXplID09PSAwKSB7CiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldCBzaWduYWwoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsOwogICAgICAgIH0KICAgICAgICBhYm9ydCgpIHsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWdncmVnYXRlQWJvcnRDb250cm9sbGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IFNldCgpOwogICAgICAgIH0KICAgICAgICBhZGRDYWxsYmFjayhjYWxsYmFjayA9ICgpID0+IHsKICAgICAgICB9KSB7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGQoY2FsbGJhY2spOwogICAgICAgICAgY2FsbGJhY2sodGhpcy5jdXJyZW50TWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UpIHsKICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaCgoZWx0KSA9PiB7CiAgICAgICAgICAgIGVsdChtZXNzYWdlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcwogIHZhciByZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWJvcnRhYmxlUHJvbWlzZUNhY2hlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyKCkpOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNhY2hlIH0pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBmaWxsIGZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWNoZSBtdXN0IGltcGxlbWVudCBnZXQoa2V5KSwgc2V0KGtleSwgdmFsKSwgYW5kIGFuZCBkZWxldGUoa2V5KSIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlOwogICAgICAgICAgdGhpcy5maWxsQ2FsbGJhY2sgPSBmaWxsOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfQogICAgICAgIGV2aWN0KGtleSwgZW50cnkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmdldChrZXkpID09PSBlbnRyeSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmaWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgY29uc3QgYWJvcnRlciA9IG5ldyBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBjb25zdCBzdGF0dXNSZXBvcnRlciA9IG5ldyBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcl8xLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gewogICAgICAgICAgICBhYm9ydGVyLAogICAgICAgICAgICBwcm9taXNlOiB0aGlzLmZpbGxDYWxsYmFjayhkYXRhLCBhYm9ydGVyLnNpZ25hbCwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgaWYgKCFuZXdFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oKCkgPT4gewogICAgICAgICAgICBuZXdFbnRyeS5zZXR0bGVkID0gdHJ1ZTsKICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIG5ld0VudHJ5KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGNoZWNrU2luZ2xlUHJvbWlzZShwcm9taXNlLCBzaWduYWwpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yU2luZ2xlQWJvcnQoKSB7CiAgICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiYWJvcnRlZCIpLCB7IGNvZGU6ICJFUlJfQUJPUlRFRCIgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gewogICAgICAgICAgICBjaGVja0ZvclNpbmdsZUFib3J0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9LCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgaWYgKCFzaWduYWwgJiYgZGF0YSBpbnN0YW5jZW9mIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0U2lnbmFsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInNlY29uZCBnZXQgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhbiBBYm9ydFNpZ25hbCwgcGVyaGFwcyB5b3UgbWVhbnQgdG8gcGFzcyBgbnVsbGAgZm9yIHRoZSBmaWxsIGRhdGE/Iik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSB7CiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBjYWNoZUVudHJ5KTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZUVudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGNhY2hlRW50cnkuc3RhdHVzUmVwb3J0ZXIuYWRkQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5maWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVkRW50cnkpIHsKICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgY29uc3Qga2V5SXRlciA9IHRoaXMuY2FjaGUua2V5cygpOwogICAgICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMDsKICAgICAgICAgIGZvciAobGV0IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpOyAhcmVzdWx0LmRvbmU7IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICAgIGRlbGV0ZUNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVsZXRlQ291bnQ7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9pbmRleC5qcwogIHZhciByZXF1aXJlX2VzbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUoKSk7CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMS5kZWZhdWx0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIHZhciByZXF1aXJlX3F1aWNrX2xydSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFF1aWNrTFJVID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkgewogICAgICAgICAgaWYgKCEob3B0aW9ucy5tYXhTaXplICYmIG9wdGlvbnMubWF4U2l6ZSA+IDApKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7CiAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgIH0KICAgICAgICBfc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgdGhpcy5fc2l6ZSsrOwogICAgICAgICAgaWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTsKICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0KGtleSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICAgIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXQoa2V5LCB2YWx1ZSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgaGFzKGtleSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSkgfHwgdGhpcy5vbGRDYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgcGVlayhrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRlbGV0ZShrZXkpIHsKICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgaWYgKGRlbGV0ZWQpIHsKICAgICAgICAgICAgdGhpcy5fc2l6ZS0tOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSkgfHwgZGVsZXRlZDsKICAgICAgICB9CiAgICAgICAgY2xlYXIoKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7CiAgICAgICAgICB0aGlzLm9sZENhY2hlLmNsZWFyKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgKmtleXMoKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQga2V5OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAqdmFsdWVzKCkgewogICAgICAgICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykgewogICAgICAgICAgICB5aWVsZCB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHsKICAgICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7CiAgICAgICAgICAgIGNvbnN0IFtrZXldID0gaXRlbTsKICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQgc2l6ZSgpIHsKICAgICAgICAgIGxldCBvbGRDYWNoZVNpemUgPSAwOwogICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5vbGRDYWNoZS5rZXlzKCkpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgICAgb2xkQ2FjaGVTaXplKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplICsgb2xkQ2FjaGVTaXplOwogICAgICAgIH0KICAgICAgfTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gUXVpY2tMUlU7CiAgICB9CiAgfSk7CgogIC8vIChkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vbG9jYWxGaWxlCiAgdmFyIHJlcXVpcmVfbG9jYWxGaWxlID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9sb2NhbEZpbGUiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFRZUEVEX09LID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBVaW50MTZBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIEludDMyQXJyYXkgIT09ICJ1bmRlZmluZWQiOwogICAgICBmdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuYXNzaWduID0gZnVuY3Rpb24ob2JqKSB7CiAgICAgICAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgICAgIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkgewogICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTsKICAgICAgICAgIGlmICghc291cmNlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICJvYmplY3QiKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgIm11c3QgYmUgbm9uLW9iamVjdCIpOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHsKICAgICAgICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkgewogICAgICAgICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqOwogICAgICB9OwogICAgICBleHBvcnRzMi5zaHJpbmtCdWYgPSBmdW5jdGlvbihidWYsIHNpemUpIHsKICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgewogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSkgewogICAgICAgICAgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsKICAgICAgICB9CiAgICAgICAgYnVmLmxlbmd0aCA9IHNpemU7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgdmFyIGZuVHlwZWQgPSB7CiAgICAgICAgYXJyYXlTZXQ6IGZ1bmN0aW9uKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7CiAgICAgICAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHsKICAgICAgICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7CiAgICAgICAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7CiAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pOwogICAgICAgICAgcG9zID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGNodW5rID0gY2h1bmtzW2ldOwogICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpOwogICAgICAgICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBmblVudHlwZWQgPSB7CiAgICAgICAgYXJyYXlTZXQ6IGZ1bmN0aW9uKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNldFR5cGVkID0gZnVuY3Rpb24ob24pIHsKICAgICAgICBpZiAob24pIHsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjggPSBVaW50OEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMTYgPSBVaW50MTZBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjMyID0gSW50MzJBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLmFzc2lnbihleHBvcnRzMiwgZm5UeXBlZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjggPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjE2ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYzMiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuYXNzaWduKGV4cG9ydHMyLCBmblVudHlwZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuc2V0VHlwZWQoVFlQRURfT0spOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcwogIHZhciByZXF1aXJlX3RyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0JJTkFSWSA9IDA7CiAgICAgIHZhciBaX1RFWFQgPSAxOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgU1RPUkVEX0JMT0NLID0gMDsKICAgICAgdmFyIFNUQVRJQ19UUkVFUyA9IDE7CiAgICAgIHZhciBEWU5fVFJFRVMgPSAyOwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBCdWZfc2l6ZSA9IDE2OwogICAgICB2YXIgTUFYX0JMX0JJVFMgPSA3OwogICAgICB2YXIgRU5EX0JMT0NLID0gMjU2OwogICAgICB2YXIgUkVQXzNfNiA9IDE2OwogICAgICB2YXIgUkVQWl8zXzEwID0gMTc7CiAgICAgIHZhciBSRVBaXzExXzEzOCA9IDE4OwogICAgICB2YXIgZXh0cmFfbGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF07CiAgICAgIHZhciBleHRyYV9kYml0cyA9IFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTNdOwogICAgICB2YXIgZXh0cmFfYmxiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDddOwogICAgICB2YXIgYmxfb3JkZXIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07CiAgICAgIHZhciBESVNUX0NPREVfTEVOID0gNTEyOwogICAgICB2YXIgc3RhdGljX2x0cmVlID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTsKICAgICAgemVybyhzdGF0aWNfbHRyZWUpOwogICAgICB2YXIgc3RhdGljX2R0cmVlID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTsKICAgICAgemVybyhzdGF0aWNfZHRyZWUpOwogICAgICB2YXIgX2Rpc3RfY29kZSA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTsKICAgICAgemVybyhfZGlzdF9jb2RlKTsKICAgICAgdmFyIF9sZW5ndGhfY29kZSA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTsKICAgICAgemVybyhfbGVuZ3RoX2NvZGUpOwogICAgICB2YXIgYmFzZV9sZW5ndGggPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTsKICAgICAgemVybyhiYXNlX2xlbmd0aCk7CiAgICAgIHZhciBiYXNlX2Rpc3QgPSBuZXcgQXJyYXkoRF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9kaXN0KTsKICAgICAgZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7CiAgICAgICAgdGhpcy5zdGF0aWNfdHJlZSA9IHN0YXRpY190cmVlOwogICAgICAgIHRoaXMuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7CiAgICAgICAgdGhpcy5leHRyYV9iYXNlID0gZXh0cmFfYmFzZTsKICAgICAgICB0aGlzLmVsZW1zID0gZWxlbXM7CiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDsKICAgICAgICB0aGlzLmhhc19zdHJlZSA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2xfZGVzYzsKICAgICAgdmFyIHN0YXRpY19kX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfYmxfZGVzYzsKICAgICAgZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykgewogICAgICAgIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsKICAgICAgICB0aGlzLm1heF9jb2RlID0gMDsKICAgICAgICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkX2NvZGUoZGlzdCkgewogICAgICAgIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfc2hvcnQocywgdykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgPj4+IDggJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuZ3RoKSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSB2YWx1ZSA+PiBCdWZfc2l6ZSAtIHMuYmlfdmFsaWQ7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHsKICAgICAgICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0sIHRyZWVbYyAqIDIgKyAxXSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHsKICAgICAgICB2YXIgcmVzID0gMDsKICAgICAgICBkbyB7CiAgICAgICAgICByZXMgfD0gY29kZSAmIDE7CiAgICAgICAgICBjb2RlID4+Pj0gMTsKICAgICAgICAgIHJlcyA8PD0gMTsKICAgICAgICB9IHdoaWxlICgtLWxlbiA+IDApOwogICAgICAgIHJldHVybiByZXMgPj4+IDE7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfZmx1c2gocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID09PSAxNikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMjU1OwogICAgICAgICAgcy5iaV9idWYgPj49IDg7CiAgICAgICAgICBzLmJpX3ZhbGlkIC09IDg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSBkZXNjLm1heF9jb2RlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGV4dHJhID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0czsKICAgICAgICB2YXIgYmFzZSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7CiAgICAgICAgdmFyIG1heF9sZW5ndGggPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoOwogICAgICAgIHZhciBoOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciB4Yml0czsKICAgICAgICB2YXIgZjsKICAgICAgICB2YXIgb3ZlcmZsb3cgPSAwOwogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsKICAgICAgICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7CiAgICAgICAgICBuID0gcy5oZWFwW2hdOwogICAgICAgICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdICogMiArIDFdICsgMTsKICAgICAgICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkgewogICAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDsKICAgICAgICAgICAgb3ZlcmZsb3crKzsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICBpZiAobiA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSsrOwogICAgICAgICAgeGJpdHMgPSAwOwogICAgICAgICAgaWYgKG4gPj0gYmFzZSkgewogICAgICAgICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTsKICAgICAgICAgIH0KICAgICAgICAgIGYgPSB0cmVlW24gKiAyXTsKICAgICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gKyB4Yml0cyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvdmVyZmxvdyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7CiAgICAgICAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgewogICAgICAgICAgICBiaXRzLS07CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdLS07CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOwogICAgICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tOwogICAgICAgICAgb3ZlcmZsb3cgLT0gMjsKICAgICAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApOwogICAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkgewogICAgICAgICAgbiA9IHMuYmxfY291bnRbYml0c107CiAgICAgICAgICB3aGlsZSAobiAhPT0gMCkgewogICAgICAgICAgICBtID0gcy5oZWFwWy0taF07CiAgICAgICAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHJlZVttICogMiArIDFdICE9PSBiaXRzKSB7CiAgICAgICAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdKSAqIHRyZWVbbSAqIDJdOwogICAgICAgICAgICAgIHRyZWVbbSAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbi0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSB7CiAgICAgICAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIHZhciBjb2RlID0gMDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSBjb2RlICsgYmxfY291bnRbYml0cyAtIDFdIDw8IDE7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXTsKICAgICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxlbmd0aDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICBsZW5ndGggPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoOwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfbGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTsKICAgICAgICBkaXN0ID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGlzdCA+Pj0gNzsKICAgICAgICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV0gLSA3OyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIG4gPSAwOwogICAgICAgIHdoaWxlIChuIDw9IDE0MykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjU1KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDk7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs5XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNzkpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gNzsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzddKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI4NykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXSA9IDU7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuLCA1KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9kdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5ibF90cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTsKICAgICAgICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3dpbmR1cChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7CiAgICAgICAgfQogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpIHsKICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgaWYgKGhlYWRlcikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIGxlbik7CiAgICAgICAgICBwdXRfc2hvcnQocywgfmxlbik7CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTsKICAgICAgICBzLnBlbmRpbmcgKz0gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHsKICAgICAgICB2YXIgX24yID0gbiAqIDI7CiAgICAgICAgdmFyIF9tMiA9IG0gKiAyOwogICAgICAgIHJldHVybiB0cmVlW19uMl0gPCB0cmVlW19tMl0gfHwgdHJlZVtfbjJdID09PSB0cmVlW19tMl0gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKSB7CiAgICAgICAgdmFyIHYgPSBzLmhlYXBba107CiAgICAgICAgdmFyIGogPSBrIDw8IDE7CiAgICAgICAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikgewogICAgICAgICAgaWYgKGogPCBzLmhlYXBfbGVuICYmIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdOwogICAgICAgICAgayA9IGo7CiAgICAgICAgICBqIDw8PSAxOwogICAgICAgIH0KICAgICAgICBzLmhlYXBba10gPSB2OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBsYzsKICAgICAgICB2YXIgbHggPSAwOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBleHRyYTsKICAgICAgICBpZiAocy5sYXN0X2xpdCAhPT0gMCkgewogICAgICAgICAgZG8gewogICAgICAgICAgICBkaXN0ID0gcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4IHwgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV07CiAgICAgICAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdOwogICAgICAgICAgICBseCsrOwogICAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7CiAgICAgICAgfQogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZWxlbXMgPSBkZXNjLnN0YXRfZGVzYy5lbGVtczsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSAtMTsKICAgICAgICB2YXIgbm9kZTsKICAgICAgICBzLmhlYXBfbGVuID0gMDsKICAgICAgICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7CiAgICAgICAgICBpZiAodHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47CiAgICAgICAgICAgIHMuZGVwdGhbbl0gPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7CiAgICAgICAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMDsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAwOwogICAgICAgICAgcy5vcHRfbGVuLS07CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7CiAgICAgICAgZm9yIChuID0gcy5oZWFwX2xlbiA+PiAxOyBuID49IDE7IG4tLSkgewogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsKICAgICAgICB9CiAgICAgICAgbm9kZSA9IGVsZW1zOwogICAgICAgIGRvIHsKICAgICAgICAgIG4gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbMV0gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgICBtID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSB0cmVlW24gKiAyXSArIHRyZWVbbSAqIDJdOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxOwogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gdHJlZVttICogMiArIDFdID0gbm9kZTsKICAgICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKzsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTsKICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxXTsKICAgICAgICBnZW5fYml0bGVuKHMsIGRlc2MpOwogICAgICAgIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSA2NTUzNTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0gKz0gY291bnQ7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0rKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdKys7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgICBjb3VudC0tOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7CiAgICAgICAgdmFyIG1heF9ibGluZGV4OwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTsKICAgICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7CiAgICAgICAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDsKICAgICAgICByZXR1cm4gbWF4X2JsaW5kZXg7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpIHsKICAgICAgICB2YXIgcmFuazsKICAgICAgICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCA0KTsKICAgICAgICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTsKICAgICAgICB9CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsKICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykgewogICAgICAgIHZhciBibGFja19tYXNrID0gNDA5MzYyNDQ0NzsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7CiAgICAgICAgICBpZiAoYmxhY2tfbWFzayAmIDEgJiYgcy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEzICogMl0gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykgewogICAgICAgICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTsKICAgICAgZnVuY3Rpb24gX3RyX2luaXQocykgewogICAgICAgIGlmICghc3RhdGljX2luaXRfZG9uZSkgewogICAgICAgICAgdHJfc3RhdGljX2luaXQoKTsKICAgICAgICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlOwogICAgICAgIH0KICAgICAgICBzLmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7CiAgICAgICAgcy5kX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpOwogICAgICAgIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTsKICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfYWxpZ24ocykgewogICAgICAgIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTsKICAgICAgICBiaV9mbHVzaChzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsKICAgICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOwogICAgICAgIGlmIChzLmxldmVsID4gMCkgewogICAgICAgICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikgewogICAgICAgICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTsKICAgICAgICAgIH0KICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpOwogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7CiAgICAgICAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7CiAgICAgICAgICBvcHRfbGVuYiA9IHMub3B0X2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgc3RhdGljX2xlbmIgPSBzLnN0YXRpY19sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgewogICAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7CiAgICAgICAgfQogICAgICAgIGlmIChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYiAmJiBidWYgIT09IC0xKSB7CiAgICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7CiAgICAgICAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpOwogICAgICAgIH0KICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICAgIGlmIChsYXN0KSB7CiAgICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSA9IGRpc3QgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDI1NTsKICAgICAgICBzLmxhc3RfbGl0Kys7CiAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgIHMuZHluX2x0cmVlW2xjICogMl0rKzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5tYXRjaGVzKys7CiAgICAgICAgICBkaXN0LS07CiAgICAgICAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrOwogICAgICAgICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0rKzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxOwogICAgICB9CiAgICAgIGV4cG9ydHMyLl90cl9pbml0ID0gX3RyX2luaXQ7CiAgICAgIGV4cG9ydHMyLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrOwogICAgICBleHBvcnRzMi5fdHJfZmx1c2hfYmxvY2sgPSBfdHJfZmx1c2hfYmxvY2s7CiAgICAgIGV4cG9ydHMyLl90cl90YWxseSA9IF90cl90YWxseTsKICAgICAgZXhwb3J0czIuX3RyX2FsaWduID0gX3RyX2FsaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzCiAgdmFyIHJlcXVpcmVfYWRsZXIzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHMxID0gYWRsZXIgJiA2NTUzNSB8IDAsIHMyID0gYWRsZXIgPj4+IDE2ICYgNjU1MzUgfCAwLCBuID0gMDsKICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7CiAgICAgICAgICBuID0gbGVuID4gMmUzID8gMmUzIDogbGVuOwogICAgICAgICAgbGVuIC09IG47CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMxID0gczEgKyBidWZbcG9zKytdIHwgMDsKICAgICAgICAgICAgczIgPSBzMiArIHMxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzMSAlPSA2NTUyMTsKICAgICAgICAgIHMyICU9IDY1NTIxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gczEgfCBzMiA8PCAxNiB8IDA7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gYWRsZXIzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMKICB2YXIgcmVxdWlyZV9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gbWFrZVRhYmxlKCkgewogICAgICAgIHZhciBjLCB0YWJsZSA9IFtdOwogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHsKICAgICAgICAgIGMgPSBuOwogICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHsKICAgICAgICAgICAgYyA9IGMgJiAxID8gMzk4ODI5MjM4NCBeIGMgPj4+IDEgOiBjID4+PiAxOwogICAgICAgICAgfQogICAgICAgICAgdGFibGVbbl0gPSBjOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFibGU7CiAgICAgIH0KICAgICAgdmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7CiAgICAgIGZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykgewogICAgICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjsKICAgICAgICBjcmMgXj0gLTE7CiAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7CiAgICAgICAgICBjcmMgPSBjcmMgPj4+IDggXiB0WyhjcmMgXiBidWZbaV0pICYgMjU1XTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyYyBeIC0xOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNyYzMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcwogIHZhciByZXF1aXJlX21lc3NhZ2VzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHRyZWVzID0gcmVxdWlyZV90cmVlcygpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaX05PX0ZMVVNIID0gMDsKICAgICAgdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7CiAgICAgIHZhciBaX0ZVTExfRkxVU0ggPSAzOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9CTE9DSyA9IDU7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX0JVRl9FUlJPUiA9IC01OwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0ZJTFRFUkVEID0gMTsKICAgICAgdmFyIFpfSFVGRk1BTl9PTkxZID0gMjsKICAgICAgdmFyIFpfUkxFID0gMzsKICAgICAgdmFyIFpfRklYRUQgPSA0OwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfVU5LTk9XTiA9IDI7CiAgICAgIHZhciBaX0RFRkxBVEVEID0gODsKICAgICAgdmFyIE1BWF9NRU1fTEVWRUwgPSA5OwogICAgICB2YXIgTUFYX1dCSVRTID0gMTU7CiAgICAgIHZhciBERUZfTUVNX0xFVkVMID0gODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBNSU5fTUFUQ0ggPSAzOwogICAgICB2YXIgTUFYX01BVENIID0gMjU4OwogICAgICB2YXIgTUlOX0xPT0tBSEVBRCA9IE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDE7CiAgICAgIHZhciBQUkVTRVRfRElDVCA9IDMyOwogICAgICB2YXIgSU5JVF9TVEFURSA9IDQyOwogICAgICB2YXIgRVhUUkFfU1RBVEUgPSA2OTsKICAgICAgdmFyIE5BTUVfU1RBVEUgPSA3MzsKICAgICAgdmFyIENPTU1FTlRfU1RBVEUgPSA5MTsKICAgICAgdmFyIEhDUkNfU1RBVEUgPSAxMDM7CiAgICAgIHZhciBCVVNZX1NUQVRFID0gMTEzOwogICAgICB2YXIgRklOSVNIX1NUQVRFID0gNjY2OwogICAgICB2YXIgQlNfTkVFRF9NT1JFID0gMTsKICAgICAgdmFyIEJTX0JMT0NLX0RPTkUgPSAyOwogICAgICB2YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOwogICAgICB2YXIgQlNfRklOSVNIX0RPTkUgPSA0OwogICAgICB2YXIgT1NfQ09ERSA9IDM7CiAgICAgIGZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHsKICAgICAgICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdOwogICAgICAgIHJldHVybiBlcnJvckNvZGU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmFuayhmKSB7CiAgICAgICAgcmV0dXJuIChmIDw8IDEpIC0gKGYgPiA0ID8gOSA6IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHplcm8oYnVmKSB7CiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHsKICAgICAgICAgIGJ1ZltsZW5dID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7CiAgICAgICAgdmFyIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHZhciBsZW4gPSBzLnBlbmRpbmc7CiAgICAgICAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7CiAgICAgICAgICBsZW4gPSBzdHJtLmF2YWlsX291dDsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTsKICAgICAgICBzdHJtLm5leHRfb3V0ICs9IGxlbjsKICAgICAgICBzLnBlbmRpbmdfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX291dCArPSBsZW47CiAgICAgICAgc3RybS5hdmFpbF9vdXQgLT0gbGVuOwogICAgICAgIHMucGVuZGluZyAtPSBsZW47CiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gMCkgewogICAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkgewogICAgICAgIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCBzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEsIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDsKICAgICAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0X2J5dGUocywgYikgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiID4+PiA4ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDI1NTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7CiAgICAgICAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgaWYgKGxlbiA+IHNpemUpIHsKICAgICAgICAgIGxlbiA9IHNpemU7CiAgICAgICAgfQogICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBzdHJtLmF2YWlsX2luIC09IGxlbjsKICAgICAgICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7CiAgICAgICAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkgewogICAgICAgICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9IGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikgewogICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBsZW47CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkgewogICAgICAgIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7CiAgICAgICAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OwogICAgICAgIHZhciBtYXRjaDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7CiAgICAgICAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7CiAgICAgICAgdmFyIGxpbWl0ID0gcy5zdHJzdGFydCA+IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCA/IHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDA7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICB2YXIgd21hc2sgPSBzLndfbWFzazsKICAgICAgICB2YXIgcHJldiA9IHMucHJldjsKICAgICAgICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICB2YXIgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICB2YXIgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7CiAgICAgICAgICBjaGFpbl9sZW5ndGggPj49IDI7CiAgICAgICAgfQogICAgICAgIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgbWF0Y2ggPSBjdXJfbWF0Y2g7CiAgICAgICAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAhPT0gc2Nhbl9lbmQgfHwgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fCBfd2luW21hdGNoXSAhPT0gX3dpbltzY2FuXSB8fCBfd2luWysrbWF0Y2hdICE9PSBfd2luW3NjYW4gKyAxXSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHNjYW4gKz0gMjsKICAgICAgICAgIG1hdGNoKys7CiAgICAgICAgICBkbyB7CiAgICAgICAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIHNjYW4gPCBzdHJlbmQpOwogICAgICAgICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDsKICAgICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikgewogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoOwogICAgICAgICAgICBiZXN0X2xlbiA9IGxlbjsKICAgICAgICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICAgICAgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTsKICAgICAgICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBiZXN0X2xlbjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubG9va2FoZWFkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHsKICAgICAgICB2YXIgX3dfc2l6ZSA9IHMud19zaXplOwogICAgICAgIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7CiAgICAgICAgZG8gewogICAgICAgICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApOwogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBuID0gcy5oYXNoX3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMuaGVhZFstLXBdOwogICAgICAgICAgICAgIHMuaGVhZFtwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbiA9IF93X3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMucHJldlstLXBdOwogICAgICAgICAgICAgIHMucHJldltwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbW9yZSArPSBfd19zaXplOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpOwogICAgICAgICAgcy5sb29rYWhlYWQgKz0gbjsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7CiAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdOwogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHdoaWxlIChzLmluc2VydCkgewogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgICBzdHIrKzsKICAgICAgICAgICAgICBzLmluc2VydC0tOwogICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgewogICAgICAgIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDY1NTM1OwogICAgICAgIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHsKICAgICAgICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTsKICAgICAgICB9CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkgewogICAgICAgICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaCAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTsKICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkgewogICAgICAgIHZhciBoYXNoX2hlYWQ7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICB2YXIgbWF4X2luc2VydDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYXNoX2hlYWQgPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgIH0KICAgICAgICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJiAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCBzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5NikpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7CiAgICAgICAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxOwogICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC09IDI7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApOwogICAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBwcmV2OwogICAgICAgIHZhciBzY2FuLCBzdHJlbmQ7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7CiAgICAgICAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTsKICAgICAgICAgICAgcHJldiA9IF93aW5bc2Nhbl07CiAgICAgICAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkgewogICAgICAgICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7CiAgICAgICAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoOwogICAgICAgIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTsKICAgICAgICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47CiAgICAgICAgdGhpcy5mdW5jID0gZnVuYzsKICAgICAgfQogICAgICB2YXIgY29uZmlndXJhdGlvbl90YWJsZTsKICAgICAgY29uZmlndXJhdGlvbl90YWJsZSA9IFsKICAgICAgICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykKICAgICAgXTsKICAgICAgZnVuY3Rpb24gbG1faW5pdChzKSB7CiAgICAgICAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTsKICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7CiAgICAgICAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDsKICAgICAgICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoOwogICAgICAgIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluOwogICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgcy5pbnNfaCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMuc3RybSA9IG51bGw7CiAgICAgICAgdGhpcy5zdGF0dXMgPSAwOwogICAgICAgIHRoaXMucGVuZGluZ19idWYgPSBudWxsOwogICAgICAgIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nID0gMDsKICAgICAgICB0aGlzLndyYXAgPSAwOwogICAgICAgIHRoaXMuZ3poZWFkID0gbnVsbDsKICAgICAgICB0aGlzLmd6aW5kZXggPSAwOwogICAgICAgIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsKICAgICAgICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICB0aGlzLndfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy53X2JpdHMgPSAwOwogICAgICAgIHRoaXMud19tYXNrID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuaW5zX2ggPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaXplID0gMDsKICAgICAgICB0aGlzLmhhc2hfYml0cyA9IDA7CiAgICAgICAgdGhpcy5oYXNoX21hc2sgPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaGlmdCA9IDA7CiAgICAgICAgdGhpcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgIHRoaXMucHJldl9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHRoaXMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHRoaXMubWF0Y2hfc3RhcnQgPSAwOwogICAgICAgIHRoaXMubG9va2FoZWFkID0gMDsKICAgICAgICB0aGlzLnByZXZfbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubGV2ZWwgPSAwOwogICAgICAgIHRoaXMuc3RyYXRlZ3kgPSAwOwogICAgICAgIHRoaXMuZ29vZF9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5uaWNlX21hdGNoID0gMDsKICAgICAgICB0aGlzLmR5bl9sdHJlZSA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTsKICAgICAgICB0aGlzLmR5bl9kdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHRoaXMuYmxfdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2x0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2R0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuYmxfdHJlZSk7CiAgICAgICAgdGhpcy5sX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuZF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmJsX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTsKICAgICAgICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsKICAgICAgICB6ZXJvKHRoaXMuaGVhcCk7CiAgICAgICAgdGhpcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgdGhpcy5oZWFwX21heCA9IDA7CiAgICAgICAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5kZXB0aCk7CiAgICAgICAgdGhpcy5sX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0X2xpdCA9IDA7CiAgICAgICAgdGhpcy5kX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5vcHRfbGVuID0gMDsKICAgICAgICB0aGlzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHRoaXMubWF0Y2hlcyA9IDA7CiAgICAgICAgdGhpcy5pbnNlcnQgPSAwOwogICAgICAgIHRoaXMuYmlfYnVmID0gMDsKICAgICAgICB0aGlzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgczsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwOwogICAgICAgIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOOwogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHMucGVuZGluZyA9IDA7CiAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgaWYgKHMud3JhcCA8IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHMuc3RhdHVzID0gcy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEU7CiAgICAgICAgc3RybS5hZGxlciA9IHMud3JhcCA9PT0gMiA/IDAgOiAxOwogICAgICAgIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7CiAgICAgICAgdHJlZXMuX3RyX2luaXQocyk7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgICBpZiAocmV0ID09PSBaX09LKSB7CiAgICAgICAgICBsbV9pbml0KHN0cm0uc3RhdGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHZhciB3cmFwID0gMTsKICAgICAgICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikgewogICAgICAgICAgbGV2ZWwgPSA2OwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7CiAgICAgICAgICB3cmFwID0gMjsKICAgICAgICAgIHdpbmRvd0JpdHMgLT0gMTY7CiAgICAgICAgfQogICAgICAgIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fCB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fCBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHsKICAgICAgICAgIHdpbmRvd0JpdHMgPSA5OwogICAgICAgIH0KICAgICAgICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gczsKICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcy5nemhlYWQgPSBudWxsOwogICAgICAgIHMud19iaXRzID0gd2luZG93Qml0czsKICAgICAgICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7CiAgICAgICAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7CiAgICAgICAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzOwogICAgICAgIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxOwogICAgICAgIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTsKICAgICAgICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7CiAgICAgICAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTsKICAgICAgICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpOwogICAgICAgIHMubGl0X2J1ZnNpemUgPSAxIDw8IG1lbUxldmVsICsgNjsKICAgICAgICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDsKICAgICAgICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTsKICAgICAgICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplOwogICAgICAgIHMubGV2ZWwgPSBsZXZlbDsKICAgICAgICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7CiAgICAgICAgcy5tZXRob2QgPSBtZXRob2Q7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkgewogICAgICAgIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIG9sZF9mbHVzaCwgczsKICAgICAgICB2YXIgYmVnLCB2YWw7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8IGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHsKICAgICAgICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgc3RybS5hdmFpbF9vdXQgPT09IDAgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJtID0gc3RybTsKICAgICAgICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAzMSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDEzOSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDgpOwogICAgICAgICAgICBpZiAoIXMuZ3poZWFkKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICsgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNikpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAxNiAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAyNCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMjU1KTsKICAgICAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAyNTUpOwogICAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGhlYWRlciA9IFpfREVGTEFURUQgKyAocy53X2JpdHMgLSA4IDw8IDQpIDw8IDg7CiAgICAgICAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xOwogICAgICAgICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMDsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMTsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgfD0gbGV2ZWxfZmxhZ3MgPDwgNjsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyICs9IDMxIC0gaGVhZGVyICUgMzE7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzdHJtLmFkbGVyID0gMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiA2NTUzNSkpIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDI1NSk7CiAgICAgICAgICAgICAgcy5nemluZGV4Kys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5uYW1lKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIHZhbCA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAyNTU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHsKICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHsKICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiYgZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8IGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHZhciBic3RhdGUgPSBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOiBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7CiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHsKICAgICAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPD0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA9PT0gMikgewogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDI0ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAyNCAmIDI1NSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgfQogICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgaWYgKHMud3JhcCA+IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkgewogICAgICAgIHZhciBzdGF0dXM7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzOwogICAgICAgIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJiBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiYgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJiBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzOwogICAgICAgIHZhciBzdHIsIG47CiAgICAgICAgdmFyIHdyYXA7CiAgICAgICAgdmFyIGF2YWlsOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBpbnB1dDsKICAgICAgICB2YXIgdG1wRGljdDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgd3JhcCA9IHMud3JhcDsKICAgICAgICBpZiAod3JhcCA9PT0gMiB8fCB3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFIHx8IHMubG9va2FoZWFkKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmICh3cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICB9CiAgICAgICAgcy53cmFwID0gMDsKICAgICAgICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkgewogICAgICAgICAgaWYgKHdyYXAgPT09IDApIHsKICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7CiAgICAgICAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTsKICAgICAgICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0OwogICAgICAgICAgZGljdExlbmd0aCA9IHMud19zaXplOwogICAgICAgIH0KICAgICAgICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0OwogICAgICAgICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpOwogICAgICAgICAgZG8gewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgc3RyKys7CiAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgcy5zdHJzdGFydCA9IHN0cjsKICAgICAgICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIH0KICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgc3RybS5pbnB1dCA9IGlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDsKICAgICAgICBzLndyYXAgPSB3cmFwOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0OwogICAgICBleHBvcnRzMi5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUluZm8gPSAicGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzCiAgdmFyIHJlcXVpcmVfc3RyaW5ncyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7CiAgICAgIHZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTsKICAgICAgdHJ5IHsKICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFswXSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX09LID0gZmFsc2U7CiAgICAgIH0KICAgICAgdHJ5IHsKICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsKICAgICAgfSBjYXRjaCAoX18pIHsKICAgICAgICBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7CiAgICAgIH0KICAgICAgdmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTsKICAgICAgZm9yIChxID0gMDsgcSA8IDI1NjsgcSsrKSB7CiAgICAgICAgX3V0ZjhsZW5bcV0gPSBxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxOwogICAgICB9CiAgICAgIHZhciBxOwogICAgICBfdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7CiAgICAgIGV4cG9ydHMyLnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDsKICAgICAgICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBidWZfbGVuICs9IGMgPCAxMjggPyAxIDogYyA8IDIwNDggPyAyIDogYyA8IDY1NTM2ID8gMyA6IDQ7CiAgICAgICAgfQogICAgICAgIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pOwogICAgICAgIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIG1fcG9zICsgMSA8IHN0cl9sZW4pIHsKICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgICAgICBpZiAoKGMyICYgNjQ1MTIpID09PSA1NjMyMCkgewogICAgICAgICAgICAgIGMgPSA2NTUzNiArIChjIC0gNTUyOTYgPDwgMTApICsgKGMyIC0gNTYzMjApOwogICAgICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gYzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHsKICAgICAgICAgICAgYnVmW2krK10gPSAxOTIgfCBjID4+PiA2OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjI0IHwgYyA+Pj4gMTI7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjQwIHwgYyA+Pj4gMTg7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gMTIgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiA2ICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBmdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7CiAgICAgICAgaWYgKGxlbiA8IDY1NTM0KSB7CiAgICAgICAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0sgfHwgIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spIHsKICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIGV4cG9ydHMyLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbihidWYpIHsKICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpOwogICAgICB9OwogICAgICBleHBvcnRzMi5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpOwogICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBleHBvcnRzMi5idWYyc3RyaW5nID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgaSwgb3V0LCBjLCBjX2xlbjsKICAgICAgICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpOwogICAgICAgIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47ICkgewogICAgICAgICAgYyA9IGJ1ZltpKytdOwogICAgICAgICAgaWYgKGMgPCAxMjgpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdOwogICAgICAgICAgaWYgKGNfbGVuID4gNCkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgaSArPSBjX2xlbiAtIDE7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDMxIDogY19sZW4gPT09IDMgPyAxNSA6IDc7CiAgICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHsKICAgICAgICAgICAgYyA9IGMgPDwgNiB8IGJ1ZltpKytdICYgNjM7CiAgICAgICAgICAgIGNfbGVuLS07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY19sZW4gPiAxKSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDY1NTMzOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgNjU1MzYpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGMgLT0gNjU1MzY7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU1Mjk2IHwgYyA+PiAxMCAmIDEwMjM7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU2MzIwIHwgYyAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpOwogICAgICB9OwogICAgICBleHBvcnRzMi51dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgcG9zOwogICAgICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7CiAgICAgICAgICBtYXggPSBidWYubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBwb3MgPSBtYXggLSAxOwogICAgICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgIHBvcy0tOwogICAgICAgIH0KICAgICAgICBpZiAocG9zIDwgMCkgewogICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKHBvcyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCA/IHBvcyA6IG1heDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcwogIHZhciByZXF1aXJlX3pzdHJlYW0gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFpTdHJlYW07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfZGVmbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUoKTsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHN0cmluZ3MgPSByZXF1aXJlX3N0cmluZ3MoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIHRvU3RyaW5nMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIHZhciBaX05PX0ZMVVNIID0gMDsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1lOQ19GTFVTSDIgPSAyOwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIGZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkKICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTiwKICAgICAgICAgIG1ldGhvZDogWl9ERUZMQVRFRCwKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAxNSwKICAgICAgICAgIG1lbUxldmVsOiA4LAogICAgICAgICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPiAwKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICB9IGVsc2UgaWYgKG9wdC5nemlwICYmIG9wdC53aW5kb3dCaXRzID4gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAxNjsKICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC5sZXZlbCwgb3B0Lm1ldGhvZCwgb3B0LndpbmRvd0JpdHMsIG9wdC5tZW1MZXZlbCwgb3B0LnN0cmF0ZWd5KTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LmhlYWRlcikgewogICAgICAgICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICB2YXIgZGljdDsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZzIuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nMi5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSDIpKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikgewogICAgICAgICAgdGhpcy5vbkVuZChaX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoZGVmbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMuZ3ppcCA9IHRydWU7CiAgICAgICAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLkRlZmxhdGUgPSBEZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLmd6aXAgPSBnemlwOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzCiAgdmFyIHJlcXVpcmVfaW5mZmFzdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgQkFEID0gMzA7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgX2luOwogICAgICAgIHZhciBsYXN0OwogICAgICAgIHZhciBfb3V0OwogICAgICAgIHZhciBiZWc7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgZG1heDsKICAgICAgICB2YXIgd3NpemU7CiAgICAgICAgdmFyIHdoYXZlOwogICAgICAgIHZhciB3bmV4dDsKICAgICAgICB2YXIgc193aW5kb3c7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxjb2RlOwogICAgICAgIHZhciBkY29kZTsKICAgICAgICB2YXIgbG1hc2s7CiAgICAgICAgdmFyIGRtYXNrOwogICAgICAgIHZhciBoZXJlOwogICAgICAgIHZhciBvcDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBmcm9tOwogICAgICAgIHZhciBmcm9tX3NvdXJjZTsKICAgICAgICB2YXIgaW5wdXQsIG91dHB1dDsKICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgX2luID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTsKICAgICAgICBfb3V0ID0gc3RybS5uZXh0X291dDsKICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpOwogICAgICAgIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpOwogICAgICAgIGRtYXggPSBzdGF0ZS5kbWF4OwogICAgICAgIHdzaXplID0gc3RhdGUud3NpemU7CiAgICAgICAgd2hhdmUgPSBzdGF0ZS53aGF2ZTsKICAgICAgICB3bmV4dCA9IHN0YXRlLnduZXh0OwogICAgICAgIHNfd2luZG93ID0gc3RhdGUud2luZG93OwogICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgIGxjb2RlID0gc3RhdGUubGVuY29kZTsKICAgICAgICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlOwogICAgICAgIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxOwogICAgICAgIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTsKICAgICAgICB0b3A6CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTsKICAgICAgICAgICAgZG9sZW46CiAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMTYpIHsKICAgICAgICAgICAgICAgICAgbGVuID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgaWYgKG9wKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGhvbGQgJiAoMSA8PCBvcCkgLSAxOwogICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTsKICAgICAgICAgICAgICAgICAgZG9kaXN0OgogICAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgICAgaWYgKG9wICYgMTYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICAgICAgb3AgJj0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoMSA8PCBvcCkgLSAxOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHduZXh0IDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZG9kaXN0OwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSBjb2RlIjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgNjU1MzUpICsgKGhvbGQgJiAoMSA8PCBvcCkgLSAxKV07CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGRvbGVuOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCAmIDMyKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpOwogICAgICAgIGxlbiA9IGJpdHMgPj4gMzsKICAgICAgICBfaW4gLT0gbGVuOwogICAgICAgIGJpdHMgLT0gbGVuIDw8IDM7CiAgICAgICAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7CiAgICAgICAgc3RybS5uZXh0X2luID0gX2luOwogICAgICAgIHN0cm0ubmV4dF9vdXQgPSBfb3V0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCk7CiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpOwogICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgIHJldHVybjsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMKICB2YXIgcmVxdWlyZV9pbmZ0cmVlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIE1BWEJJVFMgPSAxNTsKICAgICAgdmFyIEVOT1VHSF9MRU5TID0gODUyOwogICAgICB2YXIgRU5PVUdIX0RJU1RTID0gNTkyOwogICAgICB2YXIgQ09ERVMgPSAwOwogICAgICB2YXIgTEVOUyA9IDE7CiAgICAgIHZhciBESVNUUyA9IDI7CiAgICAgIHZhciBsYmFzZSA9IFsKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA2LAogICAgICAgIDcsCiAgICAgICAgOCwKICAgICAgICA5LAogICAgICAgIDEwLAogICAgICAgIDExLAogICAgICAgIDEzLAogICAgICAgIDE1LAogICAgICAgIDE3LAogICAgICAgIDE5LAogICAgICAgIDIzLAogICAgICAgIDI3LAogICAgICAgIDMxLAogICAgICAgIDM1LAogICAgICAgIDQzLAogICAgICAgIDUxLAogICAgICAgIDU5LAogICAgICAgIDY3LAogICAgICAgIDgzLAogICAgICAgIDk5LAogICAgICAgIDExNSwKICAgICAgICAxMzEsCiAgICAgICAgMTYzLAogICAgICAgIDE5NSwKICAgICAgICAyMjcsCiAgICAgICAgMjU4LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgbGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAxNiwKICAgICAgICA3MiwKICAgICAgICA3OAogICAgICBdOwogICAgICB2YXIgZGJhc2UgPSBbCiAgICAgICAgMSwKICAgICAgICAyLAogICAgICAgIDMsCiAgICAgICAgNCwKICAgICAgICA1LAogICAgICAgIDcsCiAgICAgICAgOSwKICAgICAgICAxMywKICAgICAgICAxNywKICAgICAgICAyNSwKICAgICAgICAzMywKICAgICAgICA0OSwKICAgICAgICA2NSwKICAgICAgICA5NywKICAgICAgICAxMjksCiAgICAgICAgMTkzLAogICAgICAgIDI1NywKICAgICAgICAzODUsCiAgICAgICAgNTEzLAogICAgICAgIDc2OSwKICAgICAgICAxMDI1LAogICAgICAgIDE1MzcsCiAgICAgICAgMjA0OSwKICAgICAgICAzMDczLAogICAgICAgIDQwOTcsCiAgICAgICAgNjE0NSwKICAgICAgICA4MTkzLAogICAgICAgIDEyMjg5LAogICAgICAgIDE2Mzg1LAogICAgICAgIDI0NTc3LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgZGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMiwKICAgICAgICAyMiwKICAgICAgICAyMywKICAgICAgICAyMywKICAgICAgICAyNCwKICAgICAgICAyNCwKICAgICAgICAyNSwKICAgICAgICAyNSwKICAgICAgICAyNiwKICAgICAgICAyNiwKICAgICAgICAyNywKICAgICAgICAyNywKICAgICAgICAyOCwKICAgICAgICAyOCwKICAgICAgICAyOSwKICAgICAgICAyOSwKICAgICAgICA2NCwKICAgICAgICA2NAogICAgICBdOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdDIgPSAwOwogICAgICAgIHZhciBjdXJyID0gMDsKICAgICAgICB2YXIgZHJvcCA9IDA7CiAgICAgICAgdmFyIGxlZnQgPSAwOwogICAgICAgIHZhciB1c2VkID0gMDsKICAgICAgICB2YXIgaHVmZiA9IDA7CiAgICAgICAgdmFyIGluY3I7CiAgICAgICAgdmFyIGZpbGw7CiAgICAgICAgdmFyIGxvdzsKICAgICAgICB2YXIgbWFzazsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgYmFzZSA9IG51bGw7CiAgICAgICAgdmFyIGJhc2VfaW5kZXggPSAwOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7CiAgICAgICAgdmFyIGV4dHJhID0gbnVsbDsKICAgICAgICB2YXIgZXh0cmFfaW5kZXggPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBjb3VudFtsZW5dID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHsKICAgICAgICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7CiAgICAgICAgfQogICAgICAgIHJvb3QyID0gYml0czsKICAgICAgICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkgewogICAgICAgICAgaWYgKGNvdW50W21heF0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyb290MiA+IG1heCkgewogICAgICAgICAgcm9vdDIgPSBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChtYXggPT09IDApIHsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIG9wdHMuYml0cyA9IDE7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7CiAgICAgICAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHJvb3QyIDwgbWluKSB7CiAgICAgICAgICByb290MiA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3QyOwogICAgICAgIGRyb3AgPSAwOwogICAgICAgIGxvdyA9IC0xOwogICAgICAgIHVzZWQgPSAxIDw8IHJvb3QyOwogICAgICAgIG1hc2sgPSB1c2VkIC0gMTsKICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDsKICAgICAgICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDA7CiAgICAgICAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dOwogICAgICAgICAgfSBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7CiAgICAgICAgICAgIGhlcmVfdmFsID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIGRyb3A7CiAgICAgICAgICBmaWxsID0gMSA8PCBjdXJyOwogICAgICAgICAgbWluID0gZmlsbDsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZmlsbCAtPSBpbmNyOwogICAgICAgICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IGhlcmVfYml0cyA8PCAyNCB8IGhlcmVfb3AgPDwgMTYgfCBoZXJlX3ZhbCB8IDA7CiAgICAgICAgICB9IHdoaWxlIChmaWxsICE9PSAwKTsKICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIDE7CiAgICAgICAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHsKICAgICAgICAgICAgaW5jciA+Pj0gMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpbmNyICE9PSAwKSB7CiAgICAgICAgICAgIGh1ZmYgJj0gaW5jciAtIDE7CiAgICAgICAgICAgIGh1ZmYgKz0gaW5jcjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGh1ZmYgPSAwOwogICAgICAgICAgfQogICAgICAgICAgc3ltKys7CiAgICAgICAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7CiAgICAgICAgICAgIGlmIChsZW4gPT09IG1heCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobGVuID4gcm9vdDIgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3QyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHQgKz0gbWluOwogICAgICAgICAgICBjdXJyID0gbGVuIC0gZHJvcDsKICAgICAgICAgICAgbGVmdCA9IDEgPDwgY3VycjsKICAgICAgICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7CiAgICAgICAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07CiAgICAgICAgICAgICAgaWYgKGxlZnQgPD0gMCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGN1cnIrKzsKICAgICAgICAgICAgICBsZWZ0IDw8PSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHVzZWQgKz0gMSA8PCBjdXJyOwogICAgICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrOwogICAgICAgICAgICB0YWJsZVtsb3ddID0gcm9vdDIgPDwgMjQgfCBjdXJyIDw8IDE2IHwgbmV4dCAtIHRhYmxlX2luZGV4IHwgMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGh1ZmYgIT09IDApIHsKICAgICAgICAgIHRhYmxlW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3AgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgfQogICAgICAgIG9wdHMuYml0cyA9IHJvb3QyOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBpbmZsYXRlX2Zhc3QgPSByZXF1aXJlX2luZmZhc3QoKTsKICAgICAgdmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlX2luZnRyZWVzKCk7CiAgICAgIHZhciBDT0RFUyA9IDA7CiAgICAgIHZhciBMRU5TID0gMTsKICAgICAgdmFyIERJU1RTID0gMjsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9UUkVFUyA9IDY7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX05FRURfRElDVCA9IDI7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX01FTV9FUlJPUiA9IC00OwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgSEVBRCA9IDE7CiAgICAgIHZhciBGTEFHUyA9IDI7CiAgICAgIHZhciBUSU1FID0gMzsKICAgICAgdmFyIE9TID0gNDsKICAgICAgdmFyIEVYTEVOID0gNTsKICAgICAgdmFyIEVYVFJBID0gNjsKICAgICAgdmFyIE5BTUUgPSA3OwogICAgICB2YXIgQ09NTUVOVCA9IDg7CiAgICAgIHZhciBIQ1JDID0gOTsKICAgICAgdmFyIERJQ1RJRCA9IDEwOwogICAgICB2YXIgRElDVCA9IDExOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICB2YXIgVFlQRURPID0gMTM7CiAgICAgIHZhciBTVE9SRUQgPSAxNDsKICAgICAgdmFyIENPUFlfID0gMTU7CiAgICAgIHZhciBDT1BZID0gMTY7CiAgICAgIHZhciBUQUJMRSA9IDE3OwogICAgICB2YXIgTEVOTEVOUyA9IDE4OwogICAgICB2YXIgQ09ERUxFTlMgPSAxOTsKICAgICAgdmFyIExFTl8gPSAyMDsKICAgICAgdmFyIExFTiA9IDIxOwogICAgICB2YXIgTEVORVhUID0gMjI7CiAgICAgIHZhciBESVNUID0gMjM7CiAgICAgIHZhciBESVNURVhUID0gMjQ7CiAgICAgIHZhciBNQVRDSCA9IDI1OwogICAgICB2YXIgTElUID0gMjY7CiAgICAgIHZhciBDSEVDSyA9IDI3OwogICAgICB2YXIgTEVOR1RIID0gMjg7CiAgICAgIHZhciBET05FID0gMjk7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIE1FTSA9IDMxOwogICAgICB2YXIgU1lOQyA9IDMyOwogICAgICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgICAgIHZhciBFTk9VR0hfRElTVFMgPSA1OTI7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9XQklUUyA9IE1BWF9XQklUUzsKICAgICAgZnVuY3Rpb24genN3YXAzMihxKSB7CiAgICAgICAgcmV0dXJuIChxID4+PiAyNCAmIDI1NSkgKyAocSA+Pj4gOCAmIDY1MjgwKSArICgocSAmIDY1MjgwKSA8PCA4KSArICgocSAmIDI1NSkgPDwgMjQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLm1vZGUgPSAwOwogICAgICAgIHRoaXMubGFzdCA9IGZhbHNlOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmxhZ3MgPSAwOwogICAgICAgIHRoaXMuZG1heCA9IDA7CiAgICAgICAgdGhpcy5jaGVjayA9IDA7CiAgICAgICAgdGhpcy50b3RhbCA9IDA7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLndiaXRzID0gMDsKICAgICAgICB0aGlzLndzaXplID0gMDsKICAgICAgICB0aGlzLndoYXZlID0gMDsKICAgICAgICB0aGlzLnduZXh0ID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy5ob2xkID0gMDsKICAgICAgICB0aGlzLmJpdHMgPSAwOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm9mZnNldCA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IDA7CiAgICAgICAgdGhpcy5sZW5jb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmxlbmJpdHMgPSAwOwogICAgICAgIHRoaXMuZGlzdGJpdHMgPSAwOwogICAgICAgIHRoaXMubmNvZGUgPSAwOwogICAgICAgIHRoaXMubmxlbiA9IDA7CiAgICAgICAgdGhpcy5uZGlzdCA9IDA7CiAgICAgICAgdGhpcy5oYXZlID0gMDsKICAgICAgICB0aGlzLm5leHQgPSBudWxsOwogICAgICAgIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOwogICAgICAgIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOwogICAgICAgIHRoaXMubGVuZHluID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3RkeW4gPSBudWxsOwogICAgICAgIHRoaXMuc2FuZSA9IDA7CiAgICAgICAgdGhpcy5iYWNrID0gMDsKICAgICAgICB0aGlzLndhcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwOwogICAgICAgIHN0cm0ubXNnID0gIiI7CiAgICAgICAgaWYgKHN0YXRlLndyYXApIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubW9kZSA9IEhFQUQ7CiAgICAgICAgc3RhdGUubGFzdCA9IDA7CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAwOwogICAgICAgIHN0YXRlLmRtYXggPSAzMjc2ODsKICAgICAgICBzdGF0ZS5oZWFkID0gbnVsbDsKICAgICAgICBzdGF0ZS5ob2xkID0gMDsKICAgICAgICBzdGF0ZS5iaXRzID0gMDsKICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTsKICAgICAgICBzdGF0ZS5zYW5lID0gMTsKICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdGF0ZS53c2l6ZSA9IDA7CiAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxOwogICAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgICB3aW5kb3dCaXRzICY9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgICAgICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpOwogICAgICAgIGlmIChyZXQgIT09IFpfT0spIHsKICAgICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHsKICAgICAgICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7CiAgICAgIH0KICAgICAgdmFyIHZpcmdpbiA9IHRydWU7CiAgICAgIHZhciBsZW5maXg7CiAgICAgIHZhciBkaXN0Zml4OwogICAgICBmdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkgewogICAgICAgIGlmICh2aXJnaW4pIHsKICAgICAgICAgIHZhciBzeW07CiAgICAgICAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTsKICAgICAgICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAxNDQpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI1NikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjgwKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNzsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODgpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAzMikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pOwogICAgICAgICAgdmlyZ2luID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4OwogICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHsKICAgICAgICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0czsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7CiAgICAgICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICAgICAgZGlzdCA9IGNvcHk7CiAgICAgICAgICB9CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpOwogICAgICAgICAgY29weSAtPSBkaXN0OwogICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApOwogICAgICAgICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7CiAgICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS53bmV4dCArPSBkaXN0OwogICAgICAgICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud2hhdmUgKz0gZGlzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBwdXQ7CiAgICAgICAgdmFyIGhhdmUsIGxlZnQ7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIF9pbiwgX291dDsKICAgICAgICB2YXIgY29weTsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGhlcmUgPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOwogICAgICAgIHZhciBvcHRzOwogICAgICAgIHZhciBuOwogICAgICAgIHZhciBvcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgIH0KICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBfaW4gPSBoYXZlOwogICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgIHJldCA9IFpfT0s7CiAgICAgICAgaW5mX2xlYXZlOgogICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkgewogICAgICAgICAgICAgIGNhc2UgSEVBRDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmIDIgJiYgaG9sZCA9PT0gMzU2MTUpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IDA7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAoKChob2xkICYgMjU1KSA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBoZWFkZXIgY2hlY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoaG9sZCAmIDE1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBsZW4gPSAoaG9sZCAmIDE1KSArIDg7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgd2luZG93IHNpemUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjsKICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDUxMiA/IERJQ1RJRCA6IFRZUEU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBGTEFHUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkOwogICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDI1NSkgIT09IFpfREVGTEFURUQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDU3MzQ0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gaGVhZGVyIGZsYWdzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gaG9sZCA+PiA4ICYgMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FOwogICAgICAgICAgICAgIGNhc2UgVElNRToKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMl0gPSBob2xkID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlszXSA9IGhvbGQgPj4+IDI0ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gT1M7CiAgICAgICAgICAgICAgY2FzZSBPUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gaG9sZCA+PiA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOOwogICAgICAgICAgICAgIGNhc2UgRVhMRU46CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTsKICAgICAgICAgICAgICBjYXNlIEVYVFJBOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkgewogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLmhlYWQuZXh0cmEsIGlucHV0LCBuZXh0LCBjb3B5LCBsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7CiAgICAgICAgICAgICAgY2FzZSBOQU1FOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMjA0OCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7CiAgICAgICAgICAgICAgY2FzZSBDT01NRU5UOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNDA5NikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gSENSQzsKICAgICAgICAgICAgICBjYXNlIEhDUkM6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImhlYWRlciBjcmMgbWlzbWF0Y2giOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gc3RhdGUuZmxhZ3MgPj4gOSAmIDE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIERJQ1RJRDoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDsKICAgICAgICAgICAgICBjYXNlIERJQ1Q6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgY2FzZSBUWVBFOgogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIFRZUEVETzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0ID0gaG9sZCAmIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMTsKICAgICAgICAgICAgICAgIHN3aXRjaCAoaG9sZCAmIDMpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJsb2NrIHR5cGUiOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgU1RPUkVEOgogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgNjU1MzUpICE9PSAoaG9sZCA+Pj4gMTYgXiA2NTUzNSkpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDY1NTM1OwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBDT1BZXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZOwogICAgICAgICAgICAgIGNhc2UgQ09QWToKICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpOwogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBwdXQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIFRBQkxFOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAzMSkgKyAyNTc7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAzMSkgKyAxOwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMTUpICsgNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUzsKICAgICAgICAgICAgICBjYXNlIExFTkxFTlM6CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IGhvbGQgJiA3OwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSAzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNzsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgY29kZSBsZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7CiAgICAgICAgICAgICAgY2FzZSBDT0RFTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAzKTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMzsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDcpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDEyNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gNzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gNzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjsKICAgICAgICAgICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2VzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgTEVOXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgY2FzZSBMRU46CiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpOwogICAgICAgICAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgICAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgICAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICAgICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IDA7CiAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDI0MCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUOwogICAgICAgICAgICAgIGNhc2UgTEVORVhUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgxIDw8IHN0YXRlLmV4dHJhKSAtIDE7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNUOwogICAgICAgICAgICAgIGNhc2UgRElTVDoKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDsKICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDsKICAgICAgICAgICAgICBjYXNlIE1BVENIOgogICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5OwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IGxlZnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBMSVQ6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgbGVmdC0tOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgQ0hFQ0s6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0IC09IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIGlmIChfb3V0KSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGRhdGEgY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDsKICAgICAgICAgICAgICBjYXNlIExFTkdUSDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiA0Mjk0OTY3Mjk1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBsZW5ndGggY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7CiAgICAgICAgICAgICAgY2FzZSBET05FOgogICAgICAgICAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgQkFEOgogICAgICAgICAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgTUVNOgogICAgICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgICAgIGNhc2UgU1lOQzoKICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICBpZiAoc3RhdGUud3NpemUgfHwgX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJiAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpIHsKICAgICAgICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfaW4gLT0gc3RybS5hdmFpbF9pbjsKICAgICAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gX2luOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpOwogICAgICAgIH0KICAgICAgICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICsgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTsKICAgICAgICBpZiAoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7CiAgICAgICAgICByZXQgPSBaX0JVRl9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud2luZG93KSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oZWFkID0gaGVhZDsKICAgICAgICBoZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGRpY3RpZDsKICAgICAgICB2YXIgcmV0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkgewogICAgICAgICAgZGljdGlkID0gMTsKICAgICAgICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTsKICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0OwogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZSA9IGluZmxhdGU7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kOwogICAgICBleHBvcnRzMi5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluZm8gPSAicGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcwogIHZhciByZXF1aXJlX2NvbnN0YW50cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICBaX05PX0ZMVVNIOiAwLAogICAgICAgIFpfUEFSVElBTF9GTFVTSDogMSwKICAgICAgICBaX1NZTkNfRkxVU0g6IDIsCiAgICAgICAgWl9GVUxMX0ZMVVNIOiAzLAogICAgICAgIFpfRklOSVNIOiA0LAogICAgICAgIFpfQkxPQ0s6IDUsCiAgICAgICAgWl9UUkVFUzogNiwKICAgICAgICBaX09LOiAwLAogICAgICAgIFpfU1RSRUFNX0VORDogMSwKICAgICAgICBaX05FRURfRElDVDogMiwKICAgICAgICBaX0VSUk5POiAtMSwKICAgICAgICBaX1NUUkVBTV9FUlJPUjogLTIsCiAgICAgICAgWl9EQVRBX0VSUk9SOiAtMywKICAgICAgICBaX0JVRl9FUlJPUjogLTUsCiAgICAgICAgWl9OT19DT01QUkVTU0lPTjogMCwKICAgICAgICBaX0JFU1RfU1BFRUQ6IDEsCiAgICAgICAgWl9CRVNUX0NPTVBSRVNTSU9OOiA5LAogICAgICAgIFpfREVGQVVMVF9DT01QUkVTU0lPTjogLTEsCiAgICAgICAgWl9GSUxURVJFRDogMSwKICAgICAgICBaX0hVRkZNQU5fT05MWTogMiwKICAgICAgICBaX1JMRTogMywKICAgICAgICBaX0ZJWEVEOiA0LAogICAgICAgIFpfREVGQVVMVF9TVFJBVEVHWTogMCwKICAgICAgICBaX0JJTkFSWTogMCwKICAgICAgICBaX1RFWFQ6IDEsCiAgICAgICAgWl9VTktOT1dOOiAyLAogICAgICAgIFpfREVGTEFURUQ6IDgKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMKICB2YXIgcmVxdWlyZV9nemhlYWRlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gR1poZWFkZXIoKSB7CiAgICAgICAgdGhpcy50ZXh0ID0gMDsKICAgICAgICB0aGlzLnRpbWUgPSAwOwogICAgICAgIHRoaXMueGZsYWdzID0gMDsKICAgICAgICB0aGlzLm9zID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gbnVsbDsKICAgICAgICB0aGlzLmV4dHJhX2xlbiA9IDA7CiAgICAgICAgdGhpcy5uYW1lID0gIiI7CiAgICAgICAgdGhpcy5jb21tZW50ID0gIiI7CiAgICAgICAgdGhpcy5oY3JjID0gMDsKICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBHWmhlYWRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMKICB2YXIgcmVxdWlyZV9pbmZsYXRlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmVfaW5mbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgYyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaU3RyZWFtID0gcmVxdWlyZV96c3RyZWFtKCk7CiAgICAgIHZhciBHWmhlYWRlciA9IHJlcXVpcmVfZ3poZWFkZXIoKTsKICAgICAgdmFyIHRvU3RyaW5nMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIEluZmxhdGUyKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZTIpKQogICAgICAgICAgcmV0dXJuIG5ldyBJbmZsYXRlMihvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgY2h1bmtTaXplOiAxNjM4NCwKICAgICAgICAgIHdpbmRvd0JpdHM6IDAsCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID49IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsKICAgICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYgJiYgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzICs9IDMyOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPiAxNSAmJiBvcHQud2luZG93Qml0cyA8IDQ4KSB7CiAgICAgICAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmVyciA9IDA7CiAgICAgICAgdGhpcy5tc2cgPSAiIjsKICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpOwogICAgICAgIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgIHZhciBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSwgb3B0LndpbmRvd0JpdHMpOwogICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTsKICAgICAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTsKICAgICAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcyLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wdC5yYXcpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7CiAgICAgICAgdmFyIHN0YXR1cywgX21vZGU7CiAgICAgICAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7CiAgICAgICAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSDsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpOwogICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcyLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7CiAgICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHsKICAgICAgICAgICAgc3RhdHVzID0gYy5aX09LOwogICAgICAgICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5uZXh0X291dCkgewogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSB7CiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpOwogICAgICAgICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4OwogICAgICAgICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7CiAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDsKICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDsKICAgICAgICAgICAgICAgIGlmICh0YWlsKSB7CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7CiAgICAgICAgICBfbW9kZSA9IGMuWl9GSU5JU0g7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkgewogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTsKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKGMuWl9PSyk7CiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH07CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBJbmZsYXRlMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlMihvcHRpb25zKTsKICAgICAgICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuSW5mbGF0ZSA9IEluZmxhdGUyOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLnVuZ3ppcCA9IGluZmxhdGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFzc2lnbiA9IHJlcXVpcmVfY29tbW9uKCkuYXNzaWduOwogICAgICB2YXIgZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZTIoKTsKICAgICAgdmFyIGluZmxhdGUgPSByZXF1aXJlX2luZmxhdGUyKCk7CiAgICAgIHZhciBjb25zdGFudHMgPSByZXF1aXJlX2NvbnN0YW50cygpOwogICAgICB2YXIgcGFrbyA9IHt9OwogICAgICBhc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gcGFrbzsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMKICB2YXIgcmVxdWlyZV9sb25nID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gTG9uZzQ7CiAgICAgIHZhciB3YXNtMiA9IG51bGw7CiAgICAgIHRyeSB7CiAgICAgICAgd2FzbTIgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nNChsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwOwogICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICB9CiAgICAgIExvbmc0LnByb3RvdHlwZS5fX2lzTG9uZ19fOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZzQucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZzIob2JqKSB7CiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqWyJfX2lzTG9uZ19fIl0pID09PSB0cnVlOwogICAgICB9CiAgICAgIExvbmc0LmlzTG9uZyA9IGlzTG9uZzI7CiAgICAgIHZhciBJTlRfQ0FDSEUyID0ge307CiAgICAgIHZhciBVSU5UX0NBQ0hFMiA9IHt9OwogICAgICBmdW5jdGlvbiBmcm9tSW50Mih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgdmFsdWUgPj4+PSAwOwogICAgICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFMlt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzMih2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTsKICAgICAgICAgIGlmIChjYWNoZSkKICAgICAgICAgICAgVUlOVF9DQUNIRTJbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFsdWUgfD0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFMlt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzMih2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIElOVF9DQUNIRTJbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUludCA9IGZyb21JbnQyOwogICAgICBmdW5jdGlvbiBmcm9tTnVtYmVyMih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpKQogICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgICByZXR1cm4gVVpFUk8yOwogICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMMikKICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwyKQogICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwyKQogICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFMjsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyMigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwyIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTDIgfCAwLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbU51bWJlciA9IGZyb21OdW1iZXIyOwogICAgICBmdW5jdGlvbiBmcm9tQml0czIobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21CaXRzID0gZnJvbUJpdHMyOwogICAgICB2YXIgcG93X2RibDIgPSBNYXRoLnBvdzsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZzIoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHsKICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHRocm93IEVycm9yKCJlbXB0eSBzdHJpbmciKTsKICAgICAgICBpZiAoc3RyID09PSAiTmFOIiB8fCBzdHIgPT09ICJJbmZpbml0eSIgfHwgc3RyID09PSAiK0luZmluaXR5IiB8fCBzdHIgPT09ICItSW5maW5pdHkiKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLCB1bnNpZ25lZCA9IGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgICAgfQogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICB2YXIgcDsKICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcyKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyMihwb3dfZGJsMihyYWRpeCwgOCkpOwogICAgICAgIHZhciByZXN1bHQgPSBaRVJPMjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkgewogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyMihwb3dfZGJsMihyYWRpeCwgc2l6ZSkpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcjIodmFsdWUpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyMih2YWx1ZSkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIExvbmc0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nMjsKICAgICAgZnVuY3Rpb24gZnJvbVZhbHVlMih2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIyKHZhbCwgdW5zaWduZWQpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nMih2YWwsIHVuc2lnbmVkKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tVmFsdWUgPSBmcm9tVmFsdWUyOwogICAgICB2YXIgVFdPX1BXUl8xNl9EQkwyID0gMSA8PCAxNjsKICAgICAgdmFyIFRXT19QV1JfMjRfREJMMiA9IDEgPDwgMjQ7CiAgICAgIHZhciBUV09fUFdSXzMyX0RCTDIgPSBUV09fUFdSXzE2X0RCTDIgKiBUV09fUFdSXzE2X0RCTDI7CiAgICAgIHZhciBUV09fUFdSXzY0X0RCTDIgPSBUV09fUFdSXzMyX0RCTDIgKiBUV09fUFdSXzMyX0RCTDI7CiAgICAgIHZhciBUV09fUFdSXzYzX0RCTDIgPSBUV09fUFdSXzY0X0RCTDIgLyAyOwogICAgICB2YXIgVFdPX1BXUl8yNDIgPSBmcm9tSW50MihUV09fUFdSXzI0X0RCTDIpOwogICAgICB2YXIgWkVSTzIgPSBmcm9tSW50MigwKTsKICAgICAgTG9uZzQuWkVSTyA9IFpFUk8yOwogICAgICB2YXIgVVpFUk8yID0gZnJvbUludDIoMCwgdHJ1ZSk7CiAgICAgIExvbmc0LlVaRVJPID0gVVpFUk8yOwogICAgICB2YXIgT05FMiA9IGZyb21JbnQyKDEpOwogICAgICBMb25nNC5PTkUgPSBPTkUyOwogICAgICB2YXIgVU9ORTIgPSBmcm9tSW50MigxLCB0cnVlKTsKICAgICAgTG9uZzQuVU9ORSA9IFVPTkUyOwogICAgICB2YXIgTkVHX09ORTIgPSBmcm9tSW50MigtMSk7CiAgICAgIExvbmc0Lk5FR19PTkUgPSBORUdfT05FMjsKICAgICAgdmFyIE1BWF9WQUxVRTIgPSBmcm9tQml0czIoNDI5NDk2NzI5NSB8IDAsIDIxNDc0ODM2NDcgfCAwLCBmYWxzZSk7CiAgICAgIExvbmc0Lk1BWF9WQUxVRSA9IE1BWF9WQUxVRTI7CiAgICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUyID0gZnJvbUJpdHMyKDQyOTQ5NjcyOTUgfCAwLCA0Mjk0OTY3Mjk1IHwgMCwgdHJ1ZSk7CiAgICAgIExvbmc0Lk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTI7CiAgICAgIHZhciBNSU5fVkFMVUUyID0gZnJvbUJpdHMyKDAsIDIxNDc0ODM2NDggfCAwLCBmYWxzZSk7CiAgICAgIExvbmc0Lk1JTl9WQUxVRSA9IE1JTl9WQUxVRTI7CiAgICAgIHZhciBMb25nUHJvdG90eXBlMiA9IExvbmc0LnByb3RvdHlwZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9JbnQgPSBmdW5jdGlvbiB0b0ludDIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyMygpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMMiArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMMiArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcyKHJhZGl4KSB7CiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpCiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuICIwIjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKSB7CiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyMihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcjIocG93X2RibDIocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgcmVtID0gcmVtRGl2OwogICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgICAgICByZXN1bHQgPSAiIiArIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMyKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkMigpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0czIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQyKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMyKCkgewogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRTIpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTsKICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdzsKICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgICAgICBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybzIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXF6ID0gTG9uZ1Byb3RvdHlwZTIuaXNaZXJvOwogICAgICBMb25nUHJvdG90eXBlMi5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZTIoKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlMigpIHsKICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuaXNPZGQgPSBmdW5jdGlvbiBpc09kZDIoKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4yKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzMihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nMihvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZTIob3RoZXIpOwogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXEgPSBMb25nUHJvdG90eXBlMi5lcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUyLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFsczIob3RoZXIpIHsKICAgICAgICByZXR1cm4gIXRoaXMuZXEob3RoZXIpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5uZXEgPSBMb25nUHJvdG90eXBlMi5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUyLm5lID0gTG9uZ1Byb3RvdHlwZTIubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlMi5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubHQgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmx0ZSA9IExvbmdQcm90b3R5cGUyLmxlc3NUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGUgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4yKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5ndCA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuOwogICAgICBMb25nUHJvdG90eXBlMi5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwyKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ3RlID0gTG9uZ1Byb3RvdHlwZTIuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlMi5nZSA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuY29tcCA9IExvbmdQcm90b3R5cGUyLmNvbXBhcmU7CiAgICAgIExvbmdQcm90b3R5cGUyLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZTIoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FMik7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm5lZyA9IExvbmdQcm90b3R5cGUyLm5lZ2F0ZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuYWRkID0gZnVuY3Rpb24gYWRkMihhZGRlbmQpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoYWRkZW5kKSkKICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZTIoYWRkZW5kKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKyBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKyBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKyBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKyBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0czIoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0MihzdWJ0cmFoZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKHN1YnRyYWhlbmQpKQogICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZTIoc3VidHJhaGVuZCk7CiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zdWIgPSBMb25nUHJvdG90eXBlMi5zdWJ0cmFjdDsKICAgICAgTG9uZ1Byb3RvdHlwZTIubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseTIobXVsdGlwbGllcikgewogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICghaXNMb25nMihtdWx0aXBsaWVyKSkKICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUyKG11bHRpcGxpZXIpOwogICAgICAgIGlmICh3YXNtMikgewogICAgICAgICAgdmFyIGxvdyA9IHdhc20yLm11bCh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0czIobG93LCB3YXNtMi5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gWkVSTzI7CiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFMiA6IFpFUk8yOwogICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRTIgOiBaRVJPMjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTsKICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0MikgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0MikpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcjIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICogYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICogYjAwOwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTAwICogYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICogYjAwOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTE2ICogYjE2OwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTAwICogYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubXVsID0gTG9uZ1Byb3RvdHlwZTIubXVsdGlwbHk7CiAgICAgIExvbmdQcm90b3R5cGUyLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZTIoZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nMihkaXZpc29yKSkKICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUyKGRpdmlzb3IpOwogICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKQogICAgICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbTIuZGl2X3UgOiB3YXNtMi5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGxvdywgd2FzbTIuZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTzIgOiBaRVJPMjsKICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlczsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKSB7CiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORTIpIHx8IGRpdmlzb3IuZXEoTkVHX09ORTIpKQogICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUUyOwogICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgICAgIHJldHVybiBPTkUyOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTsKICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpOwogICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTzIpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUyIDogTkVHX09ORTI7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTsKICAgICAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpOwogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICAgICAgcmVzID0gWkVSTzI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkKICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgICAgIHJldHVybiBVWkVSTzI7CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgICAgICByZXR1cm4gVU9ORTI7CiAgICAgICAgICByZXMgPSBVWkVSTzI7CiAgICAgICAgfQogICAgICAgIHJlbSA9IHRoaXM7CiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHsKICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsKICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsMigyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyMihhcHByb3gpLCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhOwogICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyMihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICAgICAgYXBwcm94UmVzID0gT05FMjsKICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZGl2ID0gTG9uZ1Byb3RvdHlwZTIuZGl2aWRlOwogICAgICBMb25nUHJvdG90eXBlMi5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8yKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlMihkaXZpc29yKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20yLnJlbV91IDogd2FzbTIucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3csIHdhc20yLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubW9kID0gTG9uZ1Byb3RvdHlwZTIubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlMi5yZW0gPSBMb25nUHJvdG90eXBlMi5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUyLm5vdCA9IGZ1bmN0aW9uIG5vdDIoKSB7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5hbmQgPSBmdW5jdGlvbiBhbmQyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm9yID0gZnVuY3Rpb24gb3IyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnhvciA9IGZ1bmN0aW9uIHhvcjIob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZzIob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUyKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0MihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMigwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaGwgPSBMb25nUHJvdG90eXBlMi5zaGlmdExlZnQ7CiAgICAgIExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0MihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaHIgPSBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0OwogICAgICBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQyKG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nMihudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgbnVtQml0cyAmPSA2MzsKICAgICAgICBpZiAobnVtQml0cyA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7CiAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdzsKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3cgPj4+IG51bUJpdHMgfCBoaWdoIDw8IDMyIC0gbnVtQml0cywgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaHJ1ID0gTG9uZ1Byb3RvdHlwZTIuc2hpZnRSaWdodFVuc2lnbmVkOwogICAgICBMb25nUHJvdG90eXBlMi5zaHJfdSA9IExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZDIoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkMigpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzMihsZSkgewogICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUyKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgbG8gJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGhpICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMjQKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUyKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgaGkgPj4+IDI0LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gJiAyNTUKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nNC5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZzQuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRTIoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LCBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0LCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmc0LmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUyKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcwogIHZhciByZXF1aXJlX2V2ZW50cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gIm9iamVjdCIgPyBSZWZsZWN0IDogbnVsbDsKICAgICAgdmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICJmdW5jdGlvbiIgPyBSLmFwcGx5IDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5Mih0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7CiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpOwogICAgICB9OwogICAgICB2YXIgUmVmbGVjdE93bktleXM7CiAgICAgIGlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5czsKICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7CiAgICAgICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5czIodGFyZ2V0KSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTsKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXMyKHRhcmdldCkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykgewogICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikKICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTsKICAgICAgfQogICAgICB2YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4yKHZhbHVlKSB7CiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkgewogICAgICAgIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gRXZlbnRFbWl0dGVyOwogICAgICBtb2R1bGUyLmV4cG9ydHMub25jZSA9IG9uY2U7CiAgICAgIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHZvaWQgMDsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwOwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB2b2lkIDA7CiAgICAgIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7CiAgICAgIGZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHsKICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgImxpc3RlbmVyIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICJkZWZhdWx0TWF4TGlzdGVuZXJzIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzOwogICAgICAgIH0sCiAgICAgICAgc2V0OiBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAibnVtYmVyIiB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiAiZGVmYXVsdE1heExpc3RlbmVycyIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICIuIik7CiAgICAgICAgICB9CiAgICAgICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIEV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdm9pZCAwIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHsKICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7CiAgICAgICAgfQogICAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB2b2lkIDA7CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHsKICAgICAgICBpZiAodHlwZW9mIG4gIT09ICJudW1iZXIiIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mICJuIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICIuIik7CiAgICAgICAgfQogICAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkgewogICAgICAgIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHZvaWQgMCkKICAgICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVyczsKICAgICAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzOwogICAgICB9CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkgewogICAgICAgIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpOwogICAgICB9OwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHsKICAgICAgICB2YXIgYXJncyA9IFtdOwogICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKQogICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7CiAgICAgICAgdmFyIGRvRXJyb3IgPSB0eXBlID09PSAiZXJyb3IiOwogICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7CiAgICAgICAgaWYgKGV2ZW50cyAhPT0gdm9pZCAwKQogICAgICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB2b2lkIDA7CiAgICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKGRvRXJyb3IpIHsKICAgICAgICAgIHZhciBlcjsKICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApCiAgICAgICAgICAgIGVyID0gYXJnc1swXTsKICAgICAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgICAgIHRocm93IGVyOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigiVW5oYW5kbGVkIGVycm9yLiIgKyAoZXIgPyAiICgiICsgZXIubWVzc2FnZSArICIpIiA6ICIiKSk7CiAgICAgICAgICBlcnIuY29udGV4dCA9IGVyOwogICAgICAgICAgdGhyb3cgZXJyOwogICAgICAgIH0KICAgICAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTsKICAgICAgICBpZiAoaGFuZGxlciA9PT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7CiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkKICAgICAgICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBmdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkgewogICAgICAgIHZhciBtOwogICAgICAgIHZhciBldmVudHM7CiAgICAgICAgdmFyIGV4aXN0aW5nOwogICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpOwogICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogICAgICAgIGlmIChldmVudHMgPT09IHZvaWQgMCkgewogICAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHZvaWQgMCkgewogICAgICAgICAgICB0YXJnZXQuZW1pdCgibmV3TGlzdGVuZXIiLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpOwogICAgICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50czsKICAgICAgICAgIH0KICAgICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdOwogICAgICAgIH0KICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHZvaWQgMCkgewogICAgICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjsKICAgICAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdOwogICAgICAgICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7CiAgICAgICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7CiAgICAgICAgICB9CiAgICAgICAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpOwogICAgICAgICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkgewogICAgICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlOwogICAgICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcigiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAiICsgZXhpc3RpbmcubGVuZ3RoICsgIiAiICsgU3RyaW5nKHR5cGUpICsgIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Iik7CiAgICAgICAgICAgIHcubmFtZSA9ICJNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmciOwogICAgICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7CiAgICAgICAgICAgIHcudHlwZSA9IHR5cGU7CiAgICAgICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7CiAgICAgICAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhcmdldDsKICAgICAgfQogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyOwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHsKICAgICAgICBpZiAoIXRoaXMuZmlyZWQpIHsKICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pOwogICAgICAgICAgdGhpcy5maXJlZCA9IHRydWU7CiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7CiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHsKICAgICAgICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB2b2lkIDAsIHRhcmdldCwgdHlwZSwgbGlzdGVuZXIgfTsKICAgICAgICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpOwogICAgICAgIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjsKICAgICAgICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkOwogICAgICAgIHJldHVybiB3cmFwcGVkOwogICAgICB9CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UyKHR5cGUsIGxpc3RlbmVyKSB7CiAgICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7CiAgICAgICAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpOwogICAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjsKICAgICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTsKICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7CiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTsKICAgICAgICBpZiAobGlzdCA9PT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7CiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkKICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdOwogICAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICAgICAgICAgIHRoaXMuZW1pdCgicmVtb3ZlTGlzdGVuZXIiLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBwb3NpdGlvbiA9IC0xOwogICAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHsKICAgICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjsKICAgICAgICAgICAgICBwb3NpdGlvbiA9IGk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApCiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKQogICAgICAgICAgICBsaXN0LnNoaWZ0KCk7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkKICAgICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTsKICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHZvaWQgMCkKICAgICAgICAgICAgdGhpcy5lbWl0KCJyZW1vdmVMaXN0ZW5lciIsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyOwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7CiAgICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpOwogICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKICAgICAgICBpZiAoZXZlbnRzID09PSB2b2lkIDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB2b2lkIDApIHsKICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDsKICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB2b2lkIDApIHsKICAgICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApCiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsKICAgICAgICAgIHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKGV2ZW50cyk7CiAgICAgICAgICB2YXIga2V5OwogICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGtleSA9IGtleXMyW2ldOwogICAgICAgICAgICBpZiAoa2V5ID09PSAicmVtb3ZlTGlzdGVuZXIiKQogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoInJlbW92ZUxpc3RlbmVyIik7CiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTsKICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpOwogICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB2b2lkIDApIHsKICAgICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBmdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7CiAgICAgICAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogICAgICAgIGlmIChldmVudHMgPT09IHZvaWQgMCkKICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTsKICAgICAgICBpZiAoZXZsaXN0ZW5lciA9PT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTsKICAgICAgICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7CiAgICAgIH0KICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkgewogICAgICAgIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpOwogICAgICB9OwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7CiAgICAgICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpOwogICAgICB9OwogICAgICBFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHsKICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7CiAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkgewogICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7CiAgICAgICAgaWYgKGV2ZW50cyAhPT0gdm9pZCAwKSB7CiAgICAgICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTsKICAgICAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHsKICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdOwogICAgICB9OwogICAgICBmdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikgewogICAgICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKQogICAgICAgICAgY29weVtpXSA9IGFycltpXTsKICAgICAgICByZXR1cm4gY29weTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHsKICAgICAgICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspCiAgICAgICAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTsKICAgICAgICBsaXN0LnBvcCgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHsKICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkgewogICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7CiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpOwogICAgICAgICAgICByZWplY3QoZXJyKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkgewogICAgICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsIGVycm9yTGlzdGVuZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTsKICAgICAgICAgIH0KICAgICAgICAgIDsKICAgICAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pOwogICAgICAgICAgaWYgKG5hbWUgIT09ICJlcnJvciIpIHsKICAgICAgICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgImVycm9yIiwgaGFuZGxlciwgZmxhZ3MpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBpZiAoZmxhZ3Mub25jZSkgewogICAgICAgICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykgewogICAgICAgICAgICBpZiAoZmxhZ3Mub25jZSkgewogICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxpc3RlbmVyKGFyZyk7CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJlbWl0dGVyIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfaW5oZXJpdHNfYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewogICAgICAgICAgaWYgKHN1cGVyQ3RvcikgewogICAgICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjsKICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHsKICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICAgICAgdmFsdWU6IGN0b3IsCiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewogICAgICAgICAgaWYgKHN1cGVyQ3RvcikgewogICAgICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjsKICAgICAgICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7CiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7CiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9ldmVudHMoKS5FdmVudEVtaXR0ZXI7CiAgICB9CiAgfSk7CgogIC8vIChkaXNhYmxlZCk6dXRpbAogIHZhciByZXF1aXJlX3V0aWwgPSBfX2NvbW1vbkpTKHsKICAgICIoZGlzYWJsZWQpOnV0aWwiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMKICB2YXIgcmVxdWlyZV9idWZmZXJfbGlzdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsKICAgICAgICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QpOwogICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7CiAgICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsKICAgICAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7CiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOwogICAgICAgICAgfSkpLCBrZXlzMi5wdXNoLmFwcGx5KGtleXMyLCBzeW1ib2xzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGtleXMyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OwogICAgICAgICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsKICAgICAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhcmdldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7CiAgICAgICAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsKICAgICAgICBpZiAoa2V5IGluIG9iaikgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikKICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7CiAgICAgICAgaWYgKHByb3RvUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOwogICAgICAgIGlmIChzdGF0aWNQcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCAicHJvdG90eXBlIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7CiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgewogICAgICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCAic3RyaW5nIik7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICJzeW1ib2wiID8ga2V5IDogU3RyaW5nKGtleSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7CiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gIm9iamVjdCIgfHwgaW5wdXQgPT09IG51bGwpCiAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOwogICAgICAgIGlmIChwcmltICE9PSB2b2lkIDApIHsKICAgICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgImRlZmF1bHQiKTsKICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAib2JqZWN0IikKICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoaGludCA9PT0gInN0cmluZyIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsKICAgICAgfQogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX2J1ZmZlcigpOwogICAgICB2YXIgQnVmZmVyMTAgPSBfcmVxdWlyZS5CdWZmZXI7CiAgICAgIHZhciBfcmVxdWlyZTIgPSByZXF1aXJlX3V0aWwoKTsKICAgICAgdmFyIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDsKICAgICAgdmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgImluc3BlY3QiOwogICAgICBmdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHsKICAgICAgICBCdWZmZXIxMC5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpOwogICAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7CiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbewogICAgICAgICAga2V5OiAicHVzaCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7CiAgICAgICAgICAgIHZhciBlbnRyeSA9IHsKICAgICAgICAgICAgICBkYXRhOiB2LAogICAgICAgICAgICAgIG5leHQ6IG51bGwKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkKICAgICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5OwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgdGhpcy5oZWFkID0gZW50cnk7CiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5OwogICAgICAgICAgICArK3RoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInVuc2hpZnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikgewogICAgICAgICAgICB2YXIgZW50cnkgPSB7CiAgICAgICAgICAgICAgZGF0YTogdiwKICAgICAgICAgICAgICBuZXh0OiB0aGlzLmhlYWQKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5OwogICAgICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeTsKICAgICAgICAgICAgKyt0aGlzLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJzaGlmdCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKQogICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDsKICAgICAgICAgICAgLS10aGlzLmxlbmd0aDsKICAgICAgICAgICAgcmV0dXJuIHJldDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJjbGVhciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7CiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJqb2luIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICAgICAgICAgIHZhciByZXQgPSAiIiArIHAuZGF0YTsKICAgICAgICAgICAgd2hpbGUgKHAgPSBwLm5leHQpCiAgICAgICAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7CiAgICAgICAgICAgIHJldHVybiByZXQ7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY29uY2F0IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikgewogICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApCiAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKDApOwogICAgICAgICAgICB2YXIgcmV0ID0gQnVmZmVyMTAuYWxsb2NVbnNhZmUobiA+Pj4gMCk7CiAgICAgICAgICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgICAgICAgICB2YXIgaSA9IDA7CiAgICAgICAgICAgIHdoaWxlIChwKSB7CiAgICAgICAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7CiAgICAgICAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoOwogICAgICAgICAgICAgIHAgPSBwLm5leHQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJldDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJjb25zdW1lIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHsKICAgICAgICAgICAgdmFyIHJldDsKICAgICAgICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHsKICAgICAgICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTsKICAgICAgICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pOwogICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkgewogICAgICAgICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXQ7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZmlyc3QiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX2dldFN0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7CiAgICAgICAgICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgICAgICAgICB2YXIgYyA9IDE7CiAgICAgICAgICAgIHZhciByZXQgPSBwLmRhdGE7CiAgICAgICAgICAgIG4gLT0gcmV0Lmxlbmd0aDsKICAgICAgICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgICAgICAgICAgICB2YXIgc3RyID0gcC5kYXRhOwogICAgICAgICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47CiAgICAgICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0ICs9IHN0cjsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICByZXQgKz0gc3RyLnNsaWNlKDAsIG4pOwogICAgICAgICAgICAgIG4gLT0gbmI7CiAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHsKICAgICAgICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICArK2M7CiAgICAgICAgICAgICAgICAgIGlmIChwLm5leHQpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gcC5uZXh0OwogICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7CiAgICAgICAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgKytjOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMubGVuZ3RoIC09IGM7CiAgICAgICAgICAgIHJldHVybiByZXQ7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX2dldEJ1ZmZlciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7CiAgICAgICAgICAgIHZhciByZXQgPSBCdWZmZXIxMC5hbGxvY1Vuc2FmZShuKTsKICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICAgICAgICAgIHZhciBjID0gMTsKICAgICAgICAgICAgcC5kYXRhLmNvcHkocmV0KTsKICAgICAgICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoOwogICAgICAgICAgICB3aGlsZSAocCA9IHAubmV4dCkgewogICAgICAgICAgICAgIHZhciBidWYgPSBwLmRhdGE7CiAgICAgICAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjsKICAgICAgICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7CiAgICAgICAgICAgICAgbiAtPSBuYjsKICAgICAgICAgICAgICBpZiAobiA9PT0gMCkgewogICAgICAgICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICsrYzsKICAgICAgICAgICAgICAgICAgaWYgKHAubmV4dCkKICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBwLm5leHQ7CiAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gcDsKICAgICAgICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICArK2M7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5sZW5ndGggLT0gYzsKICAgICAgICAgICAgcmV0dXJuIHJldDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6IGN1c3RvbSwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7CiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7CiAgICAgICAgICAgICAgZGVwdGg6IDAsCiAgICAgICAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UKICAgICAgICAgICAgfSkpOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQnVmZmVyTGlzdDsKICAgICAgfSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMKICB2YXIgcmVxdWlyZV9kZXN0cm95ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7CiAgICAgICAgdmFyIF90aGlzID0gdGhpczsKICAgICAgICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkOwogICAgICAgIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgICAgICAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7CiAgICAgICAgICBpZiAoY2IpIHsKICAgICAgICAgICAgY2IoZXJyKTsKICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlOwogICAgICAgIH0KICAgICAgICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbihlcnIyKSB7CiAgICAgICAgICBpZiAoIWNiICYmIGVycjIpIHsKICAgICAgICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycjIpOwogICAgICAgICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHsKICAgICAgICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycjIpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChjYikgewogICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7CiAgICAgICAgICAgIGNiKGVycjIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZjIsIGVycikgewogICAgICAgIGVtaXRFcnJvck5UKHNlbGYyLCBlcnIpOwogICAgICAgIGVtaXRDbG9zZU5UKHNlbGYyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmMikgewogICAgICAgIGlmIChzZWxmMi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZjIuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKQogICAgICAgICAgcmV0dXJuOwogICAgICAgIGlmIChzZWxmMi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZjIuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKQogICAgICAgICAgcmV0dXJuOwogICAgICAgIHNlbGYyLmVtaXQoImNsb3NlIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdW5kZXN0cm95KCkgewogICAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7CiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7CiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7CiAgICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7CiAgICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZjIsIGVycikgewogICAgICAgIHNlbGYyLmVtaXQoImVycm9yIiwgZXJyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikgewogICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKICAgICAgICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KQogICAgICAgICAgc3RyZWFtLmRlc3Ryb3koZXJyKTsKICAgICAgICBlbHNlCiAgICAgICAgICBzdHJlYW0uZW1pdCgiZXJyb3IiLCBlcnIpOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICBkZXN0cm95LAogICAgICAgIHVuZGVzdHJveSwKICAgICAgICBlcnJvck9yRGVzdHJveQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfZXJyb3JzX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsKICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsKICAgICAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOwogICAgICB9CiAgICAgIHZhciBjb2RlcyA9IHt9OwogICAgICBmdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkgewogICAgICAgIGlmICghQmFzZSkgewogICAgICAgICAgQmFzZSA9IEVycm9yOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHsKICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIE5vZGVFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfQmFzZSkgewogICAgICAgICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yMiwgX0Jhc2UpOwogICAgICAgICAgZnVuY3Rpb24gTm9kZUVycm9yMihhcmcxLCBhcmcyLCBhcmczKSB7CiAgICAgICAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gTm9kZUVycm9yMjsKICAgICAgICB9KEJhc2UpOwogICAgICAgIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTsKICAgICAgICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlOwogICAgICAgIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykgewogICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkgewogICAgICAgICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDsKICAgICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uKGkpIHsKICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpKTsKICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKGxlbiA+IDIpIHsKICAgICAgICAgICAgcmV0dXJuICJvbmUgb2YgIi5jb25jYXQodGhpbmcsICIgIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oIiwgIiksICIsIG9yICIpICsgZXhwZWN0ZWRbbGVuIC0gMV07CiAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikgewogICAgICAgICAgICByZXR1cm4gIm9uZSBvZiAiLmNvbmNhdCh0aGluZywgIiAiKS5jb25jYXQoZXhwZWN0ZWRbMF0sICIgb3IgIikuY29uY2F0KGV4cGVjdGVkWzFdKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiAib2YgIi5jb25jYXQodGhpbmcsICIgIikuY29uY2F0KGV4cGVjdGVkWzBdKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuICJvZiAiLmNvbmNhdCh0aGluZywgIiAiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykgewogICAgICAgIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikgewogICAgICAgIGlmICh0aGlzX2xlbiA9PT0gdm9pZCAwIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkgewogICAgICAgICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkgewogICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX0lOVkFMSURfT1BUX1ZBTFVFIiwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsKICAgICAgICByZXR1cm4gJ1RoZSB2YWx1ZSAiJyArIHZhbHVlICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICInICsgbmFtZSArICciJzsKICAgICAgfSwgVHlwZUVycm9yKTsKICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIGZ1bmN0aW9uKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHsKICAgICAgICB2YXIgZGV0ZXJtaW5lcjsKICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAic3RyaW5nIiAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAibm90ICIpKSB7CiAgICAgICAgICBkZXRlcm1pbmVyID0gIm11c3Qgbm90IGJlIjsKICAgICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAiIik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRldGVybWluZXIgPSAibXVzdCBiZSI7CiAgICAgICAgfQogICAgICAgIHZhciBtc2c7CiAgICAgICAgaWYgKGVuZHNXaXRoKG5hbWUsICIgYXJndW1lbnQiKSkgewogICAgICAgICAgbXNnID0gIlRoZSAiLmNvbmNhdChuYW1lLCAiICIpLmNvbmNhdChkZXRlcm1pbmVyLCAiICIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgInR5cGUiKSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgIi4iKSA/ICJwcm9wZXJ0eSIgOiAiYXJndW1lbnQiOwogICAgICAgICAgbXNnID0gJ1RoZSAiJy5jb25jYXQobmFtZSwgJyIgJykuY29uY2F0KHR5cGUsICIgIikuY29uY2F0KGRldGVybWluZXIsICIgIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAidHlwZSIpKTsKICAgICAgICB9CiAgICAgICAgbXNnICs9ICIuIFJlY2VpdmVkIHR5cGUgIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7CiAgICAgICAgcmV0dXJuIG1zZzsKICAgICAgfSwgVHlwZUVycm9yKTsKICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GIiwgInN0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GIik7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQiLCBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgcmV0dXJuICJUaGUgIiArIG5hbWUgKyAiIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQiOwogICAgICB9KTsKICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSIsICJQcmVtYXR1cmUgY2xvc2UiKTsKICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfU1RSRUFNX0RFU1RST1lFRCIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICByZXR1cm4gIkNhbm5vdCBjYWxsICIgKyBuYW1lICsgIiBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkIjsKICAgICAgfSk7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX01VTFRJUExFX0NBTExCQUNLIiwgIkNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyIpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUiLCAiQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZSIpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EIiwgIndyaXRlIGFmdGVyIGVuZCIpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMiLCAiTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0iLCBUeXBlRXJyb3IpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9VTktOT1dOX0VOQ09ESU5HIiwgZnVuY3Rpb24oYXJnKSB7CiAgICAgICAgcmV0dXJuICJVbmtub3duIGVuY29kaW5nOiAiICsgYXJnOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQiLCAic3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQiKTsKICAgICAgbW9kdWxlMi5leHBvcnRzLmNvZGVzID0gY29kZXM7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMKICB2YXIgcmVxdWlyZV9zdGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTsKICAgICAgZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkgewogICAgICAgIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDsKICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7CiAgICAgICAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpOwogICAgICAgIGlmIChod20gIT0gbnVsbCkgewogICAgICAgICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkgewogICAgICAgICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogImhpZ2hXYXRlck1hcmsiOwogICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihod20pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICBnZXRIaWdoV2F0ZXJNYXJrCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGRlcHJlY2F0ZTsKICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtc2cpIHsKICAgICAgICBpZiAoY29uZmlnKCJub0RlcHJlY2F0aW9uIikpIHsKICAgICAgICAgIHJldHVybiBmbjsKICAgICAgICB9CiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlOwogICAgICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7CiAgICAgICAgICBpZiAoIXdhcm5lZCkgewogICAgICAgICAgICBpZiAoY29uZmlnKCJ0aHJvd0RlcHJlY2F0aW9uIikpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcoInRyYWNlRGVwcmVjYXRpb24iKSkgewogICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB3YXJuZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZXByZWNhdGVkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbmZpZyhuYW1lKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0gY2F0Y2ggKF8pIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07CiAgICAgICAgaWYgKHZhbCA9PSBudWxsKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAidHJ1ZSI7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcwogIHZhciByZXF1aXJlX3N0cmVhbV93cml0YWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBXcml0YWJsZTsKICAgICAgZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkgewogICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDsKICAgICAgICB0aGlzLmVudHJ5ID0gbnVsbDsKICAgICAgICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIHZhciBEdXBsZXg7CiAgICAgIFdyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlOwogICAgICB2YXIgaW50ZXJuYWxVdGlsID0gewogICAgICAgIGRlcHJlY2F0ZTogcmVxdWlyZV9icm93c2VyKCkKICAgICAgfTsKICAgICAgdmFyIFN0cmVhbSA9IHJlcXVpcmVfc3RyZWFtX2Jyb3dzZXIoKTsKICAgICAgdmFyIEJ1ZmZlcjEwID0gcmVxdWlyZV9idWZmZXIoKS5CdWZmZXI7CiAgICAgIHZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24oKSB7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHsKICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbShjaHVuayk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHsKICAgICAgICByZXR1cm4gQnVmZmVyMTAuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5OwogICAgICB9CiAgICAgIHZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmVfZGVzdHJveSgpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3N0YXRlKCk7CiAgICAgIHZhciBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyazsKICAgICAgdmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzOwogICAgICB2YXIgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsKICAgICAgdmFyIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQ7CiAgICAgIHZhciBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0s7CiAgICAgIHZhciBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRTsKICAgICAgdmFyIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7CiAgICAgIHZhciBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUzsKICAgICAgdmFyIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQ7CiAgICAgIHZhciBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HOwogICAgICB2YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTsKICAgICAgcmVxdWlyZV9pbmhlcml0c19icm93c2VyKCkoV3JpdGFibGUsIFN0cmVhbSk7CiAgICAgIGZ1bmN0aW9uIG5vcCgpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHsKICAgICAgICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZV9zdHJlYW1fZHVwbGV4KCk7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gImJvb2xlYW4iKQogICAgICAgICAgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7CiAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CiAgICAgICAgaWYgKGlzRHVwbGV4KQogICAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7CiAgICAgICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwgaXNEdXBsZXgpOwogICAgICAgIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOwogICAgICAgIHRoaXMuZW5kaW5nID0gZmFsc2U7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgICAgIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7CiAgICAgICAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOwogICAgICAgIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgInV0ZjgiOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLndyaXRpbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLmNvcmtlZCA9IDA7CiAgICAgICAgdGhpcy5zeW5jID0gdHJ1ZTsKICAgICAgICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikgewogICAgICAgICAgb253cml0ZShzdHJlYW0sIGVyKTsKICAgICAgICB9OwogICAgICAgIHRoaXMud3JpdGVjYiA9IG51bGw7CiAgICAgICAgdGhpcy53cml0ZWxlbiA9IDA7CiAgICAgICAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsOwogICAgICAgIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgICAgICAgdGhpcy5wZW5kaW5nY2IgPSAwOwogICAgICAgIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOwogICAgICAgIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7CiAgICAgICAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CiAgICAgICAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTsKICAgICAgfQogICAgICBXcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7CiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDsKICAgICAgICB2YXIgb3V0ID0gW107CiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHsKICAgICAgICAgIG91dC5wdXNoKGN1cnJlbnQpOwogICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dDsKICAgICAgfTsKICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICJidWZmZXIiLCB7CiAgICAgICAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpOwogICAgICAgICAgICB9LCAiX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgaW5zdGVhZC4iLCAiREVQMDAwMyIpCiAgICAgICAgICB9KTsKICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgfQogICAgICB9KSgpOwogICAgICB2YXIgcmVhbEhhc0luc3RhbmNlOwogICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHsKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHsKICAgICAgICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpCiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2UyKG9iamVjdCkgewogICAgICAgICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7CiAgICAgICAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpOwogICAgICAgIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7CiAgICAgICAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKQogICAgICAgICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTsKICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOwogICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlOwogICAgICAgIGlmIChvcHRpb25zKSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2OwogICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDsKICAgICAgICB9CiAgICAgICAgU3RyZWFtLmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7CiAgICAgICAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7CiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7CiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7CiAgICAgICAgdmFyIGVyOwogICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkgewogICAgICAgICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAic3RyaW5nIiAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgICAgICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoImNodW5rIiwgWyJzdHJpbmciLCAiQnVmZmVyIl0sIGNodW5rKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVyKSB7CiAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHJldCA9IGZhbHNlOwogICAgICAgIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspOwogICAgICAgIGlmIChpc0J1ZiAmJiAhQnVmZmVyMTAuaXNCdWZmZXIoY2h1bmspKSB7CiAgICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBjYiA9IGVuY29kaW5nOwogICAgICAgICAgZW5jb2RpbmcgPSBudWxsOwogICAgICAgIH0KICAgICAgICBpZiAoaXNCdWYpCiAgICAgICAgICBlbmNvZGluZyA9ICJidWZmZXIiOwogICAgICAgIGVsc2UgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nOwogICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICJmdW5jdGlvbiIpCiAgICAgICAgICBjYiA9IG5vcDsKICAgICAgICBpZiAoc3RhdGUuZW5kaW5nKQogICAgICAgICAgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7CiAgICAgICAgZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkgewogICAgICAgICAgc3RhdGUucGVuZGluZ2NiKys7CiAgICAgICAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH07CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKzsKICAgICAgfTsKICAgICAgV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgICAgICAgc3RhdGUuY29ya2VkLS07CiAgICAgICAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpCiAgICAgICAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIikKICAgICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTsKICAgICAgICBpZiAoIShbImhleCIsICJ1dGY4IiwgInV0Zi04IiwgImFzY2lpIiwgImJpbmFyeSIsICJiYXNlNjQiLCAidWNzMiIsICJ1Y3MtMiIsICJ1dGYxNmxlIiwgInV0Zi0xNmxlIiwgInJhdyJdLmluZGV4T2YoKGVuY29kaW5nICsgIiIpLnRvTG93ZXJDYXNlKCkpID4gLTEpKQogICAgICAgICAgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTsKICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAid3JpdGFibGVCdWZmZXIiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAic3RyaW5nIikgewogICAgICAgICAgY2h1bmsgPSBCdWZmZXIxMC5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjaHVuazsKICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyazsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgaWYgKCFpc0J1ZikgewogICAgICAgICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7CiAgICAgICAgICAgIGlzQnVmID0gdHJ1ZTsKICAgICAgICAgICAgZW5jb2RpbmcgPSAiYnVmZmVyIjsKICAgICAgICAgICAgY2h1bmsgPSBuZXdDaHVuazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgICAgIHN0YXRlLmxlbmd0aCArPSBsZW47CiAgICAgICAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7CiAgICAgICAgaWYgKCFyZXQpCiAgICAgICAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlOwogICAgICAgIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkgewogICAgICAgICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgICAgICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHsKICAgICAgICAgICAgY2h1bmssCiAgICAgICAgICAgIGVuY29kaW5nLAogICAgICAgICAgICBpc0J1ZiwKICAgICAgICAgICAgY2FsbGJhY2s6IGNiLAogICAgICAgICAgICBuZXh0OiBudWxsCiAgICAgICAgICB9OwogICAgICAgICAgaWYgKGxhc3QpIHsKICAgICAgICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHsKICAgICAgICBzdGF0ZS53cml0ZWxlbiA9IGxlbjsKICAgICAgICBzdGF0ZS53cml0ZWNiID0gY2I7CiAgICAgICAgc3RhdGUud3JpdGluZyA9IHRydWU7CiAgICAgICAgc3RhdGUuc3luYyA9IHRydWU7CiAgICAgICAgaWYgKHN0YXRlLmRlc3Ryb3llZCkKICAgICAgICAgIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCJ3cml0ZSIpKTsKICAgICAgICBlbHNlIGlmICh3cml0ZXYpCiAgICAgICAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpOwogICAgICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7CiAgICAgICAgLS1zdGF0ZS5wZW5kaW5nY2I7CiAgICAgICAgaWYgKHN5bmMpIHsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpOwogICAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY2IoZXIpOwogICAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsKICAgICAgICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHsKICAgICAgICBzdGF0ZS53cml0aW5nID0gZmFsc2U7CiAgICAgICAgc3RhdGUud3JpdGVjYiA9IG51bGw7CiAgICAgICAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuOwogICAgICAgIHN0YXRlLndyaXRlbGVuID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jOwogICAgICAgIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7CiAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTsKICAgICAgICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpOwogICAgICAgIGlmIChlcikKICAgICAgICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDsKICAgICAgICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHsKICAgICAgICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3luYykgewogICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7CiAgICAgICAgaWYgKCFmaW5pc2hlZCkKICAgICAgICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTsKICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKICAgICAgICBjYigpOwogICAgICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHsKICAgICAgICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlOwogICAgICAgICAgc3RyZWFtLmVtaXQoImRyYWluIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHsKICAgICAgICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTsKICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7CiAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHsKICAgICAgICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7CiAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpOwogICAgICAgICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTsKICAgICAgICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5OwogICAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTsKICAgICAgICAgIHdoaWxlIChlbnRyeSkgewogICAgICAgICAgICBidWZmZXJbY291bnRdID0gZW50cnk7CiAgICAgICAgICAgIGlmICghZW50cnkuaXNCdWYpCiAgICAgICAgICAgICAgYWxsQnVmZmVycyA9IGZhbHNlOwogICAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgICAgICAgICAgIGNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7CiAgICAgICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAiIiwgaG9sZGVyLmZpbmlzaCk7CiAgICAgICAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgICAgICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOwogICAgICAgICAgaWYgKGhvbGRlci5uZXh0KSB7CiAgICAgICAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0OwogICAgICAgICAgICBob2xkZXIubmV4dCA9IG51bGw7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHdoaWxlIChlbnRyeSkgewogICAgICAgICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuazsKICAgICAgICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7CiAgICAgICAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrOwogICAgICAgICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CiAgICAgICAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsKICAgICAgICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGVudHJ5ID09PSBudWxsKQogICAgICAgICAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7CiAgICAgICAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgICB9CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCJfd3JpdGUoKSIpKTsKICAgICAgfTsKICAgICAgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsOwogICAgICBXcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgY2IgPSBjaHVuazsKICAgICAgICAgIGNodW5rID0gbnVsbDsKICAgICAgICAgIGVuY29kaW5nID0gbnVsbDsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgY2IgPSBlbmNvZGluZzsKICAgICAgICAgIGVuY29kaW5nID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB2b2lkIDApCiAgICAgICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgICAgICAgc3RhdGUuY29ya2VkID0gMTsKICAgICAgICAgIHRoaXMudW5jb3JrKCk7CiAgICAgICAgfQogICAgICAgIGlmICghc3RhdGUuZW5kaW5nKQogICAgICAgICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgIndyaXRhYmxlTGVuZ3RoIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHsKICAgICAgICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgc3RyZWFtLl9maW5hbChmdW5jdGlvbihlcnIpIHsKICAgICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7CiAgICAgICAgICBzdHJlYW0uZW1pdCgicHJlZmluaXNoIik7CiAgICAgICAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICAgICAgICB9KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICJmdW5jdGlvbiIgJiYgIXN0YXRlLmRlc3Ryb3llZCkgewogICAgICAgICAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgICAgICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlOwogICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7CiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCJwcmVmaW5pc2giKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7CiAgICAgICAgaWYgKG5lZWQpIHsKICAgICAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTsKICAgICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHsKICAgICAgICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlOwogICAgICAgICAgICBzdHJlYW0uZW1pdCgiZmluaXNoIik7CiAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkgewogICAgICAgICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7CiAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gbmVlZDsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikgewogICAgICAgIHN0YXRlLmVuZGluZyA9IHRydWU7CiAgICAgICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgaWYgKGNiKSB7CiAgICAgICAgICBpZiAoc3RhdGUuZmluaXNoZWQpCiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBzdHJlYW0ub25jZSgiZmluaXNoIiwgY2IpOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5lbmRlZCA9IHRydWU7CiAgICAgICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikgewogICAgICAgIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7CiAgICAgICAgY29ya1JlcS5lbnRyeSA9IG51bGw7CiAgICAgICAgd2hpbGUgKGVudHJ5KSB7CiAgICAgICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgICAgICAgY2IoZXJyKTsKICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgICB9CiAgICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxOwogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICJkZXN0cm95ZWQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICAgICAgICB9LAogICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7CiAgICAgICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBXcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwogICAgICBXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7CiAgICAgICAgY2IoZXJyKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fZHVwbGV4ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikgewogICAgICAgIHZhciBrZXlzMyA9IFtdOwogICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopCiAgICAgICAgICBrZXlzMy5wdXNoKGtleSk7CiAgICAgICAgcmV0dXJuIGtleXMzOwogICAgICB9OwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBEdXBsZXg7CiAgICAgIHZhciBSZWFkYWJsZSA9IHJlcXVpcmVfc3RyZWFtX3JlYWRhYmxlKCk7CiAgICAgIHZhciBXcml0YWJsZSA9IHJlcXVpcmVfc3RyZWFtX3dyaXRhYmxlKCk7CiAgICAgIHJlcXVpcmVfaW5oZXJpdHNfYnJvd3NlcigpKER1cGxleCwgUmVhZGFibGUpOwogICAgICB7CiAgICAgICAga2V5czIgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7CiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGtleXMyLmxlbmd0aDsgdisrKSB7CiAgICAgICAgICBtZXRob2QgPSBrZXlzMlt2XTsKICAgICAgICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKQogICAgICAgICAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIGtleXMyOwogICAgICB2YXIgbWV0aG9kOwogICAgICB2YXIgdjsKICAgICAgZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkKICAgICAgICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpOwogICAgICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgICAgICAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTsKICAgICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlOwogICAgICAgIGlmIChvcHRpb25zKSB7CiAgICAgICAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpCiAgICAgICAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTsKICAgICAgICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkKICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlOwogICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHsKICAgICAgICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMub25jZSgiZW5kIiwgb25lbmQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICJ3cml0YWJsZUJ1ZmZlciIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICJ3cml0YWJsZUxlbmd0aCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkKICAgICAgICAgIHJldHVybjsKICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG9uRW5kTlQoc2VsZjIpIHsKICAgICAgICBzZWxmMi5lbmQoKTsKICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgImRlc3Ryb3llZCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB2b2lkIDAgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICAgICAgICB9LAogICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7CiAgICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdm9pZCAwIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHZvaWQgMCkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfc2FmZV9idWZmZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBidWZmZXIgPSByZXF1aXJlX2J1ZmZlcigpOwogICAgICB2YXIgQnVmZmVyMTAgPSBidWZmZXIuQnVmZmVyOwogICAgICBmdW5jdGlvbiBjb3B5UHJvcHMoc3JjLCBkc3QpIHsKICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7CiAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoQnVmZmVyMTAuZnJvbSAmJiBCdWZmZXIxMC5hbGxvYyAmJiBCdWZmZXIxMC5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIxMC5hbGxvY1Vuc2FmZVNsb3cpIHsKICAgICAgICBtb2R1bGUyLmV4cG9ydHMgPSBidWZmZXI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0czIpOwogICAgICAgIGV4cG9ydHMyLkJ1ZmZlciA9IFNhZmVCdWZmZXI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gU2FmZUJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBCdWZmZXIxMChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgIGNvcHlQcm9wcyhCdWZmZXIxMCwgU2FmZUJ1ZmZlcik7CiAgICAgIFNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlciIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gQnVmZmVyMTAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9OwogICAgICBTYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIik7CiAgICAgICAgfQogICAgICAgIHZhciBidWYgPSBCdWZmZXIxMChzaXplKTsKICAgICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIikgewogICAgICAgICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWYuZmlsbChmaWxsKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgYnVmLmZpbGwoMCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIFNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gQnVmZmVyMTAoc2l6ZSk7CiAgICAgIH07CiAgICAgIFNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24oc2l6ZSkgewogICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzCiAgdmFyIHJlcXVpcmVfc3RyaW5nX2RlY29kZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJ1ZmZlcjEwID0gcmVxdWlyZV9zYWZlX2J1ZmZlcigpLkJ1ZmZlcjsKICAgICAgdmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIxMC5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7CiAgICAgICAgZW5jb2RpbmcgPSAiIiArIGVuY29kaW5nOwogICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgY2FzZSAicmF3IjoKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9OwogICAgICBmdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7CiAgICAgICAgaWYgKCFlbmMpCiAgICAgICAgICByZXR1cm4gInV0ZjgiOwogICAgICAgIHZhciByZXRyaWVkOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuYykgewogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiAidXRmOCI7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuICJ1dGYxNmxlIjsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gImxhdGluMSI7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gZW5jOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChyZXRyaWVkKQogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIGVuYyA9ICgiIiArIGVuYykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICByZXRyaWVkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7CiAgICAgICAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTsKICAgICAgICBpZiAodHlwZW9mIG5lbmMgIT09ICJzdHJpbmciICYmIChCdWZmZXIxMC5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKQogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jKTsKICAgICAgICByZXR1cm4gbmVuYyB8fCBlbmM7CiAgICAgIH0KICAgICAgZXhwb3J0czIuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7CiAgICAgIGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHsKICAgICAgICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpOwogICAgICAgIHZhciBuYjsKICAgICAgICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHsKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7CiAgICAgICAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7CiAgICAgICAgICAgIG5iID0gNDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDsKICAgICAgICAgICAgbmIgPSA0OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7CiAgICAgICAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kOwogICAgICAgICAgICBuYiA9IDM7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlOwogICAgICAgICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB0aGlzLmxhc3ROZWVkID0gMDsKICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDA7CiAgICAgICAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlcjEwLmFsbG9jVW5zYWZlKG5iKTsKICAgICAgfQogICAgICBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZikgewogICAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIHZhciByOwogICAgICAgIHZhciBpOwogICAgICAgIGlmICh0aGlzLmxhc3ROZWVkKSB7CiAgICAgICAgICByID0gdGhpcy5maWxsTGFzdChidWYpOwogICAgICAgICAgaWYgKHIgPT09IHZvaWQgMCkKICAgICAgICAgICAgcmV0dXJuICIiOwogICAgICAgICAgaSA9IHRoaXMubGFzdE5lZWQ7CiAgICAgICAgICB0aGlzLmxhc3ROZWVkID0gMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaSA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChpIDwgYnVmLmxlbmd0aCkKICAgICAgICAgIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7CiAgICAgICAgcmV0dXJuIHIgfHwgIiI7CiAgICAgIH07CiAgICAgIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7CiAgICAgIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDsKICAgICAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbihidWYpIHsKICAgICAgICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpOwogICAgICAgICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwogICAgICAgIH0KICAgICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpOwogICAgICAgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7CiAgICAgICAgaWYgKGJ5dGUgPD0gMTI3KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSA2KQogICAgICAgICAgcmV0dXJuIDI7CiAgICAgICAgZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAxNCkKICAgICAgICAgIHJldHVybiAzOwogICAgICAgIGVsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMzApCiAgICAgICAgICByZXR1cm4gNDsKICAgICAgICByZXR1cm4gYnl0ZSA+PiA2ID09PSAyID8gLTEgOiAtMjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYyLCBidWYsIGkpIHsKICAgICAgICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxOwogICAgICAgIGlmIChqIDwgaSkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICAgICAgICBpZiAobmIgPj0gMCkgewogICAgICAgICAgaWYgKG5iID4gMCkKICAgICAgICAgICAgc2VsZjIubGFzdE5lZWQgPSBuYiAtIDE7CiAgICAgICAgICByZXR1cm4gbmI7CiAgICAgICAgfQogICAgICAgIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwogICAgICAgIGlmIChuYiA+PSAwKSB7CiAgICAgICAgICBpZiAobmIgPiAwKQogICAgICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IG5iIC0gMjsKICAgICAgICAgIHJldHVybiBuYjsKICAgICAgICB9CiAgICAgICAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgICAgICAgaWYgKG5iID49IDApIHsKICAgICAgICAgIGlmIChuYiA+IDApIHsKICAgICAgICAgICAgaWYgKG5iID09PSAyKQogICAgICAgICAgICAgIG5iID0gMDsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIHNlbGYyLmxhc3ROZWVkID0gbmIgLSAzOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5iOwogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYyLCBidWYsIHApIHsKICAgICAgICBpZiAoKGJ1ZlswXSAmIDE5MikgIT09IDEyOCkgewogICAgICAgICAgc2VsZjIubGFzdE5lZWQgPSAwOwogICAgICAgICAgcmV0dXJuICJcdUZGRkQiOwogICAgICAgIH0KICAgICAgICBpZiAoc2VsZjIubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7CiAgICAgICAgICBpZiAoKGJ1ZlsxXSAmIDE5MikgIT09IDEyOCkgewogICAgICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IDE7CiAgICAgICAgICAgIHJldHVybiAiXHVGRkZEIjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzZWxmMi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgaWYgKChidWZbMl0gJiAxOTIpICE9PSAxMjgpIHsKICAgICAgICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IDI7CiAgICAgICAgICAgICAgcmV0dXJuICJcdUZGRkQiOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHsKICAgICAgICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKICAgICAgICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTsKICAgICAgICBpZiAociAhPT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIHI7CiAgICAgICAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewogICAgICAgICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7CiAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7CiAgICAgICAgfQogICAgICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpOwogICAgICAgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHsKICAgICAgICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7CiAgICAgICAgaWYgKCF0aGlzLmxhc3ROZWVkKQogICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygidXRmOCIsIGkpOwogICAgICAgIHRoaXMubGFzdFRvdGFsID0gdG90YWw7CiAgICAgICAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTsKICAgICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpOwogICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoInV0ZjgiLCBpLCBlbmQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7CiAgICAgICAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICIiOwogICAgICAgIGlmICh0aGlzLmxhc3ROZWVkKQogICAgICAgICAgcmV0dXJuIHIgKyAiXHVGRkZEIjsKICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7CiAgICAgICAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7CiAgICAgICAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygidXRmMTZsZSIsIGkpOwogICAgICAgICAgaWYgKHIpIHsKICAgICAgICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTsKICAgICAgICAgICAgaWYgKGMgPj0gNTUyOTYgJiYgYyA8PSA1NjMxOSkgewogICAgICAgICAgICAgIHRoaXMubGFzdE5lZWQgPSAyOwogICAgICAgICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDsKICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTsKICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByOwogICAgICAgIH0KICAgICAgICB0aGlzLmxhc3ROZWVkID0gMTsKICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDI7CiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygidXRmMTZsZSIsIGksIGJ1Zi5sZW5ndGggLSAxKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNkVuZChidWYpIHsKICAgICAgICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogIiI7CiAgICAgICAgaWYgKHRoaXMubGFzdE5lZWQpIHsKICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7CiAgICAgICAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoInV0ZjE2bGUiLCAwLCBlbmQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkgewogICAgICAgIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7CiAgICAgICAgaWYgKG4gPT09IDApCiAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCJiYXNlNjQiLCBpKTsKICAgICAgICB0aGlzLmxhc3ROZWVkID0gMyAtIG47CiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSAzOwogICAgICAgIGlmIChuID09PSAxKSB7CiAgICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07CiAgICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygiYmFzZTY0IiwgaSwgYnVmLmxlbmd0aCAtIG4pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHsKICAgICAgICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogIiI7CiAgICAgICAgaWYgKHRoaXMubGFzdE5lZWQpCiAgICAgICAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoImJhc2U2NCIsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTsKICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHsKICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHsKICAgICAgICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAiIjsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMKICB2YXIgcmVxdWlyZV9lbmRfb2Zfc3RyZWFtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFOwogICAgICBmdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlOwogICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmIChjYWxsZWQpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGNhbGxlZCA9IHRydWU7CiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHsKICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTsKICAgICAgICAgIH0KICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbm9vcCgpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7CiAgICAgICAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gImZ1bmN0aW9uIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykgewogICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTsKICAgICAgICBpZiAoIW9wdHMpCiAgICAgICAgICBvcHRzID0ge307CiAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgICAgIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlOwogICAgICAgIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlOwogICAgICAgIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoMigpIHsKICAgICAgICAgIGlmICghc3RyZWFtLndyaXRhYmxlKQogICAgICAgICAgICBvbmZpbmlzaCgpOwogICAgICAgIH07CiAgICAgICAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkOwogICAgICAgIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoMigpIHsKICAgICAgICAgIHdyaXRhYmxlID0gZmFsc2U7CiAgICAgICAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTsKICAgICAgICAgIGlmICghcmVhZGFibGUpCiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTsKICAgICAgICB9OwogICAgICAgIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkOwogICAgICAgIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kMigpIHsKICAgICAgICAgIHJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTsKICAgICAgICAgIGlmICghd3JpdGFibGUpCiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTsKICAgICAgICB9OwogICAgICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcjIoZXJyKSB7CiAgICAgICAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTsKICAgICAgICB9OwogICAgICAgIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZTIoKSB7CiAgICAgICAgICB2YXIgZXJyOwogICAgICAgICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7CiAgICAgICAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpCiAgICAgICAgICAgICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkgewogICAgICAgICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKQogICAgICAgICAgICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpOwogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0MigpIHsKICAgICAgICAgIHN0cmVhbS5yZXEub24oImZpbmlzaCIsIG9uZmluaXNoKTsKICAgICAgICB9OwogICAgICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgewogICAgICAgICAgc3RyZWFtLm9uKCJjb21wbGV0ZSIsIG9uZmluaXNoKTsKICAgICAgICAgIHN0cmVhbS5vbigiYWJvcnQiLCBvbmNsb3NlKTsKICAgICAgICAgIGlmIChzdHJlYW0ucmVxKQogICAgICAgICAgICBvbnJlcXVlc3QoKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgc3RyZWFtLm9uKCJyZXF1ZXN0Iiwgb25yZXF1ZXN0KTsKICAgICAgICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgIHN0cmVhbS5vbigiZW5kIiwgb25sZWdhY3lmaW5pc2gpOwogICAgICAgICAgc3RyZWFtLm9uKCJjbG9zZSIsIG9ubGVnYWN5ZmluaXNoKTsKICAgICAgICB9CiAgICAgICAgc3RyZWFtLm9uKCJlbmQiLCBvbmVuZCk7CiAgICAgICAgc3RyZWFtLm9uKCJmaW5pc2giLCBvbmZpbmlzaCk7CiAgICAgICAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKQogICAgICAgICAgc3RyZWFtLm9uKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgIHN0cmVhbS5vbigiY2xvc2UiLCBvbmNsb3NlKTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoImNvbXBsZXRlIiwgb25maW5pc2gpOwogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJhYm9ydCIsIG9uY2xvc2UpOwogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJyZXF1ZXN0Iiwgb25yZXF1ZXN0KTsKICAgICAgICAgIGlmIChzdHJlYW0ucmVxKQogICAgICAgICAgICBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCJmaW5pc2giLCBvbmZpbmlzaCk7CiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoImVuZCIsIG9ubGVnYWN5ZmluaXNoKTsKICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBvbmxlZ2FjeWZpbmlzaCk7CiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoImZpbmlzaCIsIG9uZmluaXNoKTsKICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigiZW5kIiwgb25lbmQpOwogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJjbG9zZSIsIG9uY2xvc2UpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gZW9zOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfYXN5bmNfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTzsKICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgewogICAgICAgIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7CiAgICAgICAgaWYgKGtleSBpbiBvYmopIHsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsKICAgICAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgInN0cmluZyIpOwogICAgICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAic3ltYm9sIiA/IGtleSA6IFN0cmluZyhrZXkpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgewogICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICJvYmplY3QiIHx8IGlucHV0ID09PSBudWxsKQogICAgICAgICAgcmV0dXJuIGlucHV0OwogICAgICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsKICAgICAgICBpZiAocHJpbSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8ICJkZWZhdWx0Iik7CiAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gIm9iamVjdCIpCiAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLiIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gKGhpbnQgPT09ICJzdHJpbmciID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7CiAgICAgIH0KICAgICAgdmFyIGZpbmlzaGVkID0gcmVxdWlyZV9lbmRfb2Zfc3RyZWFtKCk7CiAgICAgIHZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woImxhc3RSZXNvbHZlIik7CiAgICAgIHZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgibGFzdFJlamVjdCIpOwogICAgICB2YXIga0Vycm9yID0gU3ltYm9sKCJlcnJvciIpOwogICAgICB2YXIga0VuZGVkID0gU3ltYm9sKCJlbmRlZCIpOwogICAgICB2YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCJsYXN0UHJvbWlzZSIpOwogICAgICB2YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woImhhbmRsZVByb21pc2UiKTsKICAgICAgdmFyIGtTdHJlYW0gPSBTeW1ib2woInN0cmVhbSIpOwogICAgICBmdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHZhbHVlLAogICAgICAgICAgZG9uZQogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikgewogICAgICAgIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdOwogICAgICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7CiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOwogICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHsKICAgICAgICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDsKICAgICAgICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDsKICAgICAgICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsOwogICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7CiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICBpZiAoaXRlcltrRW5kZWRdKSB7CiAgICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpOwogICAgICAgICAgfSwgcmVqZWN0KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIHZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKCkgewogICAgICB9KTsKICAgICAgdmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0gewogICAgICAgIGdldCBzdHJlYW0oKSB7CiAgICAgICAgICByZXR1cm4gdGhpc1trU3RyZWFtXTsKICAgICAgICB9LAogICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICAgICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdOwogICAgICAgICAgaWYgKGVycm9yICE9PSBudWxsKSB7CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpc1trRW5kZWRdKSB7CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7CiAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07CiAgICAgICAgICB2YXIgcHJvbWlzZTsKICAgICAgICAgIGlmIChsYXN0UHJvbWlzZSkgewogICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7CiAgICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7CiAgICAgICAgICByZXR1cm4gcHJvbWlzZTsKICAgICAgICB9CiAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sICJyZXR1cm4iLCBmdW5jdGlvbiBfcmV0dXJuKCkgewogICAgICAgIHZhciBfdGhpczIgPSB0aGlzOwogICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGVycik7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpKTsKICAgICAgICAgIH0pOwogICAgICAgIH0pOwogICAgICB9KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7CiAgICAgIHZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IyKHN0cmVhbSkgewogICAgICAgIHZhciBfT2JqZWN0JGNyZWF0ZTsKICAgICAgICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwgewogICAgICAgICAgdmFsdWU6IHN0cmVhbSwKICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7CiAgICAgICAgICB2YWx1ZTogbnVsbCwKICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHsKICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHsKICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHsKICAgICAgICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCwKICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHsKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7CiAgICAgICAgICAgIGlmIChkYXRhKSB7CiAgICAgICAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7CiAgICAgICAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7CiAgICAgICAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDsKICAgICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgIH0pLCBfT2JqZWN0JGNyZWF0ZSkpOwogICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsOwogICAgICAgIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UiKSB7CiAgICAgICAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07CiAgICAgICAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsOwogICAgICAgICAgICAgIHJlamVjdChlcnIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTsKICAgICAgICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7CiAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsOwogICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDsKICAgICAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDsKICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpOwogICAgICAgICAgfQogICAgICAgICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7CiAgICAgICAgfSk7CiAgICAgICAgc3RyZWFtLm9uKCJyZWFkYWJsZSIsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpOwogICAgICAgIHJldHVybiBpdGVyYXRvcjsKICAgICAgfTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2Zyb21fYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS1icm93c2VyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyIik7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fcmVhZGFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gUmVhZGFibGU7CiAgICAgIHZhciBEdXBsZXg7CiAgICAgIFJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlOwogICAgICB2YXIgRUUgPSByZXF1aXJlX2V2ZW50cygpLkV2ZW50RW1pdHRlcjsKICAgICAgdmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudDIoZW1pdHRlciwgdHlwZSkgewogICAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7CiAgICAgIH07CiAgICAgIHZhciBTdHJlYW0gPSByZXF1aXJlX3N0cmVhbV9icm93c2VyKCk7CiAgICAgIHZhciBCdWZmZXIxMCA9IHJlcXVpcmVfYnVmZmVyKCkuQnVmZmVyOwogICAgICB2YXIgT3VyVWludDhBcnJheSA9ICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHt9KS5VaW50OEFycmF5IHx8IGZ1bmN0aW9uKCkgewogICAgICB9OwogICAgICBmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmZyb20oY2h1bmspOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTsKICAgICAgfQogICAgICB2YXIgZGVidWdVdGlsID0gcmVxdWlyZV91dGlsKCk7CiAgICAgIHZhciBkZWJ1ZzsKICAgICAgaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHsKICAgICAgICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygic3RyZWFtIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZzIoKSB7CiAgICAgICAgfTsKICAgICAgfQogICAgICB2YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmVfYnVmZmVyX2xpc3QoKTsKICAgICAgdmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZV9kZXN0cm95KCk7CiAgICAgIHZhciBfcmVxdWlyZSA9IHJlcXVpcmVfc3RhdGUoKTsKICAgICAgdmFyIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrOwogICAgICB2YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlX2Vycm9yc19icm93c2VyKCkuY29kZXM7CiAgICAgIHZhciBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOwogICAgICB2YXIgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0Y7CiAgICAgIHZhciBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEOwogICAgICB2YXIgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7CiAgICAgIHZhciBTdHJpbmdEZWNvZGVyOwogICAgICB2YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOwogICAgICB2YXIgZnJvbTsKICAgICAgcmVxdWlyZV9pbmhlcml0c19icm93c2VyKCkoUmVhZGFibGUsIFN0cmVhbSk7CiAgICAgIHZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95OwogICAgICB2YXIga1Byb3h5RXZlbnRzID0gWyJlcnJvciIsICJjbG9zZSIsICJkZXN0cm95IiwgInBhdXNlIiwgInJlc3VtZSJdOwogICAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOwogICAgICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKQogICAgICAgICAgZW1pdHRlci5vbihldmVudCwgZm4pOwogICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpCiAgICAgICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pOwogICAgICAgIGVsc2UKICAgICAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkgewogICAgICAgIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlX3N0cmVhbV9kdXBsZXgoKTsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAiYm9vbGVhbiIpCiAgICAgICAgICBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsKICAgICAgICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTsKICAgICAgICBpZiAoaXNEdXBsZXgpCiAgICAgICAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsKICAgICAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCBpc0R1cGxleCk7CiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLnBpcGVzID0gbnVsbDsKICAgICAgICB0aGlzLnBpcGVzQ291bnQgPSAwOwogICAgICAgIHRoaXMuZmxvd2luZyA9IG51bGw7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMucmVhZGluZyA9IGZhbHNlOwogICAgICAgIHRoaXMuc3luYyA9IHRydWU7CiAgICAgICAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICAgIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTsKICAgICAgICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsKICAgICAgICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OwogICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7CiAgICAgICAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAidXRmOCI7CiAgICAgICAgdGhpcy5hd2FpdERyYWluID0gMDsKICAgICAgICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7CiAgICAgICAgdGhpcy5kZWNvZGVyID0gbnVsbDsKICAgICAgICB0aGlzLmVuY29kaW5nID0gbnVsbDsKICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZykgewogICAgICAgICAgaWYgKCFTdHJpbmdEZWNvZGVyKQogICAgICAgICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZV9zdHJpbmdfZGVjb2RlcigpLlN0cmluZ0RlY29kZXI7CiAgICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTsKICAgICAgICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7CiAgICAgICAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpOwogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpCiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOwogICAgICAgIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7CiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsKICAgICAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTsKICAgICAgICBpZiAob3B0aW9ucykgewogICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTsKICAgICAgICB9CiAgICAgICAgU3RyZWFtLmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgImRlc3Ryb3llZCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB2b2lkIDApIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkOwogICAgICAgIH0sCiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHsKICAgICAgICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTsKICAgICAgUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKGVyciwgY2IpIHsKICAgICAgICBjYihlcnIpOwogICAgICB9OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHNraXBDaHVua0NoZWNrOwogICAgICAgIGlmICghc3RhdGUub2JqZWN0TW9kZSkgewogICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHsKICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlcjEwLmZyb20oY2h1bmssIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9ICIiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7CiAgICAgIH07CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpOwogICAgICB9OwogICAgICBmdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykgewogICAgICAgIGRlYnVnKCJyZWFkYWJsZUFkZENodW5rIiwgY2h1bmspOwogICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHsKICAgICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKICAgICAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBlcjsKICAgICAgICAgIGlmICghc2tpcENodW5rQ2hlY2spCiAgICAgICAgICAgIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7CiAgICAgICAgICBpZiAoZXIpIHsKICAgICAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7CiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkgewogICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAic3RyaW5nIiAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIxMC5wcm90b3R5cGUpIHsKICAgICAgICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChhZGRUb0Zyb250KSB7CiAgICAgICAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpCiAgICAgICAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpOwogICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkgewogICAgICAgICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHsKICAgICAgICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApCiAgICAgICAgICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7CiAgICAgICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7CiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7CiAgICAgICAgICBzdGF0ZS5hd2FpdERyYWluID0gMDsKICAgICAgICAgIHN0cmVhbS5lbWl0KCJkYXRhIiwgY2h1bmspOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkKICAgICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7CiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKQogICAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTsKICAgICAgICB9CiAgICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7CiAgICAgICAgdmFyIGVyOwogICAgICAgIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAic3RyaW5nIiAmJiBjaHVuayAhPT0gdm9pZCAwICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7CiAgICAgICAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgiY2h1bmsiLCBbInN0cmluZyIsICJCdWZmZXIiLCAiVWludDhBcnJheSJdLCBjaHVuayk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBlcjsKICAgICAgfQogICAgICBSZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTsKICAgICAgfTsKICAgICAgUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7CiAgICAgICAgaWYgKCFTdHJpbmdEZWNvZGVyKQogICAgICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmVfc3RyaW5nX2RlY29kZXIoKS5TdHJpbmdEZWNvZGVyOwogICAgICAgIHZhciBkZWNvZGVyMiA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7CiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjI7CiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsKICAgICAgICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7CiAgICAgICAgdmFyIGNvbnRlbnQgPSAiIjsKICAgICAgICB3aGlsZSAocCAhPT0gbnVsbCkgewogICAgICAgICAgY29udGVudCArPSBkZWNvZGVyMi53cml0ZShwLmRhdGEpOwogICAgICAgICAgcCA9IHAubmV4dDsKICAgICAgICB9CiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTsKICAgICAgICBpZiAoY29udGVudCAhPT0gIiIpCiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpOwogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIHZhciBNQVhfSFdNID0gMTA3Mzc0MTgyNDsKICAgICAgZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikgewogICAgICAgIGlmIChuID49IE1BWF9IV00pIHsKICAgICAgICAgIG4gPSBNQVhfSFdNOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBuLS07CiAgICAgICAgICBuIHw9IG4gPj4+IDE7CiAgICAgICAgICBuIHw9IG4gPj4+IDI7CiAgICAgICAgICBuIHw9IG4gPj4+IDQ7CiAgICAgICAgICBuIHw9IG4gPj4+IDg7CiAgICAgICAgICBuIHw9IG4gPj4+IDE2OwogICAgICAgICAgbisrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7CiAgICAgICAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIGlmIChuICE9PSBuKSB7CiAgICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpCiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKQogICAgICAgICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pOwogICAgICAgIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkKICAgICAgICAgIHJldHVybiBuOwogICAgICAgIGlmICghc3RhdGUuZW5kZWQpIHsKICAgICAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDsKICAgICAgfQogICAgICBSZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHsKICAgICAgICBkZWJ1ZygicmVhZCIsIG4pOwogICAgICAgIG4gPSBwYXJzZUludChuLCAxMCk7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICB2YXIgbk9yaWcgPSBuOwogICAgICAgIGlmIChuICE9PSAwKQogICAgICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7CiAgICAgICAgICBkZWJ1ZygicmVhZDogZW1pdFJlYWRhYmxlIiwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7CiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKQogICAgICAgICAgICBlbmRSZWFkYWJsZSh0aGlzKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpOwogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQogICAgICAgIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsKICAgICAgICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgewogICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkKICAgICAgICAgICAgZW5kUmVhZGFibGUodGhpcyk7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CiAgICAgICAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTsKICAgICAgICBkZWJ1ZygibmVlZCByZWFkYWJsZSIsIGRvUmVhZCk7CiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgICAgICAgZG9SZWFkID0gdHJ1ZTsKICAgICAgICAgIGRlYnVnKCJsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyayIsIGRvUmVhZCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7CiAgICAgICAgICBkb1JlYWQgPSBmYWxzZTsKICAgICAgICAgIGRlYnVnKCJyZWFkaW5nIG9yIGVuZGVkIiwgZG9SZWFkKTsKICAgICAgICB9IGVsc2UgaWYgKGRvUmVhZCkgewogICAgICAgICAgZGVidWcoImRvIHJlYWQiKTsKICAgICAgICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlOwogICAgICAgICAgc3RhdGUuc3luYyA9IHRydWU7CiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKQogICAgICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICAgICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTsKICAgICAgICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsKICAgICAgICAgIGlmICghc3RhdGUucmVhZGluZykKICAgICAgICAgICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTsKICAgICAgICB9CiAgICAgICAgdmFyIHJldDsKICAgICAgICBpZiAobiA+IDApCiAgICAgICAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0ID0gbnVsbDsKICAgICAgICBpZiAocmV0ID09PSBudWxsKSB7CiAgICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyazsKICAgICAgICAgIG4gPSAwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gbjsKICAgICAgICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICBpZiAoIXN0YXRlLmVuZGVkKQogICAgICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKQogICAgICAgICAgICBlbmRSZWFkYWJsZSh0aGlzKTsKICAgICAgICB9CiAgICAgICAgaWYgKHJldCAhPT0gbnVsbCkKICAgICAgICAgIHRoaXMuZW1pdCgiZGF0YSIsIHJldCk7CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgZGVidWcoIm9uRW9mQ2h1bmsiKTsKICAgICAgICBpZiAoc3RhdGUuZW5kZWQpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIpIHsKICAgICAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CiAgICAgICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7CiAgICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKICAgICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzdGF0ZS5lbmRlZCA9IHRydWU7CiAgICAgICAgaWYgKHN0YXRlLnN5bmMpIHsKICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7CiAgICAgICAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7CiAgICAgICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkgewogICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBkZWJ1ZygiZW1pdFJlYWRhYmxlIiwgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpOwogICAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7CiAgICAgICAgICBkZWJ1ZygiZW1pdFJlYWRhYmxlIiwgc3RhdGUuZmxvd2luZyk7CiAgICAgICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlOwogICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkgewogICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBkZWJ1ZygiZW1pdFJlYWRhYmxlXyIsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7CiAgICAgICAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHsKICAgICAgICAgIHN0cmVhbS5lbWl0KCJyZWFkYWJsZSIpOwogICAgICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyazsKICAgICAgICBmbG93KHN0cmVhbSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkgewogICAgICAgICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlOwogICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHsKICAgICAgICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkgewogICAgICAgICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgIGRlYnVnKCJtYXliZVJlYWRNb3JlIHJlYWQgMCIpOwogICAgICAgICAgc3RyZWFtLnJlYWQoMCk7CiAgICAgICAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlOwogICAgICB9CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHsKICAgICAgICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoIl9yZWFkKCkiKSk7CiAgICAgIH07CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHsKICAgICAgICB2YXIgc3JjID0gdGhpczsKICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkgewogICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHN0YXRlLnBpcGVzQ291bnQgKz0gMTsKICAgICAgICBkZWJ1ZygicGlwZSBjb3VudD0lZCBvcHRzPSVqIiwgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpOwogICAgICAgIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7CiAgICAgICAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTsKICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pOwogICAgICAgIGVsc2UKICAgICAgICAgIHNyYy5vbmNlKCJlbmQiLCBlbmRGbik7CiAgICAgICAgZGVzdC5vbigidW5waXBlIiwgb251bnBpcGUpOwogICAgICAgIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7CiAgICAgICAgICBkZWJ1Zygib251bnBpcGUiKTsKICAgICAgICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7CiAgICAgICAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHsKICAgICAgICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlOwogICAgICAgICAgICAgIGNsZWFudXAoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgICAgICAgIGRlYnVnKCJvbmVuZCIpOwogICAgICAgICAgZGVzdC5lbmQoKTsKICAgICAgICB9CiAgICAgICAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpOwogICAgICAgIGRlc3Qub24oImRyYWluIiwgb25kcmFpbik7CiAgICAgICAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlOwogICAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7CiAgICAgICAgICBkZWJ1ZygiY2xlYW51cCIpOwogICAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBvbmNsb3NlKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoImZpbmlzaCIsIG9uZmluaXNoKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoImRyYWluIiwgb25kcmFpbik7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigidW5waXBlIiwgb251bnBpcGUpOwogICAgICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCBvbmVuZCk7CiAgICAgICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoImVuZCIsIHVucGlwZSk7CiAgICAgICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoImRhdGEiLCBvbmRhdGEpOwogICAgICAgICAgY2xlYW5lZFVwID0gdHJ1ZTsKICAgICAgICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpCiAgICAgICAgICAgIG9uZHJhaW4oKTsKICAgICAgICB9CiAgICAgICAgc3JjLm9uKCJkYXRhIiwgb25kYXRhKTsKICAgICAgICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHsKICAgICAgICAgIGRlYnVnKCJvbmRhdGEiKTsKICAgICAgICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTsKICAgICAgICAgIGRlYnVnKCJkZXN0LndyaXRlIiwgcmV0KTsKICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHsKICAgICAgICAgICAgICBkZWJ1ZygiZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlIiwgc3RhdGUuYXdhaXREcmFpbik7CiAgICAgICAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNyYy5wYXVzZSgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7CiAgICAgICAgICBkZWJ1Zygib25lcnJvciIsIGVyKTsKICAgICAgICAgIHVucGlwZSgpOwogICAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigiZXJyb3IiLCBvbmVycm9yKTsKICAgICAgICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgImVycm9yIikgPT09IDApCiAgICAgICAgICAgIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTsKICAgICAgICB9CiAgICAgICAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJmaW5pc2giLCBvbmZpbmlzaCk7CiAgICAgICAgICB1bnBpcGUoKTsKICAgICAgICB9CiAgICAgICAgZGVzdC5vbmNlKCJjbG9zZSIsIG9uY2xvc2UpOwogICAgICAgIGZ1bmN0aW9uIG9uZmluaXNoKCkgewogICAgICAgICAgZGVidWcoIm9uZmluaXNoIik7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJjbG9zZSIsIG9uY2xvc2UpOwogICAgICAgICAgdW5waXBlKCk7CiAgICAgICAgfQogICAgICAgIGRlc3Qub25jZSgiZmluaXNoIiwgb25maW5pc2gpOwogICAgICAgIGZ1bmN0aW9uIHVucGlwZSgpIHsKICAgICAgICAgIGRlYnVnKCJ1bnBpcGUiKTsKICAgICAgICAgIHNyYy51bnBpcGUoZGVzdCk7CiAgICAgICAgfQogICAgICAgIGRlc3QuZW1pdCgicGlwZSIsIHNyYyk7CiAgICAgICAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7CiAgICAgICAgICBkZWJ1ZygicGlwZSByZXN1bWUiKTsKICAgICAgICAgIHNyYy5yZXN1bWUoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlc3Q7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykgewogICAgICAgIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkgewogICAgICAgICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlOwogICAgICAgICAgZGVidWcoInBpcGVPbkRyYWluIiwgc3RhdGUuYXdhaXREcmFpbik7CiAgICAgICAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikKICAgICAgICAgICAgc3RhdGUuYXdhaXREcmFpbi0tOwogICAgICAgICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgImRhdGEiKSkgewogICAgICAgICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsKICAgICAgICAgICAgZmxvdyhzcmMpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHsKICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIHZhciB1bnBpcGVJbmZvID0gewogICAgICAgICAgaGFzVW5waXBlZDogZmFsc2UKICAgICAgICB9OwogICAgICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHsKICAgICAgICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKQogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIGlmICghZGVzdCkKICAgICAgICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzOwogICAgICAgICAgc3RhdGUucGlwZXMgPSBudWxsOwogICAgICAgICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CiAgICAgICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7CiAgICAgICAgICBpZiAoZGVzdCkKICAgICAgICAgICAgZGVzdC5lbWl0KCJ1bnBpcGUiLCB0aGlzLCB1bnBpcGVJbmZvKTsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBpZiAoIWRlc3QpIHsKICAgICAgICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzOwogICAgICAgICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7CiAgICAgICAgICBzdGF0ZS5waXBlcyA9IG51bGw7CiAgICAgICAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDsKICAgICAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspCiAgICAgICAgICAgIGRlc3RzW2ldLmVtaXQoInVucGlwZSIsIHRoaXMsIHsKICAgICAgICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZQogICAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTsKICAgICAgICBpZiAoaW5kZXggPT09IC0xKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgICBzdGF0ZS5waXBlc0NvdW50IC09IDE7CiAgICAgICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpCiAgICAgICAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdOwogICAgICAgIGRlc3QuZW1pdCgidW5waXBlIiwgdGhpcywgdW5waXBlSW5mbyk7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikgewogICAgICAgIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTsKICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIGlmIChldiA9PT0gImRhdGEiKSB7CiAgICAgICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgicmVhZGFibGUiKSA+IDA7CiAgICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpCiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7CiAgICAgICAgfSBlbHNlIGlmIChldiA9PT0gInJlYWRhYmxlIikgewogICAgICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykgewogICAgICAgICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAgICAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKICAgICAgICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgICAgIGRlYnVnKCJvbiByZWFkYWJsZSIsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7CiAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH07CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjsKICAgICAgUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXYsIGZuKSB7CiAgICAgICAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pOwogICAgICAgIGlmIChldiA9PT0gInJlYWRhYmxlIikgewogICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH07CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldikgewogICAgICAgIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgIGlmIChldiA9PT0gInJlYWRhYmxlIiB8fCBldiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZjIpIHsKICAgICAgICB2YXIgc3RhdGUgPSBzZWxmMi5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYyLmxpc3RlbmVyQ291bnQoInJlYWRhYmxlIikgPiAwOwogICAgICAgIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkgewogICAgICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7CiAgICAgICAgfSBlbHNlIGlmIChzZWxmMi5saXN0ZW5lckNvdW50KCJkYXRhIikgPiAwKSB7CiAgICAgICAgICBzZWxmMi5yZXN1bWUoKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmMikgewogICAgICAgIGRlYnVnKCJyZWFkYWJsZSBuZXh0dGljayByZWFkIDAiKTsKICAgICAgICBzZWxmMi5yZWFkKDApOwogICAgICB9CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIGlmICghc3RhdGUuZmxvd2luZykgewogICAgICAgICAgZGVidWcoInJlc3VtZSIpOwogICAgICAgICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZzsKICAgICAgICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7CiAgICAgICAgfQogICAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBmdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7CiAgICAgICAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlOwogICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgZGVidWcoInJlc3VtZSIsIHN0YXRlLnJlYWRpbmcpOwogICAgICAgIGlmICghc3RhdGUucmVhZGluZykgewogICAgICAgICAgc3RyZWFtLnJlYWQoMCk7CiAgICAgICAgfQogICAgICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgIHN0cmVhbS5lbWl0KCJyZXN1bWUiKTsKICAgICAgICBmbG93KHN0cmVhbSk7CiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpCiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTsKICAgICAgfQogICAgICBSZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHsKICAgICAgICBkZWJ1ZygiY2FsbCBwYXVzZSBmbG93aW5nPSVqIiwgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTsKICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgewogICAgICAgICAgZGVidWcoInBhdXNlIik7CiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKICAgICAgICAgIHRoaXMuZW1pdCgicGF1c2UiKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBmdW5jdGlvbiBmbG93KHN0cmVhbSkgewogICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBkZWJ1ZygiZmxvdyIsIHN0YXRlLmZsb3dpbmcpOwogICAgICAgIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpCiAgICAgICAgICA7CiAgICAgIH0KICAgICAgUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHsKICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHBhdXNlZCA9IGZhbHNlOwogICAgICAgIHN0cmVhbS5vbigiZW5kIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICBkZWJ1Zygid3JhcHBlZCBlbmQiKTsKICAgICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkgewogICAgICAgICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpOwogICAgICAgICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKQogICAgICAgICAgICAgIF90aGlzLnB1c2goY2h1bmspOwogICAgICAgICAgfQogICAgICAgICAgX3RoaXMucHVzaChudWxsKTsKICAgICAgICB9KTsKICAgICAgICBzdHJlYW0ub24oImRhdGEiLCBmdW5jdGlvbihjaHVuaykgewogICAgICAgICAgZGVidWcoIndyYXBwZWQgZGF0YSIpOwogICAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIpCiAgICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7CiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHZvaWQgMCkpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTsKICAgICAgICAgIGlmICghcmV0KSB7CiAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7CiAgICAgICAgICAgIHN0cmVhbS5wYXVzZSgpOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7CiAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdm9pZCAwICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfShpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHsKICAgICAgICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpOwogICAgICAgIH0KICAgICAgICB0aGlzLl9yZWFkID0gZnVuY3Rpb24objIpIHsKICAgICAgICAgIGRlYnVnKCJ3cmFwcGVkIF9yZWFkIiwgbjIpOwogICAgICAgICAgaWYgKHBhdXNlZCkgewogICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTsKICAgICAgICAgICAgc3RyZWFtLnJlc3VtZSgpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmVfYXN5bmNfaXRlcmF0b3IoKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyazsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAicmVhZGFibGVCdWZmZXIiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAicmVhZGFibGVGbG93aW5nIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZzsKICAgICAgICB9LAogICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7CiAgICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOwogICAgICBSZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgInJlYWRhYmxlTGVuZ3RoIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7CiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUpCiAgICAgICAgICByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTsKICAgICAgICBlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIpCiAgICAgICAgICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCIiKTsKICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpCiAgICAgICAgICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7CiAgICAgICAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7CiAgICAgICAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIGRlYnVnKCJlbmRSZWFkYWJsZSIsIHN0YXRlLmVuZEVtaXR0ZWQpOwogICAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCkgewogICAgICAgICAgc3RhdGUuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7CiAgICAgICAgZGVidWcoImVuZFJlYWRhYmxlTlQiLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOwogICAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHsKICAgICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlOwogICAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgICBzdHJlYW0uZW1pdCgiZW5kIik7CiAgICAgICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHsKICAgICAgICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKICAgICAgICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkgewogICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24oaXRlcmFibGUsIG9wdHMpIHsKICAgICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsKICAgICAgICAgICAgZnJvbSA9IHJlcXVpcmVfZnJvbV9icm93c2VyKCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5kZXhPZih4cywgeCkgewogICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICBpZiAoeHNbaV0gPT09IHgpCiAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBUcmFuc2Zvcm0yOwogICAgICB2YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlX2Vycm9yc19icm93c2VyKCkuY29kZXM7CiAgICAgIHZhciBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEOwogICAgICB2YXIgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLOwogICAgICB2YXIgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkc7CiAgICAgIHZhciBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7CiAgICAgIHZhciBEdXBsZXggPSByZXF1aXJlX3N0cmVhbV9kdXBsZXgoKTsKICAgICAgcmVxdWlyZV9pbmhlcml0c19icm93c2VyKCkoVHJhbnNmb3JtMiwgRHVwbGV4KTsKICAgICAgZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHsKICAgICAgICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTsKICAgICAgICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTsKICAgICAgICB2YXIgY2IgPSB0cy53cml0ZWNiOwogICAgICAgIGlmIChjYiA9PT0gbnVsbCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgiZXJyb3IiLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpOwogICAgICAgIH0KICAgICAgICB0cy53cml0ZWNodW5rID0gbnVsbDsKICAgICAgICB0cy53cml0ZWNiID0gbnVsbDsKICAgICAgICBpZiAoZGF0YSAhPSBudWxsKQogICAgICAgICAgdGhpcy5wdXNoKGRhdGEpOwogICAgICAgIGNiKGVyKTsKICAgICAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIHJzLnJlYWRpbmcgPSBmYWxzZTsKICAgICAgICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHsKICAgICAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybTIob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0yKSkKICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtMihvcHRpb25zKTsKICAgICAgICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTsKICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHsKICAgICAgICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLAogICAgICAgICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsCiAgICAgICAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLAogICAgICAgICAgd3JpdGVjYjogbnVsbCwKICAgICAgICAgIHdyaXRlY2h1bms6IG51bGwsCiAgICAgICAgICB3cml0ZWVuY29kaW5nOiBudWxsCiAgICAgICAgfTsKICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7CiAgICAgICAgaWYgKG9wdGlvbnMpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtOwogICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAiZnVuY3Rpb24iKQogICAgICAgICAgICB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7CiAgICAgICAgfQogICAgICAgIHRoaXMub24oInByZWZpbmlzaCIsIHByZWZpbmlzaCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHJlZmluaXNoKCkgewogICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gImZ1bmN0aW9uIiAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHsKICAgICAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyLCBkYXRhKSB7CiAgICAgICAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTsKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpOwogICAgICAgIH0KICAgICAgfQogICAgICBUcmFuc2Zvcm0yLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7CiAgICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlOwogICAgICAgIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpOwogICAgICB9OwogICAgICBUcmFuc2Zvcm0yLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikgewogICAgICAgIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgiX3RyYW5zZm9ybSgpIikpOwogICAgICB9OwogICAgICBUcmFuc2Zvcm0yLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CiAgICAgICAgdHMud3JpdGVjYiA9IGNiOwogICAgICAgIHRzLndyaXRlY2h1bmsgPSBjaHVuazsKICAgICAgICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7CiAgICAgICAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHsKICAgICAgICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykKICAgICAgICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIFRyYW5zZm9ybTIucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikgewogICAgICAgIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwogICAgICAgIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHsKICAgICAgICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7CiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIFRyYW5zZm9ybTIucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oZXJyLCBjYikgewogICAgICAgIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uKGVycjIpIHsKICAgICAgICAgIGNiKGVycjIpOwogICAgICAgIH0pOwogICAgICB9OwogICAgICBmdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHsKICAgICAgICBpZiAoZXIpCiAgICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoImVycm9yIiwgZXIpOwogICAgICAgIGlmIChkYXRhICE9IG51bGwpCiAgICAgICAgICBzdHJlYW0ucHVzaChkYXRhKTsKICAgICAgICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTsKICAgICAgICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpCiAgICAgICAgICB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpOwogICAgICAgIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzCiAgdmFyIHJlcXVpcmVfc3RyZWFtX3Bhc3N0aHJvdWdoID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFBhc3NUaHJvdWdoOwogICAgICB2YXIgVHJhbnNmb3JtMiA9IHJlcXVpcmVfc3RyZWFtX3RyYW5zZm9ybSgpOwogICAgICByZXF1aXJlX2luaGVyaXRzX2Jyb3dzZXIoKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtMik7CiAgICAgIGZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKQogICAgICAgICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTsKICAgICAgICBUcmFuc2Zvcm0yLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgY2IobnVsbCwgY2h1bmspOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzCiAgdmFyIHJlcXVpcmVfcGlwZWxpbmUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGVvczsKICAgICAgZnVuY3Rpb24gb25jZShjYWxsYmFjaykgewogICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoY2FsbGVkKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICBjYWxsZWQgPSB0cnVlOwogICAgICAgICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgdmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzOwogICAgICB2YXIgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7CiAgICAgIHZhciBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEOwogICAgICBmdW5jdGlvbiBub29wKGVycikgewogICAgICAgIGlmIChlcnIpCiAgICAgICAgICB0aHJvdyBlcnI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkgewogICAgICAgIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spOwogICAgICAgIHZhciBjbG9zZWQgPSBmYWxzZTsKICAgICAgICBzdHJlYW0ub24oImNsb3NlIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICBjbG9zZWQgPSB0cnVlOwogICAgICAgIH0pOwogICAgICAgIGlmIChlb3MgPT09IHZvaWQgMCkKICAgICAgICAgIGVvcyA9IHJlcXVpcmVfZW5kX29mX3N0cmVhbSgpOwogICAgICAgIGVvcyhzdHJlYW0sIHsKICAgICAgICAgIHJlYWRhYmxlOiByZWFkaW5nLAogICAgICAgICAgd3JpdGFibGU6IHdyaXRpbmcKICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgIGlmIChlcnIpCiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgY2xvc2VkID0gdHJ1ZTsKICAgICAgICAgIGNhbGxiYWNrKCk7CiAgICAgICAgfSk7CiAgICAgICAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlOwogICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgIGlmIChjbG9zZWQpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGlmIChkZXN0cm95ZWQpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGRlc3Ryb3llZCA9IHRydWU7CiAgICAgICAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpCiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uYWJvcnQoKTsKICAgICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uZGVzdHJveSgpOwogICAgICAgICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgicGlwZSIpKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNhbGwoZm4pIHsKICAgICAgICBmbigpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHsKICAgICAgICByZXR1cm4gZnJvbS5waXBlKHRvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7CiAgICAgICAgaWYgKCFzdHJlYW1zLmxlbmd0aCkKICAgICAgICAgIHJldHVybiBub29wOwogICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAiZnVuY3Rpb24iKQogICAgICAgICAgcmV0dXJuIG5vb3A7CiAgICAgICAgcmV0dXJuIHN0cmVhbXMucG9wKCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcGlwZWxpbmUoKSB7CiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7CiAgICAgICAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldOwogICAgICAgIH0KICAgICAgICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkKICAgICAgICAgIHN0cmVhbXMgPSBzdHJlYW1zWzBdOwogICAgICAgIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHsKICAgICAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCJzdHJlYW1zIik7CiAgICAgICAgfQogICAgICAgIHZhciBlcnJvcjsKICAgICAgICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbihzdHJlYW0sIGkpIHsKICAgICAgICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTsKICAgICAgICAgIHZhciB3cml0aW5nID0gaSA+IDA7CiAgICAgICAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgIGlmICghZXJyb3IpCiAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7CiAgICAgICAgICAgIGlmIChlcnIpCiAgICAgICAgICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTsKICAgICAgICAgICAgaWYgKHJlYWRpbmcpCiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpOwogICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gcGlwZWxpbmU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcwogIHZhciByZXF1aXJlX3N0cmVhbV9icm93c2VyaWZ5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFN0cmVhbTsKICAgICAgdmFyIEVFID0gcmVxdWlyZV9ldmVudHMoKS5FdmVudEVtaXR0ZXI7CiAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmVfaW5oZXJpdHNfYnJvd3NlcigpOwogICAgICBpbmhlcml0cyhTdHJlYW0sIEVFKTsKICAgICAgU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZV9zdHJlYW1fcmVhZGFibGUoKTsKICAgICAgU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZV9zdHJlYW1fd3JpdGFibGUoKTsKICAgICAgU3RyZWFtLkR1cGxleCA9IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpOwogICAgICBTdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtKCk7CiAgICAgIFN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmVfc3RyZWFtX3Bhc3N0aHJvdWdoKCk7CiAgICAgIFN0cmVhbS5maW5pc2hlZCA9IHJlcXVpcmVfZW5kX29mX3N0cmVhbSgpOwogICAgICBTdHJlYW0ucGlwZWxpbmUgPSByZXF1aXJlX3BpcGVsaW5lKCk7CiAgICAgIFN0cmVhbS5TdHJlYW0gPSBTdHJlYW07CiAgICAgIGZ1bmN0aW9uIFN0cmVhbSgpIHsKICAgICAgICBFRS5jYWxsKHRoaXMpOwogICAgICB9CiAgICAgIFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgc291cmNlID0gdGhpczsKICAgICAgICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHsKICAgICAgICAgIGlmIChkZXN0LndyaXRhYmxlKSB7CiAgICAgICAgICAgIGlmIChkZXN0LndyaXRlKGNodW5rKSA9PT0gZmFsc2UgJiYgc291cmNlLnBhdXNlKSB7CiAgICAgICAgICAgICAgc291cmNlLnBhdXNlKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc291cmNlLm9uKCJkYXRhIiwgb25kYXRhKTsKICAgICAgICBmdW5jdGlvbiBvbmRyYWluKCkgewogICAgICAgICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7CiAgICAgICAgICAgIHNvdXJjZS5yZXN1bWUoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVzdC5vbigiZHJhaW4iLCBvbmRyYWluKTsKICAgICAgICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHsKICAgICAgICAgIHNvdXJjZS5vbigiZW5kIiwgb25lbmQpOwogICAgICAgICAgc291cmNlLm9uKCJjbG9zZSIsIG9uY2xvc2UpOwogICAgICAgIH0KICAgICAgICB2YXIgZGlkT25FbmQgPSBmYWxzZTsKICAgICAgICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgICAgICAgIGlmIChkaWRPbkVuZCkKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgZGlkT25FbmQgPSB0cnVlOwogICAgICAgICAgZGVzdC5lbmQoKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb25jbG9zZSgpIHsKICAgICAgICAgIGlmIChkaWRPbkVuZCkKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgZGlkT25FbmQgPSB0cnVlOwogICAgICAgICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIGRlc3QuZGVzdHJveSgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7CiAgICAgICAgICBjbGVhbnVwKCk7CiAgICAgICAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAiZXJyb3IiKSA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBlcjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc291cmNlLm9uKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgIGRlc3Qub24oImVycm9yIiwgb25lcnJvcik7CiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgICAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcigiZGF0YSIsIG9uZGF0YSk7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJkcmFpbiIsIG9uZHJhaW4pOwogICAgICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCBvbmVuZCk7CiAgICAgICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgb25jbG9zZSk7CiAgICAgICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoImVycm9yIiwgb25lcnJvcik7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCBjbGVhbnVwKTsKICAgICAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBjbGVhbnVwKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgY2xlYW51cCk7CiAgICAgICAgfQogICAgICAgIHNvdXJjZS5vbigiZW5kIiwgY2xlYW51cCk7CiAgICAgICAgc291cmNlLm9uKCJjbG9zZSIsIGNsZWFudXApOwogICAgICAgIGRlc3Qub24oImNsb3NlIiwgY2xlYW51cCk7CiAgICAgICAgZGVzdC5lbWl0KCJwaXBlIiwgc291cmNlKTsKICAgICAgICByZXR1cm4gZGVzdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pc19vYnNlcnZhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSAodmFsdWUpID0+IHsKICAgICAgICBpZiAoIXZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sLm9ic2VydmFibGUgPT09ICJzeW1ib2wiICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWVbIkBAb2JzZXJ2YWJsZSJdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlWyJAQG9ic2VydmFibGUiXSgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMKICB2YXIgcmVxdWlyZV9zZXJpYWxpemVycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuRGVmYXVsdFNlcmlhbGl6ZXIgPSBleHBvcnRzMi5leHRlbmRTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICBmdW5jdGlvbiBleHRlbmRTZXJpYWxpemVyKGV4dGVuZCwgaW1wbGVtZW50YXRpb24pIHsKICAgICAgICBjb25zdCBmYWxsYmFja0Rlc2VyaWFsaXplciA9IGV4dGVuZC5kZXNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgY29uc3QgZmFsbGJhY2tTZXJpYWxpemVyID0gZXh0ZW5kLnNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLmRlc2VyaWFsaXplKG1lc3NhZ2UsIGZhbGxiYWNrRGVzZXJpYWxpemVyKTsKICAgICAgICAgIH0sCiAgICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLnNlcmlhbGl6ZShpbnB1dCwgZmFsbGJhY2tTZXJpYWxpemVyKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4dGVuZFNlcmlhbGl6ZXIgPSBleHRlbmRTZXJpYWxpemVyOwogICAgICB2YXIgRGVmYXVsdEVycm9yU2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihFcnJvcihtZXNzYWdlLm1lc3NhZ2UpLCB7CiAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSwKICAgICAgICAgICAgc3RhY2s6IG1lc3NhZ2Uuc3RhY2sKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGVycm9yKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBfX2Vycm9yX21hcmtlcjogIiQkZXJyb3IiLAogICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLAogICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLAogICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2sKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgaXNTZXJpYWxpemVkRXJyb3IgPSAodGhpbmcpID0+IHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgIl9fZXJyb3JfbWFya2VyIiBpbiB0aGluZyAmJiB0aGluZy5fX2Vycm9yX21hcmtlciA9PT0gIiQkZXJyb3IiOwogICAgICBleHBvcnRzMi5EZWZhdWx0U2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkRXJyb3IobWVzc2FnZSkpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLnNlcmlhbGl6ZSA9IGV4cG9ydHMyLmRlc2VyaWFsaXplID0gZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgc2VyaWFsaXplcnNfMSA9IHJlcXVpcmVfc2VyaWFsaXplcnMoKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5EZWZhdWx0U2VyaWFsaXplcjsKICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJpYWxpemVyMihzZXJpYWxpemVyKSB7CiAgICAgICAgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLmV4dGVuZFNlcmlhbGl6ZXIocmVnaXN0ZXJlZFNlcmlhbGl6ZXIsIHNlcmlhbGl6ZXIpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHJlZ2lzdGVyU2VyaWFsaXplcjI7CiAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTsKICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuc2VyaWFsaXplID0gc2VyaWFsaXplOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMKICB2YXIgcmVxdWlyZV9zeW1ib2xzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gZXhwb3J0czIuJHRlcm1pbmF0ZSA9IGV4cG9ydHMyLiRldmVudHMgPSBleHBvcnRzMi4kZXJyb3JzID0gdm9pZCAwOwogICAgICBleHBvcnRzMi4kZXJyb3JzID0gU3ltYm9sKCJ0aHJlYWQuZXJyb3JzIik7CiAgICAgIGV4cG9ydHMyLiRldmVudHMgPSBTeW1ib2woInRocmVhZC5ldmVudHMiKTsKICAgICAgZXhwb3J0czIuJHRlcm1pbmF0ZSA9IFN5bWJvbCgidGhyZWFkLnRlcm1pbmF0ZSIpOwogICAgICBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gU3ltYm9sKCJ0aHJlYWQudHJhbnNmZXJhYmxlIik7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBTeW1ib2woInRocmVhZC53b3JrZXIiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMKICB2YXIgcmVxdWlyZV90cmFuc2ZlcmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gdm9pZCAwOwogICAgICB2YXIgc3ltYm9sc18xID0gcmVxdWlyZV9zeW1ib2xzKCk7CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKHRoaW5nKSB7CiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICJvYmplY3QiKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdGhpbmdbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gaXNUcmFuc2ZlckRlc2NyaXB0b3I7CiAgICAgIGZ1bmN0aW9uIFRyYW5zZmVyMihwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgaWYgKCF0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgICBpZiAoIWlzVHJhbnNmZXJhYmxlKHBheWxvYWQpKQogICAgICAgICAgICB0aHJvdyBFcnJvcigpOwogICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IFtwYXlsb2FkXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIFtzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV06IHRydWUsCiAgICAgICAgICBzZW5kOiBwYXlsb2FkLAogICAgICAgICAgdHJhbnNmZXJhYmxlcwogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuVHJhbnNmZXIgPSBUcmFuc2ZlcjI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgPSB2b2lkIDA7CiAgICAgIHZhciBNYXN0ZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKE1hc3Rlck1lc3NhZ2VUeXBlMikgewogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsiY2FuY2VsIl0gPSAiY2FuY2VsIjsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbInJ1biJdID0gInJ1biI7CiAgICAgIH0pKE1hc3Rlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLk1hc3Rlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgICAgdmFyIFdvcmtlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oV29ya2VyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJlcnJvciJdID0gImVycm9yIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImluaXQiXSA9ICJpbml0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJlc3VsdCJdID0gInJlc3VsdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJydW5uaW5nIl0gPSAicnVubmluZyI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJ1bmNhdWdodEVycm9yIl0gPSAidW5jYXVnaHRFcnJvciI7CiAgICAgIH0pKFdvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBpc1dvcmtlclJ1bnRpbWUgPSBmdW5jdGlvbiBpc1dvcmtlclJ1bnRpbWUyKCkgewogICAgICAgIGNvbnN0IGlzV2luZG93Q29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgV2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmIGluc3RhbmNlb2YgV2luZG93OwogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZi5wb3N0TWVzc2FnZSAmJiAhaXNXaW5kb3dDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlOwogICAgICB9OwogICAgICB2YXIgcG9zdE1lc3NhZ2VUb01hc3RlciA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlVG9NYXN0ZXIyKGRhdGEsIHRyYW5zZmVyTGlzdCkgewogICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTsKICAgICAgfTsKICAgICAgdmFyIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMgPSBmdW5jdGlvbiBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzMihvbk1lc3NhZ2UpIHsKICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlRXZlbnQuZGF0YSk7CiAgICAgICAgfTsKICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHsKICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICB9OwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSB7CiAgICAgICAgaXNXb3JrZXJSdW50aW1lLAogICAgICAgIHBvc3RNZXNzYWdlVG9NYXN0ZXIsCiAgICAgICAgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcwogIHZhciByZXF1aXJlX3dvcmtlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9fYXdhaXRlciA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9fYXdhaXRlciB8fCBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHsKICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyJ0aHJvdyJdKHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7CiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOwogICAgICAgICAgfQogICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpOwogICAgICAgIH0pOwogICAgICB9OwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5leHBvc2UgPSBleHBvcnRzMi5pc1dvcmtlclJ1bnRpbWUgPSBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIGlzX29ic2VydmFibGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2lzX29ic2VydmFibGUoKSk7CiAgICAgIHZhciBjb21tb25fMSA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzEgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICB2YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmVfbWVzc2FnZXMyKCk7CiAgICAgIHZhciBpbXBsZW1lbnRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlcigpKTsKICAgICAgdmFyIGNvbW1vbl8yID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgInJlZ2lzdGVyU2VyaWFsaXplciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gY29tbW9uXzIucmVnaXN0ZXJTZXJpYWxpemVyOwogICAgICB9IH0pOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzIgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJUcmFuc2ZlciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzIuVHJhbnNmZXI7CiAgICAgIH0gfSk7CiAgICAgIGV4cG9ydHMyLmlzV29ya2VyUnVudGltZSA9IGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWU7CiAgICAgIHZhciBleHBvc2VDYWxsZWQgPSBmYWxzZTsKICAgICAgdmFyIGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7CiAgICAgIHZhciBpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUuY2FuY2VsOwogICAgICB2YXIgaXNNYXN0ZXJKb2JSdW5NZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLnJ1bjsKICAgICAgdmFyIGlzT2JzZXJ2YWJsZSA9ICh0aGluZykgPT4gaXNfb2JzZXJ2YWJsZV8xLmRlZmF1bHQodGhpbmcpIHx8IGlzWmVuT2JzZXJ2YWJsZSh0aGluZyk7CiAgICAgIGZ1bmN0aW9uIGlzWmVuT2JzZXJ2YWJsZSh0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHR5cGVvZiB0aGluZy5zdWJzY3JpYmUgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjb25zdHJ1Y3RUcmFuc2Zlcih0aGluZykgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMS5pc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgPyB7IHBheWxvYWQ6IHRoaW5nLnNlbmQsIHRyYW5zZmVyYWJsZXM6IHRoaW5nLnRyYW5zZmVyYWJsZXMgfSA6IHsgcGF5bG9hZDogdGhpbmcsIHRyYW5zZmVyYWJsZXM6IHZvaWQgMCB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCkgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAiZnVuY3Rpb24iCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJtb2R1bGUiLAogICAgICAgICAgICBtZXRob2RzOiBtZXRob2ROYW1lcwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JFcnJvck1lc3NhZ2UodWlkLCByYXdFcnJvcikgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZDogZXJyb3IsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmF3RXJyb3IpOwogICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuZXJyb3IsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iUmVzdWx0TWVzc2FnZSh1aWQsIGNvbXBsZXRlZCwgcmVzdWx0VmFsdWUpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmVzdWx0VmFsdWUpOwogICAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJlc3VsdCwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZWQgPyB0cnVlIDogdm9pZCAwLAogICAgICAgICAgcGF5bG9hZAogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIocmVzdWx0TWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlN0YXJ0TWVzc2FnZSh1aWQsIHJlc3VsdFR5cGUpIHsKICAgICAgICBjb25zdCBzdGFydE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJ1bm5pbmcsCiAgICAgICAgICB1aWQsCiAgICAgICAgICByZXN1bHRUeXBlCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihzdGFydE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvcikgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUudW5jYXVnaHRFcnJvciwKICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICAgIH07CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UpOwogICAgICAgIH0gY2F0Y2ggKHN1YkVycm9yKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJOb3QgcmVwb3J0aW5nIHVuY2F1Z2h0IGVycm9yIGJhY2sgdG8gbWFzdGVyIHRocmVhZCBhcyBpdCBvY2N1cmVkIHdoaWxlIHJlcG9ydGluZyBhbiB1bmNhdWdodCBlcnJvciBhbHJlYWR5LlxuTGF0ZXN0IGVycm9yOiIsIHN1YkVycm9yLCAiXG5PcmlnaW5hbCBlcnJvcjoiLCBlcnJvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uKGpvYlVJRCwgZm4sIGFyZ3MpIHsKICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgewogICAgICAgICAgbGV0IHN5bmNSZXN1bHQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzeW5jUmVzdWx0ID0gZm4oLi4uYXJncyk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICByZXR1cm4gcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHJlc3VsdFR5cGUgPSBpc09ic2VydmFibGUoc3luY1Jlc3VsdCkgPyAib2JzZXJ2YWJsZSIgOiAicHJvbWlzZSI7CiAgICAgICAgICBwb3N0Sm9iU3RhcnRNZXNzYWdlKGpvYlVJRCwgcmVzdWx0VHlwZSk7CiAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpKSB7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN5bmNSZXN1bHQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4gcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCBmYWxzZSwgY29tbW9uXzEuc2VyaWFsaXplKHZhbHVlKSksIChlcnJvcikgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5zZXQoam9iVUlELCBzdWJzY3JpcHRpb24pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzeW5jUmVzdWx0OwogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSwgY29tbW9uXzEuc2VyaWFsaXplKHJlc3VsdCkpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV4cG9zZTIoZXhwb3NlZCkgewogICAgICAgIGlmICghaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIGluIHRoZSBtYXN0ZXIgdGhyZWFkLiIpOwogICAgICAgIH0KICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLiBUaGlzIGlzIG5vdCBwb3NzaWJsZS4gUGFzcyBhbiBvYmplY3QgdG8gZXhwb3NlKCkgaWYgeW91IHdhbnQgdG8gZXhwb3NlIG11bHRpcGxlIGZ1bmN0aW9ucy4iKTsKICAgICAgICB9CiAgICAgICAgZXhwb3NlQ2FsbGVkID0gdHJ1ZTsKICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiAhbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gIm9iamVjdCIgJiYgZXhwb3NlZCkgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmIG1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZFttZXNzYWdlRGF0YS5tZXRob2RdLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3NlZCkuZmlsdGVyKChrZXkpID0+IHR5cGVvZiBleHBvc2VkW2tleV0gPT09ICJmdW5jdGlvbiIpOwogICAgICAgICAgcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGV4cG9zZSgpLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCwgZ290OiAke2V4cG9zZWR9YCk7CiAgICAgICAgfQogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgaWYgKGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZShtZXNzYWdlRGF0YSkpIHsKICAgICAgICAgICAgY29uc3Qgam9iVUlEID0gbWVzc2FnZURhdGEudWlkOwogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3RpdmVTdWJzY3JpcHRpb25zLmdldChqb2JVSUQpOwogICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7CiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4cG9zZSA9IGV4cG9zZTI7CiAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHNlbGYuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShldmVudC5lcnJvciB8fCBldmVudCksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJ1bmhhbmRsZWRyZWplY3Rpb24iLCAoZXZlbnQpID0+IHsKICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQucmVhc29uOwogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHByb2Nlc3Mub24oInVuaGFuZGxlZFJlamVjdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvZ2ZmL2dmZi13b3JrZXIudHM/d29ya2VyJmlubGluZT93b3JrZXJfZmlsZQogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZXNtKCkpOwogIHZhciBpbXBvcnRfcXVpY2tfbHJ1ID0gX190b01vZHVsZShyZXF1aXJlX3F1aWNrX2xydSgpKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjcgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvY2FsRmlsZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb2NhbEZpbGUoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL3JlbW90ZUZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICB2YXIgbXlHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB7IGZldGNoOiB2b2lkIDAgfTsKICB2YXIgUmVtb3RlRmlsZSA9IGNsYXNzIHsKICAgIGFzeW5jIGdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSkgewogICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIHJldHVybiByZXNwb25zZS5idWZmZXIoKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuYXJyYXlCdWZmZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICByZXR1cm4gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmZyb20ocmVzcCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgaGFzIG5vIGJ1ZmZlciBtZXRob2QsIGFuZCBubyBhcnJheUJ1ZmZlciBtZXRob2QiKTsKICAgICAgfQogICAgfQogICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRzID0ge30pIHsKICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0ge307CiAgICAgIHRoaXMudXJsID0gc291cmNlOwogICAgICBjb25zdCBmZXRjaCA9IG9wdHMuZmV0Y2ggfHwgbXlHbG9iYWwuZmV0Y2ggJiYgbXlHbG9iYWwuZmV0Y2guYmluZChteUdsb2JhbCk7CiAgICAgIGlmICghZmV0Y2gpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YCk7CiAgICAgIH0KICAgICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7CiAgICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0gb3B0cy5vdmVycmlkZXM7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2g7CiAgICB9CiAgICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdDIpIHsKICAgICAgbGV0IHJlc3BvbnNlOwogICAgICB0cnkgewogICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCBpbml0Mik7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAoYCR7ZX1gLmluY2x1ZGVzKCJGYWlsZWQgdG8gZmV0Y2giKSkgewogICAgICAgICAgY29uc29sZS53YXJuKGBnZW5lcmljLWZpbGVoYW5kbGU6IHJlZmV0Y2hpbmcgJHtpbnB1dH0gdG8gYXR0ZW1wdCB0byB3b3JrIGFyb3VuZCBjaHJvbWUgQ09SUyBoZWFkZXIgY2FjaGluZyBidWdgKTsKICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCB7CiAgICAgICAgICAgIC4uLmluaXQyLAogICAgICAgICAgICBjYWNoZTogInJlbG9hZCIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICB9CiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0ID0gMCwgbGVuZ3RoLCBwb3NpdGlvbiA9IDAsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9uICsgbGVuZ3RofWA7CiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYDsKICAgICAgfQogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMsCiAgICAgICAgaGVhZGVyczogewogICAgICAgICAgLi4uaGVhZGVycywKICAgICAgICAgIC4uLm92ZXJyaWRlcy5oZWFkZXJzLAogICAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMKICAgICAgICB9LAogICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICBzaWduYWwKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke3RoaXMudXJsfWApOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikgewogICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICBjb25zdCByZXMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgiY29udGVudC1yYW5nZSIpOwogICAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cLyhcZCspJC8uZXhlYyhyZXMgfHwgIiIpOwogICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXIgfTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIiR7dGhpcy51cmx9IGZldGNoIHJldHVybmVkIHN0YXR1cyAyMDAsIGV4cGVjdGVkIDIwNiIpOwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH0KICAgIGFzeW5jIHJlYWRGaWxlKG9wdGlvbnMgPSB7fSkgewogICAgICBsZXQgZW5jb2Rpbmc7CiAgICAgIGxldCBvcHRzOwogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJzdHJpbmciKSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zOwogICAgICAgIG9wdHMgPSB7fTsKICAgICAgfSBlbHNlIHsKICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7CiAgICAgICAgb3B0cyA9IG9wdGlvbnM7CiAgICAgICAgZGVsZXRlIG9wdHMuZW5jb2Rpbmc7CiAgICAgIH0KICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgaGVhZGVycywKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsLAogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiZ2VuZXJpYy1maWxlaGFuZGxlIGZhaWxlZCB0byBmZXRjaCIpOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkgewogICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApLCB7CiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cwogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChlbmNvZGluZyA9PT0gInV0ZjgiKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2VuY29kaW5nfWApOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICB9CiAgICBhc3luYyBzdGF0KCkgewogICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICBjb25zdCBidWYgPSBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuYWxsb2NVbnNhZmUoMTApOwogICAgICAgIGF3YWl0IHRoaXMucmVhZChidWYsIDAsIDEwLCAwKTsKICAgICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgJHt0aGlzLnVybH1gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuX3N0YXQ7CiAgICB9CiAgICBhc3luYyBjbG9zZSgpIHsKICAgICAgcmV0dXJuOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2Jsb2JGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2ZpbGVoYW5kbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9iZ3pGaWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL3VuemlwLXBha28uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXI0ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICB2YXIgaW1wb3J0X3Bha28gPSBfX3RvTW9kdWxlKHJlcXVpcmVfcGFrbygpKTsKICBhc3luYyBmdW5jdGlvbiB1bnppcChpbnB1dERhdGEpIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBsZXQgcG9zID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7CiAgICAgIGxldCBpbmZsYXRvcjsKICAgICAgZG8gewogICAgICAgIGNvbnN0IHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnN1YmFycmF5KHBvcyk7CiAgICAgICAgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGNodW5rc1tpXSA9IGluZmxhdG9yLnJlc3VsdDsKICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICBpICs9IDE7CiAgICAgIH0gd2hpbGUgKHN0cm0uYXZhaWxfaW4pOwogICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpOwogICAgICBmb3IgKGxldCBpMiA9IDAsIG9mZnNldCA9IDA7IGkyIDwgY2h1bmtzLmxlbmd0aDsgaTIrKykgewogICAgICAgIHJlc3VsdC5zZXQoY2h1bmtzW2kyXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQgKz0gY2h1bmtzW2kyXS5sZW5ndGg7CiAgICAgIH0KICAgICAgcmV0dXJuIGltcG9ydF9idWZmZXI0LkJ1ZmZlci5mcm9tKHJlc3VsdCk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIGlmIChgJHtlfWAubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigicHJvYmxlbSBkZWNvbXByZXNzaW5nIGJsb2NrOiBpbmNvcnJlY3QgZ3ppcCBoZWFkZXIgY2hlY2siKTsKICAgICAgfQogICAgICB0aHJvdyBlOwogICAgfQogIH0KICBhc3luYyBmdW5jdGlvbiB1bnppcENodW5rU2xpY2UoaW5wdXREYXRhLCBjaHVuaykgewogICAgdHJ5IHsKICAgICAgbGV0IHN0cm07CiAgICAgIGNvbnN0IHsgbWludiwgbWF4diB9ID0gY2h1bms7CiAgICAgIGxldCBjcG9zID0gbWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBsZXQgZHBvcyA9IG1pbnYuZGF0YVBvc2l0aW9uOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgY29uc3QgY3Bvc2l0aW9ucyA9IFtdOwogICAgICBjb25zdCBkcG9zaXRpb25zID0gW107CiAgICAgIGxldCB0b3RhbFNpemUgPSAwOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGRvIHsKICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zdWJhcnJheShjcG9zIC0gbWludi5ibG9ja1Bvc2l0aW9uKTsKICAgICAgICBjb25zdCBpbmZsYXRvciA9IG5ldyBpbXBvcnRfcGFrby5JbmZsYXRlKCk7CiAgICAgICAgKHsgc3RybSB9ID0gaW5mbGF0b3IpOwogICAgICAgIGluZmxhdG9yLnB1c2gocmVtYWluaW5nSW5wdXQsIGltcG9ydF9wYWtvLlpfU1lOQ19GTFVTSCk7CiAgICAgICAgaWYgKGluZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluZmxhdG9yLm1zZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBpbmZsYXRvci5yZXN1bHQ7CiAgICAgICAgY2h1bmtzLnB1c2goYnVmZmVyMik7CiAgICAgICAgbGV0IGxlbiA9IGJ1ZmZlcjIubGVuZ3RoOwogICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICBkcG9zaXRpb25zLnB1c2goZHBvcyk7CiAgICAgICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEgJiYgbWludi5kYXRhUG9zaXRpb24pIHsKICAgICAgICAgIGNodW5rc1swXSA9IGNodW5rc1swXS5zdWJhcnJheShtaW52LmRhdGFQb3NpdGlvbik7CiAgICAgICAgICBsZW4gPSBjaHVua3NbMF0ubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBjb25zdCBvcmlnQ3BvcyA9IGNwb3M7CiAgICAgICAgY3BvcyArPSBzdHJtLm5leHRfaW47CiAgICAgICAgZHBvcyArPSBsZW47CiAgICAgICAgaWYgKG9yaWdDcG9zID49IG1heHYuYmxvY2tQb3NpdGlvbikgewogICAgICAgICAgY2h1bmtzW2ldID0gY2h1bmtzW2ldLnN1YmFycmF5KDAsIG1heHYuYmxvY2tQb3NpdGlvbiA9PT0gbWludi5ibG9ja1Bvc2l0aW9uID8gbWF4di5kYXRhUG9zaXRpb24gLSBtaW52LmRhdGFQb3NpdGlvbiArIDEgOiBtYXh2LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgY3Bvc2l0aW9ucy5wdXNoKGNwb3MpOwogICAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgaSsrOwogICAgICB9IHdoaWxlIChzdHJtLmF2YWlsX2luKTsKICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTsKICAgICAgZm9yIChsZXQgaTIgPSAwLCBvZmZzZXQgPSAwOyBpMiA8IGNodW5rcy5sZW5ndGg7IGkyKyspIHsKICAgICAgICByZXN1bHQuc2V0KGNodW5rc1tpMl0sIG9mZnNldCk7CiAgICAgICAgb2Zmc2V0ICs9IGNodW5rc1tpMl0ubGVuZ3RoOwogICAgICB9CiAgICAgIGNvbnN0IGJ1ZmZlciA9IGltcG9ydF9idWZmZXI0LkJ1ZmZlci5mcm9tKHJlc3VsdCk7CiAgICAgIHJldHVybiB7IGJ1ZmZlciwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9OwogICAgfSBjYXRjaCAoZSkgewogICAgICBpZiAoYCR7ZX1gLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgIH0KICAgICAgdGhyb3cgZTsKICAgIH0KICB9CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2d6aUluZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL25vZGVfbW9kdWxlcy9sb25nL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciB3YXNtID0gbnVsbDsKICB0cnkgewogICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFsKICAgICAgMCwKICAgICAgOTcsCiAgICAgIDExNSwKICAgICAgMTA5LAogICAgICAxLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAxLAogICAgICAxMywKICAgICAgMiwKICAgICAgOTYsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDEyNywKICAgICAgOTYsCiAgICAgIDQsCiAgICAgIDEyNywKICAgICAgMTI3LAogICAgICAxMjcsCiAgICAgIDEyNywKICAgICAgMSwKICAgICAgMTI3LAogICAgICAzLAogICAgICA3LAogICAgICA2LAogICAgICAwLAogICAgICAxLAogICAgICAxLAogICAgICAxLAogICAgICAxLAogICAgICAxLAogICAgICA2LAogICAgICA2LAogICAgICAxLAogICAgICAxMjcsCiAgICAgIDEsCiAgICAgIDY1LAogICAgICAwLAogICAgICAxMSwKICAgICAgNywKICAgICAgNTAsCiAgICAgIDYsCiAgICAgIDMsCiAgICAgIDEwOSwKICAgICAgMTE3LAogICAgICAxMDgsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDUsCiAgICAgIDEwMCwKICAgICAgMTA1LAogICAgICAxMTgsCiAgICAgIDk1LAogICAgICAxMTUsCiAgICAgIDAsCiAgICAgIDIsCiAgICAgIDUsCiAgICAgIDEwMCwKICAgICAgMTA1LAogICAgICAxMTgsCiAgICAgIDk1LAogICAgICAxMTcsCiAgICAgIDAsCiAgICAgIDMsCiAgICAgIDUsCiAgICAgIDExNCwKICAgICAgMTAxLAogICAgICAxMDksCiAgICAgIDk1LAogICAgICAxMTUsCiAgICAgIDAsCiAgICAgIDQsCiAgICAgIDUsCiAgICAgIDExNCwKICAgICAgMTAxLAogICAgICAxMDksCiAgICAgIDk1LAogICAgICAxMTcsCiAgICAgIDAsCiAgICAgIDUsCiAgICAgIDgsCiAgICAgIDEwMywKICAgICAgMTAxLAogICAgICAxMTYsCiAgICAgIDk1LAogICAgICAxMDQsCiAgICAgIDEwNSwKICAgICAgMTAzLAogICAgICAxMDQsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEwLAogICAgICAxOTEsCiAgICAgIDEsCiAgICAgIDYsCiAgICAgIDQsCiAgICAgIDAsCiAgICAgIDM1LAogICAgICAwLAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTI2LAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMjcsCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEsCiAgICAgIDM2LAogICAgICAxLAogICAgICAxLAogICAgICAxMjYsCiAgICAgIDMyLAogICAgICAwLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAxLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDMyLAogICAgICAyLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAzLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDEyOCwKICAgICAgMzQsCiAgICAgIDQsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM1LAogICAgICAxNjcsCiAgICAgIDM2LAogICAgICAwLAogICAgICAzMiwKICAgICAgNCwKICAgICAgMTY3LAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTI5LAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMzAsCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEKICAgIF0pKSwge30pLmV4cG9ydHM7CiAgfSBjYXRjaCAoZSkgewogIH0KICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHsKICAgIHRoaXMubG93ID0gbG93IHwgMDsKICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgfQogIExvbmcucHJvdG90eXBlLl9faXNMb25nX187CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgZnVuY3Rpb24gaXNMb25nKG9iaikgewogICAgcmV0dXJuIChvYmogJiYgb2JqWyJfX2lzTG9uZ19fIl0pID09PSB0cnVlOwogIH0KICBmdW5jdGlvbiBjdHozMih2YWx1ZSkgewogICAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTsKICAgIHJldHVybiB2YWx1ZSA/IDMxIC0gYyA6IGM7CiAgfQogIExvbmcuaXNMb25nID0gaXNMb25nOwogIHZhciBJTlRfQ0FDSEUgPSB7fTsKICB2YXIgVUlOVF9DQUNIRSA9IHt9OwogIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7CiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdOwogICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICB9CiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTsKICAgICAgaWYgKGNhY2hlKQogICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICByZXR1cm4gb2JqOwogICAgfSBlbHNlIHsKICAgICAgdmFsdWUgfD0gMDsKICAgICAgaWYgKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkgewogICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7CiAgICAgIH0KICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICBpZiAoY2FjaGUpCiAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgcmV0dXJuIG9iajsKICAgIH0KICB9CiAgTG9uZy5mcm9tSW50ID0gZnJvbUludDsKICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkgewogICAgaWYgKGlzTmFOKHZhbHVlKSkKICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpCiAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTsKICAgIH0gZWxzZSB7CiAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpCiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkKICAgICAgICByZXR1cm4gTUFYX1ZBTFVFOwogICAgfQogICAgaWYgKHZhbHVlIDwgMCkKICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7CiAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7CiAgfQogIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7CiAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7CiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICB9CiAgTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzOwogIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7CiAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkgewogICAgaWYgKHN0ci5sZW5ndGggPT09IDApCiAgICAgIHRocm93IEVycm9yKCJlbXB0eSBzdHJpbmciKTsKICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgIHJhZGl4ID0gdW5zaWduZWQ7CiAgICAgIHVuc2lnbmVkID0gZmFsc2U7CiAgICB9IGVsc2UgewogICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICB9CiAgICBpZiAoc3RyID09PSAiTmFOIiB8fCBzdHIgPT09ICJJbmZpbml0eSIgfHwgc3RyID09PSAiK0luZmluaXR5IiB8fCBzdHIgPT09ICItSW5maW5pdHkiKQogICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgdmFyIHA7CiAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgIHRocm93IEVycm9yKCJpbnRlcmlvciBoeXBoZW4iKTsKICAgIGVsc2UgaWYgKHAgPT09IDApIHsKICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTsKICAgIH0KICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTsKICAgIHZhciByZXN1bHQgPSBaRVJPOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHsKICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgaWYgKHNpemUgPCA4KSB7CiAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7CiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7CiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgIH0KICAgIH0KICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkOwogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZzsKICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkgewogICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTsKICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikKICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7CiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gImJvb2xlYW4iID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpOwogIH0KICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsKICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2OwogIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7CiAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDsKICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMOwogIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjsKICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpOwogIHZhciBaRVJPID0gZnJvbUludCgwKTsKICBMb25nLlpFUk8gPSBaRVJPOwogIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7CiAgTG9uZy5VWkVSTyA9IFVaRVJPOwogIHZhciBPTkUgPSBmcm9tSW50KDEpOwogIExvbmcuT05FID0gT05FOwogIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTsKICBMb25nLlVPTkUgPSBVT05FOwogIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7CiAgTG9uZy5ORUdfT05FID0gTkVHX09ORTsKICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoNDI5NDk2NzI5NSB8IDAsIDIxNDc0ODM2NDcgfCAwLCBmYWxzZSk7CiAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7CiAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDQyOTQ5NjcyOTUgfCAwLCA0Mjk0OTY3Mjk1IHwgMCwgdHJ1ZSk7CiAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7CiAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDIxNDc0ODM2NDggfCAwLCBmYWxzZSk7CiAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7CiAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTsKICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7CiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7CiAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICB9OwogIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkgewogICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICByZXR1cm4gIjAiOwogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgfSBlbHNlCiAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgfQogICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLCByZW0gPSB0aGlzOwogICAgdmFyIHJlc3VsdCA9ICIiOwogICAgd2hpbGUgKHRydWUpIHsKICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSwgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7CiAgICAgIHJlbSA9IHJlbURpdjsKICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0OwogICAgICBlbHNlIHsKICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICBkaWdpdHMgPSAiMCIgKyBkaWdpdHM7CiAgICAgICAgcmVzdWx0ID0gIiIgKyBkaWdpdHMgKyByZXN1bHQ7CiAgICAgIH0KICAgIH0KICB9OwogIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkgewogICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7CiAgICByZXR1cm4gdGhpcy5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHsKICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7CiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpCiAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpOwogICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApCiAgICAgICAgYnJlYWs7CiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgfTsKICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvOwogIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7CiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDsKICB9OwogIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7CiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICB9OwogIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHsKICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTsKICB9OwogIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkgewogICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpCiAgICAgIHJldHVybiBmYWxzZTsKICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICB9OwogIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFsczsKICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikgewogICAgcmV0dXJuICF0aGlzLmVxKG90aGVyKTsKICB9OwogIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikgewogICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47CiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogIExvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuOwogIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7CiAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikgewogICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICBpZiAodGhpcy5lcShvdGhlcikpCiAgICAgIHJldHVybiAwOwogICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpCiAgICAgIHJldHVybiAtMTsKICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgcmV0dXJuIDE7CiAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlOwogIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkgewogICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTsKICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHsKICAgIGlmICghaXNMb25nKGFkZGVuZCkpCiAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpOwogICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgNjU1MzU7CiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7CiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICBjMDAgKz0gYTAwICsgYjAwOwogICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICBjMDAgJj0gNjU1MzU7CiAgICBjMTYgKz0gYTE2ICsgYjE2OwogICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICBjMTYgJj0gNjU1MzU7CiAgICBjMzIgKz0gYTMyICsgYjMyOwogICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICBjMzIgJj0gNjU1MzU7CiAgICBjNDggKz0gYTQ4ICsgYjQ4OwogICAgYzQ4ICY9IDY1NTM1OwogICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7CiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSkKICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTsKICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICB9OwogIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDsKICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikgewogICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpCiAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7CiAgICBpZiAod2FzbSkgewogICAgICB2YXIgbG93ID0gd2FzbVsibXVsIl0odGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bImdldF9oaWdoIl0oKSwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkKICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKQogICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpCiAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPOwogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7CiAgICAgIGVsc2UKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKQogICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpOwogICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiA2NTUzNTsKICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgYzAwICs9IGEwMCAqIGIwMDsKICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgYzAwICY9IDY1NTM1OwogICAgYzE2ICs9IGExNiAqIGIwMDsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzMyICs9IGEzMiAqIGIwMDsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzMyICs9IGExNiAqIGIxNjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzMyICs9IGEwMCAqIGIzMjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgIGM0OCAmPSA2NTUzNTsKICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7CiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikgewogICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkKICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgIGlmICh3YXNtKSB7CiAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVsiZGl2X3UiXSA6IHdhc21bImRpdl9zIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtWyJnZXRfaGlnaCJdKCksIHRoaXMudW5zaWduZWQpOwogICAgfQogICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgdmFyIGFwcHJveCwgcmVtLCByZXM7CiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSkKICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIE9ORTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpOwogICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTsKICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHsKICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpOwogICAgICAgICAgICByZXR1cm4gcmVzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7CiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICByZXMgPSBaRVJPOwogICAgfSBlbHNlIHsKICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKQogICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgIHJldHVybiBVT05FOwogICAgICByZXMgPSBVWkVSTzsKICAgIH0KICAgIHJlbSA9IHRoaXM7CiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkgewogICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSwgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICBhcHByb3ggLT0gZGVsdGE7CiAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgIH0KICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICBhcHByb3hSZXMgPSBPTkU7CiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pOwogICAgfQogICAgcmV0dXJuIHJlczsKICB9OwogIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7CiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikgewogICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICBpZiAod2FzbSkgewogICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtWyJyZW1fdSJdIDogd2FzbVsicmVtX3MiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bImdldF9oaWdoIl0oKSwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICB9OwogIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbzsKICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHsKICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50TGVhZGluZ1plcm9zKCkgewogICAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7CiAgfTsKICBMb25nUHJvdG90eXBlLmNseiA9IExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3M7CiAgTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3MoKSB7CiAgICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7CiAgfTsKICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zOwogIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgZWxzZQogICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7CiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgIGVsc2UKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0OwogIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzIDwgMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICBpZiAobnVtQml0cyA9PT0gMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gbnVtQml0cyAtIDMyLCAwLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkOwogIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHsKICAgIHZhciBiOwogICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7CiAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgIGIgPSAzMiAtIG51bUJpdHM7CiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLnVuc2lnbmVkKTsKICAgIH0KICAgIG51bUJpdHMgLT0gMzI7CiAgICBiID0gMzIgLSBudW1CaXRzOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IGIsIHRoaXMubG93IDw8IG51bUJpdHMgfCB0aGlzLmhpZ2ggPj4+IGIsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0OwogIExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7CiAgICB2YXIgYjsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzID09PSAzMikKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpOwogICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICBiID0gMzIgLSBudW1CaXRzOwogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBudW1CaXRzIC09IDMyOwogICAgYiA9IDMyIC0gbnVtQml0czsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBiIHwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgYiB8IHRoaXMubG93ID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUucm90ciA9IExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQ7CiAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkgewogICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICByZXR1cm4gdGhpczsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkgewogICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiB0aGlzOwogICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkgewogICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHsKICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgIHJldHVybiBbCiAgICAgIGxvICYgMjU1LAogICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICBsbyA+Pj4gMjQsCiAgICAgIGhpICYgMjU1LAogICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICBoaSA+Pj4gMjQKICAgIF07CiAgfTsKICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHsKICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgIHJldHVybiBbCiAgICAgIGhpID4+PiAyNCwKICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgaGkgJiAyNTUsCiAgICAgIGxvID4+PiAyNCwKICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgbG8gJiAyNTUKICAgIF07CiAgfTsKICBMb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7CiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7CiAgfTsKICBMb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpOwogIH07CiAgTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9nemlJbmRleC5qcwogIHZhciBpbXBvcnRfYnVmZmVyNSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBsb25nVG9OdW1iZXIobG9uZykgewogICAgaWYgKGxvbmcuZ3JlYXRlclRoYW4oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IGxvbmcubGVzc1RoYW4oTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiaW50ZWdlciBvdmVyZmxvdyIpOwogICAgfQogICAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKTsKICB9CiAgdmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHsKICB9OwogIGZ1bmN0aW9uIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKSB7CiAgICBpZiAoIXNpZ25hbCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbigiYWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZSA9IG5ldyBBYm9ydEVycm9yKCJhYm9ydGVkIik7CiAgICAgICAgZS5jb2RlID0gIkVSUl9BQk9SVEVEIjsKICAgICAgICB0aHJvdyBlOwogICAgICB9CiAgICB9CiAgfQogIGZ1bmN0aW9uIGNhbk1lcmdlQmxvY2tzKGNodW5rMSwgY2h1bmsyKSB7CiAgICByZXR1cm4gY2h1bmsyLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5tYXh2LmJsb2NrUG9zaXRpb24gPCA2NWUzICYmIGNodW5rMi5tYXh2LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWludi5ibG9ja1Bvc2l0aW9uIDwgNWU2OwogIH0KICBmdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkgewogICAgY29uc3QgbWVyZ2VkQ2h1bmtzID0gW107CiAgICBsZXQgbGFzdENodW5rID0gbnVsbDsKICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBjaHVua3M7CiAgICB9CiAgICBjaHVua3Muc29ydChmdW5jdGlvbihjMCwgYzEpIHsKICAgICAgY29uc3QgZGlmID0gYzAubWludi5ibG9ja1Bvc2l0aW9uIC0gYzEubWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBpZiAoZGlmICE9PSAwKSB7CiAgICAgICAgcmV0dXJuIGRpZjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYzAubWludi5kYXRhUG9zaXRpb24gLSBjMS5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgfQogICAgfSk7CiAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IHsKICAgICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHsKICAgICAgICBpZiAobGFzdENodW5rID09PSBudWxsKSB7CiAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGNhbk1lcmdlQmxvY2tzKGxhc3RDaHVuaywgY2h1bmspKSB7CiAgICAgICAgICAgIGlmIChjaHVuay5tYXh2LmNvbXBhcmVUbyhsYXN0Q2h1bmsubWF4dikgPiAwKSB7CiAgICAgICAgICAgICAgbGFzdENodW5rLm1heHYgPSBjaHVuay5tYXh2OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YmkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3ZpcnR1YWxPZmZzZXQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIFZpcnR1YWxPZmZzZXQgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihibG9ja1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24pIHsKICAgICAgdGhpcy5ibG9ja1Bvc2l0aW9uID0gYmxvY2tQb3NpdGlvbjsKICAgICAgdGhpcy5kYXRhUG9zaXRpb24gPSBkYXRhUG9zaXRpb247CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIGAke3RoaXMuYmxvY2tQb3NpdGlvbn06JHt0aGlzLmRhdGFQb3NpdGlvbn1gOwogICAgfQogICAgY29tcGFyZVRvKGIpIHsKICAgICAgcmV0dXJuIHRoaXMuYmxvY2tQb3NpdGlvbiAtIGIuYmxvY2tQb3NpdGlvbiB8fCB0aGlzLmRhdGFQb3NpdGlvbiAtIGIuZGF0YVBvc2l0aW9uOwogICAgfQogICAgc3RhdGljIG1pbiguLi5hcmdzKSB7CiAgICAgIGxldCBtaW47CiAgICAgIGxldCBpID0gMDsKICAgICAgZm9yICg7ICFtaW47IGkgKz0gMSkgewogICAgICAgIG1pbiA9IGFyZ3NbaV07CiAgICAgIH0KICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKG1pbi5jb21wYXJlVG8oYXJnc1tpXSkgPiAwKSB7CiAgICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbWluOwogICAgfQogIH07CiAgZnVuY3Rpb24gZnJvbUJ5dGVzMihieXRlcywgb2Zmc2V0ID0gMCwgYmlnZW5kaWFuID0gZmFsc2UpIHsKICAgIGlmIChiaWdlbmRpYW4pIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJiaWctZW5kaWFuIHZpcnR1YWwgZmlsZSBvZmZzZXRzIG5vdCBpbXBsZW1lbnRlZCIpOwogICAgfQogICAgcmV0dXJuIG5ldyBWaXJ0dWFsT2Zmc2V0KGJ5dGVzW29mZnNldCArIDddICogMTA5OTUxMTYyNzc3NiArIGJ5dGVzW29mZnNldCArIDZdICogNDI5NDk2NzI5NiArIGJ5dGVzW29mZnNldCArIDVdICogMTY3NzcyMTYgKyBieXRlc1tvZmZzZXQgKyA0XSAqIDY1NTM2ICsgYnl0ZXNbb2Zmc2V0ICsgM10gKiAyNTYgKyBieXRlc1tvZmZzZXQgKyAyXSwgYnl0ZXNbb2Zmc2V0ICsgMV0gPDwgOCB8IGJ5dGVzW29mZnNldF0pOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9jaHVuay5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgQ2h1bmsgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihtaW52LCBtYXh2LCBiaW4sIGZldGNoZWRTaXplID0gdm9pZCAwKSB7CiAgICAgIHRoaXMubWludiA9IG1pbnY7CiAgICAgIHRoaXMubWF4diA9IG1heHY7CiAgICAgIHRoaXMuYmluID0gYmluOwogICAgICB0aGlzLl9mZXRjaGVkU2l6ZSA9IGZldGNoZWRTaXplOwogICAgfQogICAgdG9VbmlxdWVTdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLm1pbnZ9Li4ke3RoaXMubWF4dn0gKGJpbiAke3RoaXMuYmlufSwgZmV0Y2hlZFNpemUgJHt0aGlzLmZldGNoZWRTaXplKCl9KWA7CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIHRoaXMudG9VbmlxdWVTdHJpbmcoKTsKICAgIH0KICAgIGNvbXBhcmVUbyhiKSB7CiAgICAgIHJldHVybiB0aGlzLm1pbnYuY29tcGFyZVRvKGIubWludikgfHwgdGhpcy5tYXh2LmNvbXBhcmVUbyhiLm1heHYpIHx8IHRoaXMuYmluIC0gYi5iaW47CiAgICB9CiAgICBmZXRjaGVkU2l6ZSgpIHsKICAgICAgaWYgKHRoaXMuX2ZldGNoZWRTaXplICE9PSB2b2lkIDApIHsKICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hlZFNpemU7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMubWF4di5ibG9ja1Bvc2l0aW9uICsgKDEgPDwgMTYpIC0gdGhpcy5taW52LmJsb2NrUG9zaXRpb247CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleEZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIEluZGV4RmlsZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHsgZmlsZWhhbmRsZSwgcmVuYW1lUmVmU2VxcyA9IChuKSA9PiBuIH0pIHsKICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzOwogICAgfQogICAgYXN5bmMgZ2V0TWV0YWRhdGEob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgaW5kaWNlcywgLi4ucmVzdCB9ID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgcmV0dXJuIHJlc3Q7CiAgICB9CiAgICBfZmluZEZpcnN0RGF0YShjdXJyZW50RmRsLCB2aXJ0dWFsT2Zmc2V0KSB7CiAgICAgIGlmIChjdXJyZW50RmRsKSB7CiAgICAgICAgcmV0dXJuIGN1cnJlbnRGZGwuY29tcGFyZVRvKHZpcnR1YWxPZmZzZXQpID4gMCA/IHZpcnR1YWxPZmZzZXQgOiBjdXJyZW50RmRsOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2aXJ0dWFsT2Zmc2V0OwogICAgICB9CiAgICB9CiAgICBhc3luYyBwYXJzZShvcHRzID0ge30pIHsKICAgICAgaWYgKCF0aGlzLnBhcnNlUCkgewogICAgICAgIHRoaXMucGFyc2VQID0gdGhpcy5fcGFyc2Uob3B0cykuY2F0Y2goKGUpID0+IHsKICAgICAgICAgIHRoaXMucGFyc2VQID0gdm9pZCAwOwogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5wYXJzZVA7CiAgICB9CiAgICBhc3luYyBoYXNSZWZTZXEoc2VxSWQsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gISEoKGF3YWl0IHRoaXMucGFyc2Uob3B0cykpLmluZGljZXNbc2VxSWRdIHx8IHt9KS5iaW5JbmRleDsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RiaS5qcwogIHZhciBUQklfTUFHSUMgPSAyMTU3ODMyNDsKICB2YXIgVEFEX0xJRFhfU0hJRlQgPSAxNDsKICBmdW5jdGlvbiByZWcyYmlucyhiZWcsIGVuZCkgewogICAgYmVnICs9IDE7CiAgICBlbmQgLT0gMTsKICAgIHJldHVybiBbCiAgICAgIFswLCAwXSwKICAgICAgWzEgKyAoYmVnID4+IDI2KSwgMSArIChlbmQgPj4gMjYpXSwKICAgICAgWzkgKyAoYmVnID4+IDIzKSwgOSArIChlbmQgPj4gMjMpXSwKICAgICAgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLAogICAgICBbNTg1ICsgKGJlZyA+PiAxNyksIDU4NSArIChlbmQgPj4gMTcpXSwKICAgICAgWzQ2ODEgKyAoYmVnID4+IDE0KSwgNDY4MSArIChlbmQgPj4gMTQpXQogICAgXTsKICB9CiAgdmFyIFRhYml4SW5kZXggPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKTsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB1bnppcChidWYpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSAhPT0gVEJJX01BR0lDKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBUQkkgZmlsZSIpOwogICAgICB9CiAgICAgIGNvbnN0IHJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgIGNvbnN0IGZvcm1hdEZsYWdzID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID0gZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICBjb25zdCBmb3JtYXRPcHRzID0gewogICAgICAgIDA6ICJnZW5lcmljIiwKICAgICAgICAxOiAiU0FNIiwKICAgICAgICAyOiAiVkNGIgogICAgICB9OwogICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRPcHRzW2Zvcm1hdEZsYWdzICYgMTVdOwogICAgICBpZiAoIWZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7Zm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHsKICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKDEyKSwKICAgICAgICBzdGFydDogYnl0ZXMucmVhZEludDMyTEUoMTYpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUoMjApCiAgICAgIH07CiAgICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKDI0KTsKICAgICAgY29uc3QgZGVwdGggPSA1OwogICAgICBjb25zdCBtYXhCaW5OdW1iZXIgPSAoKDEgPDwgKGRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAoMTQgKyBkZXB0aCAqIDMpOwogICAgICBjb25zdCBtZXRhQ2hhciA9IG1ldGFWYWx1ZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUobWV0YVZhbHVlKSA6IG51bGw7CiAgICAgIGNvbnN0IHNraXBMaW5lcyA9IGJ5dGVzLnJlYWRJbnQzMkxFKDI4KTsKICAgICAgY29uc3QgbmFtZVNlY3Rpb25MZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgzMik7CiAgICAgIGNvbnN0IHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH0gPSB0aGlzLl9wYXJzZU5hbWVCeXRlcyhieXRlcy5zbGljZSgzNiwgMzYgKyBuYW1lU2VjdGlvbkxlbmd0aCkpOwogICAgICBsZXQgY3Vyck9mZnNldCA9IDM2ICsgbmFtZVNlY3Rpb25MZW5ndGg7CiAgICAgIGxldCBmaXJzdERhdGFMaW5lOwogICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHJlZkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiB7CiAgICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBsZXQgc3RhdHM7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICBpZiAoYmluID4gbWF4QmluTnVtYmVyICsgMSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInRhYml4IGluZGV4IGNvbnRhaW5zIHRvbyBtYW55IGJpbnMsIHBsZWFzZSB1c2UgYSBDU0kgaW5kZXgiKTsKICAgICAgICAgIH0gZWxzZSBpZiAoYmluID09PSBtYXhCaW5OdW1iZXIgKyAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICBpZiAoY2h1bmtDb3VudCA9PT0gMikgewogICAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNiAqIGNodW5rQ291bnQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgdSk7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgbGluZWFySW5kZXhba10gPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gODsKICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxpbmVhckluZGV4W2tdKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIGxpbmVhckluZGV4LCBzdGF0cyB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIHsKICAgICAgICBpbmRpY2VzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIG1heEJpbk51bWJlciwKICAgICAgICBtYXhSZWZMZW5ndGgsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIGZpcnN0RGF0YUxpbmUsCiAgICAgICAgY29sdW1uTnVtYmVycywKICAgICAgICBjb29yZGluYXRlVHlwZSwKICAgICAgICBmb3JtYXQsCiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2CiAgICAgIH07CiAgICB9CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZzIuZGVmYXVsdC5mcm9tQnl0ZXNMRShieXRlcy5zbGljZShvZmZzZXQgKyAxNiwgb2Zmc2V0ICsgMjQpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXMpIHsKICAgICAgbGV0IGN1cnJSZWZJZCA9IDA7CiAgICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMDsKICAgICAgY29uc3QgcmVmSWRUb05hbWUgPSBbXTsKICAgICAgY29uc3QgcmVmTmFtZVRvSWQgPSB7fTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc0J5dGVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7CiAgICAgICAgICBpZiAoY3Vyck5hbWVTdGFydCA8IGkpIHsKICAgICAgICAgICAgbGV0IHJlZk5hbWUgPSBuYW1lc0J5dGVzLnRvU3RyaW5nKCJ1dGY4IiwgY3Vyck5hbWVTdGFydCwgaSk7CiAgICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKTsKICAgICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWU7CiAgICAgICAgICAgIHJlZk5hbWVUb0lkW3JlZk5hbWVdID0gY3VyclJlZklkOwogICAgICAgICAgfQogICAgICAgICAgY3Vyck5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VyclJlZklkICs9IDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHJlZk5hbWVUb0lkLCByZWZJZFRvTmFtZSB9OwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWJhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IG1pbk9mZnNldCA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aCA/IGJhLmxpbmVhckluZGV4W21pbiA+PiBUQURfTElEWF9TSElGVCA+PSBiYS5saW5lYXJJbmRleC5sZW5ndGggPyBiYS5saW5lYXJJbmRleC5sZW5ndGggLSAxIDogbWluID4+IFRBRF9MSURYX1NISUZUXSA6IG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApOwogICAgICBpZiAoIW1pbk9mZnNldCkgewogICAgICAgIGNvbnNvbGUud2FybigicXVlcnlpbmcgb3V0c2lkZSBvZiBwb3NzaWJsZSB0YWJpeCByYW5nZSIpOwogICAgICB9CiAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDsKICAgICAgbGV0IGxvd2VzdCA9IG51bGw7CiAgICAgIGNvbnN0IG1pbkxpbiA9IE1hdGgubWluKG1pbiA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgY29uc3QgbWF4TGluID0gTWF0aC5taW4obWF4ID4+IDE0LCBuaW50diAtIDEpOwogICAgICBmb3IgKGxldCBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7CiAgICAgICAgY29uc3QgdnAgPSBiYS5saW5lYXJJbmRleFtpXTsKICAgICAgICBpZiAodnApIHsKICAgICAgICAgIGlmICghbG93ZXN0IHx8IHZwLmNvbXBhcmVUbyhsb3dlc3QpIDwgMCkgewogICAgICAgICAgICBsb3dlc3QgPSB2cDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL2NzaS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvbmczID0gX190b01vZHVsZShyZXF1aXJlX2xvbmcoKSk7CiAgdmFyIENTSTFfTUFHSUMgPSAyMTU4MjY1OTsKICB2YXIgQ1NJMl9NQUdJQyA9IDM4MzU5ODc1OwogIGZ1bmN0aW9uIGxzaGlmdChudW0sIGJpdHMpIHsKICAgIHJldHVybiBudW0gKiAyICoqIGJpdHM7CiAgfQogIGZ1bmN0aW9uIHJzaGlmdChudW0sIGJpdHMpIHsKICAgIHJldHVybiBNYXRoLmZsb29yKG51bSAvIDIgKiogYml0cyk7CiAgfQogIHZhciBDU0kgPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7CiAgICAgIHN1cGVyKGFyZ3MpOwogICAgICB0aGlzLm1heEJpbk51bWJlciA9IDA7CiAgICAgIHRoaXMuZGVwdGggPSAwOwogICAgICB0aGlzLm1pblNoaWZ0ID0gMDsKICAgIH0KICAgIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFpZHgpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoc3RhdHMpIHsKICAgICAgICByZXR1cm4gc3RhdHMubGluZUNvdW50OwogICAgICB9CiAgICAgIHJldHVybiAtMTsKICAgIH0KICAgIGFzeW5jIGluZGV4Q292KCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkNTSSBpbmRleGVzIGRvIG5vdCBzdXBwb3J0IGluZGV4Y292Iik7CiAgICB9CiAgICBwYXJzZUF1eERhdGEoYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBmb3JtYXRGbGFncyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCk7CiAgICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID0gZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICBjb25zdCBmb3JtYXQgPSB7IDA6ICJnZW5lcmljIiwgMTogIlNBTSIsIDI6ICJWQ0YiIH1bZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZm9ybWF0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgNCksCiAgICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDgpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTIpCiAgICAgIH07CiAgICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDE2KTsKICAgICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiBudWxsOwogICAgICBjb25zdCBza2lwTGluZXMgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAyMCk7CiAgICAgIGNvbnN0IG5hbWVTZWN0aW9uTGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjQpOwogICAgICBjb25zdCB7IHJlZklkVG9OYW1lLCByZWZOYW1lVG9JZCB9ID0gdGhpcy5fcGFyc2VOYW1lQnl0ZXMoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMjgsIG9mZnNldCArIDI4ICsgbmFtZVNlY3Rpb25MZW5ndGgpKTsKICAgICAgcmV0dXJuIHsKICAgICAgICByZWZJZFRvTmFtZSwKICAgICAgICByZWZOYW1lVG9JZCwKICAgICAgICBza2lwTGluZXMsCiAgICAgICAgbWV0YUNoYXIsCiAgICAgICAgY29sdW1uTnVtYmVycywKICAgICAgICBmb3JtYXQsCiAgICAgICAgY29vcmRpbmF0ZVR5cGUKICAgICAgfTsKICAgIH0KICAgIF9wYXJzZU5hbWVCeXRlcyhuYW1lc0J5dGVzKSB7CiAgICAgIGxldCBjdXJyUmVmSWQgPSAwOwogICAgICBsZXQgY3Vyck5hbWVTdGFydCA9IDA7CiAgICAgIGNvbnN0IHJlZklkVG9OYW1lID0gW107CiAgICAgIGNvbnN0IHJlZk5hbWVUb0lkID0ge307CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmICghbmFtZXNCeXRlc1tpXSkgewogICAgICAgICAgaWYgKGN1cnJOYW1lU3RhcnQgPCBpKSB7CiAgICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygidXRmOCIsIGN1cnJOYW1lU3RhcnQsIGkpOwogICAgICAgICAgICByZWZOYW1lID0gdGhpcy5yZW5hbWVSZWZTZXEocmVmTmFtZSk7CiAgICAgICAgICAgIHJlZklkVG9OYW1lW2N1cnJSZWZJZF0gPSByZWZOYW1lOwogICAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZDsKICAgICAgICAgIH0KICAgICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMTsKICAgICAgICAgIGN1cnJSZWZJZCArPSAxOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfTsKICAgIH0KICAgIGFzeW5jIF9wYXJzZShvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB1bnppcChhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZEZpbGUob3B0cykpOwogICAgICBsZXQgY3NpVmVyc2lvbjsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMV9NQUdJQykgewogICAgICAgIGNzaVZlcnNpb24gPSAxOwogICAgICB9IGVsc2UgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMl9NQUdJQykgewogICAgICAgIGNzaVZlcnNpb24gPSAyOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTm90IGEgQ1NJIGZpbGUiKTsKICAgICAgfQogICAgICB0aGlzLm1pblNoaWZ0ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgIHRoaXMuZGVwdGggPSBieXRlcy5yZWFkSW50MzJMRSg4KTsKICAgICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAoKDEgPDwgKHRoaXMuZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICh0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDMpOwogICAgICBjb25zdCBhdXhMZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgxMik7CiAgICAgIGNvbnN0IGF1eCA9IGF1eExlbmd0aCAmJiBhdXhMZW5ndGggPj0gMzAgPyB0aGlzLnBhcnNlQXV4RGF0YShieXRlcywgMTYpIDogewogICAgICAgIHJlZklkVG9OYW1lOiBbXSwKICAgICAgICByZWZOYW1lVG9JZDoge30sCiAgICAgICAgbWV0YUNoYXI6IG51bGwsCiAgICAgICAgY29sdW1uTnVtYmVyczogeyByZWY6IDAsIHN0YXJ0OiAxLCBlbmQ6IDIgfSwKICAgICAgICBjb29yZGluYXRlVHlwZTogInplcm8tYmFzZWQtaGFsZi1vcGVuIiwKICAgICAgICBmb3JtYXQ6ICJnZW5lcmljIgogICAgICB9OwogICAgICBjb25zdCByZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDE2ICsgYXV4TGVuZ3RoKTsKICAgICAgbGV0IGZpcnN0RGF0YUxpbmU7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gMTYgKyBhdXhMZW5ndGggKyA0OwogICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHJlZkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiB7CiAgICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBsZXQgc3RhdHM7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICBpZiAoYmluID4gdGhpcy5tYXhCaW5OdW1iZXIpIHsKICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNCArIDggKyA0ICsgMTYgKyAxNjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGxvZmZzZXQgPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxvZmZzZXQpOwogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCArIDEyKTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMyKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIHN0YXRzIH07CiAgICAgIH0pOwogICAgICByZXR1cm4gewogICAgICAgIC4uLmF1eCwKICAgICAgICBjc2k6IHRydWUsCiAgICAgICAgcmVmQ291bnQsCiAgICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2LAogICAgICAgIGZpcnN0RGF0YUxpbmUsCiAgICAgICAgY3NpVmVyc2lvbiwKICAgICAgICBpbmRpY2VzLAogICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoLAogICAgICAgIG1heEJpbk51bWJlcjogdGhpcy5tYXhCaW5OdW1iZXIsCiAgICAgICAgbWF4UmVmTGVuZ3RoCiAgICAgIH07CiAgICB9CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZzMuZGVmYXVsdC5mcm9tQnl0ZXNMRShieXRlcy5zbGljZShvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMzYpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWJhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHRoaXMucmVnMmJpbnMobWluLCBtYXgpOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2Ygb3ZlcmxhcHBpbmdCaW5zKSB7CiAgICAgICAgZm9yIChsZXQgYmluID0gc3RhcnQ7IGJpbiA8PSBlbmQ7IGJpbisrKSB7CiAgICAgICAgICBpZiAoYmEuYmluSW5kZXhbYmluXSkgewogICAgICAgICAgICBjb25zdCBiaW5DaHVua3MgPSBiYS5iaW5JbmRleFtiaW5dOwogICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykgewogICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBDaHVuayhiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApKTsKICAgIH0KICAgIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICAgIGJlZyAtPSAxOwogICAgICBpZiAoYmVnIDwgMSkgewogICAgICAgIGJlZyA9IDE7CiAgICAgIH0KICAgICAgaWYgKGVuZCA+IDIgKiogNTApIHsKICAgICAgICBlbmQgPSAyICoqIDM0OwogICAgICB9CiAgICAgIGVuZCAtPSAxOwogICAgICBsZXQgbCA9IDA7CiAgICAgIGxldCB0ID0gMDsKICAgICAgbGV0IHMgPSB0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDM7CiAgICAgIGNvbnN0IGJpbnMgPSBbXTsKICAgICAgZm9yICg7IGwgPD0gdGhpcy5kZXB0aDsgcyAtPSAzLCB0ICs9IGxzaGlmdCgxLCBsICogMyksIGwgKz0gMSkgewogICAgICAgIGNvbnN0IGIgPSB0ICsgcnNoaWZ0KGJlZywgcyk7CiAgICAgICAgY29uc3QgZSA9IHQgKyByc2hpZnQoZW5kLCBzKTsKICAgICAgICBpZiAoZSAtIGIgKyBiaW5zLmxlbmd0aCA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHF1ZXJ5ICR7YmVnfS0ke2VuZH0gaXMgdG9vIGxhcmdlIGZvciBjdXJyZW50IGJpbm5pbmcgc2NoZW1lIChzaGlmdCAke3RoaXMubWluU2hpZnR9LCBkZXB0aCAke3RoaXMuZGVwdGh9KSwgdHJ5IGEgc21hbGxlciBxdWVyeSBvciBhIGNvYXJzZXIgaW5kZXggYmlubmluZyBzY2hlbWVgKTsKICAgICAgICB9CiAgICAgICAgYmlucy5wdXNoKFtiLCBlXSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGJpbnM7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgdmFyIGRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICJ1bmRlZmluZWQiID8gbmV3IFRleHREZWNvZGVyKCJ1dGYtOCIpIDogdm9pZCAwOwogIGZ1bmN0aW9uIHRpbWVvdXQodGltZSkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKTsKICB9CiAgdmFyIFRhYml4SW5kZXhlZEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IHBhdGgsIGZpbGVoYW5kbGUsIHRiaVBhdGgsIHRiaUZpbGVoYW5kbGUsIGNzaVBhdGgsIGNzaUZpbGVoYW5kbGUsIHlpZWxkVGltZSA9IDUwMCwgY2h1bmtTaXplTGltaXQgPSA1ZTcsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiwgY2h1bmtDYWNoZVNpemUgPSA1ICogMiAqKiAyMCB9KSB7CiAgICAgIGlmIChmaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChwYXRoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCIpOwogICAgICB9CiAgICAgIGlmICh0YmlGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IHRiaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAoY3NpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHsKICAgICAgICAgIGZpbGVoYW5kbGU6IGNzaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAodGJpUGF0aCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgVGFiaXhJbmRleCh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KHRiaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KGNzaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChgJHtwYXRofS50YmlgKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgb25lIG9mIHRiaUZpbGVoYW5kbGUsIHRiaVBhdGgsIGNzaUZpbGVoYW5kbGUsIG9yIGNzaVBhdGgiKTsKICAgICAgfQogICAgICB0aGlzLmNodW5rU2l6ZUxpbWl0ID0gY2h1bmtTaXplTGltaXQ7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgICAgdGhpcy55aWVsZFRpbWUgPSB5aWVsZFRpbWU7CiAgICAgIHRoaXMuY2h1bmtDYWNoZSA9IG5ldyBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUuZGVmYXVsdCh7CiAgICAgICAgY2FjaGU6IG5ldyBpbXBvcnRfcXVpY2tfbHJ1LmRlZmF1bHQoeyBtYXhTaXplOiBNYXRoLmZsb29yKGNodW5rQ2FjaGVTaXplIC8gKDEgPDwgMTYpKSB9KSwKICAgICAgICBmaWxsOiAoYXJncywgc2lnbmFsKSA9PiB0aGlzLnJlYWRDaHVuayhhcmdzLCB7IHNpZ25hbCB9KQogICAgICB9KTsKICAgIH0KICAgIGFzeW5jIGdldExpbmVzKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdHMpIHsKICAgICAgbGV0IHNpZ25hbDsKICAgICAgbGV0IG9wdGlvbnMgPSB7fTsKICAgICAgbGV0IGNhbGxiYWNrOwogICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIik7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvcHRzOwogICAgICB9IGVsc2UgewogICAgICAgIG9wdGlvbnMgPSBvcHRzOwogICAgICAgIGNhbGxiYWNrID0gb3B0cy5saW5lQ2FsbGJhY2s7CiAgICAgIH0KICAgICAgaWYgKHJlZk5hbWUgPT09IHZvaWQgMCkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm11c3QgcHJvdmlkZSBhIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lIik7CiAgICAgIH0KICAgICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImxpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCIpOwogICAgICB9CiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5pbmRleC5nZXRNZXRhZGF0YShvcHRpb25zKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICBpZiAoIXN0YXJ0KSB7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9CiAgICAgIGlmICghZW5kKSB7CiAgICAgICAgZW5kID0gbWV0YWRhdGEubWF4UmVmTGVuZ3RoOwogICAgICB9CiAgICAgIGlmICghKHN0YXJ0IDw9IGVuZCkpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMuIHN0YXJ0IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGVuZCIpOwogICAgICB9CiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBjb25zdCBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKCk7CiAgICAgICAgaWYgKHNpemUgPiB0aGlzLmNodW5rU2l6ZUxpbWl0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtdWNoIGRhdGEuIENodW5rIHNpemUgJHtzaXplLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzIGV4Y2VlZHMgY2h1bmtTaXplTGltaXQgb2YgJHt0aGlzLmNodW5rU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCl9LmApOwogICAgICAgIH0KICAgICAgfQogICAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7CiAgICAgIGZvciAobGV0IGNodW5rTnVtID0gMDsgY2h1bmtOdW0gPCBjaHVua3MubGVuZ3RoOyBjaHVua051bSArPSAxKSB7CiAgICAgICAgbGV0IHByZXZpb3VzU3RhcnRDb29yZGluYXRlOwogICAgICAgIGNvbnN0IGMgPSBjaHVua3NbY2h1bmtOdW1dOwogICAgICAgIGNvbnN0IHsgYnVmZmVyLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zIH0gPSBhd2FpdCB0aGlzLmNodW5rQ2FjaGUuZ2V0KGMudG9TdHJpbmcoKSwgYyk7CiAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgIGxldCBibG9ja1N0YXJ0ID0gMDsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCA8IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGNvbnN0IG4gPSBidWZmZXIuaW5kZXhPZigiXG4iLCBibG9ja1N0YXJ0KTsKICAgICAgICAgIGlmIChuID09PSAtMSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IGIgPSBidWZmZXIuc2xpY2UoYmxvY2tTdGFydCwgbik7CiAgICAgICAgICBjb25zdCBsaW5lID0gKGRlY29kZXIgPT09IG51bGwgfHwgZGVjb2RlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb2Rlci5kZWNvZGUoYikpIHx8IGIudG9TdHJpbmcoKTsKICAgICAgICAgIGlmIChkcG9zaXRpb25zKSB7CiAgICAgICAgICAgIHdoaWxlIChibG9ja1N0YXJ0ICsgYy5taW52LmRhdGFQb3NpdGlvbiA+PSBkcG9zaXRpb25zW3BvcysrXSkgewogICAgICAgICAgICB9CiAgICAgICAgICAgIHBvcy0tOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgeyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzIH0gPSB0aGlzLmNoZWNrTGluZShtZXRhZGF0YSwgcmVmTmFtZSwgc3RhcnQsIGVuZCwgbGluZSk7CiAgICAgICAgICBpZiAocHJldmlvdXNTdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA+IHN0YXJ0Q29vcmRpbmF0ZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVzIG5vdCBzb3J0ZWQgYnkgc3RhcnQgY29vcmRpbmF0ZSAoJHtwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZX0gPiAke3N0YXJ0Q29vcmRpbmF0ZX0pLCB0aGlzIGZpbGUgaXMgbm90IHVzYWJsZSB3aXRoIFRhYml4LmApOwogICAgICAgICAgfQogICAgICAgICAgcHJldmlvdXNTdGFydENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGU7CiAgICAgICAgICBpZiAob3ZlcmxhcHMpIHsKICAgICAgICAgICAgY2FsbGJhY2sobGluZS50cmltKCksIGNwb3NpdGlvbnNbcG9zXSAqICgxIDw8IDgpICsgKGJsb2NrU3RhcnQgLSBkcG9zaXRpb25zW3Bvc10pICsgYy5taW52LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgfSBlbHNlIGlmIChzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgPj0gZW5kKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLnlpZWxkVGltZSAmJiBsYXN0IC0gRGF0ZS5ub3coKSA+IHRoaXMueWllbGRUaW1lKSB7CiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpOwogICAgICAgICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMSk7CiAgICAgICAgICB9CiAgICAgICAgICBibG9ja1N0YXJ0ID0gbiArIDE7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBhc3luYyBnZXRNZXRhZGF0YShvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0cyk7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXJCdWZmZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgZmlyc3REYXRhTGluZSwgbWV0YUNoYXIsIG1heEJsb2NrU2l6ZSB9ID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGNvbnN0IG1heEZldGNoID0gKChmaXJzdERhdGFMaW5lID09PSBudWxsIHx8IGZpcnN0RGF0YUxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0RGF0YUxpbmUuYmxvY2tQb3NpdGlvbikgfHwgMCkgKyBtYXhCbG9ja1NpemU7CiAgICAgIGxldCBieXRlcyA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oMCwgbWF4RmV0Y2gsIG9wdHMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgdHJ5IHsKICAgICAgICBieXRlcyA9IGF3YWl0IHVuemlwKGJ5dGVzKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBkZWNvbXByZXNzaW5nIGJsb2NrICR7ZS5jb2RlfSBhdCAwIChsZW5ndGggJHttYXhGZXRjaH0pICR7ZX1gKTsKICAgICAgfQogICAgICBpZiAobWV0YUNoYXIpIHsKICAgICAgICBsZXQgbGFzdE5ld2xpbmUgPSAtMTsKICAgICAgICBjb25zdCBuZXdsaW5lQnl0ZSA9ICJcbiIuY2hhckNvZGVBdCgwKTsKICAgICAgICBjb25zdCBtZXRhQnl0ZSA9IG1ldGFDaGFyLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgaWYgKGkgPT09IGxhc3ROZXdsaW5lICsgMSAmJiBieXRlc1tpXSAhPT0gbWV0YUJ5dGUpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnl0ZXNbaV0gPT09IG5ld2xpbmVCeXRlKSB7CiAgICAgICAgICAgIGxhc3ROZXdsaW5lID0gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgwLCBsYXN0TmV3bGluZSArIDEpOwogICAgICB9CiAgICAgIHJldHVybiBieXRlczsKICAgIH0KICAgIGFzeW5jIGdldEhlYWRlcihvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmdldEhlYWRlckJ1ZmZlcihvcHRzKTsKICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCJ1dGY4Iik7CiAgICB9CiAgICBhc3luYyBnZXRSZWZlcmVuY2VTZXF1ZW5jZU5hbWVzKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIHJldHVybiBtZXRhZGF0YS5yZWZJZFRvTmFtZTsKICAgIH0KICAgIGNoZWNrTGluZShtZXRhZGF0YSwgcmVnaW9uUmVmTmFtZSwgcmVnaW9uU3RhcnQsIHJlZ2lvbkVuZCwgbGluZSkgewogICAgICBjb25zdCB7IGNvbHVtbk51bWJlcnMsIG1ldGFDaGFyLCBjb29yZGluYXRlVHlwZSwgZm9ybWF0IH0gPSBtZXRhZGF0YTsKICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBtZXRhQ2hhcikgewogICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICB9CiAgICAgIGxldCB7IHJlZiwgc3RhcnQsIGVuZCB9ID0gY29sdW1uTnVtYmVyczsKICAgICAgaWYgKCFyZWYpIHsKICAgICAgICByZWYgPSAwOwogICAgICB9CiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICBzdGFydCA9IDA7CiAgICAgIH0KICAgICAgaWYgKCFlbmQpIHsKICAgICAgICBlbmQgPSAwOwogICAgICB9CiAgICAgIGlmIChmb3JtYXQgPT09ICJWQ0YiKSB7CiAgICAgICAgZW5kID0gODsKICAgICAgfQogICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChyZWYsIHN0YXJ0LCBlbmQpOwogICAgICBsZXQgY3VycmVudENvbHVtbk51bWJlciA9IDE7CiAgICAgIGxldCBjdXJyZW50Q29sdW1uU3RhcnQgPSAwOwogICAgICBsZXQgcmVmU2VxID0gIiI7CiAgICAgIGxldCBzdGFydENvb3JkaW5hdGUgPSAtSW5maW5pdHk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGggKyAxOyBpICs9IDEpIHsKICAgICAgICBpZiAobGluZVtpXSA9PT0gIgkiIHx8IGkgPT09IGxpbmUubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gcmVmKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnJlbmFtZVJlZlNlcShsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpICE9PSByZWdpb25SZWZOYW1lKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMCk7CiAgICAgICAgICAgIGlmIChjb29yZGluYXRlVHlwZSA9PT0gIjEtYmFzZWQtY2xvc2VkIikgewogICAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSAtPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgPj0gcmVnaW9uRW5kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kID09PSAwIHx8IGVuZCA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlICsgMSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAiVkNGIiAmJiBjdXJyZW50Q29sdW1uTnVtYmVyID09PSA0KSB7CiAgICAgICAgICAgIHJlZlNlcSA9IGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gZW5kKSB7CiAgICAgICAgICAgIGxldCBlbmRDb29yZGluYXRlOwogICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSB0aGlzLl9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlbmRDb29yZGluYXRlIDw9IHJlZ2lvblN0YXJ0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGN1cnJlbnRDb2x1bW5TdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VycmVudENvbHVtbk51bWJlciArPSAxOwogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPiBtYXhDb2x1bW4pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IHRydWUgfTsKICAgIH0KICAgIF9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGluZm8pIHsKICAgICAgbGV0IGVuZENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGUgKyByZWZTZXEubGVuZ3RoOwogICAgICBjb25zdCBpc1RSQSA9IGluZm8uaW5kZXhPZigiU1ZUWVBFPVRSQSIpICE9PSAtMTsKICAgICAgaWYgKGluZm9bMF0gIT09ICIuIiAmJiAhaXNUUkEpIHsKICAgICAgICBsZXQgcHJldkNoYXIgPSAiOyI7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLmxlbmd0aDsgaiArPSAxKSB7CiAgICAgICAgICBpZiAocHJldkNoYXIgPT09ICI7IiAmJiBpbmZvLnNsaWNlKGosIGogKyA0KSA9PT0gIkVORD0iKSB7CiAgICAgICAgICAgIGxldCB2YWx1ZUVuZCA9IGluZm8uaW5kZXhPZigiOyIsIGopOwogICAgICAgICAgICBpZiAodmFsdWVFbmQgPT09IC0xKSB7CiAgICAgICAgICAgICAgdmFsdWVFbmQgPSBpbmZvLmxlbmd0aDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQoaW5mby5zbGljZShqICsgNCwgdmFsdWVFbmQpLCAxMCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcHJldkNoYXIgPSBpbmZvW2pdOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc1RSQSkgewogICAgICAgIHJldHVybiBzdGFydENvb3JkaW5hdGUgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBlbmRDb29yZGluYXRlOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmTmFtZSwgb3B0cyk7CiAgICB9CiAgICBhc3luYyBfcmVhZFJlZ2lvbihwb3MsIHNpemUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBiID0gaW1wb3J0X2J1ZmZlcjcuQnVmZmVyLmFsbG9jKHNpemUpOwogICAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZChiLCAwLCBzaXplLCBwb3MsIG9wdHMpOwogICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzUmVhZCk7CiAgICB9CiAgICBhc3luYyByZWFkQ2h1bmsoYywgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKGMubWludi5ibG9ja1Bvc2l0aW9uLCBjLmZldGNoZWRTaXplKCksIG9wdHMpOwogICAgICB0cnkgewogICAgICAgIHJldHVybiB1bnppcENodW5rU2xpY2UoZGF0YSwgYyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgYyAke2MudG9TdHJpbmcoKX0gJHtlfWApOwogICAgICB9CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2dmZi9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9nZmYvZXNtL2FwaS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X3N0cmVhbSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9zdHJlYW1fYnJvd3NlcmlmeSgpKTsKICB2YXIgaW1wb3J0X3N0cmluZ19kZWNvZGVyID0gX190b01vZHVsZShyZXF1aXJlX3N0cmluZ19kZWNvZGVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS9wYXJzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2dmZi9lc20vdXRpbC5qcwogIHZhciB1dGlsX2V4cG9ydHMgPSB7fTsKICBfX2V4cG9ydCh1dGlsX2V4cG9ydHMsIHsKICAgIGVzY2FwZTogKCkgPT4gZXNjYXBlLAogICAgZXNjYXBlQ29sdW1uOiAoKSA9PiBlc2NhcGVDb2x1bW4sCiAgICBmb3JtYXRBdHRyaWJ1dGVzOiAoKSA9PiBmb3JtYXRBdHRyaWJ1dGVzLAogICAgZm9ybWF0Q29tbWVudDogKCkgPT4gZm9ybWF0Q29tbWVudCwKICAgIGZvcm1hdERpcmVjdGl2ZTogKCkgPT4gZm9ybWF0RGlyZWN0aXZlLAogICAgZm9ybWF0RmVhdHVyZTogKCkgPT4gZm9ybWF0RmVhdHVyZSwKICAgIGZvcm1hdEl0ZW06ICgpID0+IGZvcm1hdEl0ZW0sCiAgICBmb3JtYXRTZXF1ZW5jZTogKCkgPT4gZm9ybWF0U2VxdWVuY2UsCiAgICBwYXJzZUF0dHJpYnV0ZXM6ICgpID0+IHBhcnNlQXR0cmlidXRlcywKICAgIHBhcnNlRGlyZWN0aXZlOiAoKSA9PiBwYXJzZURpcmVjdGl2ZSwKICAgIHBhcnNlRmVhdHVyZTogKCkgPT4gcGFyc2VGZWF0dXJlLAogICAgdW5lc2NhcGU6ICgpID0+IHVuZXNjYXBlCiAgfSk7CiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZ1ZhbCkgewogICAgcmV0dXJuIHN0cmluZ1ZhbC5yZXBsYWNlKC8lKFswLTlBLUZhLWZdezJ9KS9nLCAoX21hdGNoLCBzZXEpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc2VxLCAxNikpKTsKICB9CiAgZnVuY3Rpb24gX2VzY2FwZShyZWdleCwgcykgewogICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKHJlZ2V4LCAoY2gpID0+IHsKICAgICAgY29uc3QgaGV4ID0gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAiMCIpOwogICAgICByZXR1cm4gYCUke2hleH1gOwogICAgfSk7CiAgfQogIGZ1bmN0aW9uIGVzY2FwZShyYXdWYWwpIHsKICAgIHJldHVybiBfZXNjYXBlKC9bXG47XHJcdD0lJixceDAwLVx4MWZceDdmLVx4ZmZdL2csIHJhd1ZhbCk7CiAgfQogIGZ1bmN0aW9uIGVzY2FwZUNvbHVtbihyYXdWYWwpIHsKICAgIHJldHVybiBfZXNjYXBlKC9bXG5cclx0JVx4MDAtXHgxZlx4N2YtXHhmZl0vZywgcmF3VmFsKTsKICB9CiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGF0dHJTdHJpbmcpIHsKICAgIGlmICghKGF0dHJTdHJpbmcgJiYgYXR0clN0cmluZy5sZW5ndGgpIHx8IGF0dHJTdHJpbmcgPT09ICIuIikKICAgICAgcmV0dXJuIHt9OwogICAgY29uc3QgYXR0cnMgPSB7fTsKICAgIGF0dHJTdHJpbmcucmVwbGFjZSgvXHI/XG4kLywgIiIpLnNwbGl0KCI7IikuZm9yRWFjaCgoYSkgPT4gewogICAgICBjb25zdCBudiA9IGEuc3BsaXQoIj0iLCAyKTsKICAgICAgaWYgKCEobnZbMV0gJiYgbnZbMV0ubGVuZ3RoKSkKICAgICAgICByZXR1cm47CiAgICAgIG52WzBdID0gbnZbMF0udHJpbSgpOwogICAgICBsZXQgYXJlYyA9IGF0dHJzW252WzBdLnRyaW0oKV07CiAgICAgIGlmICghYXJlYykgewogICAgICAgIGFyZWMgPSBbXTsKICAgICAgICBhdHRyc1tudlswXV0gPSBhcmVjOwogICAgICB9CiAgICAgIGFyZWMucHVzaCguLi5udlsxXS5zcGxpdCgiLCIpLm1hcCgocykgPT4gcy50cmltKCkpLm1hcCh1bmVzY2FwZSkpOwogICAgfSk7CiAgICByZXR1cm4gYXR0cnM7CiAgfQogIGZ1bmN0aW9uIHBhcnNlRmVhdHVyZShsaW5lKSB7CiAgICBjb25zdCBmID0gbGluZS5zcGxpdCgiCSIpLm1hcCgoYSkgPT4gYSA9PT0gIi4iIHx8IGEgPT09ICIiID8gbnVsbCA6IGEpOwogICAgY29uc3QgcGFyc2VkID0gewogICAgICBzZXFfaWQ6IGZbMF0gJiYgdW5lc2NhcGUoZlswXSksCiAgICAgIHNvdXJjZTogZlsxXSAmJiB1bmVzY2FwZShmWzFdKSwKICAgICAgdHlwZTogZlsyXSAmJiB1bmVzY2FwZShmWzJdKSwKICAgICAgc3RhcnQ6IGZbM10gPT09IG51bGwgPyBudWxsIDogcGFyc2VJbnQoZlszXSwgMTApLAogICAgICBlbmQ6IGZbNF0gPT09IG51bGwgPyBudWxsIDogcGFyc2VJbnQoZls0XSwgMTApLAogICAgICBzY29yZTogZls1XSA9PT0gbnVsbCA/IG51bGwgOiBwYXJzZUZsb2F0KGZbNV0pLAogICAgICBzdHJhbmQ6IGZbNl0sCiAgICAgIHBoYXNlOiBmWzddLAogICAgICBhdHRyaWJ1dGVzOiBmWzhdID09PSBudWxsID8gbnVsbCA6IHBhcnNlQXR0cmlidXRlcyhmWzhdKQogICAgfTsKICAgIHJldHVybiBwYXJzZWQ7CiAgfQogIGZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlKGxpbmUpIHsKICAgIGNvbnN0IG1hdGNoID0gL15ccyojI1xzKihcUyspXHMqKC4qKS8uZXhlYyhsaW5lKTsKICAgIGlmICghbWF0Y2gpCiAgICAgIHJldHVybiBudWxsOwogICAgY29uc3QgWywgbmFtZV0gPSBtYXRjaDsKICAgIGxldCBbLCAsIGNvbnRlbnRzXSA9IG1hdGNoOwogICAgY29uc3QgcGFyc2VkID0geyBkaXJlY3RpdmU6IG5hbWUgfTsKICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHsKICAgICAgY29udGVudHMgPSBjb250ZW50cy5yZXBsYWNlKC9ccj9cbiQvLCAiIik7CiAgICAgIHBhcnNlZC52YWx1ZSA9IGNvbnRlbnRzOwogICAgfQogICAgaWYgKG5hbWUgPT09ICJzZXF1ZW5jZS1yZWdpb24iKSB7CiAgICAgIGNvbnN0IGMgPSBjb250ZW50cy5zcGxpdCgvXHMrLywgMyk7CiAgICAgIHJldHVybiB7CiAgICAgICAgLi4ucGFyc2VkLAogICAgICAgIHNlcV9pZDogY1swXSwKICAgICAgICBzdGFydDogY1sxXSAmJiBjWzFdLnJlcGxhY2UoL1xEL2csICIiKSwKICAgICAgICBlbmQ6IGNbMl0gJiYgY1syXS5yZXBsYWNlKC9cRC9nLCAiIikKICAgICAgfTsKICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gImdlbm9tZS1idWlsZCIpIHsKICAgICAgY29uc3QgW3NvdXJjZSwgYnVpbGROYW1lXSA9IGNvbnRlbnRzLnNwbGl0KC9ccysvLCAyKTsKICAgICAgcmV0dXJuIHsKICAgICAgICAuLi5wYXJzZWQsCiAgICAgICAgc291cmNlLAogICAgICAgIGJ1aWxkTmFtZQogICAgICB9OwogICAgfQogICAgcmV0dXJuIHBhcnNlZDsKICB9CiAgZnVuY3Rpb24gZm9ybWF0QXR0cmlidXRlcyhhdHRycykgewogICAgY29uc3QgYXR0ck9yZGVyID0gW107CiAgICBPYmplY3QuZW50cmllcyhhdHRycykuZm9yRWFjaCgoW3RhZywgdmFsXSkgPT4gewogICAgICBpZiAoIXZhbCkKICAgICAgICByZXR1cm47CiAgICAgIGxldCB2YWxzdHJpbmc7CiAgICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkoInRvU3RyaW5nIikpIHsKICAgICAgICB2YWxzdHJpbmcgPSBlc2NhcGUodmFsLnRvU3RyaW5nKCkpOwogICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgewogICAgICAgIHZhbHN0cmluZyA9IHZhbC5tYXAoZXNjYXBlKS5qb2luKCIsIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFsc3RyaW5nID0gZXNjYXBlKHZhbCk7CiAgICAgIH0KICAgICAgYXR0ck9yZGVyLnB1c2goYCR7ZXNjYXBlKHRhZyl9PSR7dmFsc3RyaW5nfWApOwogICAgfSk7CiAgICByZXR1cm4gYXR0ck9yZGVyLmxlbmd0aCA/IGF0dHJPcmRlci5qb2luKCI7IikgOiAiLiI7CiAgfQogIGZ1bmN0aW9uIF9mb3JtYXRTaW5nbGVGZWF0dXJlKGYsIHNlZW5GZWF0dXJlKSB7CiAgICBjb25zdCBhdHRyU3RyaW5nID0gZi5hdHRyaWJ1dGVzID09PSBudWxsIHx8IGYuYXR0cmlidXRlcyA9PT0gdm9pZCAwID8gIi4iIDogZm9ybWF0QXR0cmlidXRlcyhmLmF0dHJpYnV0ZXMpOwogICAgY29uc3QgZmllbGRzID0gWwogICAgICBmLnNlcV9pZCA9PT0gbnVsbCA/ICIuIiA6IGVzY2FwZUNvbHVtbihmLnNlcV9pZCksCiAgICAgIGYuc291cmNlID09PSBudWxsID8gIi4iIDogZXNjYXBlQ29sdW1uKGYuc291cmNlKSwKICAgICAgZi50eXBlID09PSBudWxsID8gIi4iIDogZXNjYXBlQ29sdW1uKGYudHlwZSksCiAgICAgIGYuc3RhcnQgPT09IG51bGwgPyAiLiIgOiBlc2NhcGVDb2x1bW4oZi5zdGFydCksCiAgICAgIGYuZW5kID09PSBudWxsID8gIi4iIDogZXNjYXBlQ29sdW1uKGYuZW5kKSwKICAgICAgZi5zY29yZSA9PT0gbnVsbCA/ICIuIiA6IGVzY2FwZUNvbHVtbihmLnNjb3JlKSwKICAgICAgZi5zdHJhbmQgPT09IG51bGwgPyAiLiIgOiBlc2NhcGVDb2x1bW4oZi5zdHJhbmQpLAogICAgICBmLnBoYXNlID09PSBudWxsID8gIi4iIDogZXNjYXBlQ29sdW1uKGYucGhhc2UpLAogICAgICBhdHRyU3RyaW5nCiAgICBdOwogICAgY29uc3QgZm9ybWF0dGVkU3RyaW5nID0gYCR7ZmllbGRzLmpvaW4oIgkiKX0KYDsKICAgIGlmIChzZWVuRmVhdHVyZVtmb3JtYXR0ZWRTdHJpbmddKSB7CiAgICAgIHJldHVybiAiIjsKICAgIH0KICAgIHNlZW5GZWF0dXJlW2Zvcm1hdHRlZFN0cmluZ10gPSB0cnVlOwogICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZzsKICB9CiAgZnVuY3Rpb24gX2Zvcm1hdEZlYXR1cmUoZmVhdHVyZSwgc2VlbkZlYXR1cmUpIHsKICAgIGlmIChBcnJheS5pc0FycmF5KGZlYXR1cmUpKSB7CiAgICAgIHJldHVybiBmZWF0dXJlLm1hcCgoZikgPT4gX2Zvcm1hdEZlYXR1cmUoZiwgc2VlbkZlYXR1cmUpKS5qb2luKCIiKTsKICAgIH0KICAgIGNvbnN0IHN0cmluZ3MgPSBbX2Zvcm1hdFNpbmdsZUZlYXR1cmUoZmVhdHVyZSwgc2VlbkZlYXR1cmUpXTsKICAgIGlmIChfaXNGZWF0dXJlTGluZVdpdGhSZWZzKGZlYXR1cmUpKSB7CiAgICAgIHN0cmluZ3MucHVzaCguLi5mZWF0dXJlLmNoaWxkX2ZlYXR1cmVzLm1hcCgoZikgPT4gX2Zvcm1hdEZlYXR1cmUoZiwgc2VlbkZlYXR1cmUpKSwgLi4uZmVhdHVyZS5kZXJpdmVkX2ZlYXR1cmVzLm1hcCgoZikgPT4gX2Zvcm1hdEZlYXR1cmUoZiwgc2VlbkZlYXR1cmUpKSk7CiAgICB9CiAgICByZXR1cm4gc3RyaW5ncy5qb2luKCIiKTsKICB9CiAgZnVuY3Rpb24gZm9ybWF0RmVhdHVyZShmZWF0dXJlT3JGZWF0dXJlcykgewogICAgY29uc3Qgc2VlbiA9IHt9OwogICAgcmV0dXJuIF9mb3JtYXRGZWF0dXJlKGZlYXR1cmVPckZlYXR1cmVzLCBzZWVuKTsKICB9CiAgZnVuY3Rpb24gZm9ybWF0RGlyZWN0aXZlKGRpcmVjdGl2ZSkgewogICAgbGV0IHN0ciA9IGAjIyR7ZGlyZWN0aXZlLmRpcmVjdGl2ZX1gOwogICAgaWYgKGRpcmVjdGl2ZS52YWx1ZSkKICAgICAgc3RyICs9IGAgJHtkaXJlY3RpdmUudmFsdWV9YDsKICAgIHN0ciArPSAiXG4iOwogICAgcmV0dXJuIHN0cjsKICB9CiAgZnVuY3Rpb24gZm9ybWF0Q29tbWVudChjb21tZW50KSB7CiAgICByZXR1cm4gYCMgJHtjb21tZW50LmNvbW1lbnR9CmA7CiAgfQogIGZ1bmN0aW9uIGZvcm1hdFNlcXVlbmNlKHNlcSkgewogICAgcmV0dXJuIGA+JHtzZXEuaWR9JHtzZXEuZGVzY3JpcHRpb24gPyBgICR7c2VxLmRlc2NyaXB0aW9ufWAgOiAiIn0KJHtzZXEuc2VxdWVuY2V9CmA7CiAgfQogIGZ1bmN0aW9uIGZvcm1hdEl0ZW0oaXRlbU9ySXRlbXMpIHsKICAgIGZ1bmN0aW9uIGZvcm1hdFNpbmdsZUl0ZW0oaXRlbSkgewogICAgICBpZiAoImF0dHJpYnV0ZXMiIGluIGl0ZW0pCiAgICAgICAgcmV0dXJuIGZvcm1hdEZlYXR1cmUoaXRlbSk7CiAgICAgIGlmICgiZGlyZWN0aXZlIiBpbiBpdGVtKQogICAgICAgIHJldHVybiBmb3JtYXREaXJlY3RpdmUoaXRlbSk7CiAgICAgIGlmICgic2VxdWVuY2UiIGluIGl0ZW0pCiAgICAgICAgcmV0dXJuIGZvcm1hdFNlcXVlbmNlKGl0ZW0pOwogICAgICBpZiAoImNvbW1lbnQiIGluIGl0ZW0pCiAgICAgICAgcmV0dXJuIGZvcm1hdENvbW1lbnQoaXRlbSk7CiAgICAgIHJldHVybiAiIyAoaW52YWxpZCBpdGVtIGZvdW5kIGR1cmluZyBmb3JtYXQpXG4iOwogICAgfQogICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbU9ySXRlbXMpKSB7CiAgICAgIHJldHVybiBpdGVtT3JJdGVtcy5tYXAoZm9ybWF0U2luZ2xlSXRlbSk7CiAgICB9CiAgICByZXR1cm4gZm9ybWF0U2luZ2xlSXRlbShpdGVtT3JJdGVtcyk7CiAgfQogIGZ1bmN0aW9uIF9pc0ZlYXR1cmVMaW5lV2l0aFJlZnMoZmVhdHVyZUxpbmUpIHsKICAgIHJldHVybiBmZWF0dXJlTGluZS5jaGlsZF9mZWF0dXJlcyAhPT0gdm9pZCAwICYmIGZlYXR1cmVMaW5lLmRlcml2ZWRfZmVhdHVyZXMgIT09IHZvaWQgMDsKICB9CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9nZmYvZXNtL3BhcnNlLmpzCiAgdmFyIGNvbnRhaW5lckF0dHJpYnV0ZXMgPSB7CiAgICBQYXJlbnQ6ICJjaGlsZF9mZWF0dXJlcyIsCiAgICBEZXJpdmVzX2Zyb206ICJkZXJpdmVkX2ZlYXR1cmVzIgogIH07CiAgdmFyIEZBU1RBUGFyc2VyID0gY2xhc3MgewogICAgY29uc3RydWN0b3Ioc2VxQ2FsbGJhY2spIHsKICAgICAgdGhpcy5zZXFDYWxsYmFjayA9IHNlcUNhbGxiYWNrOwogICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHZvaWQgMDsKICAgIH0KICAgIGFkZExpbmUobGluZSkgewogICAgICBjb25zdCBkZWZNYXRjaCA9IC9ePlxzKihcUyspXHMqKC4qKS8uZXhlYyhsaW5lKTsKICAgICAgaWYgKGRlZk1hdGNoKSB7CiAgICAgICAgdGhpcy5fZmx1c2goKTsKICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHsgaWQ6IGRlZk1hdGNoWzFdLCBzZXF1ZW5jZTogIiIgfTsKICAgICAgICBpZiAoZGVmTWF0Y2hbMl0pCiAgICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5kZXNjcmlwdGlvbiA9IGRlZk1hdGNoWzJdLnRyaW0oKTsKICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSAmJiAvXFMvLnRlc3QobGluZSkpIHsKICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5zZXF1ZW5jZSArPSBsaW5lLnJlcGxhY2UoL1xzL2csICIiKTsKICAgICAgfQogICAgfQogICAgX2ZsdXNoKCkgewogICAgICBpZiAodGhpcy5jdXJyZW50U2VxdWVuY2UpCiAgICAgICAgdGhpcy5zZXFDYWxsYmFjayh0aGlzLmN1cnJlbnRTZXF1ZW5jZSk7CiAgICB9CiAgICBmaW5pc2goKSB7CiAgICAgIHRoaXMuX2ZsdXNoKCk7CiAgICB9CiAgfTsKICB2YXIgUGFyc2VyID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoYXJncykgewogICAgICB0aGlzLmZhc3RhUGFyc2VyID0gdm9pZCAwOwogICAgICB0aGlzLmVvZiA9IGZhbHNlOwogICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwOwogICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvblRvcExldmVsID0gW107CiAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uQnlJZCA9IHt9OwogICAgICB0aGlzLl9jb21wbGV0ZWRSZWZlcmVuY2VzID0ge307CiAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uT3JwaGFucyA9IHt9OwogICAgICBjb25zdCBudWxsRnVuYyA9ICgpID0+IHsKICAgICAgfTsKICAgICAgdGhpcy5mZWF0dXJlQ2FsbGJhY2sgPSBhcmdzLmZlYXR1cmVDYWxsYmFjayB8fCBudWxsRnVuYzsKICAgICAgdGhpcy5lbmRDYWxsYmFjayA9IGFyZ3MuZW5kQ2FsbGJhY2sgfHwgbnVsbEZ1bmM7CiAgICAgIHRoaXMuY29tbWVudENhbGxiYWNrID0gYXJncy5jb21tZW50Q2FsbGJhY2sgfHwgbnVsbEZ1bmM7CiAgICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IGFyZ3MuZXJyb3JDYWxsYmFjayB8fCBudWxsRnVuYzsKICAgICAgdGhpcy5kaXJlY3RpdmVDYWxsYmFjayA9IGFyZ3MuZGlyZWN0aXZlQ2FsbGJhY2sgfHwgbnVsbEZ1bmM7CiAgICAgIHRoaXMuc2VxdWVuY2VDYWxsYmFjayA9IGFyZ3Muc2VxdWVuY2VDYWxsYmFjayB8fCBudWxsRnVuYzsKICAgICAgdGhpcy5kaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzID0gYXJncy5kaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzIHx8IGZhbHNlOwogICAgICB0aGlzLmJ1ZmZlclNpemUgPSBhcmdzLmJ1ZmZlclNpemUgPT09IHZvaWQgMCA/IDFlMyA6IGFyZ3MuYnVmZmVyU2l6ZTsKICAgIH0KICAgIGFkZExpbmUobGluZSkgewogICAgICBpZiAodGhpcy5mYXN0YVBhcnNlcikgewogICAgICAgIHRoaXMuZmFzdGFQYXJzZXIuYWRkTGluZShsaW5lKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKHRoaXMuZW9mKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIHRoaXMubGluZU51bWJlciArPSAxOwogICAgICBpZiAoL15ccypbXiNccz5dLy50ZXN0KGxpbmUpKSB7CiAgICAgICAgdGhpcy5fYnVmZmVyTGluZShsaW5lKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgY29uc3QgbWF0Y2ggPSAvXlxzKigjKykoLiopLy5leGVjKGxpbmUpOwogICAgICBpZiAobWF0Y2gpIHsKICAgICAgICBjb25zdCBbLCBoYXNoc2lnbnNdID0gbWF0Y2g7CiAgICAgICAgbGV0IFssICwgY29udGVudHNdID0gbWF0Y2g7CiAgICAgICAgaWYgKGhhc2hzaWducy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgIHRoaXMuX2VtaXRBbGxVbmRlckNvbnN0cnVjdGlvbkZlYXR1cmVzKCk7CiAgICAgICAgfSBlbHNlIGlmIChoYXNoc2lnbnMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSBwYXJzZURpcmVjdGl2ZShsaW5lKTsKICAgICAgICAgIGlmIChkaXJlY3RpdmUpIHsKICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5kaXJlY3RpdmUgPT09ICJGQVNUQSIpIHsKICAgICAgICAgICAgICB0aGlzLl9lbWl0QWxsVW5kZXJDb25zdHJ1Y3Rpb25GZWF0dXJlcygpOwogICAgICAgICAgICAgIHRoaXMuZW9mID0gdHJ1ZTsKICAgICAgICAgICAgICB0aGlzLmZhc3RhUGFyc2VyID0gbmV3IEZBU1RBUGFyc2VyKHRoaXMuc2VxdWVuY2VDYWxsYmFjayk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy5fZW1pdEl0ZW0oZGlyZWN0aXZlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnJlcGxhY2UoL1xzKi8sICIiKTsKICAgICAgICAgIHRoaXMuX2VtaXRJdGVtKHsgY29tbWVudDogY29udGVudHMgfSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKC9eXHMqJC8udGVzdChsaW5lKSkgewogICAgICB9IGVsc2UgaWYgKC9eXHMqPi8udGVzdChsaW5lKSkgewogICAgICAgIHRoaXMuX2VtaXRBbGxVbmRlckNvbnN0cnVjdGlvbkZlYXR1cmVzKCk7CiAgICAgICAgdGhpcy5lb2YgPSB0cnVlOwogICAgICAgIHRoaXMuZmFzdGFQYXJzZXIgPSBuZXcgRkFTVEFQYXJzZXIodGhpcy5zZXF1ZW5jZUNhbGxiYWNrKTsKICAgICAgICB0aGlzLmZhc3RhUGFyc2VyLmFkZExpbmUobGluZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZXJyTGluZSA9IGxpbmUucmVwbGFjZSgvXHI/XG4/JC9nLCAiIik7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHRkYzIHBhcnNlIGVycm9yLiAgQ2Fubm90IHBhcnNlICcke2VyckxpbmV9Jy5gKTsKICAgICAgfQogICAgfQogICAgZmluaXNoKCkgewogICAgICB0aGlzLl9lbWl0QWxsVW5kZXJDb25zdHJ1Y3Rpb25GZWF0dXJlcygpOwogICAgICBpZiAodGhpcy5mYXN0YVBhcnNlcikKICAgICAgICB0aGlzLmZhc3RhUGFyc2VyLmZpbmlzaCgpOwogICAgICB0aGlzLmVuZENhbGxiYWNrKCk7CiAgICB9CiAgICBfZW1pdEl0ZW0oaSkgewogICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkKICAgICAgICB0aGlzLmZlYXR1cmVDYWxsYmFjayhpKTsKICAgICAgZWxzZSBpZiAoImRpcmVjdGl2ZSIgaW4gaSkKICAgICAgICB0aGlzLmRpcmVjdGl2ZUNhbGxiYWNrKGkpOwogICAgICBlbHNlIGlmICgiY29tbWVudCIgaW4gaSkKICAgICAgICB0aGlzLmNvbW1lbnRDYWxsYmFjayhpKTsKICAgIH0KICAgIF9lbmZvcmNlQnVmZmVyU2l6ZUxpbWl0KGFkZGl0aW9uYWxJdGVtQ291bnQgPSAwKSB7CiAgICAgIGNvbnN0IF91bmJ1ZmZlckl0ZW0gPSAoaXRlbSkgPT4gewogICAgICAgIGlmIChpdGVtICYmIEFycmF5LmlzQXJyYXkoaXRlbSkgJiYgaXRlbVswXS5hdHRyaWJ1dGVzICYmIGl0ZW1bMF0uYXR0cmlidXRlcy5JRCAmJiBpdGVtWzBdLmF0dHJpYnV0ZXMuSURbMF0pIHsKICAgICAgICAgIGNvbnN0IGlkcyA9IGl0ZW1bMF0uYXR0cmlidXRlcy5JRDsKICAgICAgICAgIGlkcy5mb3JFYWNoKChpZCkgPT4gewogICAgICAgICAgICBkZWxldGUgdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25CeUlkW2lkXTsKICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbXBsZXRlZFJlZmVyZW5jZXNbaWRdOwogICAgICAgICAgfSk7CiAgICAgICAgICBpdGVtLmZvckVhY2goKGkpID0+IHsKICAgICAgICAgICAgaWYgKGkuY2hpbGRfZmVhdHVyZXMpCiAgICAgICAgICAgICAgaS5jaGlsZF9mZWF0dXJlcy5mb3JFYWNoKChjKSA9PiBfdW5idWZmZXJJdGVtKGMpKTsKICAgICAgICAgICAgaWYgKGkuZGVyaXZlZF9mZWF0dXJlcykKICAgICAgICAgICAgICBpLmRlcml2ZWRfZmVhdHVyZXMuZm9yRWFjaCgoZCkgPT4gX3VuYnVmZmVySXRlbShkKSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHdoaWxlICh0aGlzLl91bmRlckNvbnN0cnVjdGlvblRvcExldmVsLmxlbmd0aCArIGFkZGl0aW9uYWxJdGVtQ291bnQgPiB0aGlzLmJ1ZmZlclNpemUpIHsKICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25Ub3BMZXZlbC5zaGlmdCgpOwogICAgICAgIGlmIChpdGVtKSB7CiAgICAgICAgICB0aGlzLl9lbWl0SXRlbShpdGVtKTsKICAgICAgICAgIF91bmJ1ZmZlckl0ZW0oaXRlbSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBfZW1pdEFsbFVuZGVyQ29uc3RydWN0aW9uRmVhdHVyZXMoKSB7CiAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uVG9wTGV2ZWwuZm9yRWFjaCh0aGlzLl9lbWl0SXRlbS5iaW5kKHRoaXMpKTsKICAgICAgdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25Ub3BMZXZlbCA9IFtdOwogICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvbkJ5SWQgPSB7fTsKICAgICAgdGhpcy5fY29tcGxldGVkUmVmZXJlbmNlcyA9IHt9OwogICAgICBpZiAoQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uT3JwaGFucykpLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgc29tZSBmZWF0dXJlcyByZWZlcmVuY2Ugb3RoZXIgZmVhdHVyZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIGZpbGUgKG9yIGluIHRoZSBzYW1lICcjIyMnIHNjb3BlKS4gJHtPYmplY3Qua2V5cyh0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnMpfWApOwogICAgICB9CiAgICB9CiAgICBfYnVmZmVyTGluZShsaW5lKSB7CiAgICAgIHZhciBfYSwgX2IsIF9jOwogICAgICBjb25zdCByYXdGZWF0dXJlTGluZSA9IHBhcnNlRmVhdHVyZShsaW5lKTsKICAgICAgY29uc3QgZmVhdHVyZUxpbmUgPSB7CiAgICAgICAgLi4ucmF3RmVhdHVyZUxpbmUsCiAgICAgICAgY2hpbGRfZmVhdHVyZXM6IFtdLAogICAgICAgIGRlcml2ZWRfZmVhdHVyZXM6IFtdCiAgICAgIH07CiAgICAgIGNvbnN0IGlkcyA9ICgoX2EgPSBmZWF0dXJlTGluZS5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuSUQpIHx8IFtdOwogICAgICBjb25zdCBwYXJlbnRzID0gKChfYiA9IGZlYXR1cmVMaW5lLmF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5QYXJlbnQpIHx8IFtdOwogICAgICBjb25zdCBkZXJpdmVzID0gdGhpcy5kaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzID8gW10gOiAoKF9jID0gZmVhdHVyZUxpbmUuYXR0cmlidXRlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLkRlcml2ZXNfZnJvbSkgfHwgW107CiAgICAgIGlmICghaWRzLmxlbmd0aCAmJiAhcGFyZW50cy5sZW5ndGggJiYgIWRlcml2ZXMubGVuZ3RoKSB7CiAgICAgICAgdGhpcy5fZW1pdEl0ZW0oW2ZlYXR1cmVMaW5lXSk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGxldCBmZWF0dXJlID0gdm9pZCAwOwogICAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHsKICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uQnlJZFtpZF07CiAgICAgICAgaWYgKGV4aXN0aW5nKSB7CiAgICAgICAgICBpZiAoZXhpc3RpbmdbZXhpc3RpbmcubGVuZ3RoIC0gMV0udHlwZSAhPT0gZmVhdHVyZUxpbmUudHlwZSkgewogICAgICAgICAgICB0aGlzLl9wYXJzZUVycm9yKGBtdWx0aS1saW5lIGZlYXR1cmUgIiR7aWR9IiBoYXMgaW5jb25zaXN0ZW50IHR5cGVzOiAiJHtmZWF0dXJlTGluZS50eXBlfSIsICIke2V4aXN0aW5nW2V4aXN0aW5nLmxlbmd0aCAtIDFdLnR5cGV9ImApOwogICAgICAgICAgfQogICAgICAgICAgZXhpc3RpbmcucHVzaChmZWF0dXJlTGluZSk7CiAgICAgICAgICBmZWF0dXJlID0gZXhpc3Rpbmc7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGZlYXR1cmUgPSBbZmVhdHVyZUxpbmVdOwogICAgICAgICAgdGhpcy5fZW5mb3JjZUJ1ZmZlclNpemVMaW1pdCgxKTsKICAgICAgICAgIGlmICghcGFyZW50cy5sZW5ndGggJiYgIWRlcml2ZXMubGVuZ3RoKSB7CiAgICAgICAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uVG9wTGV2ZWwucHVzaChmZWF0dXJlKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uQnlJZFtpZF0gPSBmZWF0dXJlOwogICAgICAgICAgdGhpcy5fcmVzb2x2ZVJlZmVyZW5jZXNUbyhmZWF0dXJlLCBpZCk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5fcmVzb2x2ZVJlZmVyZW5jZXNGcm9tKGZlYXR1cmUgfHwgW2ZlYXR1cmVMaW5lXSwgeyBQYXJlbnQ6IHBhcmVudHMsIERlcml2ZXNfZnJvbTogZGVyaXZlcyB9LCBpZHMpOwogICAgfQogICAgX3Jlc29sdmVSZWZlcmVuY2VzVG8oZmVhdHVyZSwgaWQpIHsKICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uT3JwaGFuc1tpZF07CiAgICAgIGlmICghcmVmZXJlbmNlcykKICAgICAgICByZXR1cm47CiAgICAgIGZlYXR1cmUuZm9yRWFjaCgobG9jKSA9PiB7CiAgICAgICAgbG9jLmNoaWxkX2ZlYXR1cmVzLnB1c2goLi4ucmVmZXJlbmNlcy5QYXJlbnQpOwogICAgICB9KTsKICAgICAgZmVhdHVyZS5mb3JFYWNoKChsb2MpID0+IHsKICAgICAgICBsb2MuZGVyaXZlZF9mZWF0dXJlcy5wdXNoKC4uLnJlZmVyZW5jZXMuRGVyaXZlc19mcm9tKTsKICAgICAgfSk7CiAgICAgIGRlbGV0ZSB0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnNbaWRdOwogICAgfQogICAgX3BhcnNlRXJyb3IobWVzc2FnZSkgewogICAgICB0aGlzLmVvZiA9IHRydWU7CiAgICAgIHRoaXMuZXJyb3JDYWxsYmFjayhgJHt0aGlzLmxpbmVOdW1iZXJ9OiAke21lc3NhZ2V9YCk7CiAgICB9CiAgICBfcmVzb2x2ZVJlZmVyZW5jZXNGcm9tKGZlYXR1cmUsIHJlZmVyZW5jZXMsIGlkcykgewogICAgICBmdW5jdGlvbiBwb3N0U2V0KG9iaiwgc2xvdDEsIHNsb3QyKSB7CiAgICAgICAgbGV0IHN1Yk9iaiA9IG9ialtzbG90MV07CiAgICAgICAgaWYgKCFzdWJPYmopIHsKICAgICAgICAgIHN1Yk9iaiA9IHt9OwogICAgICAgICAgb2JqW3Nsb3QxXSA9IHN1Yk9iajsKICAgICAgICB9CiAgICAgICAgY29uc3QgcmV0dXJuVmFsID0gc3ViT2JqW3Nsb3QyXSB8fCBmYWxzZTsKICAgICAgICBzdWJPYmpbc2xvdDJdID0gdHJ1ZTsKICAgICAgICByZXR1cm4gcmV0dXJuVmFsOwogICAgICB9CiAgICAgIHJlZmVyZW5jZXMuUGFyZW50LmZvckVhY2goKHRvSWQpID0+IHsKICAgICAgICBjb25zdCBvdGhlckZlYXR1cmUgPSB0aGlzLl91bmRlckNvbnN0cnVjdGlvbkJ5SWRbdG9JZF07CiAgICAgICAgaWYgKG90aGVyRmVhdHVyZSkgewogICAgICAgICAgY29uc3QgcG5hbWUgPSBjb250YWluZXJBdHRyaWJ1dGVzLlBhcmVudDsKICAgICAgICAgIGlmICghaWRzLmZpbHRlcigoaWQpID0+IHBvc3RTZXQodGhpcy5fY29tcGxldGVkUmVmZXJlbmNlcywgaWQsIGBQYXJlbnQsJHt0b0lkfWApKS5sZW5ndGgpIHsKICAgICAgICAgICAgb3RoZXJGZWF0dXJlLmZvckVhY2goKGxvY2F0aW9uKSA9PiB7CiAgICAgICAgICAgICAgbG9jYXRpb25bcG5hbWVdLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZXQgcmVmID0gdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25PcnBoYW5zW3RvSWRdOwogICAgICAgICAgaWYgKCFyZWYpIHsKICAgICAgICAgICAgcmVmID0gewogICAgICAgICAgICAgIFBhcmVudDogW10sCiAgICAgICAgICAgICAgRGVyaXZlc19mcm9tOiBbXQogICAgICAgICAgICB9OwogICAgICAgICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnNbdG9JZF0gPSByZWY7CiAgICAgICAgICB9CiAgICAgICAgICByZWYuUGFyZW50LnB1c2goZmVhdHVyZSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgcmVmZXJlbmNlcy5EZXJpdmVzX2Zyb20uZm9yRWFjaCgodG9JZCkgPT4gewogICAgICAgIGNvbnN0IG90aGVyRmVhdHVyZSA9IHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uQnlJZFt0b0lkXTsKICAgICAgICBpZiAob3RoZXJGZWF0dXJlKSB7CiAgICAgICAgICBjb25zdCBwbmFtZSA9IGNvbnRhaW5lckF0dHJpYnV0ZXMuRGVyaXZlc19mcm9tOwogICAgICAgICAgaWYgKCFpZHMuZmlsdGVyKChpZCkgPT4gcG9zdFNldCh0aGlzLl9jb21wbGV0ZWRSZWZlcmVuY2VzLCBpZCwgYERlcml2ZXNfZnJvbSwke3RvSWR9YCkpLmxlbmd0aCkgewogICAgICAgICAgICBvdGhlckZlYXR1cmUuZm9yRWFjaCgobG9jYXRpb24pID0+IHsKICAgICAgICAgICAgICBsb2NhdGlvbltwbmFtZV0ucHVzaChmZWF0dXJlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGxldCByZWYgPSB0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnNbdG9JZF07CiAgICAgICAgICBpZiAoIXJlZikgewogICAgICAgICAgICByZWYgPSB7CiAgICAgICAgICAgICAgUGFyZW50OiBbXSwKICAgICAgICAgICAgICBEZXJpdmVzX2Zyb206IFtdCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uT3JwaGFuc1t0b0lkXSA9IHJlZjsKICAgICAgICAgIH0KICAgICAgICAgIHJlZi5EZXJpdmVzX2Zyb20ucHVzaChmZWF0dXJlKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9nZmYvZXNtL2FwaS5qcwogIGZ1bmN0aW9uIF9jYWxsYmFjayhjYWxsYmFjaykgewogICAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5uZXh0VGljaykKICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7CiAgICBlbHNlCiAgICAgIGNhbGxiYWNrKCk7CiAgfQogIGZ1bmN0aW9uIF9wcm9jZXNzUGFyc2VPcHRpb25zKG9wdGlvbnMpIHsKICAgIGNvbnN0IG91dCA9IHsKICAgICAgZW5jb2Rpbmc6ICJ1dGY4IiwKICAgICAgcGFyc2VGZWF0dXJlczogdHJ1ZSwKICAgICAgcGFyc2VEaXJlY3RpdmVzOiBmYWxzZSwKICAgICAgcGFyc2VTZXF1ZW5jZXM6IHRydWUsCiAgICAgIHBhcnNlQ29tbWVudHM6IGZhbHNlLAogICAgICBidWZmZXJTaXplOiAxZTMsCiAgICAgIGRpc2FibGVEZXJpdmVzRnJvbVJlZmVyZW5jZXM6IGZhbHNlLAogICAgICAuLi5vcHRpb25zCiAgICB9OwogICAgaWYgKG9wdGlvbnMucGFyc2VBbGwpIHsKICAgICAgb3V0LnBhcnNlRmVhdHVyZXMgPSB0cnVlOwogICAgICBvdXQucGFyc2VEaXJlY3RpdmVzID0gdHJ1ZTsKICAgICAgb3V0LnBhcnNlQ29tbWVudHMgPSB0cnVlOwogICAgICBvdXQucGFyc2VTZXF1ZW5jZXMgPSB0cnVlOwogICAgfQogICAgcmV0dXJuIG91dDsKICB9CiAgdmFyIEdGRlRyYW5zZm9ybSA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X3N0cmVhbS5UcmFuc2Zvcm0gewogICAgY29uc3RydWN0b3IoaW5wdXRPcHRpb25zID0ge30pIHsKICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pOwogICAgICB0aGlzLnRleHRCdWZmZXIgPSAiIjsKICAgICAgY29uc3Qgb3B0aW9ucyA9IF9wcm9jZXNzUGFyc2VPcHRpb25zKGlucHV0T3B0aW9ucyk7CiAgICAgIHRoaXMuZW5jb2RpbmcgPSBpbnB1dE9wdGlvbnMuZW5jb2RpbmcgfHwgInV0ZjgiOwogICAgICB0aGlzLmRlY29kZXIgPSBuZXcgaW1wb3J0X3N0cmluZ19kZWNvZGVyLlN0cmluZ0RlY29kZXIoKTsKICAgICAgY29uc3QgcHVzaCA9IHRoaXMucHVzaC5iaW5kKHRoaXMpOwogICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIoewogICAgICAgIGZlYXR1cmVDYWxsYmFjazogb3B0aW9ucy5wYXJzZUZlYXR1cmVzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgICBkaXJlY3RpdmVDYWxsYmFjazogb3B0aW9ucy5wYXJzZURpcmVjdGl2ZXMgPyBwdXNoIDogdm9pZCAwLAogICAgICAgIGNvbW1lbnRDYWxsYmFjazogb3B0aW9ucy5wYXJzZUNvbW1lbnRzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgICBzZXF1ZW5jZUNhbGxiYWNrOiBvcHRpb25zLnBhcnNlU2VxdWVuY2VzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgICBlcnJvckNhbGxiYWNrOiAoZXJyKSA9PiB0aGlzLmVtaXQoImVycm9yIiwgZXJyKSwKICAgICAgICBidWZmZXJTaXplOiBvcHRpb25zLmJ1ZmZlclNpemUsCiAgICAgICAgZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlczogb3B0aW9ucy5kaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzCiAgICAgIH0pOwogICAgfQogICAgX2FkZExpbmUoZGF0YSkgewogICAgICBpZiAoZGF0YSkgewogICAgICAgIHRoaXMucGFyc2VyLmFkZExpbmUoZGF0YSk7CiAgICAgIH0KICAgIH0KICAgIF9uZXh0VGV4dChidWZmZXIpIHsKICAgICAgY29uc3QgcGllY2VzID0gKHRoaXMudGV4dEJ1ZmZlciArIGJ1ZmZlcikuc3BsaXQoL1xyP1xuLyk7CiAgICAgIHRoaXMudGV4dEJ1ZmZlciA9IHBpZWNlcy5wb3AoKSB8fCAiIjsKICAgICAgcGllY2VzLmZvckVhY2goKHBpZWNlKSA9PiB0aGlzLl9hZGRMaW5lKHBpZWNlKSk7CiAgICB9CiAgICBfdHJhbnNmb3JtKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAgIHRoaXMuX25leHRUZXh0KHRoaXMuZGVjb2Rlci53cml0ZShjaHVuaykpOwogICAgICBfY2FsbGJhY2soY2FsbGJhY2spOwogICAgfQogICAgX2ZsdXNoKGNhbGxiYWNrKSB7CiAgICAgIGlmICh0aGlzLmRlY29kZXIuZW5kKQogICAgICAgIHRoaXMuX25leHRUZXh0KHRoaXMuZGVjb2Rlci5lbmQoKSk7CiAgICAgIGlmICh0aGlzLnRleHRCdWZmZXIgIT0gbnVsbCkKICAgICAgICB0aGlzLl9hZGRMaW5lKHRoaXMudGV4dEJ1ZmZlcik7CiAgICAgIHRoaXMucGFyc2VyLmZpbmlzaCgpOwogICAgICBfY2FsbGJhY2soY2FsbGJhY2spOwogICAgfQogIH07CiAgZnVuY3Rpb24gcGFyc2VTdHJlYW0ob3B0aW9ucyA9IHt9KSB7CiAgICByZXR1cm4gbmV3IEdGRlRyYW5zZm9ybShvcHRpb25zKTsKICB9CiAgZnVuY3Rpb24gcGFyc2VTdHJpbmdTeW5jKHN0ciwgaW5wdXRPcHRpb25zID0ge30pIHsKICAgIGlmICghc3RyKQogICAgICByZXR1cm4gW107CiAgICBjb25zdCBvcHRpb25zID0gX3Byb2Nlc3NQYXJzZU9wdGlvbnMoaW5wdXRPcHRpb25zKTsKICAgIGNvbnN0IGl0ZW1zID0gW107CiAgICBjb25zdCBwdXNoID0gaXRlbXMucHVzaC5iaW5kKGl0ZW1zKTsKICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoewogICAgICBmZWF0dXJlQ2FsbGJhY2s6IG9wdGlvbnMucGFyc2VGZWF0dXJlcyA/IHB1c2ggOiB2b2lkIDAsCiAgICAgIGRpcmVjdGl2ZUNhbGxiYWNrOiBvcHRpb25zLnBhcnNlRGlyZWN0aXZlcyA/IHB1c2ggOiB2b2lkIDAsCiAgICAgIGNvbW1lbnRDYWxsYmFjazogb3B0aW9ucy5wYXJzZUNvbW1lbnRzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgc2VxdWVuY2VDYWxsYmFjazogb3B0aW9ucy5wYXJzZVNlcXVlbmNlcyA/IHB1c2ggOiB2b2lkIDAsCiAgICAgIGRpc2FibGVEZXJpdmVzRnJvbVJlZmVyZW5jZXM6IG9wdGlvbnMuZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlcyB8fCBmYWxzZSwKICAgICAgYnVmZmVyU2l6ZTogSW5maW5pdHksCiAgICAgIGVycm9yQ2FsbGJhY2s6IChlcnIpID0+IHsKICAgICAgICB0aHJvdyBlcnI7CiAgICAgIH0KICAgIH0pOwogICAgc3RyLnNwbGl0KC9ccj9cbi8pLmZvckVhY2gocGFyc2VyLmFkZExpbmUuYmluZChwYXJzZXIpKTsKICAgIHBhcnNlci5maW5pc2goKTsKICAgIHJldHVybiBpdGVtczsKICB9CiAgZnVuY3Rpb24gZm9ybWF0U3luYyhpdGVtcykgewogICAgY29uc3Qgb3RoZXIgPSBbXTsKICAgIGNvbnN0IHNlcXVlbmNlcyA9IFtdOwogICAgaXRlbXMuZm9yRWFjaCgoaSkgPT4gewogICAgICBpZiAoInNlcXVlbmNlIiBpbiBpKQogICAgICAgIHNlcXVlbmNlcy5wdXNoKGkpOwogICAgICBlbHNlCiAgICAgICAgb3RoZXIucHVzaChpKTsKICAgIH0pOwogICAgbGV0IHN0ciA9IG90aGVyLm1hcChmb3JtYXRJdGVtKS5qb2luKCIiKTsKICAgIGlmIChzZXF1ZW5jZXMubGVuZ3RoKSB7CiAgICAgIHN0ciArPSAiIyNGQVNUQVxuIjsKICAgICAgc3RyICs9IHNlcXVlbmNlcy5tYXAoZm9ybWF0U2VxdWVuY2UpLmpvaW4oIiIpOwogICAgfQogICAgcmV0dXJuIHN0cjsKICB9CiAgdmFyIEZvcm1hdHRpbmdUcmFuc2Zvcm0gPSBjbGFzcyBleHRlbmRzIGltcG9ydF9zdHJlYW0uVHJhbnNmb3JtIHsKICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkgewogICAgICBzdXBlcihPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgb2JqZWN0TW9kZTogdHJ1ZSB9KSk7CiAgICAgIHRoaXMubGluZXNTaW5jZUxhc3RTeW5jTWFyayA9IDA7CiAgICAgIHRoaXMuaGF2ZVdlRW1pdHRlZERhdGEgPSBmYWxzZTsKICAgICAgdGhpcy5mYXN0YU1vZGUgPSBmYWxzZTsKICAgICAgdGhpcy5taW5MaW5lc0JldHdlZW5TeW5jTWFya3MgPSBvcHRpb25zLm1pblN5bmNMaW5lcyB8fCAxMDA7CiAgICAgIHRoaXMuaW5zZXJ0VmVyc2lvbkRpcmVjdGl2ZSA9IG9wdGlvbnMuaW5zZXJ0VmVyc2lvbkRpcmVjdGl2ZSB8fCBmYWxzZTsKICAgIH0KICAgIF90cmFuc2Zvcm0oY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHsKICAgICAgbGV0IHN0cjsKICAgICAgaWYgKCF0aGlzLmhhdmVXZUVtaXR0ZWREYXRhICYmIHRoaXMuaW5zZXJ0VmVyc2lvbkRpcmVjdGl2ZSkgewogICAgICAgIGNvbnN0IHRoaXNDaHVuayA9IEFycmF5LmlzQXJyYXkoY2h1bmspID8gY2h1bmtbMF0gOiBjaHVuazsKICAgICAgICBpZiAoImRpcmVjdGl2ZSIgaW4gdGhpc0NodW5rKSB7CiAgICAgICAgICBpZiAodGhpc0NodW5rLmRpcmVjdGl2ZSAhPT0gImdmZi12ZXJzaW9uIikgewogICAgICAgICAgICB0aGlzLnB1c2goIiMjZ2ZmLXZlcnNpb24gM1xuIik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICgic2VxdWVuY2UiIGluIGNodW5rICYmICF0aGlzLmZhc3RhTW9kZSkgewogICAgICAgIHRoaXMucHVzaCgiIyNGQVNUQVxuIik7CiAgICAgICAgdGhpcy5mYXN0YU1vZGUgPSB0cnVlOwogICAgICB9CiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkKICAgICAgICBzdHIgPSBjaHVuay5tYXAoZm9ybWF0SXRlbSkuam9pbigiIik7CiAgICAgIGVsc2UKICAgICAgICBzdHIgPSBmb3JtYXRJdGVtKGNodW5rKTsKICAgICAgdGhpcy5wdXNoKHN0cik7CiAgICAgIGlmICh0aGlzLmxpbmVzU2luY2VMYXN0U3luY01hcmsgPj0gdGhpcy5taW5MaW5lc0JldHdlZW5TeW5jTWFya3MpIHsKICAgICAgICB0aGlzLnB1c2goIiMjI1xuIik7CiAgICAgICAgdGhpcy5saW5lc1NpbmNlTGFzdFN5bmNNYXJrID0gMDsKICAgICAgfSBlbHNlIHsKICAgICAgICBsZXQgY291bnQgPSAwOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBpZiAoc3RyW2ldID09PSAiXG4iKQogICAgICAgICAgICBjb3VudCArPSAxOwogICAgICAgIH0KICAgICAgICB0aGlzLmxpbmVzU2luY2VMYXN0U3luY01hcmsgKz0gY291bnQ7CiAgICAgIH0KICAgICAgdGhpcy5oYXZlV2VFbWl0dGVkRGF0YSA9IHRydWU7CiAgICAgIF9jYWxsYmFjayhjYWxsYmFjayk7CiAgICB9CiAgfTsKICBmdW5jdGlvbiBmb3JtYXRTdHJlYW0ob3B0aW9ucyA9IHt9KSB7CiAgICByZXR1cm4gbmV3IEZvcm1hdHRpbmdUcmFuc2Zvcm0ob3B0aW9ucyk7CiAgfQogIGZ1bmN0aW9uIGZvcm1hdEZpbGUoc3RyZWFtLCB3cml0ZVN0cmVhbSwgb3B0aW9ucyA9IHt9KSB7CiAgICBjb25zdCBuZXdPcHRpb25zID0gewogICAgICBpbnNlcnRWZXJzaW9uRGlyZWN0aXZlOiB0cnVlLAogICAgICAuLi5vcHRpb25zCiAgICB9OwogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgc3RyZWFtLnBpcGUobmV3IEZvcm1hdHRpbmdUcmFuc2Zvcm0obmV3T3B0aW9ucykpLm9uKCJlbmQiLCAoKSA9PiByZXNvbHZlKG51bGwpKS5vbigiZXJyb3IiLCByZWplY3QpLnBpcGUod3JpdGVTdHJlYW0pOwogICAgfSk7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS9pbmRleC5qcwogIHZhciBlc21fZGVmYXVsdCA9IHsKICAgIHBhcnNlU3RyZWFtLAogICAgcGFyc2VTdHJpbmdTeW5jLAogICAgZm9ybWF0U3luYywKICAgIGZvcm1hdFN0cmVhbSwKICAgIGZvcm1hdEZpbGUsCiAgICB1dGlsOiB1dGlsX2V4cG9ydHMKICB9OwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy93b3JrZXIubWpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfd29ya2VyID0gX190b01vZHVsZShyZXF1aXJlX3dvcmtlcigpKTsKICB2YXIgZXhwb3NlID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LmV4cG9zZTsKICB2YXIgcmVnaXN0ZXJTZXJpYWxpemVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LnJlZ2lzdGVyU2VyaWFsaXplcjsKICB2YXIgVHJhbnNmZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuVHJhbnNmZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbG9kYXNoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsOwogIHZhciBmcmVlR2xvYmFsX2RlZmF1bHQgPSBmcmVlR2xvYmFsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gIm9iamVjdCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsX2RlZmF1bHQgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICB2YXIgcm9vdF9kZWZhdWx0ID0gcm9vdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzCiAgdmFyIFN5bWJvbDIgPSByb290X2RlZmF1bHQuU3ltYm9sOwogIHZhciBTeW1ib2xfZGVmYXVsdCA9IFN5bWJvbDI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5OwogIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nOwogIHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbF9kZWZhdWx0ID8gU3ltYm9sX2RlZmF1bHQudG9TdHJpbmdUYWcgOiB2b2lkIDA7CiAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7CiAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgIHRyeSB7CiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHZvaWQgMDsKICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgIH0KICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTsKICAgIGlmICh1bm1hc2tlZCkgewogICAgICBpZiAoaXNPd24pIHsKICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGdldFJhd1RhZ19kZWZhdWx0ID0gZ2V0UmF3VGFnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8yID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nOwogIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcyLmNhbGwodmFsdWUpOwogIH0KICB2YXIgb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgdmFyIG51bGxUYWcgPSAiW29iamVjdCBOdWxsXSI7CiAgdmFyIHVuZGVmaW5lZFRhZyA9ICJbb2JqZWN0IFVuZGVmaW5lZF0iOwogIHZhciBzeW1Ub1N0cmluZ1RhZzIgPSBTeW1ib2xfZGVmYXVsdCA/IFN5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdm9pZCAwOwogIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHsKICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZzsKICAgIH0KICAgIHJldHVybiBzeW1Ub1N0cmluZ1RhZzIgJiYgc3ltVG9TdHJpbmdUYWcyIGluIE9iamVjdCh2YWx1ZSkgPyBnZXRSYXdUYWdfZGVmYXVsdCh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZ19kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGJhc2VHZXRUYWdfZGVmYXVsdCA9IGJhc2VHZXRUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICJvYmplY3QiOwogIH0KICB2YXIgaXNPYmplY3RMaWtlX2RlZmF1bHQgPSBpc09iamVjdExpa2U7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanMKICB2YXIgc3ltYm9sVGFnID0gIltvYmplY3QgU3ltYm9sXSI7CiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gInN5bWJvbCIgfHwgaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSkgPT0gc3ltYm9sVGFnOwogIH0KICB2YXIgaXNTeW1ib2xfZGVmYXVsdCA9IGlzU3ltYm9sOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlNYXBfZGVmYXVsdCA9IGFycmF5TWFwOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwogIHZhciBpc0FycmF5X2RlZmF1bHQgPSBpc0FycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xzLzsKICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7CiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoOwogICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7CiAgICB9CiAgICByZXR1cm4gaW5kZXg7CiAgfQogIHZhciB0cmltbWVkRW5kSW5kZXhfZGVmYXVsdCA9IHRyaW1tZWRFbmRJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICB2YXIgcmVUcmltU3RhcnQgPSAvXlxzKy87CiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7CiAgICByZXR1cm4gc3RyaW5nID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleF9kZWZhdWx0KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAiIikgOiBzdHJpbmc7CiAgfQogIHZhciBiYXNlVHJpbV9kZWZhdWx0ID0gYmFzZVRyaW07CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gIm9iamVjdCIgfHwgdHlwZSA9PSAiZnVuY3Rpb24iKTsKICB9CiAgdmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIHZhciBOQU4gPSAwIC8gMDsKICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pOwogIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pOwogIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pOwogIHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDsKICBmdW5jdGlvbiB0b051bWJlcjIodmFsdWUpIHsKICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIpIHsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogICAgaWYgKGlzU3ltYm9sX2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBOQU47CiAgICB9CiAgICBpZiAoaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gImZ1bmN0aW9uIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlOwogICAgICB2YWx1ZSA9IGlzT2JqZWN0X2RlZmF1bHQob3RoZXIpID8gb3RoZXIgKyAiIiA6IG90aGVyOwogICAgfQogICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAic3RyaW5nIikgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTsKICAgIH0KICAgIHZhbHVlID0gYmFzZVRyaW1fZGVmYXVsdCh2YWx1ZSk7CiAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpOwogICAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlOwogIH0KICB2YXIgdG9OdW1iZXJfZGVmYXVsdCA9IHRvTnVtYmVyMjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIHZhciBJTkZJTklUWSA9IDEgLyAwOwogIHZhciBNQVhfSU5URUdFUiA9IDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MjsKICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkgewogICAgaWYgKCF2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7CiAgICB9CiAgICB2YWx1ZSA9IHRvTnVtYmVyX2RlZmF1bHQodmFsdWUpOwogICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7CiAgICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxOwogICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSOwogICAgfQogICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDsKICB9CiAgdmFyIHRvRmluaXRlX2RlZmF1bHQgPSB0b0Zpbml0ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0ludGVnZXIuanMKICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHsKICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZV9kZWZhdWx0KHZhbHVlKSwgcmVtYWluZGVyID0gcmVzdWx0ICUgMTsKICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCA6IDA7CiAgfQogIHZhciB0b0ludGVnZXJfZGVmYXVsdCA9IHRvSW50ZWdlcjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBhc3luY1RhZyA9ICJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dIjsKICB2YXIgZnVuY1RhZyA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIGdlblRhZyA9ICJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSI7CiAgdmFyIHByb3h5VGFnID0gIltvYmplY3QgUHJveHldIjsKICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7CiAgICBpZiAoIWlzT2JqZWN0X2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpOwogICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZzsKICB9CiAgdmFyIGlzRnVuY3Rpb25fZGVmYXVsdCA9IGlzRnVuY3Rpb247CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7CiAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07CiAgICB9CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBjb3B5QXJyYXlfZGVmYXVsdCA9IGNvcHlBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXGQqKSQvOwogIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkgewogICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7CiAgICByZXR1cm4gISFsZW5ndGggJiYgKHR5cGUgPT0gIm51bWJlciIgfHwgdHlwZSAhPSAic3ltYm9sIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpOwogIH0KICB2YXIgaXNJbmRleF9kZWZhdWx0ID0gaXNJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHsKICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjsKICB9CiAgdmFyIGVxX2RlZmF1bHQgPSBlcTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIyID0gOTAwNzE5OTI1NDc0MDk5MTsKICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkgewogICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAibnVtYmVyIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVIyOwogIH0KICB2YXIgaXNMZW5ndGhfZGVmYXVsdCA9IGlzTGVuZ3RoOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoX2RlZmF1bHQodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl9kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGlzQXJyYXlMaWtlX2RlZmF1bHQgPSBpc0FycmF5TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkgewogICAgaWYgKCFpc09iamVjdF9kZWZhdWx0KG9iamVjdCkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7CiAgICBpZiAodHlwZSA9PSAibnVtYmVyIiA/IGlzQXJyYXlMaWtlX2RlZmF1bHQob2JqZWN0KSAmJiBpc0luZGV4X2RlZmF1bHQoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSAic3RyaW5nIiAmJiBpbmRleCBpbiBvYmplY3QpIHsKICAgICAgcmV0dXJuIGVxX2RlZmF1bHQob2JqZWN0W2luZGV4XSwgdmFsdWUpOwogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgaXNJdGVyYXRlZUNhbGxfZGVmYXVsdCA9IGlzSXRlcmF0ZWVDYWxsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8zID0gT2JqZWN0LnByb3RvdHlwZTsKICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkgewogICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAiZnVuY3Rpb24iICYmIEN0b3IucHJvdG90eXBlIHx8IG9iamVjdFByb3RvMzsKICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87CiAgfQogIHZhciBpc1Byb3RvdHlwZV9kZWZhdWx0ID0gaXNQcm90b3R5cGU7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkgewogICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG4pOwogICAgd2hpbGUgKCsraW5kZXggPCBuKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYmFzZVRpbWVzX2RlZmF1bHQgPSBiYXNlVGltZXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYXJnc1RhZyA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpID09IGFyZ3NUYWc7CiAgfQogIHZhciBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdCA9IGJhc2VJc0FyZ3VtZW50czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcwogIHZhciBvYmplY3RQcm90bzQgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTIgPSBvYmplY3RQcm90bzQuaGFzT3duUHJvcGVydHk7CiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG80LnByb3BlcnR5SXNFbnVtZXJhYmxlOwogIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50c19kZWZhdWx0KGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIGFyZ3VtZW50czsKICB9KCkpID8gYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQgOiBmdW5jdGlvbih2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eTIuY2FsbCh2YWx1ZSwgImNhbGxlZSIpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAiY2FsbGVlIik7CiAgfTsKICB2YXIgaXNBcmd1bWVudHNfZGVmYXVsdCA9IGlzQXJndW1lbnRzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciBzdHViRmFsc2VfZGVmYXVsdCA9IHN0dWJGYWxzZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcwogIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gIm9iamVjdCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwogIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzOwogIHZhciBCdWZmZXI5ID0gbW9kdWxlRXhwb3J0cyA/IHJvb3RfZGVmYXVsdC5CdWZmZXIgOiB2b2lkIDA7CiAgdmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyOSA/IEJ1ZmZlcjkuaXNCdWZmZXIgOiB2b2lkIDA7CiAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlX2RlZmF1bHQ7CiAgdmFyIGlzQnVmZmVyX2RlZmF1bHQgPSBpc0J1ZmZlcjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcyID0gIltvYmplY3QgQXJndW1lbnRzXSI7CiAgdmFyIGFycmF5VGFnID0gIltvYmplY3QgQXJyYXldIjsKICB2YXIgYm9vbFRhZyA9ICJbb2JqZWN0IEJvb2xlYW5dIjsKICB2YXIgZGF0ZVRhZyA9ICJbb2JqZWN0IERhdGVdIjsKICB2YXIgZXJyb3JUYWcgPSAiW29iamVjdCBFcnJvcl0iOwogIHZhciBmdW5jVGFnMiA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIG1hcFRhZyA9ICJbb2JqZWN0IE1hcF0iOwogIHZhciBudW1iZXJUYWcgPSAiW29iamVjdCBOdW1iZXJdIjsKICB2YXIgb2JqZWN0VGFnID0gIltvYmplY3QgT2JqZWN0XSI7CiAgdmFyIHJlZ2V4cFRhZyA9ICJbb2JqZWN0IFJlZ0V4cF0iOwogIHZhciBzZXRUYWcgPSAiW29iamVjdCBTZXRdIjsKICB2YXIgc3RyaW5nVGFnID0gIltvYmplY3QgU3RyaW5nXSI7CiAgdmFyIHdlYWtNYXBUYWcgPSAiW29iamVjdCBXZWFrTWFwXSI7CiAgdmFyIGFycmF5QnVmZmVyVGFnID0gIltvYmplY3QgQXJyYXlCdWZmZXJdIjsKICB2YXIgZGF0YVZpZXdUYWcgPSAiW29iamVjdCBEYXRhVmlld10iOwogIHZhciBmbG9hdDMyVGFnID0gIltvYmplY3QgRmxvYXQzMkFycmF5XSI7CiAgdmFyIGZsb2F0NjRUYWcgPSAiW29iamVjdCBGbG9hdDY0QXJyYXldIjsKICB2YXIgaW50OFRhZyA9ICJbb2JqZWN0IEludDhBcnJheV0iOwogIHZhciBpbnQxNlRhZyA9ICJbb2JqZWN0IEludDE2QXJyYXldIjsKICB2YXIgaW50MzJUYWcgPSAiW29iamVjdCBJbnQzMkFycmF5XSI7CiAgdmFyIHVpbnQ4VGFnID0gIltvYmplY3QgVWludDhBcnJheV0iOwogIHZhciB1aW50OENsYW1wZWRUYWcgPSAiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iOwogIHZhciB1aW50MTZUYWcgPSAiW29iamVjdCBVaW50MTZBcnJheV0iOwogIHZhciB1aW50MzJUYWcgPSAiW29iamVjdCBVaW50MzJBcnJheV0iOwogIHZhciB0eXBlZEFycmF5VGFncyA9IHt9OwogIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7CiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZzJdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7CiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBpc0xlbmd0aF9kZWZhdWx0KHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpXTsKICB9CiAgdmFyIGJhc2VJc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGJhc2VJc1R5cGVkQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykgewogICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTsKICAgIH07CiAgfQogIHZhciBiYXNlVW5hcnlfZGVmYXVsdCA9IGJhc2VVbmFyeTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVFeHBvcnRzMiA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZTIgPSBmcmVlRXhwb3J0czIgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMyID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMyOwogIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMyICYmIGZyZWVHbG9iYWxfZGVmYXVsdC5wcm9jZXNzOwogIHZhciBub2RlVXRpbCA9IGZ1bmN0aW9uKCkgewogICAgdHJ5IHsKICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIucmVxdWlyZSAmJiBmcmVlTW9kdWxlMi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7CiAgICAgIGlmICh0eXBlcykgewogICAgICAgIHJldHVybiB0eXBlczsKICAgICAgfQogICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCJ1dGlsIik7CiAgICB9IGNhdGNoIChlKSB7CiAgICB9CiAgfSgpOwogIHZhciBub2RlVXRpbF9kZWZhdWx0ID0gbm9kZVV0aWw7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzCiAgdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbF9kZWZhdWx0ICYmIG5vZGVVdGlsX2RlZmF1bHQuaXNUeXBlZEFycmF5OwogIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5X2RlZmF1bHQobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQ7CiAgdmFyIGlzVHlwZWRBcnJheV9kZWZhdWx0ID0gaXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNSA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5MyA9IG9iamVjdFByb3RvNS5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHsKICAgIHZhciBpc0FyciA9IGlzQXJyYXlfZGVmYXVsdCh2YWx1ZSksIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzX2RlZmF1bHQodmFsdWUpLCBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyX2RlZmF1bHQodmFsdWUpLCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5X2RlZmF1bHQodmFsdWUpLCBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzX2RlZmF1bHQodmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7CiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHsKICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkzLmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAibGVuZ3RoIiB8fCBpc0J1ZmYgJiYgKGtleSA9PSAib2Zmc2V0IiB8fCBrZXkgPT0gInBhcmVudCIpIHx8IGlzVHlwZSAmJiAoa2V5ID09ICJidWZmZXIiIHx8IGtleSA9PSAiYnl0ZUxlbmd0aCIgfHwga2V5ID09ICJieXRlT2Zmc2V0IikgfHwgaXNJbmRleF9kZWZhdWx0KGtleSwgbGVuZ3RoKSkpKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGFycmF5TGlrZUtleXNfZGVmYXVsdCA9IGFycmF5TGlrZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7CiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTsKICAgIH07CiAgfQogIHZhciBvdmVyQXJnX2RlZmF1bHQgPSBvdmVyQXJnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgdmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnX2RlZmF1bHQoT2JqZWN0LmtleXMsIE9iamVjdCk7CiAgdmFyIG5hdGl2ZUtleXNfZGVmYXVsdCA9IG5hdGl2ZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNiA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5NCA9IG9iamVjdFByb3RvNi5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHsKICAgIGlmICghaXNQcm90b3R5cGVfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBuYXRpdmVLZXlzX2RlZmF1bHQob2JqZWN0KTsKICAgIH0KICAgIHZhciByZXN1bHQgPSBbXTsKICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgICBpZiAoaGFzT3duUHJvcGVydHk0LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAiY29uc3RydWN0b3IiKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGJhc2VLZXlzX2RlZmF1bHQgPSBiYXNlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzCiAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsKICAgIHJldHVybiBpc0FycmF5TGlrZV9kZWZhdWx0KG9iamVjdCkgPyBhcnJheUxpa2VLZXlzX2RlZmF1bHQob2JqZWN0KSA6IGJhc2VLZXlzX2RlZmF1bHQob2JqZWN0KTsKICB9CiAgdmFyIGtleXNfZGVmYXVsdCA9IGtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbGFtcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHsKICAgIGlmIChudW1iZXIgPT09IG51bWJlcikgewogICAgICBpZiAodXBwZXIgIT09IHZvaWQgMCkgewogICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyOwogICAgICB9CiAgICAgIGlmIChsb3dlciAhPT0gdm9pZCAwKSB7CiAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBudW1iZXI7CiAgfQogIHZhciBiYXNlQ2xhbXBfZGVmYXVsdCA9IGJhc2VDbGFtcDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7CiAgICByZXR1cm4gYXJyYXlNYXBfZGVmYXVsdChwcm9wcywgZnVuY3Rpb24oa2V5KSB7CiAgICAgIHJldHVybiBvYmplY3Rba2V5XTsKICAgIH0pOwogIH0KICB2YXIgYmFzZVZhbHVlc19kZWZhdWx0ID0gYmFzZVZhbHVlczsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXNfZGVmYXVsdChvYmplY3QsIGtleXNfZGVmYXVsdChvYmplY3QpKTsKICB9CiAgdmFyIHZhbHVlc19kZWZhdWx0ID0gdmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3I7CiAgdmFyIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tOwogIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7CiAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpOwogIH0KICB2YXIgYmFzZVJhbmRvbV9kZWZhdWx0ID0gYmFzZVJhbmRvbTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxOwogICAgc2l6ZSA9IHNpemUgPT09IHZvaWQgMCA/IGxlbmd0aCA6IHNpemU7CiAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHsKICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tX2RlZmF1bHQoaW5kZXgsIGxhc3RJbmRleCksIHZhbHVlID0gYXJyYXlbcmFuZF07CiAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdOwogICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTsKICAgIH0KICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBzaHVmZmxlU2VsZl9kZWZhdWx0ID0gc2h1ZmZsZVNlbGY7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2FtcGxlU2l6ZS5qcwogIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikgewogICAgcmV0dXJuIHNodWZmbGVTZWxmX2RlZmF1bHQoY29weUFycmF5X2RlZmF1bHQoYXJyYXkpLCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0ID0gYXJyYXlTYW1wbGVTaXplOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7CiAgICB2YXIgYXJyYXkgPSB2YWx1ZXNfZGVmYXVsdChjb2xsZWN0aW9uKTsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGFycmF5LCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGJhc2VTYW1wbGVTaXplX2RlZmF1bHQgPSBiYXNlU2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkgewogICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGxfZGVmYXVsdChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB2b2lkIDApIHsKICAgICAgbiA9IDE7CiAgICB9IGVsc2UgewogICAgICBuID0gdG9JbnRlZ2VyX2RlZmF1bHQobik7CiAgICB9CiAgICB2YXIgZnVuYyA9IGlzQXJyYXlfZGVmYXVsdChjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0IDogYmFzZVNhbXBsZVNpemVfZGVmYXVsdDsKICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pOwogIH0KICB2YXIgc2FtcGxlU2l6ZV9kZWZhdWx0ID0gc2FtcGxlU2l6ZTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYXNjZW5kaW5nLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGFzY2VuZGluZ19kZWZhdWx0KGEsIGIpIHsKICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjsKICB9CgogIC8vIG5vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmlzZWN0b3JfZGVmYXVsdChmKSB7CiAgICBsZXQgZGVsdGEgPSBmOwogICAgbGV0IGNvbXBhcmUyID0gZjsKICAgIGlmIChmLmxlbmd0aCA9PT0gMSkgewogICAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDsKICAgICAgY29tcGFyZTIgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGYpOwogICAgfQogICAgZnVuY3Rpb24gbGVmdChhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICB3aGlsZSAobG8gPCBoaSkgewogICAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7CiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPCAwKQogICAgICAgICAgbG8gPSBtaWQgKyAxOwogICAgICAgIGVsc2UKICAgICAgICAgIGhpID0gbWlkOwogICAgICB9CiAgICAgIHJldHVybiBsbzsKICAgIH0KICAgIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA+IDApCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgICBlbHNlCiAgICAgICAgICBsbyA9IG1pZCArIDE7CiAgICAgIH0KICAgICAgcmV0dXJuIGxvOwogICAgfQogICAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpOwogICAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTsKICAgIH0KICAgIHJldHVybiB7IGxlZnQsIGNlbnRlciwgcmlnaHQgfTsKICB9CiAgZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7CiAgICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZ19kZWZhdWx0KGYoZCksIHgpOwogIH0KCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICB2YXIgRGF0YVNvdXJjZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGZpbGUsIGNocm9tU2l6ZXMsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5maWxlID0gZmlsZTsKICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGhpcy5jaHJvbUluZm8gPSBzaXplc1RvQ2hyb21JbmZvKGNocm9tU2l6ZXMpOwogICAgICB0aGlzLnRpbGVzZXRJbmZvID0gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKHRoaXMuY2hyb21JbmZvKTsKICAgIH0KICAgIGNocm9tSW5mbzsKICAgIHRpbGVzZXRJbmZvOwogIH07CiAgdmFyIGNocm9tSW5mb0Jpc2VjdG9yID0gYmlzZWN0b3JfZGVmYXVsdCgoZCkgPT4gZC5wb3MpLmxlZnQ7CiAgdmFyIGNoclRvQWJzID0gKGNocm9tLCBjaHJvbVBvcywgY2hyb21JbmZvKSA9PiBjaHJvbUluZm8uY2hyUG9zaXRpb25zW2Nocm9tXS5wb3MgKyBjaHJvbVBvczsKICB2YXIgYWJzVG9DaHIgPSAoYWJzUG9zaXRpb24sIGNocm9tSW5mbykgPT4gewogICAgaWYgKCFjaHJvbUluZm8gfHwgIWNocm9tSW5mby5jdW1Qb3NpdGlvbnMgfHwgIWNocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgbGV0IGluc2VydFBvaW50ID0gY2hyb21JbmZvQmlzZWN0b3IoY2hyb21JbmZvLmN1bVBvc2l0aW9ucywgYWJzUG9zaXRpb24pOwogICAgY29uc3QgbGFzdENociA9IGNocm9tSW5mby5jdW1Qb3NpdGlvbnNbY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxXS5jaHI7CiAgICBjb25zdCBsYXN0TGVuZ3RoID0gY2hyb21JbmZvLmNocm9tTGVuZ3Roc1tsYXN0Q2hyXTsKICAgIGluc2VydFBvaW50IC09IGluc2VydFBvaW50ID4gMCAmJiAxOwogICAgbGV0IGNoclBvc2l0aW9uID0gTWF0aC5mbG9vcihhYnNQb3NpdGlvbiAtIGNocm9tSW5mby5jdW1Qb3NpdGlvbnNbaW5zZXJ0UG9pbnRdLnBvcyk7CiAgICBsZXQgb2Zmc2V0ID0gMDsKICAgIGlmIChjaHJQb3NpdGlvbiA8IDApIHsKICAgICAgb2Zmc2V0ID0gY2hyUG9zaXRpb24gLSAxOwogICAgICBjaHJQb3NpdGlvbiA9IDE7CiAgICB9CiAgICBpZiAoaW5zZXJ0UG9pbnQgPT09IGNocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoIC0gMSAmJiBjaHJQb3NpdGlvbiA+IGxhc3RMZW5ndGgpIHsKICAgICAgb2Zmc2V0ID0gY2hyUG9zaXRpb24gLSBsYXN0TGVuZ3RoOwogICAgICBjaHJQb3NpdGlvbiA9IGxhc3RMZW5ndGg7CiAgICB9CiAgICByZXR1cm4gW2Nocm9tSW5mby5jdW1Qb3NpdGlvbnNbaW5zZXJ0UG9pbnRdLmNociwgY2hyUG9zaXRpb24sIG9mZnNldCwgaW5zZXJ0UG9pbnRdOwogIH07CiAgZnVuY3Rpb24gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKGNocm9tSW5mbywgdGlsZVNpemUgPSAxMDI0KSB7CiAgICByZXR1cm4gewogICAgICB0aWxlX3NpemU6IHRpbGVTaXplLAogICAgICBiaW5zX3Blcl9kaW1lbnNpb246IHRpbGVTaXplLAogICAgICBtYXhfem9vbTogTWF0aC5jZWlsKE1hdGgubG9nKGNocm9tSW5mby50b3RhbExlbmd0aCAvIHRpbGVTaXplKSAvIE1hdGgubG9nKDIpKSwKICAgICAgbWF4X3dpZHRoOiBjaHJvbUluZm8udG90YWxMZW5ndGgsCiAgICAgIG1pbl9wb3M6IFswXSwKICAgICAgbWF4X3BvczogW2Nocm9tSW5mby50b3RhbExlbmd0aF0KICAgIH07CiAgfQogIGZ1bmN0aW9uIHNpemVzVG9DaHJvbUluZm8oc2l6ZXMpIHsKICAgIGNvbnN0IGluZm8gPSB7CiAgICAgIGN1bVBvc2l0aW9uczogW10sCiAgICAgIGNocm9tTGVuZ3Roczoge30sCiAgICAgIGNoclBvc2l0aW9uczoge30sCiAgICAgIHRvdGFsTGVuZ3RoOiAwCiAgICB9OwogICAgc2l6ZXMuZm9yRWFjaCgoW2NociwgbGVuZ3RoXSwgaSkgPT4gewogICAgICBjb25zdCBjaHJQb3NpdGlvbiA9IHsgaWQ6IGksIGNociwgcG9zOiBpbmZvLnRvdGFsTGVuZ3RoIH07CiAgICAgIGluZm8uY2hyUG9zaXRpb25zW2Nocl0gPSBjaHJQb3NpdGlvbjsKICAgICAgaW5mby5jaHJvbUxlbmd0aHNbY2hyXSA9IGxlbmd0aDsKICAgICAgaW5mby5jdW1Qb3NpdGlvbnMucHVzaChjaHJQb3NpdGlvbik7CiAgICAgIGluZm8udG90YWxMZW5ndGggKz0gbGVuZ3RoOwogICAgfSk7CiAgICByZXR1cm4gewogICAgICAuLi5pbmZvLAogICAgICBhYnNUb0NocjogKGFic1BvcykgPT4gaW5mby5jaHJQb3NpdGlvbnMgPyBhYnNUb0NocihhYnNQb3MsIGluZm8pIDogbnVsbCwKICAgICAgY2hyVG9BYnM6IChbY2hyTmFtZSwgY2hyUG9zXSkgPT4gaW5mby5jaHJQb3NpdGlvbnMgPyBjaHJUb0FicyhjaHJOYW1lLCBjaHJQb3MsIGluZm8pIDogbnVsbAogICAgfTsKICB9CiAgdmFyIFJlbW90ZUZpbGUyID0gY2xhc3MgZXh0ZW5kcyBSZW1vdGVGaWxlIHsKICAgIHJlYWQgPSBhc3luYyAoYnVmZmVyLCBvZmZzZXQgPSAwLCBsZW5ndGgsIHBvc2l0aW9uID0gMCwgb3B0cyA9IHt9KSA9PiB7CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBpZiAobGVuZ3RoIDwgSW5maW5pdHkpIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YDsKICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IEluZmluaXR5ICYmIHBvc2l0aW9uICE9PSAwKSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gOwogICAgICB9CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLAogICAgICAgIC4uLm92ZXJyaWRlcywKICAgICAgICBoZWFkZXJzOiB7CiAgICAgICAgICAuLi5oZWFkZXJzLAogICAgICAgICAgLi4ub3ZlcnJpZGVzLmhlYWRlcnMsCiAgICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycwogICAgICAgIH0sCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbAogICAgICB9OwogICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godGhpcy51cmwsIGFyZ3MpOwogICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7dGhpcy51cmx9YCk7CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7CiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gcmVzcG9uc2VEYXRhLmNvcHkoYnVmZmVyLCBvZmZzZXQsIDAsIE1hdGgubWluKGxlbmd0aCwgcmVzcG9uc2VEYXRhLmxlbmd0aCkpOwogICAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgY29uc3Qgc2l6ZU1hdGNoID0gL1wvKFxkKykkLy5leGVjKHJlcyB8fCAiIik7CiAgICAgICAgaWYgKHNpemVNYXRjaCAmJiBzaXplTWF0Y2hbMV0pIHsKICAgICAgICAgIHRoaXMuX3N0YXQgPSB7IHNpemU6IHBhcnNlSW50KHNpemVNYXRjaFsxXSwgMTApIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH07CiAgfTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvZ2ZmL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGlzR0ZGM0ZlYXR1cmUoZW50cnkpIHsKICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVudHJ5KTsKICB9CiAgZnVuY3Rpb24gbWFrZVJhbmRvbVNvcnRlZEFycmF5KG4sIG1heFZhbHVlKSB7CiAgICBjb25zdCByYW5kb21BcnJheSA9IFtdOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heFZhbHVlICsgMSkpOwogICAgICByYW5kb21BcnJheS5wdXNoKHJhbmRvbU51bWJlcik7CiAgICB9CiAgICBjb25zdCBzb3J0ZWQgPSByYW5kb21BcnJheS5zb3J0KChhLCBiKSA9PiBhIC0gYik7CiAgICByZXR1cm4gWy4uLm5ldyBTZXQoc29ydGVkKV07CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9nZmYvZ2ZmLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgdmFyIEdmZkZpbGUgPSBjbGFzcyB7CiAgICAjdWlkOwogICAgdGJpOwogICAgI25fZmVhdHVyZXM7CiAgICBjb25zdHJ1Y3Rvcih0YmksIHVpZCkgewogICAgICB0aGlzLnRiaSA9IHRiaTsKICAgICAgdGhpcy4jdWlkID0gdWlkOwogICAgfQogICAgc3RhdGljIGZyb21VcmwodXJsLCBpbmRleFVybCwgdWlkLCB1cmxGZXRjaE9wdGlvbnMsIGluZGV4VXJsRmV0Y2hPcHRpb25zKSB7CiAgICAgIGNvbnN0IHRiaSA9IG5ldyBUYWJpeEluZGV4ZWRGaWxlKHsKICAgICAgICBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZTIodXJsLCB7IG92ZXJyaWRlczogdXJsRmV0Y2hPcHRpb25zIH0pLAogICAgICAgIHRiaUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMihpbmRleFVybCwgeyBvdmVycmlkZXM6IGluZGV4VXJsRmV0Y2hPcHRpb25zIH0pCiAgICAgIH0pOwogICAgICByZXR1cm4gbmV3IEdmZkZpbGUodGJpLCB1aWQpOwogICAgfQogICAgYXN5bmMgI2dldE51bWJlckZlYXR1cmVzKCkgewogICAgICBpZiAoIXRoaXMuI25fZmVhdHVyZXMpIHsKICAgICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgICBjb25zdCB7IGN1bVBvc2l0aW9ucyB9ID0gc291cmNlLmNocm9tSW5mbzsKICAgICAgICBjb25zdCBjb3VudFByb21pc2VzID0gW107CiAgICAgICAgZm9yIChjb25zdCBjdW1Qb3Mgb2YgY3VtUG9zaXRpb25zKSB7CiAgICAgICAgICBjb25zdCBjaHJvbU5hbWUgPSBjdW1Qb3MuY2hyOwogICAgICAgICAgY291bnRQcm9taXNlcy5wdXNoKHRoaXMudGJpLmxpbmVDb3VudChjaHJvbU5hbWUpKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgY291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY291bnRQcm9taXNlcyk7CiAgICAgICAgY29uc3QgdG90YWxfY291bnRzID0gY291bnRzLnJlZHVjZSgoYWNjLCBjdXIpID0+IGFjYyArIGN1ciwgMCk7CiAgICAgICAgdGhpcy4jbl9mZWF0dXJlcyA9IHRvdGFsX2NvdW50czsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy4jbl9mZWF0dXJlczsKICAgIH0KICAgICNnZXRMaW5lUHJvbWlzZXMobWluWCwgbWF4WCkgewogICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgbGV0IGN1ck1pblggPSBtaW5YOwogICAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBzb3VyY2UuY2hyb21JbmZvOwogICAgICBjb25zdCBsaW5lUHJvbWlzZXMgPSBbXTsKICAgICAgY29uc3QgTUFYX0ZFQVRVUkVTID0gNWU1OwogICAgICBjb25zdCBNQVhfV0lORE9XID0gNGU2OwogICAgICBpZiAodGhpcy4jbl9mZWF0dXJlcyAmJiB0aGlzLiNuX2ZlYXR1cmVzID4gTUFYX0ZFQVRVUkVTICYmIG1heFggLSBtaW5YID4gTUFYX1dJTkRPVykgewogICAgICAgIGNvbnN0IGRpZmYgPSBtYXhYIC0gbWluWDsKICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gNWU0OwogICAgICAgIGNvbnN0IG5fc2FtcGxlcyA9IDEwMDsKICAgICAgICBjb25zdCB0b3RhbEJpbnMgPSBNYXRoLmZsb29yKGRpZmYgLyB3aW5kb3dTaXplKTsKICAgICAgICBjb25zdCBzZWxlY3RlZEJpbnMgPSBtYWtlUmFuZG9tU29ydGVkQXJyYXkobl9zYW1wbGVzLCB0b3RhbEJpbnMpOwogICAgICAgIGNvbnN0IGJpbkxpbmVzID0gc2VsZWN0ZWRCaW5zLm1hcCgoYmluKSA9PiB7CiAgICAgICAgICBjb25zdCBiaW5TdGFydCA9IG1pblggKyBiaW4gKiB3aW5kb3dTaXplOwogICAgICAgICAgY29uc3QgYmluRW5kID0gYmluU3RhcnQgKyB3aW5kb3dTaXplOwogICAgICAgICAgcmV0dXJuIHRoaXMuI2dldExpbmVQcm9taXNlcyhiaW5TdGFydCwgYmluRW5kKTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gYmluTGluZXMuZmxhdCgpOwogICAgICB9CiAgICAgIGZvciAoY29uc3QgY3VtUG9zIG9mIGN1bVBvc2l0aW9ucykgewogICAgICAgIGNvbnN0IGNocm9tTmFtZSA9IGN1bVBvcy5jaHI7CiAgICAgICAgY29uc3QgY2hyb21TdGFydCA9IGN1bVBvcy5wb3M7CiAgICAgICAgY29uc3QgY2hyb21FbmQgPSBjdW1Qb3MucG9zICsgY2hyb21MZW5ndGhzW2Nocm9tTmFtZV07CiAgICAgICAgbGV0IHN0YXJ0UG9zLCBlbmRQb3M7CiAgICAgICAgaWYgKGNocm9tU3RhcnQgPiBjdXJNaW5YIHx8IGN1ck1pblggPj0gY2hyb21FbmQpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBjb25zdCBsaW5lUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICAgICAgICBjb25zdCBsaW5lcyA9IFtdOwogICAgICAgICAgY29uc3QgbGluZUNhbGxiYWNrID0gKGxpbmUpID0+IHsKICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTsKICAgICAgICAgIH07CiAgICAgICAgICBpZiAobWF4WCA+IGNocm9tRW5kKSB7CiAgICAgICAgICAgIHN0YXJ0UG9zID0gY3VyTWluWCAtIGNocm9tU3RhcnQ7CiAgICAgICAgICAgIGVuZFBvcyA9IGNocm9tRW5kIC0gY2hyb21TdGFydDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXJ0UG9zID0gTWF0aC5mbG9vcihjdXJNaW5YIC0gY2hyb21TdGFydCk7CiAgICAgICAgICAgIGVuZFBvcyA9IE1hdGguY2VpbChtYXhYIC0gY2hyb21TdGFydCk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVDYWxsYmFjaykudGhlbigoKSA9PiB7CiAgICAgICAgICAgIHJlc29sdmUobGluZXMpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgbGluZVByb21pc2VzLnB1c2gobGluZVByb21pc2UpOwogICAgICAgIGlmIChtYXhYIDw9IGNocm9tRW5kKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY3VyTWluWCA9IGNocm9tRW5kOwogICAgICB9CiAgICAgIHJldHVybiBsaW5lUHJvbWlzZXM7CiAgICB9CiAgICBhc3luYyBnZXRUaWxlRGF0YShtaW5YLCBtYXhYKSB7CiAgICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh0aGlzLiN1aWQpOwogICAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBzb3VyY2Uub3B0aW9ucy5zYW1wbGVMZW5ndGg7CiAgICAgIGNvbnN0IGF0dHJpYnV0ZXNUb0ZpZWxkcyA9IHNvdXJjZS5vcHRpb25zLmF0dHJpYnV0ZXNUb0ZpZWxkczsKICAgICAgYXdhaXQgdGhpcy4jZ2V0TnVtYmVyRmVhdHVyZXMoKTsKICAgICAgZnVuY3Rpb24gZmlsdGVyTGluZXMobGluZXMpIHsKICAgICAgICBjb25zdCBub25DaGlsZExpbmVzID0gbGluZXMuZmlsdGVyKChsaW5lKSA9PiB7CiAgICAgICAgICBjb25zdCBsaW5lQ29sdW1ucyA9IGxpbmUuc3BsaXQoIgkiKTsKICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBsaW5lQ29sdW1uc1s4XTsKICAgICAgICAgIHJldHVybiAhYXR0cmlidXRlcy5pbmNsdWRlcygiUGFyZW50PSIpOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiBzYW1wbGVTaXplX2RlZmF1bHQobm9uQ2hpbGRMaW5lcywgc2FtcGxlTGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwYXJzZWRMaW5lc1RvVGlsZXMocGFyc2VkKSB7CiAgICAgICAgbGV0IHRpbGVzMiA9IFtdOwogICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBwYXJzZWQpIHsKICAgICAgICAgIGlmIChpc0dGRjNGZWF0dXJlKGxpbmUpKSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBsaW5lKSB7CiAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc2VxX2lkICYmIGZlYXR1cmUuc3RhcnQpCiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0YXJ0ID0gc291cmNlLmNocm9tSW5mby5jaHJUb0FicyhbZmVhdHVyZS5zZXFfaWQsIGZlYXR1cmUuc3RhcnRdKTsKICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zZXFfaWQgJiYgZmVhdHVyZS5lbmQpCiAgICAgICAgICAgICAgICBmZWF0dXJlLmVuZCA9IHNvdXJjZS5jaHJvbUluZm8uY2hyVG9BYnMoW2ZlYXR1cmUuc2VxX2lkLCBmZWF0dXJlLmVuZF0pOwogICAgICAgICAgICAgIHRpbGVzMi5wdXNoKGZlYXR1cmUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChhdHRyaWJ1dGVzVG9GaWVsZHMpIHsKICAgICAgICAgIHRpbGVzMiA9IHRpbGVzMi5tYXAoKHRpbGUyKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aWxlMi5hdHRyaWJ1dGVzOwogICAgICAgICAgICBjb25zdCBjbGVhbkF0dCA9IHt9OwogICAgICAgICAgICBhdHRyaWJ1dGVzVG9GaWVsZHMuZm9yRWFjaCgoYXR0TWFwKSA9PiB7CiAgICAgICAgICAgICAgY29uc3QgYXR0TmFtZSA9IGF0dE1hcC5hdHRyaWJ1dGU7CiAgICAgICAgICAgICAgY29uc3QgYXR0RGVmYXVsdCA9IGF0dE1hcC5kZWZhdWx0VmFsdWU7CiAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCB8fCAhKGF0dE5hbWUgaW4gYXR0cmlidXRlcykgfHwgIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlc1thdHROYW1lXSkpCiAgICAgICAgICAgICAgICBjbGVhbkF0dFthdHROYW1lXSA9IGF0dERlZmF1bHQ7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBhdHRWYWwgPSBhdHRyaWJ1dGVzW2F0dE5hbWVdOwogICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0VmFsKSkgewogICAgICAgICAgICAgICAgICBjbGVhbkF0dFthdHROYW1lXSA9IGF0dFZhbC5sZW5ndGggPT0gMSA/IGF0dFZhbFswXSA6IGF0dFZhbC5qb2luKCIsIik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIHsgLi4udGlsZTIsIC4uLmNsZWFuQXR0IH07CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRpbGVzMjsKICAgICAgfQogICAgICBjb25zdCBsaW5lUHJvbWlzZXMgPSB0aGlzLiNnZXRMaW5lUHJvbWlzZXMobWluWCwgbWF4WCk7CiAgICAgIGNvbnN0IGFsbExpbmVzID0gKGF3YWl0IFByb21pc2UuYWxsKGxpbmVQcm9taXNlcykpLmZsYXQoKTsKICAgICAgbGV0IGxpbmVzVG9QYXJzZSA9IFtdOwogICAgICBpZiAoYWxsTGluZXMubGVuZ3RoID4gc2FtcGxlTGVuZ3RoKSB7CiAgICAgICAgbGluZXNUb1BhcnNlID0gZmlsdGVyTGluZXMoYWxsTGluZXMpOwogICAgICB9IGVsc2UgewogICAgICAgIGxpbmVzVG9QYXJzZSA9IGFsbExpbmVzOwogICAgICB9CiAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IHsKICAgICAgICBkaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzOiB0cnVlLAogICAgICAgIHBhcnNlRmVhdHVyZXM6IHRydWUsCiAgICAgICAgcGFyc2VDb21tZW50czogZmFsc2UsCiAgICAgICAgcGFyc2VEaXJlY3RpdmVzOiBmYWxzZSwKICAgICAgICBwYXJzZVNlcXVlbmNlczogZmFsc2UKICAgICAgfTsKICAgICAgY29uc3QgcGFyc2VkTGluZXMgPSBlc21fZGVmYXVsdC5wYXJzZVN0cmluZ1N5bmMobGluZXNUb1BhcnNlLmpvaW4oIlxuIiksIHBhcnNlT3B0aW9ucyk7CiAgICAgIGNvbnN0IHRpbGVzID0gcGFyc2VkTGluZXNUb1RpbGVzKHBhcnNlZExpbmVzKTsKICAgICAgcmV0dXJuIHRpbGVzOwogICAgfQogIH07CiAgdmFyIGdmZkZpbGVzID0gbmV3IE1hcCgpOwogIHZhciB0aWxlVmFsdWVzID0ge307CiAgdmFyIGRhdGFTb3VyY2VzID0gbmV3IE1hcCgpOwogIGZ1bmN0aW9uIGluaXQodWlkLCBiZWQsIGNocm9tU2l6ZXMsIG9wdGlvbnMgPSB7fSkgewogICAgbGV0IGdmZkZpbGUgPSBnZmZGaWxlcy5nZXQoYmVkLnVybCk7CiAgICBpZiAoIWdmZkZpbGUpIHsKICAgICAgZ2ZmRmlsZSA9IEdmZkZpbGUuZnJvbVVybChiZWQudXJsLCBiZWQuaW5kZXhVcmwsIHVpZCwgb3B0aW9ucy51cmxGZXRjaE9wdGlvbnMsIG9wdGlvbnMuaW5kZXhVcmxGZXRjaE9wdGlvbnMpOwogICAgfQogICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBEYXRhU291cmNlKGdmZkZpbGUsIGNocm9tU2l6ZXMsIHsKICAgICAgc2FtcGxlTGVuZ3RoOiAxZTMsCiAgICAgIC4uLm9wdGlvbnMKICAgIH0pOwogICAgZGF0YVNvdXJjZXMuc2V0KHVpZCwgZGF0YVNvdXJjZSk7CiAgfQogIHZhciB0aWxlc2V0SW5mbyA9ICh1aWQpID0+IHsKICAgIHJldHVybiBkYXRhU291cmNlcy5nZXQodWlkKS50aWxlc2V0SW5mbzsKICB9OwogIHZhciB0aWxlID0gYXN5bmMgKHVpZCwgeiwgeCkgPT4gewogICAgY29uc3Qgc291cmNlID0gZGF0YVNvdXJjZXMuZ2V0KHVpZCk7CiAgICBjb25zdCBDQUNIRV9LRVkgPSBgJHt1aWR9LiR7en0uJHt4fWA7CiAgICB0aWxlVmFsdWVzW0NBQ0hFX0tFWV0gPSBbXTsKICAgIGNvbnN0IHRpbGVXaWR0aCA9ICtzb3VyY2UudGlsZXNldEluZm8ubWF4X3dpZHRoIC8gMiAqKiArejsKICAgIGNvbnN0IG1pblggPSBzb3VyY2UudGlsZXNldEluZm8ubWluX3Bvc1swXSArIHggKiB0aWxlV2lkdGg7CiAgICBjb25zdCBtYXhYID0gc291cmNlLnRpbGVzZXRJbmZvLm1pbl9wb3NbMF0gKyAoeCArIDEpICogdGlsZVdpZHRoOwogICAgdGlsZVZhbHVlc1tDQUNIRV9LRVldID0gYXdhaXQgc291cmNlLmZpbGUuZ2V0VGlsZURhdGEobWluWCwgbWF4WCk7CiAgICByZXR1cm4gW107CiAgfTsKICB2YXIgZmV0Y2hUaWxlc0RlYm91bmNlZCA9IGFzeW5jICh1aWQsIHRpbGVJZHMpID0+IHsKICAgIGNvbnN0IHRpbGVzID0ge307CiAgICBjb25zdCB2YWxpZFRpbGVJZHMgPSBbXTsKICAgIGNvbnN0IHRpbGVQcm9taXNlcyA9IFtdOwogICAgZm9yIChjb25zdCB0aWxlSWQgb2YgdGlsZUlkcykgewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgTnVtYmVyLmlzTmFOKHopKSB7CiAgICAgICAgY29uc29sZS53YXJuKCJJbnZhbGlkIHRpbGUgem9vbSBvciBwb3NpdGlvbjoiLCB6LCB4KTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICB2YWxpZFRpbGVJZHMucHVzaCh0aWxlSWQpOwogICAgICB0aWxlUHJvbWlzZXMucHVzaCh0aWxlKHVpZCwgeiwgeCkpOwogICAgfQogICAgcmV0dXJuIFByb21pc2UuYWxsKHRpbGVQcm9taXNlcykudGhlbigodmFsdWVzMikgPT4gewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlczIubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2YWxpZFRpbGVJZCA9IHZhbGlkVGlsZUlkc1tpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0gPSB7IHRpbGVQb3NpdGlvbklkOiB2YWxpZFRpbGVJZCB9OwogICAgICB9CiAgICAgIHJldHVybiB0aWxlczsKICAgIH0pOwogIH07CiAgdmFyIGdldFRhYnVsYXJEYXRhID0gKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgZGF0YSA9IFtdOwogICAgdGlsZUlkcy5mb3JFYWNoKCh0aWxlSWQpID0+IHsKICAgICAgY29uc3QgcGFydHMgPSB0aWxlSWQuc3BsaXQoIi4iKTsKICAgICAgY29uc3QgeiA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7CiAgICAgIGNvbnN0IHggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOwogICAgICBjb25zdCB0aWxlVmFsdWUgPSB0aWxlVmFsdWVzW2Ake3VpZH0uJHt6fS4ke3h9YF07CiAgICAgIGlmICghdGlsZVZhbHVlKSB7CiAgICAgICAgY29uc29sZS53YXJuKGBObyB0aWxlIGRhdGEgY29uc3RydWN0ZWQgKCR7dGlsZUlkfSlgKTsKICAgICAgfQogICAgICBkYXRhLnB1c2godGlsZVZhbHVlKTsKICAgIH0pOwogICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LnZhbHVlcyhkYXRhKS5mbGF0KCk7CiAgICBjb25zdCBidWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkob3V0cHV0KSkuYnVmZmVyOwogICAgcmV0dXJuIFRyYW5zZmVyKGJ1ZmZlciwgW2J1ZmZlcl0pOwogIH07CiAgdmFyIHRpbGVGdW5jdGlvbnMgPSB7CiAgICBpbml0LAogICAgdGlsZXNldEluZm8sCiAgICBmZXRjaFRpbGVzRGVib3VuY2VkLAogICAgdGlsZSwKICAgIGdldFRhYnVsYXJEYXRhCiAgfTsKICBleHBvc2UodGlsZUZ1bmN0aW9ucyk7Cn0pKCk7Ci8qIQogKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4KICoKICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz4KICogQGxpY2Vuc2UgIE1JVAogKi8KLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi8KLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovCi8qKgogKiBAbGljZW5zZQogKiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMKICogQ29weXJpZ2h0IDIwMjAgRGFuaWVsIFdpcnR6IC8gVGhlIGxvbmcuanMgQXV0aG9ycy4KICoKICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiAqCiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKICoKICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQogKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAogKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICoKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAKICovCi8qKgogKiBAbGljZW5zZQogKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+CiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz0iZXMiIC1vIC4vYAogKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+CiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT4KICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT4KICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzCiAqLwo=";
const blob$1 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$1)], { type: "text/javascript;charset=utf-8" });
function Worker$2() {
  const objURL = blob$1 && (window.URL || window.webkitURL).createObjectURL(blob$1);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$1, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$1 = 200;
class GffDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "prevRequestTime");
    __publicField(this, "track");
    __publicField(this, "toFetch");
    __publicField(this, "fetchTimeout");
    __publicField(this, "worker");
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$2()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$1);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    const parsed = JSON.parse(new TextDecoder().decode(buf));
    return parsed;
  }
}
__publicField(GffDataFetcher, "config", { type: "gff" });
const encodedJs = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHsKICAgIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7CiAgICBmb3IgKHZhciBuYW1lIGluIGFsbCkKICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTsKICB9OwogIHZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4gewogICAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09ICJvYmplY3QiIHx8IHR5cGVvZiBtb2R1bGUyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSkKICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09ICJkZWZhdWx0IikKICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdGFyZ2V0OwogIH07CiAgdmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4gewogICAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgImRlZmF1bHQiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiAiZGVmYXVsdCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYmFzZTY0X2pzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGV4cG9ydHMyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBleHBvcnRzMi50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5OwogICAgICBleHBvcnRzMi5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTsKICAgICAgdmFyIGxvb2t1cCA9IFtdOwogICAgICB2YXIgcmV2TG9va3VwID0gW107CiAgICAgIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgPyBVaW50OEFycmF5IDogQXJyYXk7CiAgICAgIHZhciBjb2RlID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iOwogICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgbG9va3VwW2ldID0gY29kZVtpXTsKICAgICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7CiAgICAgIH0KICAgICAgdmFyIGk7CiAgICAgIHZhciBsZW47CiAgICAgIHJldkxvb2t1cFsiLSIuY2hhckNvZGVBdCgwKV0gPSA2MjsKICAgICAgcmV2TG9va3VwWyJfIi5jaGFyQ29kZUF0KDApXSA9IDYzOwogICAgICBmdW5jdGlvbiBnZXRMZW5zKGI2NCkgewogICAgICAgIHZhciBsZW4yID0gYjY0Lmxlbmd0aDsKICAgICAgICBpZiAobGVuMiAlIDQgPiAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQiKTsKICAgICAgICB9CiAgICAgICAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoIj0iKTsKICAgICAgICBpZiAodmFsaWRMZW4gPT09IC0xKQogICAgICAgICAgdmFsaWRMZW4gPSBsZW4yOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuMiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0OwogICAgICAgIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpIHsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7CiAgICAgICAgdmFyIGN1ckJ5dGUgPSAwOwogICAgICAgIHZhciBsZW4yID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuOwogICAgICAgIHZhciBpMjsKICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW4yOyBpMiArPSA0KSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMyldOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gMTYgJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPj4gNDsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildID4+IDI7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkgewogICAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBvdXRwdXQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpMiA9IHN0YXJ0OyBpMiA8IGVuZDsgaTIgKz0gMykgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2kyXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpMiArIDFdIDw8IDggJiA2NTI4MCkgKyAodWludDhbaTIgKyAyXSAmIDI1NSk7CiAgICAgICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXRwdXQuam9pbigiIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7CiAgICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMzsKICAgICAgICB2YXIgcGFydHMgPSBbXTsKICAgICAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsKICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpMiwgaTIgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIyID8gbGVuMjIgOiBpMiArIG1heENodW5rTGVuZ3RoKSk7CiAgICAgICAgfQogICAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICAgICAgICB0bXAgPSB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiA2M10gKyAiPT0iKTsKICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtsZW4yIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgIj0iKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oIiIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfaWVlZTc1NCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGV4cG9ydHMyLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgICAgICAgdmFyIGUsIG07CiAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CiAgICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7CiAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgICAgIHZhciBuQml0cyA9IC03OwogICAgICAgIHZhciBpID0gaXNMRSA/IG5CeXRlcyAtIDEgOiAwOwogICAgICAgIHZhciBkID0gaXNMRSA/IC0xIDogMTsKICAgICAgICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsKICAgICAgICBpICs9IGQ7CiAgICAgICAgZSA9IHMgJiAoMSA8PCAtbkJpdHMpIC0gMTsKICAgICAgICBzID4+PSAtbkJpdHM7CiAgICAgICAgbkJpdHMgKz0gZUxlbjsKICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgZSA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IG1MZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBpZiAoZSA9PT0gMCkgewogICAgICAgICAgZSA9IDEgLSBlQmlhczsKICAgICAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKICAgICAgICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICBlID0gZSAtIGVCaWFzOwogICAgICAgIH0KICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTsKICAgICAgfTsKICAgICAgZXhwb3J0czIud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtLCBjOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMDsKICAgICAgICB2YXIgaSA9IGlzTEUgPyAwIDogbkJ5dGVzIC0gMTsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7CiAgICAgICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwOwogICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpOwogICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7CiAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7CiAgICAgICAgICBlID0gZU1heDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpOwogICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkgewogICAgICAgICAgICBlLS07CiAgICAgICAgICAgIGMgKj0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKICAgICAgICAgICAgZSsrOwogICAgICAgICAgICBjIC89IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgICAgICAgbSA9IDA7CiAgICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMjU1LCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgZSA9IGUgPDwgbUxlbiB8IG07CiAgICAgICAgZUxlbiArPSBtTGVuOwogICAgICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDI1NSwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcwogIHZhciByZXF1aXJlX2J1ZmZlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYmFzZTY0ID0gcmVxdWlyZV9iYXNlNjRfanMoKTsKICAgICAgdmFyIGllZWU3NTQgPSByZXF1aXJlX2llZWU3NTQoKTsKICAgICAgdmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBTeW1ib2xbImZvciJdID09PSAiZnVuY3Rpb24iID8gU3ltYm9sWyJmb3IiXSgibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20iKSA6IG51bGw7CiAgICAgIGV4cG9ydHMyLkJ1ZmZlciA9IEJ1ZmZlcjEwOwogICAgICBleHBvcnRzMi5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjsKICAgICAgZXhwb3J0czIuSU5TUEVDVF9NQVhfQllURVMgPSA1MDsKICAgICAgdmFyIEtfTUFYX0xFTkdUSCA9IDIxNDc0ODM2NDc7CiAgICAgIGV4cG9ydHMyLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7CiAgICAgIEJ1ZmZlcjEwLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpOwogICAgICBpZiAoIUJ1ZmZlcjEwLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IGBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpOwogICAgICAgICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiA0MjsKICAgICAgICAgIH0gfTsKICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pOwogICAgICAgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDI7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMTAucHJvdG90eXBlLCAicGFyZW50IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjEwLnByb3RvdHlwZSwgIm9mZnNldCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRoaXMpKQogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIobGVuZ3RoKSB7CiAgICAgICAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIGxlbmd0aCArICciIGlzIGludmFsaWQgZm9yIG9wdGlvbiAic2l6ZSInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyMTAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnBvb2xTaXplID0gODE5MjsKICAgICAgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nMih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAidW5kZWZpbmVkIiAmJiAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ2YWx1ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKTsKICAgICAgICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSk7CiAgICAgICAgaWYgKGIpCiAgICAgICAgICByZXR1cm4gYjsKICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIxMC5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oInN0cmluZyIpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5mcm9tID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9OwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMTAucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSk7CiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIxMCwgVWludDhBcnJheSk7CiAgICAgIGZ1bmN0aW9uIGFzc2VydFNpemUoc2l6ZSkgewogICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfSBlbHNlIGlmIChzaXplIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHNpemUgKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICBpZiAoc2l6ZSA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKSA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmFsbG9jID0gZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcyKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDsKICAgICAgICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpOwogICAgICAgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkgewogICAgICAgICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheSkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDsKICAgICAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlWaWV3KGFycmF5VmlldykgewogICAgICAgIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHsKICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpOwogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignIm9mZnNldCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcibGVuZ3RoIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgbGV0IGJ1ZjsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdm9pZCAwICYmIGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSk7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMTAucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKCtsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIyKGIpIHsKICAgICAgICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIgIT09IEJ1ZmZlcjEwLnByb3RvdHlwZTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKGEsIGIpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkKICAgICAgICAgIGEgPSBCdWZmZXIxMC5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYiA9IEJ1ZmZlcjEwLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyMTAuaXNCdWZmZXIoYikpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAiYnVmMSIsICJidWYyIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpOwogICAgICAgIH0KICAgICAgICBpZiAoYSA9PT0gYikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gYS5sZW5ndGg7CiAgICAgICAgbGV0IHkgPSBiLmxlbmd0aDsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgICAgICAgeCA9IGFbaV07CiAgICAgICAgICAgIHkgPSBiW2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZykgewogICAgICAgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7CiAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChsaXN0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuYWxsb2MoMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyMTAuYWxsb2NVbnNhZmUobGVuZ3RoKTsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICAgICAgbGV0IGJ1ZiA9IGxpc3RbaV07CiAgICAgICAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlcjEwLmZyb20oYnVmKTsKICAgICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoYnVmZmVyLCBidWYsIHBvcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwogICAgICAgICAgfQogICAgICAgICAgcG9zICs9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWZmZXI7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgewogICAgICAgIGlmIChCdWZmZXIxMC5pc0J1ZmZlcihzdHJpbmcpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGNvbnN0IG11c3RNYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZTsKICAgICAgICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsZW47CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gKiAyOwogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gPj4+IDE7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCB8fCBzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICIiKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7CiAgICAgIGZ1bmN0aW9uIHN3YXAoYiwgbiwgbSkgewogICAgICAgIGNvbnN0IGkgPSBiW25dOwogICAgICAgIGJbbl0gPSBiW21dOwogICAgICAgIGJbbV0gPSBpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDIgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDggIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nMigpIHsKICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpOwogICAgICAgIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyMTAucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzMihiKSB7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihiKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAodGhpcyA9PT0gYikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBCdWZmZXIxMC5jb21wYXJlKHRoaXMsIGIpID09PSAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7CiAgICAgICAgbGV0IHN0ciA9ICIiOwogICAgICAgIGNvbnN0IG1heCA9IGV4cG9ydHMyLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoImhleCIsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICIkMSAiKS50cmltKCk7CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KQogICAgICAgICAgc3RyICs9ICIgLi4uICI7CiAgICAgICAgcmV0dXJuICI8QnVmZmVyICIgKyBzdHIgKyAiPiI7CiAgICAgIH07CiAgICAgIGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7CiAgICAgICAgQnVmZmVyMTAucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyMTAucHJvdG90eXBlLmluc3BlY3Q7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlMih0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkgewogICAgICAgIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHsKICAgICAgICAgIHRhcmdldCA9IEJ1ZmZlcjEwLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGFyZ2V0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ0YXJnZXQiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB0YXJnZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNTdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzRW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID4+Pj0gMDsKICAgICAgICBlbmQgPj4+PSAwOwogICAgICAgIHRoaXNTdGFydCA+Pj49IDA7CiAgICAgICAgdGhpc0VuZCA+Pj49IDA7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDsKICAgICAgICBsZXQgeSA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpOwogICAgICAgIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpOwogICAgICAgIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7CiAgICAgICAgICAgIHggPSB0aGlzQ29weVtpXTsKICAgICAgICAgICAgeSA9IHRhcmdldENvcHlbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0OwogICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMjE0NzQ4MzY0NykgewogICAgICAgICAgYnl0ZU9mZnNldCA9IDIxNDc0ODM2NDc7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTIxNDc0ODM2NDgpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAtMjE0NzQ4MzY0ODsKICAgICAgICB9CiAgICAgICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OwogICAgICAgIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiBidWZmZXIubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKQogICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0OwogICAgICAgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgdmFsID0gQnVmZmVyMTAuZnJvbSh2YWwsIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKHZhbCkpIHsKICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBsZXQgaW5kZXhTaXplID0gMTsKICAgICAgICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDsKICAgICAgICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDsKICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1Y3MyIiB8fCBlbmNvZGluZyA9PT0gInVjcy0yIiB8fCBlbmNvZGluZyA9PT0gInV0ZjE2bGUiIHx8IGVuY29kaW5nID09PSAidXRmLTE2bGUiKSB7CiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpbmRleFNpemUgPSAyOwogICAgICAgICAgICBhcnJMZW5ndGggLz0gMjsKICAgICAgICAgICAgdmFsTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIGJ5dGVPZmZzZXQgLz0gMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVhZChidWYsIGkyKSB7CiAgICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7CiAgICAgICAgICAgIHJldHVybiBidWZbaTJdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpCiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaTsKICAgICAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpCiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpCiAgICAgICAgICAgICAgICBpIC09IGkgLSBmb3VuZEluZGV4OwogICAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7CiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChmb3VuZCkKICAgICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBoZXhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwOwogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKCFsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7CiAgICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpOwogICAgICAgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpCiAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDAgJiYgdHlwZW9mIG9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0OwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkgewogICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gbGVuZ3RoOwogICAgICAgICAgICBsZW5ndGggPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwIHx8IGxlbmd0aCA+IHJlbWFpbmluZykKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogIkJ1ZmZlciIsCiAgICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMCkKICAgICAgICB9OwogICAgICB9OwogICAgICBmdW5jdGlvbiBiYXNlNjRTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGNvbnN0IHJlcyA9IFtdOwogICAgICAgIGxldCBpID0gc3RhcnQ7CiAgICAgICAgd2hpbGUgKGkgPCBlbmQpIHsKICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXTsKICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBudWxsOwogICAgICAgICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSBmaXJzdEJ5dGUgPiAyMzkgPyA0IDogZmlyc3RCeXRlID4gMjIzID8gMyA6IGZpcnN0Qnl0ZSA+IDE5MSA/IDIgOiAxOwogICAgICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkgewogICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHsKICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMTI4KSB7CiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMTI3KSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMjA0NyAmJiAodGVtcENvZGVQb2ludCA8IDU1Mjk2IHx8IHRlbXBDb2RlUG9pbnQgPiA1NzM0MykpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmIChmb3VydGhCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDE4IHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgMTIgfCAodGhpcmRCeXRlICYgNjMpIDw8IDYgfCBmb3VydGhCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHsKICAgICAgICAgICAgY29kZVBvaW50ID0gNjU1MzM7CiAgICAgICAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkgewogICAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7CiAgICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpOwogICAgICAgICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgaSArPSBieXRlc1BlclNlcXVlbmNlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcyk7CiAgICAgIH0KICAgICAgdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gNDA5NjsKICAgICAgZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpIHsKICAgICAgICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDsKICAgICAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7CiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpOwogICAgICAgIH0KICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlIChpIDwgbGVuKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDEyNyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGF0aW4xU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaGV4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICBsZXQgb3V0ID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpOwogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBzdGFydCA9IH5+c3RhcnQ7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyBsZW4gOiB+fmVuZDsKICAgICAgICBpZiAoc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCArPSBsZW47CiAgICAgICAgICBpZiAoc3RhcnQgPCAwKQogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgICAgICAgc3RhcnQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCAwKSB7CiAgICAgICAgICBlbmQgKz0gbGVuOwogICAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICAgIGVuZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBuZXdCdWY7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0KG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICAgICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm9mZnNldCBpcyBub3QgdWludCIpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludExFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHdoaWxlIChieXRlTGVuZ3RoMiA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50OCA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAxNjc3NzIxNjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsbyA9IGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQ7CiAgICAgICAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgbGFzdCAqIDIgKiogMjQ7CiAgICAgICAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0OwogICAgICAgIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDI7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTsKICAgICAgICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgaWYgKCEodGhpc1tvZmZzZXRdICYgMTI4KSkKICAgICAgICAgIHJldHVybiB0aGlzW29mZnNldF07CiAgICAgICAgcmV0dXJuICgyNTUgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4OwogICAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICsgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICsgKGxhc3QgPDwgMjQpOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQoZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdCk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJ2YWx1ZSIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyIC0gMTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAyNTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDE2QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0TEUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDddID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA2XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNV0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDRdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyAzXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDFdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXRdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBsaW1pdCAtIDEsIC1saW1pdCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBzdWIgPSAxOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAxMjcsIC0xMjgpOwogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICB2YWx1ZSA9IDI1NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gNDI5NDk2NzI5NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIC0zNDAyODIzNDY2Mzg1Mjg4NmUyMik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwgLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRhcmdldCkpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAoIXN0YXJ0KQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kICYmIGVuZCAhPT0gMCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoOwogICAgICAgIGlmICghdGFyZ2V0U3RhcnQpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IDA7CiAgICAgICAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBpZiAoZW5kID09PSBzdGFydCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCwgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSwgdGFyZ2V0U3RhcnQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykgewogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDsKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmQ7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDAgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiAmJiAhQnVmZmVyMTAuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTsKICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAidXRmOCIgJiYgY29kZSA8IDEyOCB8fCBlbmNvZGluZyA9PT0gImxhdGluMSIpIHsKICAgICAgICAgICAgICB2YWwgPSBjb2RlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gImJvb2xlYW4iKSB7CiAgICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiT3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBzdGFydCA9IHN0YXJ0ID4+PiAwOwogICAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7CiAgICAgICAgaWYgKCF2YWwpCiAgICAgICAgICB2YWwgPSAwOwogICAgICAgIGxldCBpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2ldID0gdmFsOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBieXRlcyA9IEJ1ZmZlcjEwLmlzQnVmZmVyKHZhbCkgPyB2YWwgOiBCdWZmZXIxMC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgIicgKyB2YWwgKyAnIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAidmFsdWUiJyk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIHZhciBlcnJvcnMgPSB7fTsKICAgICAgZnVuY3Rpb24gRShzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHsKICAgICAgICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2UgewogICAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAibWVzc2FnZSIsIHsKICAgICAgICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWA7CiAgICAgICAgICAgIHRoaXMuc3RhY2s7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWU7CiAgICAgICAgICB9CiAgICAgICAgICBnZXQgY29kZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHN5bTsKICAgICAgICAgIH0KICAgICAgICAgIHNldCBjb2RlKHZhbHVlKSB7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiY29kZSIsIHsKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICB2YWx1ZSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIEUoIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICBpZiAobmFtZSkgewogICAgICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7CiAgICAgICAgfQogICAgICAgIHJldHVybiAiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcyI7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBFKCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIGZ1bmN0aW9uKG5hbWUsIGFjdHVhbCkgewogICAgICAgIHJldHVybiBgVGhlICIke25hbWV9IiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBFKCJFUlJfT1VUX09GX1JBTkdFIiwgZnVuY3Rpb24oc3RyLCByYW5nZSwgaW5wdXQpIHsKICAgICAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiAiJHtzdHJ9IiBpcyBvdXQgb2YgcmFuZ2UuYDsKICAgICAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dDsKICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikgewogICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICJiaWdpbnQiKSB7CiAgICAgICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dCk7CiAgICAgICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7CiAgICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlY2VpdmVkICs9ICJuIjsKICAgICAgICB9CiAgICAgICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gOwogICAgICAgIHJldHVybiBtc2c7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBmdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gdmFsLmxlbmd0aDsKICAgICAgICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gIi0iID8gMSA6IDA7CiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHsKICAgICAgICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBpZiAoYnVmW29mZnNldF0gPT09IHZvaWQgMCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aDJdID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoMiArIDEpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgewogICAgICAgICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICJiaWdpbnQiID8gIm4iIDogIiI7CiAgICAgICAgICBsZXQgcmFuZ2U7CiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aDIgPiAzKSB7CiAgICAgICAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOH0ke259YDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259YDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWA7CiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoInZhbHVlIiwgcmFuZ2UsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICJudW1iZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJvdW5kc0Vycm9yKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHsKICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7CiAgICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSk7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgImFuIGludGVnZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChsZW5ndGggPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCwgdmFsdWUpOwogICAgICB9CiAgICAgIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2c7CiAgICAgIGZ1bmN0aW9uIGJhc2U2NGNsZWFuKHN0cikgewogICAgICAgIHN0ciA9IHN0ci5zcGxpdCgiPSIpWzBdOwogICAgICAgIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgIiIpOwogICAgICAgIGlmIChzdHIubGVuZ3RoIDwgMikKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgICAgICAgIHN0ciA9IHN0ciArICI9IjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7CiAgICAgICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTsKICAgICAgICBsZXQgY29kZVBvaW50OwogICAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgIGNvbnN0IGJ5dGVzID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHsKICAgICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU2MzE5KSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCA1NjMyMCkgewogICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDU1Mjk2IDw8IDEwIHwgY29kZVBvaW50IC0gNTYzMjApICsgNjU1MzY7CiAgICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICB9CiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCA2NTUzNikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTIgfCAyMjQsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTggfCAyNDAsIGNvZGVQb2ludCA+PiAxMiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29kZSBwb2ludCIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikgewogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDI1NSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLCB1bml0cykgewogICAgICAgIGxldCBjLCBoaSwgbG87CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGhpID0gYyA+PiA4OwogICAgICAgICAgbG8gPSBjICUgMjU2OwogICAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pOwogICAgICAgICAgYnl0ZUFycmF5LnB1c2goaGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7CiAgICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG9iaiwgdHlwZSkgewogICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBudW1iZXJJc05hTihvYmopIHsKICAgICAgICByZXR1cm4gb2JqICE9PSBvYmo7CiAgICAgIH0KICAgICAgdmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBjb25zdCBhbHBoYWJldCA9ICIwMTIzNDU2Nzg5YWJjZGVmIjsKICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkgewogICAgICAgICAgY29uc3QgaTE2ID0gaSAqIDE2OwogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7CiAgICAgICAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9KCk7CiAgICAgIGZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZChmbikgewogICAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAidW5kZWZpbmVkIiA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQmlnSW50IG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMKICB2YXIgaW1wb3J0X2J1ZmZlcjsKICB2YXIgaW5pdF9idWZmZXJfc2hpbSA9IF9fZXNtKHsKICAgICJzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMiKCkgewogICAgICBpbXBvcnRfYnVmZmVyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Nqc19wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAidW5kZWZpbmVkIiAmJiBSZWZsZWN0LmdldCkgewogICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgInJlYXNvbiIsIHsKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbDIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcyKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRTaWduYWxdIjsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAiYWJvcnQiKSB7CiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25hYm9ydCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgdGhpcy5vbmFib3J0LmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbDIucHJvdG90eXBlKSwgImRpc3BhdGNoRXZlbnQiLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0U2lnbmFsMjsKICAgICAgfShFbWl0dGVyKTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIyKCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0Q29udHJvbGxlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJzaWduYWwiLCB7CiAgICAgICAgICAgIHZhbHVlOiBuZXcgQWJvcnRTaWduYWwoKSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydENvbnRyb2xsZXIyLCBbewogICAgICAgICAga2V5OiAiYWJvcnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHJlYXNvbikgewogICAgICAgICAgICB2YXIgZXZlbnQ7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoImFib3J0Iik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7CiAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSAiYWJvcnQiOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgiRXZlbnQiKTsKICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCJhYm9ydCIsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGV2ZW50ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAiYWJvcnQiLAogICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzaWduYWxSZWFzb24gPSByZWFzb247CiAgICAgICAgICAgIGlmIChzaWduYWxSZWFzb24gPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IERPTUV4Y2VwdGlvbigic2lnbmFsIGlzIGFib3J0ZWQgd2l0aG91dCByZWFzb24iKTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSBzaWduYWxSZWFzb247CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZzIoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydENvbnRyb2xsZXJdIjsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjI7CiAgICAgIH0oKTsKICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1N0cmluZ1RhZykgewogICAgICAgIEFib3J0Q29udHJvbGxlci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydENvbnRyb2xsZXIiOwogICAgICAgIEFib3J0U2lnbmFsLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gIkFib3J0U2lnbmFsIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmMikgewogICAgICAgIGlmIChzZWxmMi5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTD10cnVlIGlzIHNldCwgd2lsbCBmb3JjZSBpbnN0YWxsIHBvbHlmaWxsIik7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmMi5SZXF1ZXN0ID09PSAiZnVuY3Rpb24iICYmICFzZWxmMi5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgIXNlbGYyLkFib3J0Q29udHJvbGxlcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHsKICAgICAgICBpZiAodHlwZW9mIHBhdGNoVGFyZ2V0cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcGF0Y2hUYXJnZXRzID0gewogICAgICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgX3BhdGNoVGFyZ2V0cyA9IHBhdGNoVGFyZ2V0cywgZmV0Y2ggPSBfcGF0Y2hUYXJnZXRzLmZldGNoLCBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QgPSBfcGF0Y2hUYXJnZXRzLlJlcXVlc3QsIE5hdGl2ZVJlcXVlc3QgPSBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QgPT09IHZvaWQgMCA/IGZldGNoLlJlcXVlc3QgOiBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QsIE5hdGl2ZUFib3J0Q29udHJvbGxlciA9IF9wYXRjaFRhcmdldHMuQWJvcnRDb250cm9sbGVyLCBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0UgPSBfcGF0Y2hUYXJnZXRzLl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwsIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgPSBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFOwogICAgICAgIGlmICghcG9seWZpbGxOZWVkZWQoewogICAgICAgICAgZmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0OiBOYXRpdmVSZXF1ZXN0LAogICAgICAgICAgQWJvcnRDb250cm9sbGVyOiBOYXRpdmVBYm9ydENvbnRyb2xsZXIsCiAgICAgICAgICBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMCiAgICAgICAgfSkpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGZldGNoLAogICAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgUmVxdWVzdCA9IE5hdGl2ZVJlcXVlc3Q7CiAgICAgICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCJzaWduYWwiKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICAgIHZhciBzaWduYWw7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBzaWduYWwgPSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0Mik7CiAgICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwgInNpZ25hbCIsIHsKICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0OwogICAgICAgICAgfTsKICAgICAgICAgIFJlcXVlc3QucHJvdG90eXBlID0gTmF0aXZlUmVxdWVzdC5wcm90b3R5cGU7CiAgICAgICAgfQogICAgICAgIHZhciByZWFsRmV0Y2ggPSBmZXRjaDsKICAgICAgICB2YXIgYWJvcnRhYmxlRmV0Y2ggPSBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICB2YXIgc2lnbmFsID0gUmVxdWVzdCAmJiBSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSA/IGlucHV0LnNpZ25hbCA6IGluaXQyID8gaW5pdDIuc2lnbmFsIDogdm9pZCAwOwogICAgICAgICAgaWYgKHNpZ25hbCkgewogICAgICAgICAgICB2YXIgYWJvcnRFcnJvcjsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IERPTUV4Y2VwdGlvbigiQWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgIGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoIkFib3J0ZWQiKTsKICAgICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAiQWJvcnRFcnJvciI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBjYW5jZWxsYXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihfLCByZWplY3QpIHsKICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYWJvcnRFcnJvcik7CiAgICAgICAgICAgICAgfSwgewogICAgICAgICAgICAgICAgb25jZTogdHJ1ZQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgaWYgKGluaXQyICYmIGluaXQyLnNpZ25hbCkgewogICAgICAgICAgICAgIGRlbGV0ZSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uLCByZWFsRmV0Y2goaW5wdXQsIGluaXQyKV0pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlYWxGZXRjaChpbnB1dCwgaW5pdDIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGZldGNoOiBhYm9ydGFibGVGZXRjaCwKICAgICAgICAgIFJlcXVlc3QKICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0czIuYWJvcnRhYmxlRmV0Y2ggPSBhYm9ydGFibGVGZXRjaERlY29yYXRvcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5BYm9ydFNpZ25hbCA9IGV4cG9ydHMyLkFib3J0Q29udHJvbGxlciA9IHZvaWQgMDsKICAgICAgdmFyIGNqc19wb255ZmlsbF8xID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBzZWxmOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3c7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIGdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QiKTsKICAgICAgfTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIHZhciBBYm9ydFNpZ25hbCA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRTaWduYWwgOiBnZXRHbG9iYWwoKS5BYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIuanMKICB2YXIgcmVxdWlyZV9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEgPSByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCgpOwogICAgICB2YXIgTnVsbFNpZ25hbCA9IGNsYXNzIHsKICAgICAgfTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscyA9IG5ldyBTZXQoKTsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlcigpOwogICAgICAgIH0KICAgICAgICBhZGRTaWduYWwoc2lnbmFsID0gbmV3IE51bGxTaWduYWwoKSkgewogICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgYWRkIGEgc2lnbmFsLCBhbHJlYWR5IGFib3J0ZWQhIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnNpZ25hbHMuYWRkKHNpZ25hbCk7CiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBoYW5kbGVBYm9ydGVkKHNpZ25hbCkgewogICAgICAgICAgdGhpcy5zaWduYWxzLmRlbGV0ZShzaWduYWwpOwogICAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5zaXplID09PSAwKSB7CiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldCBzaWduYWwoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsOwogICAgICAgIH0KICAgICAgICBhYm9ydCgpIHsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWdncmVnYXRlQWJvcnRDb250cm9sbGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IFNldCgpOwogICAgICAgIH0KICAgICAgICBhZGRDYWxsYmFjayhjYWxsYmFjayA9ICgpID0+IHsKICAgICAgICB9KSB7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGQoY2FsbGJhY2spOwogICAgICAgICAgY2FsbGJhY2sodGhpcy5jdXJyZW50TWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UpIHsKICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaCgoZWx0KSA9PiB7CiAgICAgICAgICAgIGVsdChtZXNzYWdlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcwogIHZhciByZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWJvcnRhYmxlUHJvbWlzZUNhY2hlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyKCkpOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNhY2hlIH0pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBmaWxsIGZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWNoZSBtdXN0IGltcGxlbWVudCBnZXQoa2V5KSwgc2V0KGtleSwgdmFsKSwgYW5kIGFuZCBkZWxldGUoa2V5KSIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlOwogICAgICAgICAgdGhpcy5maWxsQ2FsbGJhY2sgPSBmaWxsOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfQogICAgICAgIGV2aWN0KGtleSwgZW50cnkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmdldChrZXkpID09PSBlbnRyeSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmaWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgY29uc3QgYWJvcnRlciA9IG5ldyBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBjb25zdCBzdGF0dXNSZXBvcnRlciA9IG5ldyBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcl8xLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gewogICAgICAgICAgICBhYm9ydGVyLAogICAgICAgICAgICBwcm9taXNlOiB0aGlzLmZpbGxDYWxsYmFjayhkYXRhLCBhYm9ydGVyLnNpZ25hbCwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgaWYgKCFuZXdFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oKCkgPT4gewogICAgICAgICAgICBuZXdFbnRyeS5zZXR0bGVkID0gdHJ1ZTsKICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIG5ld0VudHJ5KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGNoZWNrU2luZ2xlUHJvbWlzZShwcm9taXNlLCBzaWduYWwpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yU2luZ2xlQWJvcnQoKSB7CiAgICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiYWJvcnRlZCIpLCB7IGNvZGU6ICJFUlJfQUJPUlRFRCIgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gewogICAgICAgICAgICBjaGVja0ZvclNpbmdsZUFib3J0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9LCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgaWYgKCFzaWduYWwgJiYgZGF0YSBpbnN0YW5jZW9mIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0U2lnbmFsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInNlY29uZCBnZXQgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhbiBBYm9ydFNpZ25hbCwgcGVyaGFwcyB5b3UgbWVhbnQgdG8gcGFzcyBgbnVsbGAgZm9yIHRoZSBmaWxsIGRhdGE/Iik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSB7CiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBjYWNoZUVudHJ5KTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZUVudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGNhY2hlRW50cnkuc3RhdHVzUmVwb3J0ZXIuYWRkQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5maWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVkRW50cnkpIHsKICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgY29uc3Qga2V5SXRlciA9IHRoaXMuY2FjaGUua2V5cygpOwogICAgICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMDsKICAgICAgICAgIGZvciAobGV0IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpOyAhcmVzdWx0LmRvbmU7IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICAgIGRlbGV0ZUNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVsZXRlQ291bnQ7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9pbmRleC5qcwogIHZhciByZXF1aXJlX2VzbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUoKSk7CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMS5kZWZhdWx0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIHZhciByZXF1aXJlX3F1aWNrX2xydSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFF1aWNrTFJVID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkgewogICAgICAgICAgaWYgKCEob3B0aW9ucy5tYXhTaXplICYmIG9wdGlvbnMubWF4U2l6ZSA+IDApKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7CiAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgIH0KICAgICAgICBfc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgdGhpcy5fc2l6ZSsrOwogICAgICAgICAgaWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTsKICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0KGtleSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICAgIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXQoa2V5LCB2YWx1ZSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgaGFzKGtleSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSkgfHwgdGhpcy5vbGRDYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgcGVlayhrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRlbGV0ZShrZXkpIHsKICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgaWYgKGRlbGV0ZWQpIHsKICAgICAgICAgICAgdGhpcy5fc2l6ZS0tOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSkgfHwgZGVsZXRlZDsKICAgICAgICB9CiAgICAgICAgY2xlYXIoKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7CiAgICAgICAgICB0aGlzLm9sZENhY2hlLmNsZWFyKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgKmtleXMoKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQga2V5OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAqdmFsdWVzKCkgewogICAgICAgICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykgewogICAgICAgICAgICB5aWVsZCB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHsKICAgICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7CiAgICAgICAgICAgIGNvbnN0IFtrZXldID0gaXRlbTsKICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQgc2l6ZSgpIHsKICAgICAgICAgIGxldCBvbGRDYWNoZVNpemUgPSAwOwogICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5vbGRDYWNoZS5rZXlzKCkpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgICAgb2xkQ2FjaGVTaXplKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplICsgb2xkQ2FjaGVTaXplOwogICAgICAgIH0KICAgICAgfTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gUXVpY2tMUlU7CiAgICB9CiAgfSk7CgogIC8vIChkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vbG9jYWxGaWxlCiAgdmFyIHJlcXVpcmVfbG9jYWxGaWxlID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9sb2NhbEZpbGUiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFRZUEVEX09LID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBVaW50MTZBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIEludDMyQXJyYXkgIT09ICJ1bmRlZmluZWQiOwogICAgICBmdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuYXNzaWduID0gZnVuY3Rpb24ob2JqKSB7CiAgICAgICAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgICAgIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkgewogICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTsKICAgICAgICAgIGlmICghc291cmNlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICJvYmplY3QiKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgIm11c3QgYmUgbm9uLW9iamVjdCIpOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHsKICAgICAgICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkgewogICAgICAgICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqOwogICAgICB9OwogICAgICBleHBvcnRzMi5zaHJpbmtCdWYgPSBmdW5jdGlvbihidWYsIHNpemUpIHsKICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgewogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSkgewogICAgICAgICAgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsKICAgICAgICB9CiAgICAgICAgYnVmLmxlbmd0aCA9IHNpemU7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgdmFyIGZuVHlwZWQgPSB7CiAgICAgICAgYXJyYXlTZXQ6IGZ1bmN0aW9uKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7CiAgICAgICAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHsKICAgICAgICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7CiAgICAgICAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7CiAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pOwogICAgICAgICAgcG9zID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGNodW5rID0gY2h1bmtzW2ldOwogICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpOwogICAgICAgICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBmblVudHlwZWQgPSB7CiAgICAgICAgYXJyYXlTZXQ6IGZ1bmN0aW9uKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNldFR5cGVkID0gZnVuY3Rpb24ob24pIHsKICAgICAgICBpZiAob24pIHsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjggPSBVaW50OEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMTYgPSBVaW50MTZBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjMyID0gSW50MzJBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLmFzc2lnbihleHBvcnRzMiwgZm5UeXBlZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjggPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjE2ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYzMiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuYXNzaWduKGV4cG9ydHMyLCBmblVudHlwZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuc2V0VHlwZWQoVFlQRURfT0spOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcwogIHZhciByZXF1aXJlX3RyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0JJTkFSWSA9IDA7CiAgICAgIHZhciBaX1RFWFQgPSAxOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgU1RPUkVEX0JMT0NLID0gMDsKICAgICAgdmFyIFNUQVRJQ19UUkVFUyA9IDE7CiAgICAgIHZhciBEWU5fVFJFRVMgPSAyOwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBCdWZfc2l6ZSA9IDE2OwogICAgICB2YXIgTUFYX0JMX0JJVFMgPSA3OwogICAgICB2YXIgRU5EX0JMT0NLID0gMjU2OwogICAgICB2YXIgUkVQXzNfNiA9IDE2OwogICAgICB2YXIgUkVQWl8zXzEwID0gMTc7CiAgICAgIHZhciBSRVBaXzExXzEzOCA9IDE4OwogICAgICB2YXIgZXh0cmFfbGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF07CiAgICAgIHZhciBleHRyYV9kYml0cyA9IFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTNdOwogICAgICB2YXIgZXh0cmFfYmxiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDddOwogICAgICB2YXIgYmxfb3JkZXIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07CiAgICAgIHZhciBESVNUX0NPREVfTEVOID0gNTEyOwogICAgICB2YXIgc3RhdGljX2x0cmVlID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTsKICAgICAgemVybyhzdGF0aWNfbHRyZWUpOwogICAgICB2YXIgc3RhdGljX2R0cmVlID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTsKICAgICAgemVybyhzdGF0aWNfZHRyZWUpOwogICAgICB2YXIgX2Rpc3RfY29kZSA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTsKICAgICAgemVybyhfZGlzdF9jb2RlKTsKICAgICAgdmFyIF9sZW5ndGhfY29kZSA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTsKICAgICAgemVybyhfbGVuZ3RoX2NvZGUpOwogICAgICB2YXIgYmFzZV9sZW5ndGggPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTsKICAgICAgemVybyhiYXNlX2xlbmd0aCk7CiAgICAgIHZhciBiYXNlX2Rpc3QgPSBuZXcgQXJyYXkoRF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9kaXN0KTsKICAgICAgZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7CiAgICAgICAgdGhpcy5zdGF0aWNfdHJlZSA9IHN0YXRpY190cmVlOwogICAgICAgIHRoaXMuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7CiAgICAgICAgdGhpcy5leHRyYV9iYXNlID0gZXh0cmFfYmFzZTsKICAgICAgICB0aGlzLmVsZW1zID0gZWxlbXM7CiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDsKICAgICAgICB0aGlzLmhhc19zdHJlZSA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2xfZGVzYzsKICAgICAgdmFyIHN0YXRpY19kX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfYmxfZGVzYzsKICAgICAgZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykgewogICAgICAgIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsKICAgICAgICB0aGlzLm1heF9jb2RlID0gMDsKICAgICAgICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkX2NvZGUoZGlzdCkgewogICAgICAgIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfc2hvcnQocywgdykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgPj4+IDggJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuZ3RoKSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSB2YWx1ZSA+PiBCdWZfc2l6ZSAtIHMuYmlfdmFsaWQ7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHsKICAgICAgICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0sIHRyZWVbYyAqIDIgKyAxXSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHsKICAgICAgICB2YXIgcmVzID0gMDsKICAgICAgICBkbyB7CiAgICAgICAgICByZXMgfD0gY29kZSAmIDE7CiAgICAgICAgICBjb2RlID4+Pj0gMTsKICAgICAgICAgIHJlcyA8PD0gMTsKICAgICAgICB9IHdoaWxlICgtLWxlbiA+IDApOwogICAgICAgIHJldHVybiByZXMgPj4+IDE7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfZmx1c2gocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID09PSAxNikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMjU1OwogICAgICAgICAgcy5iaV9idWYgPj49IDg7CiAgICAgICAgICBzLmJpX3ZhbGlkIC09IDg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSBkZXNjLm1heF9jb2RlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGV4dHJhID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0czsKICAgICAgICB2YXIgYmFzZSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7CiAgICAgICAgdmFyIG1heF9sZW5ndGggPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoOwogICAgICAgIHZhciBoOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciB4Yml0czsKICAgICAgICB2YXIgZjsKICAgICAgICB2YXIgb3ZlcmZsb3cgPSAwOwogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsKICAgICAgICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7CiAgICAgICAgICBuID0gcy5oZWFwW2hdOwogICAgICAgICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdICogMiArIDFdICsgMTsKICAgICAgICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkgewogICAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDsKICAgICAgICAgICAgb3ZlcmZsb3crKzsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICBpZiAobiA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSsrOwogICAgICAgICAgeGJpdHMgPSAwOwogICAgICAgICAgaWYgKG4gPj0gYmFzZSkgewogICAgICAgICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTsKICAgICAgICAgIH0KICAgICAgICAgIGYgPSB0cmVlW24gKiAyXTsKICAgICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gKyB4Yml0cyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvdmVyZmxvdyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7CiAgICAgICAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgewogICAgICAgICAgICBiaXRzLS07CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdLS07CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOwogICAgICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tOwogICAgICAgICAgb3ZlcmZsb3cgLT0gMjsKICAgICAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApOwogICAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkgewogICAgICAgICAgbiA9IHMuYmxfY291bnRbYml0c107CiAgICAgICAgICB3aGlsZSAobiAhPT0gMCkgewogICAgICAgICAgICBtID0gcy5oZWFwWy0taF07CiAgICAgICAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHJlZVttICogMiArIDFdICE9PSBiaXRzKSB7CiAgICAgICAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdKSAqIHRyZWVbbSAqIDJdOwogICAgICAgICAgICAgIHRyZWVbbSAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbi0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSB7CiAgICAgICAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIHZhciBjb2RlID0gMDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSBjb2RlICsgYmxfY291bnRbYml0cyAtIDFdIDw8IDE7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXTsKICAgICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxlbmd0aDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICBsZW5ndGggPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoOwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfbGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTsKICAgICAgICBkaXN0ID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGlzdCA+Pj0gNzsKICAgICAgICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV0gLSA3OyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIG4gPSAwOwogICAgICAgIHdoaWxlIChuIDw9IDE0MykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjU1KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDk7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs5XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNzkpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gNzsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzddKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI4NykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXSA9IDU7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuLCA1KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9kdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5ibF90cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTsKICAgICAgICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3dpbmR1cChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7CiAgICAgICAgfQogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpIHsKICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgaWYgKGhlYWRlcikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIGxlbik7CiAgICAgICAgICBwdXRfc2hvcnQocywgfmxlbik7CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTsKICAgICAgICBzLnBlbmRpbmcgKz0gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHsKICAgICAgICB2YXIgX24yID0gbiAqIDI7CiAgICAgICAgdmFyIF9tMiA9IG0gKiAyOwogICAgICAgIHJldHVybiB0cmVlW19uMl0gPCB0cmVlW19tMl0gfHwgdHJlZVtfbjJdID09PSB0cmVlW19tMl0gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKSB7CiAgICAgICAgdmFyIHYgPSBzLmhlYXBba107CiAgICAgICAgdmFyIGogPSBrIDw8IDE7CiAgICAgICAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikgewogICAgICAgICAgaWYgKGogPCBzLmhlYXBfbGVuICYmIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdOwogICAgICAgICAgayA9IGo7CiAgICAgICAgICBqIDw8PSAxOwogICAgICAgIH0KICAgICAgICBzLmhlYXBba10gPSB2OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBsYzsKICAgICAgICB2YXIgbHggPSAwOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBleHRyYTsKICAgICAgICBpZiAocy5sYXN0X2xpdCAhPT0gMCkgewogICAgICAgICAgZG8gewogICAgICAgICAgICBkaXN0ID0gcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4IHwgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV07CiAgICAgICAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdOwogICAgICAgICAgICBseCsrOwogICAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7CiAgICAgICAgfQogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZWxlbXMgPSBkZXNjLnN0YXRfZGVzYy5lbGVtczsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSAtMTsKICAgICAgICB2YXIgbm9kZTsKICAgICAgICBzLmhlYXBfbGVuID0gMDsKICAgICAgICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7CiAgICAgICAgICBpZiAodHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47CiAgICAgICAgICAgIHMuZGVwdGhbbl0gPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7CiAgICAgICAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMDsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAwOwogICAgICAgICAgcy5vcHRfbGVuLS07CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7CiAgICAgICAgZm9yIChuID0gcy5oZWFwX2xlbiA+PiAxOyBuID49IDE7IG4tLSkgewogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsKICAgICAgICB9CiAgICAgICAgbm9kZSA9IGVsZW1zOwogICAgICAgIGRvIHsKICAgICAgICAgIG4gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbMV0gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgICBtID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSB0cmVlW24gKiAyXSArIHRyZWVbbSAqIDJdOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxOwogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gdHJlZVttICogMiArIDFdID0gbm9kZTsKICAgICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKzsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTsKICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxXTsKICAgICAgICBnZW5fYml0bGVuKHMsIGRlc2MpOwogICAgICAgIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSA2NTUzNTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0gKz0gY291bnQ7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0rKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdKys7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgICBjb3VudC0tOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7CiAgICAgICAgdmFyIG1heF9ibGluZGV4OwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTsKICAgICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7CiAgICAgICAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDsKICAgICAgICByZXR1cm4gbWF4X2JsaW5kZXg7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpIHsKICAgICAgICB2YXIgcmFuazsKICAgICAgICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCA0KTsKICAgICAgICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTsKICAgICAgICB9CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsKICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykgewogICAgICAgIHZhciBibGFja19tYXNrID0gNDA5MzYyNDQ0NzsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7CiAgICAgICAgICBpZiAoYmxhY2tfbWFzayAmIDEgJiYgcy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEzICogMl0gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykgewogICAgICAgICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTsKICAgICAgZnVuY3Rpb24gX3RyX2luaXQocykgewogICAgICAgIGlmICghc3RhdGljX2luaXRfZG9uZSkgewogICAgICAgICAgdHJfc3RhdGljX2luaXQoKTsKICAgICAgICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlOwogICAgICAgIH0KICAgICAgICBzLmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7CiAgICAgICAgcy5kX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpOwogICAgICAgIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTsKICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfYWxpZ24ocykgewogICAgICAgIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTsKICAgICAgICBiaV9mbHVzaChzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsKICAgICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOwogICAgICAgIGlmIChzLmxldmVsID4gMCkgewogICAgICAgICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikgewogICAgICAgICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTsKICAgICAgICAgIH0KICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpOwogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7CiAgICAgICAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7CiAgICAgICAgICBvcHRfbGVuYiA9IHMub3B0X2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgc3RhdGljX2xlbmIgPSBzLnN0YXRpY19sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgewogICAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7CiAgICAgICAgfQogICAgICAgIGlmIChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYiAmJiBidWYgIT09IC0xKSB7CiAgICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7CiAgICAgICAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpOwogICAgICAgIH0KICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICAgIGlmIChsYXN0KSB7CiAgICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSA9IGRpc3QgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDI1NTsKICAgICAgICBzLmxhc3RfbGl0Kys7CiAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgIHMuZHluX2x0cmVlW2xjICogMl0rKzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5tYXRjaGVzKys7CiAgICAgICAgICBkaXN0LS07CiAgICAgICAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrOwogICAgICAgICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0rKzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxOwogICAgICB9CiAgICAgIGV4cG9ydHMyLl90cl9pbml0ID0gX3RyX2luaXQ7CiAgICAgIGV4cG9ydHMyLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrOwogICAgICBleHBvcnRzMi5fdHJfZmx1c2hfYmxvY2sgPSBfdHJfZmx1c2hfYmxvY2s7CiAgICAgIGV4cG9ydHMyLl90cl90YWxseSA9IF90cl90YWxseTsKICAgICAgZXhwb3J0czIuX3RyX2FsaWduID0gX3RyX2FsaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzCiAgdmFyIHJlcXVpcmVfYWRsZXIzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHMxID0gYWRsZXIgJiA2NTUzNSB8IDAsIHMyID0gYWRsZXIgPj4+IDE2ICYgNjU1MzUgfCAwLCBuID0gMDsKICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7CiAgICAgICAgICBuID0gbGVuID4gMmUzID8gMmUzIDogbGVuOwogICAgICAgICAgbGVuIC09IG47CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMxID0gczEgKyBidWZbcG9zKytdIHwgMDsKICAgICAgICAgICAgczIgPSBzMiArIHMxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzMSAlPSA2NTUyMTsKICAgICAgICAgIHMyICU9IDY1NTIxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gczEgfCBzMiA8PCAxNiB8IDA7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gYWRsZXIzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMKICB2YXIgcmVxdWlyZV9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gbWFrZVRhYmxlKCkgewogICAgICAgIHZhciBjLCB0YWJsZSA9IFtdOwogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHsKICAgICAgICAgIGMgPSBuOwogICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHsKICAgICAgICAgICAgYyA9IGMgJiAxID8gMzk4ODI5MjM4NCBeIGMgPj4+IDEgOiBjID4+PiAxOwogICAgICAgICAgfQogICAgICAgICAgdGFibGVbbl0gPSBjOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFibGU7CiAgICAgIH0KICAgICAgdmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7CiAgICAgIGZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykgewogICAgICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjsKICAgICAgICBjcmMgXj0gLTE7CiAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7CiAgICAgICAgICBjcmMgPSBjcmMgPj4+IDggXiB0WyhjcmMgXiBidWZbaV0pICYgMjU1XTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyYyBeIC0xOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNyYzMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcwogIHZhciByZXF1aXJlX21lc3NhZ2VzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHRyZWVzID0gcmVxdWlyZV90cmVlcygpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaX05PX0ZMVVNIID0gMDsKICAgICAgdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7CiAgICAgIHZhciBaX0ZVTExfRkxVU0ggPSAzOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9CTE9DSyA9IDU7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX0JVRl9FUlJPUiA9IC01OwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0ZJTFRFUkVEID0gMTsKICAgICAgdmFyIFpfSFVGRk1BTl9PTkxZID0gMjsKICAgICAgdmFyIFpfUkxFID0gMzsKICAgICAgdmFyIFpfRklYRUQgPSA0OwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfVU5LTk9XTiA9IDI7CiAgICAgIHZhciBaX0RFRkxBVEVEID0gODsKICAgICAgdmFyIE1BWF9NRU1fTEVWRUwgPSA5OwogICAgICB2YXIgTUFYX1dCSVRTID0gMTU7CiAgICAgIHZhciBERUZfTUVNX0xFVkVMID0gODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBNSU5fTUFUQ0ggPSAzOwogICAgICB2YXIgTUFYX01BVENIID0gMjU4OwogICAgICB2YXIgTUlOX0xPT0tBSEVBRCA9IE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDE7CiAgICAgIHZhciBQUkVTRVRfRElDVCA9IDMyOwogICAgICB2YXIgSU5JVF9TVEFURSA9IDQyOwogICAgICB2YXIgRVhUUkFfU1RBVEUgPSA2OTsKICAgICAgdmFyIE5BTUVfU1RBVEUgPSA3MzsKICAgICAgdmFyIENPTU1FTlRfU1RBVEUgPSA5MTsKICAgICAgdmFyIEhDUkNfU1RBVEUgPSAxMDM7CiAgICAgIHZhciBCVVNZX1NUQVRFID0gMTEzOwogICAgICB2YXIgRklOSVNIX1NUQVRFID0gNjY2OwogICAgICB2YXIgQlNfTkVFRF9NT1JFID0gMTsKICAgICAgdmFyIEJTX0JMT0NLX0RPTkUgPSAyOwogICAgICB2YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOwogICAgICB2YXIgQlNfRklOSVNIX0RPTkUgPSA0OwogICAgICB2YXIgT1NfQ09ERSA9IDM7CiAgICAgIGZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHsKICAgICAgICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdOwogICAgICAgIHJldHVybiBlcnJvckNvZGU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmFuayhmKSB7CiAgICAgICAgcmV0dXJuIChmIDw8IDEpIC0gKGYgPiA0ID8gOSA6IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHplcm8oYnVmKSB7CiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHsKICAgICAgICAgIGJ1ZltsZW5dID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7CiAgICAgICAgdmFyIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHZhciBsZW4gPSBzLnBlbmRpbmc7CiAgICAgICAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7CiAgICAgICAgICBsZW4gPSBzdHJtLmF2YWlsX291dDsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTsKICAgICAgICBzdHJtLm5leHRfb3V0ICs9IGxlbjsKICAgICAgICBzLnBlbmRpbmdfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX291dCArPSBsZW47CiAgICAgICAgc3RybS5hdmFpbF9vdXQgLT0gbGVuOwogICAgICAgIHMucGVuZGluZyAtPSBsZW47CiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gMCkgewogICAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkgewogICAgICAgIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCBzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEsIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDsKICAgICAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0X2J5dGUocywgYikgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiID4+PiA4ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDI1NTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7CiAgICAgICAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgaWYgKGxlbiA+IHNpemUpIHsKICAgICAgICAgIGxlbiA9IHNpemU7CiAgICAgICAgfQogICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBzdHJtLmF2YWlsX2luIC09IGxlbjsKICAgICAgICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7CiAgICAgICAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkgewogICAgICAgICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9IGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikgewogICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBsZW47CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkgewogICAgICAgIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7CiAgICAgICAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OwogICAgICAgIHZhciBtYXRjaDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7CiAgICAgICAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7CiAgICAgICAgdmFyIGxpbWl0ID0gcy5zdHJzdGFydCA+IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCA/IHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDA7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICB2YXIgd21hc2sgPSBzLndfbWFzazsKICAgICAgICB2YXIgcHJldiA9IHMucHJldjsKICAgICAgICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICB2YXIgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICB2YXIgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7CiAgICAgICAgICBjaGFpbl9sZW5ndGggPj49IDI7CiAgICAgICAgfQogICAgICAgIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgbWF0Y2ggPSBjdXJfbWF0Y2g7CiAgICAgICAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAhPT0gc2Nhbl9lbmQgfHwgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fCBfd2luW21hdGNoXSAhPT0gX3dpbltzY2FuXSB8fCBfd2luWysrbWF0Y2hdICE9PSBfd2luW3NjYW4gKyAxXSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHNjYW4gKz0gMjsKICAgICAgICAgIG1hdGNoKys7CiAgICAgICAgICBkbyB7CiAgICAgICAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIHNjYW4gPCBzdHJlbmQpOwogICAgICAgICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDsKICAgICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikgewogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoOwogICAgICAgICAgICBiZXN0X2xlbiA9IGxlbjsKICAgICAgICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICAgICAgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTsKICAgICAgICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBiZXN0X2xlbjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubG9va2FoZWFkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHsKICAgICAgICB2YXIgX3dfc2l6ZSA9IHMud19zaXplOwogICAgICAgIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7CiAgICAgICAgZG8gewogICAgICAgICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApOwogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBuID0gcy5oYXNoX3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMuaGVhZFstLXBdOwogICAgICAgICAgICAgIHMuaGVhZFtwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbiA9IF93X3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMucHJldlstLXBdOwogICAgICAgICAgICAgIHMucHJldltwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbW9yZSArPSBfd19zaXplOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpOwogICAgICAgICAgcy5sb29rYWhlYWQgKz0gbjsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7CiAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdOwogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHdoaWxlIChzLmluc2VydCkgewogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgICBzdHIrKzsKICAgICAgICAgICAgICBzLmluc2VydC0tOwogICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgewogICAgICAgIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDY1NTM1OwogICAgICAgIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHsKICAgICAgICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTsKICAgICAgICB9CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkgewogICAgICAgICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaCAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTsKICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkgewogICAgICAgIHZhciBoYXNoX2hlYWQ7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICB2YXIgbWF4X2luc2VydDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYXNoX2hlYWQgPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgIH0KICAgICAgICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJiAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCBzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5NikpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7CiAgICAgICAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxOwogICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC09IDI7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApOwogICAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBwcmV2OwogICAgICAgIHZhciBzY2FuLCBzdHJlbmQ7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7CiAgICAgICAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTsKICAgICAgICAgICAgcHJldiA9IF93aW5bc2Nhbl07CiAgICAgICAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkgewogICAgICAgICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7CiAgICAgICAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoOwogICAgICAgIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTsKICAgICAgICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47CiAgICAgICAgdGhpcy5mdW5jID0gZnVuYzsKICAgICAgfQogICAgICB2YXIgY29uZmlndXJhdGlvbl90YWJsZTsKICAgICAgY29uZmlndXJhdGlvbl90YWJsZSA9IFsKICAgICAgICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykKICAgICAgXTsKICAgICAgZnVuY3Rpb24gbG1faW5pdChzKSB7CiAgICAgICAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTsKICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7CiAgICAgICAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDsKICAgICAgICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoOwogICAgICAgIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluOwogICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgcy5pbnNfaCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMuc3RybSA9IG51bGw7CiAgICAgICAgdGhpcy5zdGF0dXMgPSAwOwogICAgICAgIHRoaXMucGVuZGluZ19idWYgPSBudWxsOwogICAgICAgIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nID0gMDsKICAgICAgICB0aGlzLndyYXAgPSAwOwogICAgICAgIHRoaXMuZ3poZWFkID0gbnVsbDsKICAgICAgICB0aGlzLmd6aW5kZXggPSAwOwogICAgICAgIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsKICAgICAgICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICB0aGlzLndfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy53X2JpdHMgPSAwOwogICAgICAgIHRoaXMud19tYXNrID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuaW5zX2ggPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaXplID0gMDsKICAgICAgICB0aGlzLmhhc2hfYml0cyA9IDA7CiAgICAgICAgdGhpcy5oYXNoX21hc2sgPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaGlmdCA9IDA7CiAgICAgICAgdGhpcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgIHRoaXMucHJldl9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHRoaXMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHRoaXMubWF0Y2hfc3RhcnQgPSAwOwogICAgICAgIHRoaXMubG9va2FoZWFkID0gMDsKICAgICAgICB0aGlzLnByZXZfbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubGV2ZWwgPSAwOwogICAgICAgIHRoaXMuc3RyYXRlZ3kgPSAwOwogICAgICAgIHRoaXMuZ29vZF9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5uaWNlX21hdGNoID0gMDsKICAgICAgICB0aGlzLmR5bl9sdHJlZSA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTsKICAgICAgICB0aGlzLmR5bl9kdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHRoaXMuYmxfdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2x0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2R0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuYmxfdHJlZSk7CiAgICAgICAgdGhpcy5sX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuZF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmJsX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTsKICAgICAgICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsKICAgICAgICB6ZXJvKHRoaXMuaGVhcCk7CiAgICAgICAgdGhpcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgdGhpcy5oZWFwX21heCA9IDA7CiAgICAgICAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5kZXB0aCk7CiAgICAgICAgdGhpcy5sX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0X2xpdCA9IDA7CiAgICAgICAgdGhpcy5kX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5vcHRfbGVuID0gMDsKICAgICAgICB0aGlzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHRoaXMubWF0Y2hlcyA9IDA7CiAgICAgICAgdGhpcy5pbnNlcnQgPSAwOwogICAgICAgIHRoaXMuYmlfYnVmID0gMDsKICAgICAgICB0aGlzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgczsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwOwogICAgICAgIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOOwogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHMucGVuZGluZyA9IDA7CiAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgaWYgKHMud3JhcCA8IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHMuc3RhdHVzID0gcy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEU7CiAgICAgICAgc3RybS5hZGxlciA9IHMud3JhcCA9PT0gMiA/IDAgOiAxOwogICAgICAgIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7CiAgICAgICAgdHJlZXMuX3RyX2luaXQocyk7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgICBpZiAocmV0ID09PSBaX09LKSB7CiAgICAgICAgICBsbV9pbml0KHN0cm0uc3RhdGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHZhciB3cmFwID0gMTsKICAgICAgICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikgewogICAgICAgICAgbGV2ZWwgPSA2OwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7CiAgICAgICAgICB3cmFwID0gMjsKICAgICAgICAgIHdpbmRvd0JpdHMgLT0gMTY7CiAgICAgICAgfQogICAgICAgIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fCB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fCBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHsKICAgICAgICAgIHdpbmRvd0JpdHMgPSA5OwogICAgICAgIH0KICAgICAgICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gczsKICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcy5nemhlYWQgPSBudWxsOwogICAgICAgIHMud19iaXRzID0gd2luZG93Qml0czsKICAgICAgICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7CiAgICAgICAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7CiAgICAgICAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzOwogICAgICAgIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxOwogICAgICAgIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTsKICAgICAgICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7CiAgICAgICAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTsKICAgICAgICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpOwogICAgICAgIHMubGl0X2J1ZnNpemUgPSAxIDw8IG1lbUxldmVsICsgNjsKICAgICAgICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDsKICAgICAgICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTsKICAgICAgICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplOwogICAgICAgIHMubGV2ZWwgPSBsZXZlbDsKICAgICAgICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7CiAgICAgICAgcy5tZXRob2QgPSBtZXRob2Q7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkgewogICAgICAgIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIG9sZF9mbHVzaCwgczsKICAgICAgICB2YXIgYmVnLCB2YWw7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8IGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHsKICAgICAgICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgc3RybS5hdmFpbF9vdXQgPT09IDAgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJtID0gc3RybTsKICAgICAgICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAzMSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDEzOSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDgpOwogICAgICAgICAgICBpZiAoIXMuZ3poZWFkKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICsgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNikpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAxNiAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAyNCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMjU1KTsKICAgICAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAyNTUpOwogICAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGhlYWRlciA9IFpfREVGTEFURUQgKyAocy53X2JpdHMgLSA4IDw8IDQpIDw8IDg7CiAgICAgICAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xOwogICAgICAgICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMDsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMTsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgfD0gbGV2ZWxfZmxhZ3MgPDwgNjsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyICs9IDMxIC0gaGVhZGVyICUgMzE7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzdHJtLmFkbGVyID0gMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiA2NTUzNSkpIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDI1NSk7CiAgICAgICAgICAgICAgcy5nemluZGV4Kys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5uYW1lKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIHZhbCA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAyNTU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHsKICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHsKICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiYgZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8IGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHZhciBic3RhdGUgPSBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOiBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7CiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHsKICAgICAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPD0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA9PT0gMikgewogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDI0ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAyNCAmIDI1NSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgfQogICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgaWYgKHMud3JhcCA+IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkgewogICAgICAgIHZhciBzdGF0dXM7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzOwogICAgICAgIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJiBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiYgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJiBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzOwogICAgICAgIHZhciBzdHIsIG47CiAgICAgICAgdmFyIHdyYXA7CiAgICAgICAgdmFyIGF2YWlsOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBpbnB1dDsKICAgICAgICB2YXIgdG1wRGljdDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgd3JhcCA9IHMud3JhcDsKICAgICAgICBpZiAod3JhcCA9PT0gMiB8fCB3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFIHx8IHMubG9va2FoZWFkKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmICh3cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICB9CiAgICAgICAgcy53cmFwID0gMDsKICAgICAgICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkgewogICAgICAgICAgaWYgKHdyYXAgPT09IDApIHsKICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7CiAgICAgICAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTsKICAgICAgICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0OwogICAgICAgICAgZGljdExlbmd0aCA9IHMud19zaXplOwogICAgICAgIH0KICAgICAgICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0OwogICAgICAgICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpOwogICAgICAgICAgZG8gewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgc3RyKys7CiAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgcy5zdHJzdGFydCA9IHN0cjsKICAgICAgICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIH0KICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgc3RybS5pbnB1dCA9IGlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDsKICAgICAgICBzLndyYXAgPSB3cmFwOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0OwogICAgICBleHBvcnRzMi5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUluZm8gPSAicGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzCiAgdmFyIHJlcXVpcmVfc3RyaW5ncyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7CiAgICAgIHZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTsKICAgICAgdHJ5IHsKICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFswXSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX09LID0gZmFsc2U7CiAgICAgIH0KICAgICAgdHJ5IHsKICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsKICAgICAgfSBjYXRjaCAoX18pIHsKICAgICAgICBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7CiAgICAgIH0KICAgICAgdmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTsKICAgICAgZm9yIChxID0gMDsgcSA8IDI1NjsgcSsrKSB7CiAgICAgICAgX3V0ZjhsZW5bcV0gPSBxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxOwogICAgICB9CiAgICAgIHZhciBxOwogICAgICBfdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7CiAgICAgIGV4cG9ydHMyLnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDsKICAgICAgICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBidWZfbGVuICs9IGMgPCAxMjggPyAxIDogYyA8IDIwNDggPyAyIDogYyA8IDY1NTM2ID8gMyA6IDQ7CiAgICAgICAgfQogICAgICAgIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pOwogICAgICAgIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIG1fcG9zICsgMSA8IHN0cl9sZW4pIHsKICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgICAgICBpZiAoKGMyICYgNjQ1MTIpID09PSA1NjMyMCkgewogICAgICAgICAgICAgIGMgPSA2NTUzNiArIChjIC0gNTUyOTYgPDwgMTApICsgKGMyIC0gNTYzMjApOwogICAgICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gYzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHsKICAgICAgICAgICAgYnVmW2krK10gPSAxOTIgfCBjID4+PiA2OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjI0IHwgYyA+Pj4gMTI7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjQwIHwgYyA+Pj4gMTg7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gMTIgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiA2ICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBmdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7CiAgICAgICAgaWYgKGxlbiA8IDY1NTM0KSB7CiAgICAgICAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0sgfHwgIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spIHsKICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIGV4cG9ydHMyLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbihidWYpIHsKICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpOwogICAgICB9OwogICAgICBleHBvcnRzMi5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpOwogICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBleHBvcnRzMi5idWYyc3RyaW5nID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgaSwgb3V0LCBjLCBjX2xlbjsKICAgICAgICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpOwogICAgICAgIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47ICkgewogICAgICAgICAgYyA9IGJ1ZltpKytdOwogICAgICAgICAgaWYgKGMgPCAxMjgpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdOwogICAgICAgICAgaWYgKGNfbGVuID4gNCkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgaSArPSBjX2xlbiAtIDE7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDMxIDogY19sZW4gPT09IDMgPyAxNSA6IDc7CiAgICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHsKICAgICAgICAgICAgYyA9IGMgPDwgNiB8IGJ1ZltpKytdICYgNjM7CiAgICAgICAgICAgIGNfbGVuLS07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY19sZW4gPiAxKSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDY1NTMzOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgNjU1MzYpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGMgLT0gNjU1MzY7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU1Mjk2IHwgYyA+PiAxMCAmIDEwMjM7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU2MzIwIHwgYyAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpOwogICAgICB9OwogICAgICBleHBvcnRzMi51dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgcG9zOwogICAgICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7CiAgICAgICAgICBtYXggPSBidWYubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBwb3MgPSBtYXggLSAxOwogICAgICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgIHBvcy0tOwogICAgICAgIH0KICAgICAgICBpZiAocG9zIDwgMCkgewogICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKHBvcyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCA/IHBvcyA6IG1heDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcwogIHZhciByZXF1aXJlX3pzdHJlYW0gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFpTdHJlYW07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfZGVmbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUoKTsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHN0cmluZ3MgPSByZXF1aXJlX3N0cmluZ3MoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIHRvU3RyaW5nMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIHZhciBaX05PX0ZMVVNIID0gMDsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1lOQ19GTFVTSDIgPSAyOwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIGZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkKICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTiwKICAgICAgICAgIG1ldGhvZDogWl9ERUZMQVRFRCwKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAxNSwKICAgICAgICAgIG1lbUxldmVsOiA4LAogICAgICAgICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPiAwKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICB9IGVsc2UgaWYgKG9wdC5nemlwICYmIG9wdC53aW5kb3dCaXRzID4gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAxNjsKICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC5sZXZlbCwgb3B0Lm1ldGhvZCwgb3B0LndpbmRvd0JpdHMsIG9wdC5tZW1MZXZlbCwgb3B0LnN0cmF0ZWd5KTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LmhlYWRlcikgewogICAgICAgICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICB2YXIgZGljdDsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZzIuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nMi5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSDIpKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikgewogICAgICAgICAgdGhpcy5vbkVuZChaX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoZGVmbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMuZ3ppcCA9IHRydWU7CiAgICAgICAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLkRlZmxhdGUgPSBEZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLmd6aXAgPSBnemlwOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzCiAgdmFyIHJlcXVpcmVfaW5mZmFzdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgQkFEID0gMzA7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgX2luOwogICAgICAgIHZhciBsYXN0OwogICAgICAgIHZhciBfb3V0OwogICAgICAgIHZhciBiZWc7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgZG1heDsKICAgICAgICB2YXIgd3NpemU7CiAgICAgICAgdmFyIHdoYXZlOwogICAgICAgIHZhciB3bmV4dDsKICAgICAgICB2YXIgc193aW5kb3c7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxjb2RlOwogICAgICAgIHZhciBkY29kZTsKICAgICAgICB2YXIgbG1hc2s7CiAgICAgICAgdmFyIGRtYXNrOwogICAgICAgIHZhciBoZXJlOwogICAgICAgIHZhciBvcDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBmcm9tOwogICAgICAgIHZhciBmcm9tX3NvdXJjZTsKICAgICAgICB2YXIgaW5wdXQsIG91dHB1dDsKICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgX2luID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTsKICAgICAgICBfb3V0ID0gc3RybS5uZXh0X291dDsKICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpOwogICAgICAgIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpOwogICAgICAgIGRtYXggPSBzdGF0ZS5kbWF4OwogICAgICAgIHdzaXplID0gc3RhdGUud3NpemU7CiAgICAgICAgd2hhdmUgPSBzdGF0ZS53aGF2ZTsKICAgICAgICB3bmV4dCA9IHN0YXRlLnduZXh0OwogICAgICAgIHNfd2luZG93ID0gc3RhdGUud2luZG93OwogICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgIGxjb2RlID0gc3RhdGUubGVuY29kZTsKICAgICAgICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlOwogICAgICAgIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxOwogICAgICAgIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTsKICAgICAgICB0b3A6CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTsKICAgICAgICAgICAgZG9sZW46CiAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMTYpIHsKICAgICAgICAgICAgICAgICAgbGVuID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgaWYgKG9wKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGhvbGQgJiAoMSA8PCBvcCkgLSAxOwogICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTsKICAgICAgICAgICAgICAgICAgZG9kaXN0OgogICAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgICAgaWYgKG9wICYgMTYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICAgICAgb3AgJj0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoMSA8PCBvcCkgLSAxOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHduZXh0IDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZG9kaXN0OwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSBjb2RlIjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgNjU1MzUpICsgKGhvbGQgJiAoMSA8PCBvcCkgLSAxKV07CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGRvbGVuOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCAmIDMyKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpOwogICAgICAgIGxlbiA9IGJpdHMgPj4gMzsKICAgICAgICBfaW4gLT0gbGVuOwogICAgICAgIGJpdHMgLT0gbGVuIDw8IDM7CiAgICAgICAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7CiAgICAgICAgc3RybS5uZXh0X2luID0gX2luOwogICAgICAgIHN0cm0ubmV4dF9vdXQgPSBfb3V0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCk7CiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpOwogICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgIHJldHVybjsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMKICB2YXIgcmVxdWlyZV9pbmZ0cmVlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIE1BWEJJVFMgPSAxNTsKICAgICAgdmFyIEVOT1VHSF9MRU5TID0gODUyOwogICAgICB2YXIgRU5PVUdIX0RJU1RTID0gNTkyOwogICAgICB2YXIgQ09ERVMgPSAwOwogICAgICB2YXIgTEVOUyA9IDE7CiAgICAgIHZhciBESVNUUyA9IDI7CiAgICAgIHZhciBsYmFzZSA9IFsKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA2LAogICAgICAgIDcsCiAgICAgICAgOCwKICAgICAgICA5LAogICAgICAgIDEwLAogICAgICAgIDExLAogICAgICAgIDEzLAogICAgICAgIDE1LAogICAgICAgIDE3LAogICAgICAgIDE5LAogICAgICAgIDIzLAogICAgICAgIDI3LAogICAgICAgIDMxLAogICAgICAgIDM1LAogICAgICAgIDQzLAogICAgICAgIDUxLAogICAgICAgIDU5LAogICAgICAgIDY3LAogICAgICAgIDgzLAogICAgICAgIDk5LAogICAgICAgIDExNSwKICAgICAgICAxMzEsCiAgICAgICAgMTYzLAogICAgICAgIDE5NSwKICAgICAgICAyMjcsCiAgICAgICAgMjU4LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgbGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAxNiwKICAgICAgICA3MiwKICAgICAgICA3OAogICAgICBdOwogICAgICB2YXIgZGJhc2UgPSBbCiAgICAgICAgMSwKICAgICAgICAyLAogICAgICAgIDMsCiAgICAgICAgNCwKICAgICAgICA1LAogICAgICAgIDcsCiAgICAgICAgOSwKICAgICAgICAxMywKICAgICAgICAxNywKICAgICAgICAyNSwKICAgICAgICAzMywKICAgICAgICA0OSwKICAgICAgICA2NSwKICAgICAgICA5NywKICAgICAgICAxMjksCiAgICAgICAgMTkzLAogICAgICAgIDI1NywKICAgICAgICAzODUsCiAgICAgICAgNTEzLAogICAgICAgIDc2OSwKICAgICAgICAxMDI1LAogICAgICAgIDE1MzcsCiAgICAgICAgMjA0OSwKICAgICAgICAzMDczLAogICAgICAgIDQwOTcsCiAgICAgICAgNjE0NSwKICAgICAgICA4MTkzLAogICAgICAgIDEyMjg5LAogICAgICAgIDE2Mzg1LAogICAgICAgIDI0NTc3LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgZGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMiwKICAgICAgICAyMiwKICAgICAgICAyMywKICAgICAgICAyMywKICAgICAgICAyNCwKICAgICAgICAyNCwKICAgICAgICAyNSwKICAgICAgICAyNSwKICAgICAgICAyNiwKICAgICAgICAyNiwKICAgICAgICAyNywKICAgICAgICAyNywKICAgICAgICAyOCwKICAgICAgICAyOCwKICAgICAgICAyOSwKICAgICAgICAyOSwKICAgICAgICA2NCwKICAgICAgICA2NAogICAgICBdOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdDIgPSAwOwogICAgICAgIHZhciBjdXJyID0gMDsKICAgICAgICB2YXIgZHJvcCA9IDA7CiAgICAgICAgdmFyIGxlZnQgPSAwOwogICAgICAgIHZhciB1c2VkID0gMDsKICAgICAgICB2YXIgaHVmZiA9IDA7CiAgICAgICAgdmFyIGluY3I7CiAgICAgICAgdmFyIGZpbGw7CiAgICAgICAgdmFyIGxvdzsKICAgICAgICB2YXIgbWFzazsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgYmFzZSA9IG51bGw7CiAgICAgICAgdmFyIGJhc2VfaW5kZXggPSAwOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7CiAgICAgICAgdmFyIGV4dHJhID0gbnVsbDsKICAgICAgICB2YXIgZXh0cmFfaW5kZXggPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBjb3VudFtsZW5dID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHsKICAgICAgICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7CiAgICAgICAgfQogICAgICAgIHJvb3QyID0gYml0czsKICAgICAgICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkgewogICAgICAgICAgaWYgKGNvdW50W21heF0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyb290MiA+IG1heCkgewogICAgICAgICAgcm9vdDIgPSBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChtYXggPT09IDApIHsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIG9wdHMuYml0cyA9IDE7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7CiAgICAgICAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHJvb3QyIDwgbWluKSB7CiAgICAgICAgICByb290MiA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3QyOwogICAgICAgIGRyb3AgPSAwOwogICAgICAgIGxvdyA9IC0xOwogICAgICAgIHVzZWQgPSAxIDw8IHJvb3QyOwogICAgICAgIG1hc2sgPSB1c2VkIC0gMTsKICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDsKICAgICAgICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDA7CiAgICAgICAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dOwogICAgICAgICAgfSBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7CiAgICAgICAgICAgIGhlcmVfdmFsID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIGRyb3A7CiAgICAgICAgICBmaWxsID0gMSA8PCBjdXJyOwogICAgICAgICAgbWluID0gZmlsbDsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZmlsbCAtPSBpbmNyOwogICAgICAgICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IGhlcmVfYml0cyA8PCAyNCB8IGhlcmVfb3AgPDwgMTYgfCBoZXJlX3ZhbCB8IDA7CiAgICAgICAgICB9IHdoaWxlIChmaWxsICE9PSAwKTsKICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIDE7CiAgICAgICAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHsKICAgICAgICAgICAgaW5jciA+Pj0gMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpbmNyICE9PSAwKSB7CiAgICAgICAgICAgIGh1ZmYgJj0gaW5jciAtIDE7CiAgICAgICAgICAgIGh1ZmYgKz0gaW5jcjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGh1ZmYgPSAwOwogICAgICAgICAgfQogICAgICAgICAgc3ltKys7CiAgICAgICAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7CiAgICAgICAgICAgIGlmIChsZW4gPT09IG1heCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobGVuID4gcm9vdDIgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3QyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHQgKz0gbWluOwogICAgICAgICAgICBjdXJyID0gbGVuIC0gZHJvcDsKICAgICAgICAgICAgbGVmdCA9IDEgPDwgY3VycjsKICAgICAgICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7CiAgICAgICAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07CiAgICAgICAgICAgICAgaWYgKGxlZnQgPD0gMCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGN1cnIrKzsKICAgICAgICAgICAgICBsZWZ0IDw8PSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHVzZWQgKz0gMSA8PCBjdXJyOwogICAgICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrOwogICAgICAgICAgICB0YWJsZVtsb3ddID0gcm9vdDIgPDwgMjQgfCBjdXJyIDw8IDE2IHwgbmV4dCAtIHRhYmxlX2luZGV4IHwgMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGh1ZmYgIT09IDApIHsKICAgICAgICAgIHRhYmxlW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3AgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgfQogICAgICAgIG9wdHMuYml0cyA9IHJvb3QyOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBpbmZsYXRlX2Zhc3QgPSByZXF1aXJlX2luZmZhc3QoKTsKICAgICAgdmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlX2luZnRyZWVzKCk7CiAgICAgIHZhciBDT0RFUyA9IDA7CiAgICAgIHZhciBMRU5TID0gMTsKICAgICAgdmFyIERJU1RTID0gMjsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9UUkVFUyA9IDY7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX05FRURfRElDVCA9IDI7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX01FTV9FUlJPUiA9IC00OwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgSEVBRCA9IDE7CiAgICAgIHZhciBGTEFHUyA9IDI7CiAgICAgIHZhciBUSU1FID0gMzsKICAgICAgdmFyIE9TID0gNDsKICAgICAgdmFyIEVYTEVOID0gNTsKICAgICAgdmFyIEVYVFJBID0gNjsKICAgICAgdmFyIE5BTUUgPSA3OwogICAgICB2YXIgQ09NTUVOVCA9IDg7CiAgICAgIHZhciBIQ1JDID0gOTsKICAgICAgdmFyIERJQ1RJRCA9IDEwOwogICAgICB2YXIgRElDVCA9IDExOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICB2YXIgVFlQRURPID0gMTM7CiAgICAgIHZhciBTVE9SRUQgPSAxNDsKICAgICAgdmFyIENPUFlfID0gMTU7CiAgICAgIHZhciBDT1BZID0gMTY7CiAgICAgIHZhciBUQUJMRSA9IDE3OwogICAgICB2YXIgTEVOTEVOUyA9IDE4OwogICAgICB2YXIgQ09ERUxFTlMgPSAxOTsKICAgICAgdmFyIExFTl8gPSAyMDsKICAgICAgdmFyIExFTiA9IDIxOwogICAgICB2YXIgTEVORVhUID0gMjI7CiAgICAgIHZhciBESVNUID0gMjM7CiAgICAgIHZhciBESVNURVhUID0gMjQ7CiAgICAgIHZhciBNQVRDSCA9IDI1OwogICAgICB2YXIgTElUID0gMjY7CiAgICAgIHZhciBDSEVDSyA9IDI3OwogICAgICB2YXIgTEVOR1RIID0gMjg7CiAgICAgIHZhciBET05FID0gMjk7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIE1FTSA9IDMxOwogICAgICB2YXIgU1lOQyA9IDMyOwogICAgICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgICAgIHZhciBFTk9VR0hfRElTVFMgPSA1OTI7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9XQklUUyA9IE1BWF9XQklUUzsKICAgICAgZnVuY3Rpb24genN3YXAzMihxKSB7CiAgICAgICAgcmV0dXJuIChxID4+PiAyNCAmIDI1NSkgKyAocSA+Pj4gOCAmIDY1MjgwKSArICgocSAmIDY1MjgwKSA8PCA4KSArICgocSAmIDI1NSkgPDwgMjQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLm1vZGUgPSAwOwogICAgICAgIHRoaXMubGFzdCA9IGZhbHNlOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmxhZ3MgPSAwOwogICAgICAgIHRoaXMuZG1heCA9IDA7CiAgICAgICAgdGhpcy5jaGVjayA9IDA7CiAgICAgICAgdGhpcy50b3RhbCA9IDA7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLndiaXRzID0gMDsKICAgICAgICB0aGlzLndzaXplID0gMDsKICAgICAgICB0aGlzLndoYXZlID0gMDsKICAgICAgICB0aGlzLnduZXh0ID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy5ob2xkID0gMDsKICAgICAgICB0aGlzLmJpdHMgPSAwOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm9mZnNldCA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IDA7CiAgICAgICAgdGhpcy5sZW5jb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmxlbmJpdHMgPSAwOwogICAgICAgIHRoaXMuZGlzdGJpdHMgPSAwOwogICAgICAgIHRoaXMubmNvZGUgPSAwOwogICAgICAgIHRoaXMubmxlbiA9IDA7CiAgICAgICAgdGhpcy5uZGlzdCA9IDA7CiAgICAgICAgdGhpcy5oYXZlID0gMDsKICAgICAgICB0aGlzLm5leHQgPSBudWxsOwogICAgICAgIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOwogICAgICAgIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOwogICAgICAgIHRoaXMubGVuZHluID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3RkeW4gPSBudWxsOwogICAgICAgIHRoaXMuc2FuZSA9IDA7CiAgICAgICAgdGhpcy5iYWNrID0gMDsKICAgICAgICB0aGlzLndhcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwOwogICAgICAgIHN0cm0ubXNnID0gIiI7CiAgICAgICAgaWYgKHN0YXRlLndyYXApIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubW9kZSA9IEhFQUQ7CiAgICAgICAgc3RhdGUubGFzdCA9IDA7CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAwOwogICAgICAgIHN0YXRlLmRtYXggPSAzMjc2ODsKICAgICAgICBzdGF0ZS5oZWFkID0gbnVsbDsKICAgICAgICBzdGF0ZS5ob2xkID0gMDsKICAgICAgICBzdGF0ZS5iaXRzID0gMDsKICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTsKICAgICAgICBzdGF0ZS5zYW5lID0gMTsKICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdGF0ZS53c2l6ZSA9IDA7CiAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxOwogICAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgICB3aW5kb3dCaXRzICY9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgICAgICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpOwogICAgICAgIGlmIChyZXQgIT09IFpfT0spIHsKICAgICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHsKICAgICAgICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7CiAgICAgIH0KICAgICAgdmFyIHZpcmdpbiA9IHRydWU7CiAgICAgIHZhciBsZW5maXg7CiAgICAgIHZhciBkaXN0Zml4OwogICAgICBmdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkgewogICAgICAgIGlmICh2aXJnaW4pIHsKICAgICAgICAgIHZhciBzeW07CiAgICAgICAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTsKICAgICAgICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAxNDQpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI1NikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjgwKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNzsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODgpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAzMikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pOwogICAgICAgICAgdmlyZ2luID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4OwogICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHsKICAgICAgICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0czsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7CiAgICAgICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICAgICAgZGlzdCA9IGNvcHk7CiAgICAgICAgICB9CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpOwogICAgICAgICAgY29weSAtPSBkaXN0OwogICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApOwogICAgICAgICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7CiAgICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS53bmV4dCArPSBkaXN0OwogICAgICAgICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud2hhdmUgKz0gZGlzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBwdXQ7CiAgICAgICAgdmFyIGhhdmUsIGxlZnQ7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIF9pbiwgX291dDsKICAgICAgICB2YXIgY29weTsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGhlcmUgPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOwogICAgICAgIHZhciBvcHRzOwogICAgICAgIHZhciBuOwogICAgICAgIHZhciBvcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgIH0KICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBfaW4gPSBoYXZlOwogICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgIHJldCA9IFpfT0s7CiAgICAgICAgaW5mX2xlYXZlOgogICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkgewogICAgICAgICAgICAgIGNhc2UgSEVBRDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmIDIgJiYgaG9sZCA9PT0gMzU2MTUpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IDA7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAoKChob2xkICYgMjU1KSA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBoZWFkZXIgY2hlY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoaG9sZCAmIDE1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBsZW4gPSAoaG9sZCAmIDE1KSArIDg7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgd2luZG93IHNpemUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjsKICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDUxMiA/IERJQ1RJRCA6IFRZUEU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBGTEFHUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkOwogICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDI1NSkgIT09IFpfREVGTEFURUQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDU3MzQ0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gaGVhZGVyIGZsYWdzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gaG9sZCA+PiA4ICYgMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FOwogICAgICAgICAgICAgIGNhc2UgVElNRToKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMl0gPSBob2xkID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlszXSA9IGhvbGQgPj4+IDI0ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gT1M7CiAgICAgICAgICAgICAgY2FzZSBPUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gaG9sZCA+PiA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOOwogICAgICAgICAgICAgIGNhc2UgRVhMRU46CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTsKICAgICAgICAgICAgICBjYXNlIEVYVFJBOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkgewogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLmhlYWQuZXh0cmEsIGlucHV0LCBuZXh0LCBjb3B5LCBsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7CiAgICAgICAgICAgICAgY2FzZSBOQU1FOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMjA0OCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7CiAgICAgICAgICAgICAgY2FzZSBDT01NRU5UOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNDA5NikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gSENSQzsKICAgICAgICAgICAgICBjYXNlIEhDUkM6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImhlYWRlciBjcmMgbWlzbWF0Y2giOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gc3RhdGUuZmxhZ3MgPj4gOSAmIDE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIERJQ1RJRDoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDsKICAgICAgICAgICAgICBjYXNlIERJQ1Q6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgY2FzZSBUWVBFOgogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIFRZUEVETzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0ID0gaG9sZCAmIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMTsKICAgICAgICAgICAgICAgIHN3aXRjaCAoaG9sZCAmIDMpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJsb2NrIHR5cGUiOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgU1RPUkVEOgogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgNjU1MzUpICE9PSAoaG9sZCA+Pj4gMTYgXiA2NTUzNSkpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDY1NTM1OwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBDT1BZXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZOwogICAgICAgICAgICAgIGNhc2UgQ09QWToKICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpOwogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBwdXQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIFRBQkxFOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAzMSkgKyAyNTc7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAzMSkgKyAxOwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMTUpICsgNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUzsKICAgICAgICAgICAgICBjYXNlIExFTkxFTlM6CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IGhvbGQgJiA3OwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSAzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNzsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgY29kZSBsZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7CiAgICAgICAgICAgICAgY2FzZSBDT0RFTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAzKTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMzsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDcpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDEyNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gNzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gNzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjsKICAgICAgICAgICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2VzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgTEVOXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgY2FzZSBMRU46CiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpOwogICAgICAgICAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgICAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgICAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICAgICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IDA7CiAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDI0MCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUOwogICAgICAgICAgICAgIGNhc2UgTEVORVhUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgxIDw8IHN0YXRlLmV4dHJhKSAtIDE7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNUOwogICAgICAgICAgICAgIGNhc2UgRElTVDoKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDsKICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDsKICAgICAgICAgICAgICBjYXNlIE1BVENIOgogICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5OwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IGxlZnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBMSVQ6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgbGVmdC0tOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgQ0hFQ0s6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0IC09IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIGlmIChfb3V0KSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGRhdGEgY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDsKICAgICAgICAgICAgICBjYXNlIExFTkdUSDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiA0Mjk0OTY3Mjk1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBsZW5ndGggY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7CiAgICAgICAgICAgICAgY2FzZSBET05FOgogICAgICAgICAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgQkFEOgogICAgICAgICAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgTUVNOgogICAgICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgICAgIGNhc2UgU1lOQzoKICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICBpZiAoc3RhdGUud3NpemUgfHwgX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJiAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpIHsKICAgICAgICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfaW4gLT0gc3RybS5hdmFpbF9pbjsKICAgICAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gX2luOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpOwogICAgICAgIH0KICAgICAgICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICsgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTsKICAgICAgICBpZiAoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7CiAgICAgICAgICByZXQgPSBaX0JVRl9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud2luZG93KSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oZWFkID0gaGVhZDsKICAgICAgICBoZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGRpY3RpZDsKICAgICAgICB2YXIgcmV0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkgewogICAgICAgICAgZGljdGlkID0gMTsKICAgICAgICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTsKICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0OwogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZSA9IGluZmxhdGU7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kOwogICAgICBleHBvcnRzMi5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluZm8gPSAicGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcwogIHZhciByZXF1aXJlX2NvbnN0YW50cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICBaX05PX0ZMVVNIOiAwLAogICAgICAgIFpfUEFSVElBTF9GTFVTSDogMSwKICAgICAgICBaX1NZTkNfRkxVU0g6IDIsCiAgICAgICAgWl9GVUxMX0ZMVVNIOiAzLAogICAgICAgIFpfRklOSVNIOiA0LAogICAgICAgIFpfQkxPQ0s6IDUsCiAgICAgICAgWl9UUkVFUzogNiwKICAgICAgICBaX09LOiAwLAogICAgICAgIFpfU1RSRUFNX0VORDogMSwKICAgICAgICBaX05FRURfRElDVDogMiwKICAgICAgICBaX0VSUk5POiAtMSwKICAgICAgICBaX1NUUkVBTV9FUlJPUjogLTIsCiAgICAgICAgWl9EQVRBX0VSUk9SOiAtMywKICAgICAgICBaX0JVRl9FUlJPUjogLTUsCiAgICAgICAgWl9OT19DT01QUkVTU0lPTjogMCwKICAgICAgICBaX0JFU1RfU1BFRUQ6IDEsCiAgICAgICAgWl9CRVNUX0NPTVBSRVNTSU9OOiA5LAogICAgICAgIFpfREVGQVVMVF9DT01QUkVTU0lPTjogLTEsCiAgICAgICAgWl9GSUxURVJFRDogMSwKICAgICAgICBaX0hVRkZNQU5fT05MWTogMiwKICAgICAgICBaX1JMRTogMywKICAgICAgICBaX0ZJWEVEOiA0LAogICAgICAgIFpfREVGQVVMVF9TVFJBVEVHWTogMCwKICAgICAgICBaX0JJTkFSWTogMCwKICAgICAgICBaX1RFWFQ6IDEsCiAgICAgICAgWl9VTktOT1dOOiAyLAogICAgICAgIFpfREVGTEFURUQ6IDgKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMKICB2YXIgcmVxdWlyZV9nemhlYWRlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gR1poZWFkZXIoKSB7CiAgICAgICAgdGhpcy50ZXh0ID0gMDsKICAgICAgICB0aGlzLnRpbWUgPSAwOwogICAgICAgIHRoaXMueGZsYWdzID0gMDsKICAgICAgICB0aGlzLm9zID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gbnVsbDsKICAgICAgICB0aGlzLmV4dHJhX2xlbiA9IDA7CiAgICAgICAgdGhpcy5uYW1lID0gIiI7CiAgICAgICAgdGhpcy5jb21tZW50ID0gIiI7CiAgICAgICAgdGhpcy5oY3JjID0gMDsKICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBHWmhlYWRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMKICB2YXIgcmVxdWlyZV9pbmZsYXRlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmVfaW5mbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgYyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaU3RyZWFtID0gcmVxdWlyZV96c3RyZWFtKCk7CiAgICAgIHZhciBHWmhlYWRlciA9IHJlcXVpcmVfZ3poZWFkZXIoKTsKICAgICAgdmFyIHRvU3RyaW5nMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIEluZmxhdGUyKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZTIpKQogICAgICAgICAgcmV0dXJuIG5ldyBJbmZsYXRlMihvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgY2h1bmtTaXplOiAxNjM4NCwKICAgICAgICAgIHdpbmRvd0JpdHM6IDAsCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID49IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsKICAgICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYgJiYgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzICs9IDMyOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPiAxNSAmJiBvcHQud2luZG93Qml0cyA8IDQ4KSB7CiAgICAgICAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmVyciA9IDA7CiAgICAgICAgdGhpcy5tc2cgPSAiIjsKICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpOwogICAgICAgIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgIHZhciBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSwgb3B0LndpbmRvd0JpdHMpOwogICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTsKICAgICAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTsKICAgICAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcyLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wdC5yYXcpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7CiAgICAgICAgdmFyIHN0YXR1cywgX21vZGU7CiAgICAgICAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7CiAgICAgICAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSDsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpOwogICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcyLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7CiAgICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHsKICAgICAgICAgICAgc3RhdHVzID0gYy5aX09LOwogICAgICAgICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5uZXh0X291dCkgewogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSB7CiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpOwogICAgICAgICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4OwogICAgICAgICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7CiAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDsKICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDsKICAgICAgICAgICAgICAgIGlmICh0YWlsKSB7CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7CiAgICAgICAgICBfbW9kZSA9IGMuWl9GSU5JU0g7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkgewogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTsKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKGMuWl9PSyk7CiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH07CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBJbmZsYXRlMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlMihvcHRpb25zKTsKICAgICAgICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuSW5mbGF0ZSA9IEluZmxhdGUyOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLnVuZ3ppcCA9IGluZmxhdGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFzc2lnbiA9IHJlcXVpcmVfY29tbW9uKCkuYXNzaWduOwogICAgICB2YXIgZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZTIoKTsKICAgICAgdmFyIGluZmxhdGUgPSByZXF1aXJlX2luZmxhdGUyKCk7CiAgICAgIHZhciBjb25zdGFudHMgPSByZXF1aXJlX2NvbnN0YW50cygpOwogICAgICB2YXIgcGFrbyA9IHt9OwogICAgICBhc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gcGFrbzsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMKICB2YXIgcmVxdWlyZV9sb25nID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gTG9uZzQ7CiAgICAgIHZhciB3YXNtMiA9IG51bGw7CiAgICAgIHRyeSB7CiAgICAgICAgd2FzbTIgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nNChsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwOwogICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICB9CiAgICAgIExvbmc0LnByb3RvdHlwZS5fX2lzTG9uZ19fOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZzQucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZzIob2JqKSB7CiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqWyJfX2lzTG9uZ19fIl0pID09PSB0cnVlOwogICAgICB9CiAgICAgIExvbmc0LmlzTG9uZyA9IGlzTG9uZzI7CiAgICAgIHZhciBJTlRfQ0FDSEUyID0ge307CiAgICAgIHZhciBVSU5UX0NBQ0hFMiA9IHt9OwogICAgICBmdW5jdGlvbiBmcm9tSW50Mih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgdmFsdWUgPj4+PSAwOwogICAgICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFMlt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzMih2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTsKICAgICAgICAgIGlmIChjYWNoZSkKICAgICAgICAgICAgVUlOVF9DQUNIRTJbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFsdWUgfD0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFMlt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzMih2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIElOVF9DQUNIRTJbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUludCA9IGZyb21JbnQyOwogICAgICBmdW5jdGlvbiBmcm9tTnVtYmVyMih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpKQogICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgICByZXR1cm4gVVpFUk8yOwogICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMMikKICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwyKQogICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwyKQogICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFMjsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyMigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwyIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTDIgfCAwLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbU51bWJlciA9IGZyb21OdW1iZXIyOwogICAgICBmdW5jdGlvbiBmcm9tQml0czIobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21CaXRzID0gZnJvbUJpdHMyOwogICAgICB2YXIgcG93X2RibDIgPSBNYXRoLnBvdzsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZzIoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHsKICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHRocm93IEVycm9yKCJlbXB0eSBzdHJpbmciKTsKICAgICAgICBpZiAoc3RyID09PSAiTmFOIiB8fCBzdHIgPT09ICJJbmZpbml0eSIgfHwgc3RyID09PSAiK0luZmluaXR5IiB8fCBzdHIgPT09ICItSW5maW5pdHkiKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLCB1bnNpZ25lZCA9IGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgICAgfQogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICB2YXIgcDsKICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcyKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyMihwb3dfZGJsMihyYWRpeCwgOCkpOwogICAgICAgIHZhciByZXN1bHQgPSBaRVJPMjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkgewogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyMihwb3dfZGJsMihyYWRpeCwgc2l6ZSkpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcjIodmFsdWUpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyMih2YWx1ZSkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIExvbmc0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nMjsKICAgICAgZnVuY3Rpb24gZnJvbVZhbHVlMih2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIyKHZhbCwgdW5zaWduZWQpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nMih2YWwsIHVuc2lnbmVkKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tVmFsdWUgPSBmcm9tVmFsdWUyOwogICAgICB2YXIgVFdPX1BXUl8xNl9EQkwyID0gMSA8PCAxNjsKICAgICAgdmFyIFRXT19QV1JfMjRfREJMMiA9IDEgPDwgMjQ7CiAgICAgIHZhciBUV09fUFdSXzMyX0RCTDIgPSBUV09fUFdSXzE2X0RCTDIgKiBUV09fUFdSXzE2X0RCTDI7CiAgICAgIHZhciBUV09fUFdSXzY0X0RCTDIgPSBUV09fUFdSXzMyX0RCTDIgKiBUV09fUFdSXzMyX0RCTDI7CiAgICAgIHZhciBUV09fUFdSXzYzX0RCTDIgPSBUV09fUFdSXzY0X0RCTDIgLyAyOwogICAgICB2YXIgVFdPX1BXUl8yNDIgPSBmcm9tSW50MihUV09fUFdSXzI0X0RCTDIpOwogICAgICB2YXIgWkVSTzIgPSBmcm9tSW50MigwKTsKICAgICAgTG9uZzQuWkVSTyA9IFpFUk8yOwogICAgICB2YXIgVVpFUk8yID0gZnJvbUludDIoMCwgdHJ1ZSk7CiAgICAgIExvbmc0LlVaRVJPID0gVVpFUk8yOwogICAgICB2YXIgT05FMiA9IGZyb21JbnQyKDEpOwogICAgICBMb25nNC5PTkUgPSBPTkUyOwogICAgICB2YXIgVU9ORTIgPSBmcm9tSW50MigxLCB0cnVlKTsKICAgICAgTG9uZzQuVU9ORSA9IFVPTkUyOwogICAgICB2YXIgTkVHX09ORTIgPSBmcm9tSW50MigtMSk7CiAgICAgIExvbmc0Lk5FR19PTkUgPSBORUdfT05FMjsKICAgICAgdmFyIE1BWF9WQUxVRTIgPSBmcm9tQml0czIoNDI5NDk2NzI5NSB8IDAsIDIxNDc0ODM2NDcgfCAwLCBmYWxzZSk7CiAgICAgIExvbmc0Lk1BWF9WQUxVRSA9IE1BWF9WQUxVRTI7CiAgICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUyID0gZnJvbUJpdHMyKDQyOTQ5NjcyOTUgfCAwLCA0Mjk0OTY3Mjk1IHwgMCwgdHJ1ZSk7CiAgICAgIExvbmc0Lk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTI7CiAgICAgIHZhciBNSU5fVkFMVUUyID0gZnJvbUJpdHMyKDAsIDIxNDc0ODM2NDggfCAwLCBmYWxzZSk7CiAgICAgIExvbmc0Lk1JTl9WQUxVRSA9IE1JTl9WQUxVRTI7CiAgICAgIHZhciBMb25nUHJvdG90eXBlMiA9IExvbmc0LnByb3RvdHlwZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9JbnQgPSBmdW5jdGlvbiB0b0ludDIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyMygpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMMiArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMMiArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcyKHJhZGl4KSB7CiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpCiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuICIwIjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKSB7CiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyMihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcjIocG93X2RibDIocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgcmVtID0gcmVtRGl2OwogICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgICAgICByZXN1bHQgPSAiIiArIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMyKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkMigpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0czIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQyKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMyKCkgewogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRTIpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTsKICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdzsKICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgICAgICBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybzIoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXF6ID0gTG9uZ1Byb3RvdHlwZTIuaXNaZXJvOwogICAgICBMb25nUHJvdG90eXBlMi5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZTIoKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlMigpIHsKICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuaXNPZGQgPSBmdW5jdGlvbiBpc09kZDIoKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4yKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzMihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nMihvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZTIob3RoZXIpOwogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZXEgPSBMb25nUHJvdG90eXBlMi5lcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUyLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFsczIob3RoZXIpIHsKICAgICAgICByZXR1cm4gIXRoaXMuZXEob3RoZXIpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5uZXEgPSBMb25nUHJvdG90eXBlMi5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUyLm5lID0gTG9uZ1Byb3RvdHlwZTIubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlMi5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubHQgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsMihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLmx0ZSA9IExvbmdQcm90b3R5cGUyLmxlc3NUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIubGUgPSBMb25nUHJvdG90eXBlMi5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4yKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5ndCA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuOwogICAgICBMb25nUHJvdG90eXBlMi5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwyKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZ3RlID0gTG9uZ1Byb3RvdHlwZTIuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlMi5nZSA9IExvbmdQcm90b3R5cGUyLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZTIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuY29tcCA9IExvbmdQcm90b3R5cGUyLmNvbXBhcmU7CiAgICAgIExvbmdQcm90b3R5cGUyLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZTIoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFMjsKICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FMik7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm5lZyA9IExvbmdQcm90b3R5cGUyLm5lZ2F0ZTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuYWRkID0gZnVuY3Rpb24gYWRkMihhZGRlbmQpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoYWRkZW5kKSkKICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZTIoYWRkZW5kKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKyBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKyBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKyBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKyBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0czIoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0MihzdWJ0cmFoZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKHN1YnRyYWhlbmQpKQogICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZTIoc3VidHJhaGVuZCk7CiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zdWIgPSBMb25nUHJvdG90eXBlMi5zdWJ0cmFjdDsKICAgICAgTG9uZ1Byb3RvdHlwZTIubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseTIobXVsdGlwbGllcikgewogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk8yOwogICAgICAgIGlmICghaXNMb25nMihtdWx0aXBsaWVyKSkKICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUyKG11bHRpcGxpZXIpOwogICAgICAgIGlmICh3YXNtMikgewogICAgICAgICAgdmFyIGxvdyA9IHdhc20yLm11bCh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0czIobG93LCB3YXNtMi5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gWkVSTzI7CiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFMiA6IFpFUk8yOwogICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRTIgOiBaRVJPMjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTsKICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0MikgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0MikpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcjIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICogYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICogYjAwOwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTAwICogYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICogYjAwOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTE2ICogYjE2OwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTAwICogYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubXVsID0gTG9uZ1Byb3RvdHlwZTIubXVsdGlwbHk7CiAgICAgIExvbmdQcm90b3R5cGUyLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZTIoZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nMihkaXZpc29yKSkKICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUyKGRpdmlzb3IpOwogICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKQogICAgICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbTIuZGl2X3UgOiB3YXNtMi5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGxvdywgd2FzbTIuZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTzIgOiBaRVJPMjsKICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlczsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRTIpKSB7CiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORTIpIHx8IGRpdmlzb3IuZXEoTkVHX09ORTIpKQogICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUUyOwogICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRTIpKQogICAgICAgICAgICAgIHJldHVybiBPTkUyOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTsKICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpOwogICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTzIpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUyIDogTkVHX09ORTI7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTsKICAgICAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFMikpCiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8yIDogWkVSTzI7CiAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpOwogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICAgICAgcmVzID0gWkVSTzI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkKICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgICAgIHJldHVybiBVWkVSTzI7CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgICAgICByZXR1cm4gVU9ORTI7CiAgICAgICAgICByZXMgPSBVWkVSTzI7CiAgICAgICAgfQogICAgICAgIHJlbSA9IHRoaXM7CiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHsKICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsKICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsMigyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyMihhcHByb3gpLCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhOwogICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyMihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICAgICAgYXBwcm94UmVzID0gT05FMjsKICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuZGl2ID0gTG9uZ1Byb3RvdHlwZTIuZGl2aWRlOwogICAgICBMb25nUHJvdG90eXBlMi5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8yKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZzIoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlMihkaXZpc29yKTsKICAgICAgICBpZiAod2FzbTIpIHsKICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20yLnJlbV91IDogd2FzbTIucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3csIHdhc20yLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIubW9kID0gTG9uZ1Byb3RvdHlwZTIubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlMi5yZW0gPSBMb25nUHJvdG90eXBlMi5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUyLm5vdCA9IGZ1bmN0aW9uIG5vdDIoKSB7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5hbmQgPSBmdW5jdGlvbiBhbmQyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLm9yID0gZnVuY3Rpb24gb3IyKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcyKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlMihvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnhvciA9IGZ1bmN0aW9uIHhvcjIob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZzIob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUyKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZTIuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0MihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzMigwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaGwgPSBMb25nUHJvdG90eXBlMi5zaGlmdExlZnQ7CiAgICAgIExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0MihudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZzIobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaHIgPSBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0OwogICAgICBMb25nUHJvdG90eXBlMi5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQyKG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nMihudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgbnVtQml0cyAmPSA2MzsKICAgICAgICBpZiAobnVtQml0cyA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7CiAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdzsKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzMihsb3cgPj4+IG51bUJpdHMgfCBoaWdoIDw8IDMyIC0gbnVtQml0cywgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMyKGhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi5zaHJ1ID0gTG9uZ1Byb3RvdHlwZTIuc2hpZnRSaWdodFVuc2lnbmVkOwogICAgICBMb25nUHJvdG90eXBlMi5zaHJfdSA9IExvbmdQcm90b3R5cGUyLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZTIudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZDIoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzMih0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkMigpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0czIodGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUyLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzMihsZSkgewogICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUyKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgbG8gJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGhpICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMjQKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlMi50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUyKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgaGkgPj4+IDI0LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gJiAyNTUKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nNC5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZzQuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRTIoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LCBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0LCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmc0LmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUyKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvaXMtb2JzZXJ2YWJsZS9pbmRleC5qcwogIHZhciByZXF1aXJlX2lzX29ic2VydmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvaXMtb2JzZXJ2YWJsZS9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9ICh2YWx1ZSkgPT4gewogICAgICAgIGlmICghdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wub2JzZXJ2YWJsZSA9PT0gInN5bWJvbCIgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5vYnNlcnZhYmxlXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0oKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVsiQEBvYnNlcnZhYmxlIl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbIkBAb2JzZXJ2YWJsZSJdKCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zZXJpYWxpemVycy5qcwogIHZhciByZXF1aXJlX3NlcmlhbGl6ZXJzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zZXJpYWxpemVycy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5EZWZhdWx0U2VyaWFsaXplciA9IGV4cG9ydHMyLmV4dGVuZFNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIGZ1bmN0aW9uIGV4dGVuZFNlcmlhbGl6ZXIoZXh0ZW5kLCBpbXBsZW1lbnRhdGlvbikgewogICAgICAgIGNvbnN0IGZhbGxiYWNrRGVzZXJpYWxpemVyID0gZXh0ZW5kLmRlc2VyaWFsaXplLmJpbmQoZXh0ZW5kKTsKICAgICAgICBjb25zdCBmYWxsYmFja1NlcmlhbGl6ZXIgPSBleHRlbmQuc2VyaWFsaXplLmJpbmQoZXh0ZW5kKTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24uZGVzZXJpYWxpemUobWVzc2FnZSwgZmFsbGJhY2tEZXNlcmlhbGl6ZXIpOwogICAgICAgICAgfSwKICAgICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24uc2VyaWFsaXplKGlucHV0LCBmYWxsYmFja1NlcmlhbGl6ZXIpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuZXh0ZW5kU2VyaWFsaXplciA9IGV4dGVuZFNlcmlhbGl6ZXI7CiAgICAgIHZhciBEZWZhdWx0RXJyb3JTZXJpYWxpemVyID0gewogICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKEVycm9yKG1lc3NhZ2UubWVzc2FnZSksIHsKICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLAogICAgICAgICAgICBzdGFjazogbWVzc2FnZS5zdGFjawogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBzZXJpYWxpemUoZXJyb3IpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIF9fZXJyb3JfbWFya2VyOiAiJCRlcnJvciIsCiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsCiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsCiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjawogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBpc1NlcmlhbGl6ZWRFcnJvciA9ICh0aGluZykgPT4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiAiX19lcnJvcl9tYXJrZXIiIGluIHRoaW5nICYmIHRoaW5nLl9fZXJyb3JfbWFya2VyID09PSAiJCRlcnJvciI7CiAgICAgIGV4cG9ydHMyLkRlZmF1bHRTZXJpYWxpemVyID0gewogICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRFcnJvcihtZXNzYWdlKSkgewogICAgICAgICAgICByZXR1cm4gRGVmYXVsdEVycm9yU2VyaWFsaXplci5kZXNlcmlhbGl6ZShtZXNzYWdlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICAgICAgICByZXR1cm4gRGVmYXVsdEVycm9yU2VyaWFsaXplci5zZXJpYWxpemUoaW5wdXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGlucHV0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9jb21tb24uanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuc2VyaWFsaXplID0gZXhwb3J0czIuZGVzZXJpYWxpemUgPSBleHBvcnRzMi5yZWdpc3RlclNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIHZhciBzZXJpYWxpemVyc18xID0gcmVxdWlyZV9zZXJpYWxpemVycygpOwogICAgICB2YXIgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLkRlZmF1bHRTZXJpYWxpemVyOwogICAgICBmdW5jdGlvbiByZWdpc3RlclNlcmlhbGl6ZXIyKHNlcmlhbGl6ZXIpIHsKICAgICAgICByZWdpc3RlcmVkU2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzXzEuZXh0ZW5kU2VyaWFsaXplcihyZWdpc3RlcmVkU2VyaWFsaXplciwgc2VyaWFsaXplcik7CiAgICAgIH0KICAgICAgZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gcmVnaXN0ZXJTZXJpYWxpemVyMjsKICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgIHJldHVybiByZWdpc3RlcmVkU2VyaWFsaXplci5kZXNlcmlhbGl6ZShtZXNzYWdlKTsKICAgICAgfQogICAgICBleHBvcnRzMi5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplOwogICAgICBmdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgfQogICAgICBleHBvcnRzMi5zZXJpYWxpemUgPSBzZXJpYWxpemU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc3ltYm9scy5qcwogIHZhciByZXF1aXJlX3N5bWJvbHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuJHdvcmtlciA9IGV4cG9ydHMyLiR0cmFuc2ZlcmFibGUgPSBleHBvcnRzMi4kdGVybWluYXRlID0gZXhwb3J0czIuJGV2ZW50cyA9IGV4cG9ydHMyLiRlcnJvcnMgPSB2b2lkIDA7CiAgICAgIGV4cG9ydHMyLiRlcnJvcnMgPSBTeW1ib2woInRocmVhZC5lcnJvcnMiKTsKICAgICAgZXhwb3J0czIuJGV2ZW50cyA9IFN5bWJvbCgidGhyZWFkLmV2ZW50cyIpOwogICAgICBleHBvcnRzMi4kdGVybWluYXRlID0gU3ltYm9sKCJ0aHJlYWQudGVybWluYXRlIik7CiAgICAgIGV4cG9ydHMyLiR0cmFuc2ZlcmFibGUgPSBTeW1ib2woInRocmVhZC50cmFuc2ZlcmFibGUiKTsKICAgICAgZXhwb3J0czIuJHdvcmtlciA9IFN5bWJvbCgidGhyZWFkLndvcmtlciIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcwogIHZhciByZXF1aXJlX3RyYW5zZmVyYWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHJhbnNmZXJhYmxlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLlRyYW5zZmVyID0gZXhwb3J0czIuaXNUcmFuc2ZlckRlc2NyaXB0b3IgPSB2b2lkIDA7CiAgICAgIHZhciBzeW1ib2xzXzEgPSByZXF1aXJlX3N5bWJvbHMoKTsKICAgICAgZnVuY3Rpb24gaXNUcmFuc2ZlcmFibGUodGhpbmcpIHsKICAgICAgICBpZiAoIXRoaW5nIHx8IHR5cGVvZiB0aGluZyAhPT0gIm9iamVjdCIpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNUcmFuc2ZlckRlc2NyaXB0b3IodGhpbmcpIHsKICAgICAgICByZXR1cm4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiB0aGluZ1tzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV07CiAgICAgIH0KICAgICAgZXhwb3J0czIuaXNUcmFuc2ZlckRlc2NyaXB0b3IgPSBpc1RyYW5zZmVyRGVzY3JpcHRvcjsKICAgICAgZnVuY3Rpb24gVHJhbnNmZXIyKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMpIHsKICAgICAgICBpZiAoIXRyYW5zZmVyYWJsZXMpIHsKICAgICAgICAgIGlmICghaXNUcmFuc2ZlcmFibGUocGF5bG9hZCkpCiAgICAgICAgICAgIHRocm93IEVycm9yKCk7CiAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gW3BheWxvYWRdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gewogICAgICAgICAgW3N5bWJvbHNfMS4kdHJhbnNmZXJhYmxlXTogdHJ1ZSwKICAgICAgICAgIHNlbmQ6IHBheWxvYWQsCiAgICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzMi5UcmFuc2ZlciA9IFRyYW5zZmVyMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90eXBlcy9tZXNzYWdlcy5qcwogIHZhciByZXF1aXJlX21lc3NhZ2VzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgPSBleHBvcnRzMi5NYXN0ZXJNZXNzYWdlVHlwZSA9IHZvaWQgMDsKICAgICAgdmFyIE1hc3Rlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oTWFzdGVyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgTWFzdGVyTWVzc2FnZVR5cGUyWyJjYW5jZWwiXSA9ICJjYW5jZWwiOwogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsicnVuIl0gPSAicnVuIjsKICAgICAgfSkoTWFzdGVyTWVzc2FnZVR5cGUgPSBleHBvcnRzMi5NYXN0ZXJNZXNzYWdlVHlwZSB8fCAoZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgPSB7fSkpOwogICAgICB2YXIgV29ya2VyTWVzc2FnZVR5cGU7CiAgICAgIChmdW5jdGlvbihXb3JrZXJNZXNzYWdlVHlwZTIpIHsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImVycm9yIl0gPSAiZXJyb3IiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsiaW5pdCJdID0gImluaXQiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsicmVzdWx0Il0gPSAicmVzdWx0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJ1bm5pbmciXSA9ICJydW5uaW5nIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInVuY2F1Z2h0RXJyb3IiXSA9ICJ1bmNhdWdodEVycm9yIjsKICAgICAgfSkoV29ya2VyTWVzc2FnZVR5cGUgPSBleHBvcnRzMi5Xb3JrZXJNZXNzYWdlVHlwZSB8fCAoZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgPSB7fSkpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2ltcGxlbWVudGF0aW9uLmJyb3dzZXIuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGlzV29ya2VyUnVudGltZSA9IGZ1bmN0aW9uIGlzV29ya2VyUnVudGltZTIoKSB7CiAgICAgICAgY29uc3QgaXNXaW5kb3dDb250ZXh0ID0gdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBXaW5kb3cgIT09ICJ1bmRlZmluZWQiICYmIHNlbGYgaW5zdGFuY2VvZiBXaW5kb3c7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmLnBvc3RNZXNzYWdlICYmICFpc1dpbmRvd0NvbnRleHQgPyB0cnVlIDogZmFsc2U7CiAgICAgIH07CiAgICAgIHZhciBwb3N0TWVzc2FnZVRvTWFzdGVyID0gZnVuY3Rpb24gcG9zdE1lc3NhZ2VUb01hc3RlcjIoZGF0YSwgdHJhbnNmZXJMaXN0KSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpOwogICAgICB9OwogICAgICB2YXIgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcyA9IGZ1bmN0aW9uIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMyKG9uTWVzc2FnZSkgewogICAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gKG1lc3NhZ2VFdmVudCkgPT4gewogICAgICAgICAgb25NZXNzYWdlKG1lc3NhZ2VFdmVudC5kYXRhKTsKICAgICAgICB9OwogICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4gewogICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgbWVzc2FnZUhhbmRsZXIpOwogICAgICAgIH07CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgbWVzc2FnZUhhbmRsZXIpOwogICAgICAgIHJldHVybiB1bnN1YnNjcmliZTsKICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IHsKICAgICAgICBpc1dvcmtlclJ1bnRpbWUsCiAgICAgICAgcG9zdE1lc3NhZ2VUb01hc3RlciwKICAgICAgICBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfd29ya2VyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19hd2FpdGVyID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19hd2FpdGVyIHx8IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikgewogICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7CiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbInRocm93Il0odmFsdWUpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsKICAgICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLmV4cG9zZSA9IGV4cG9ydHMyLmlzV29ya2VyUnVudGltZSA9IGV4cG9ydHMyLlRyYW5zZmVyID0gZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgaXNfb2JzZXJ2YWJsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaXNfb2JzZXJ2YWJsZSgpKTsKICAgICAgdmFyIGNvbW1vbl8xID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciB0cmFuc2ZlcmFibGVfMSA9IHJlcXVpcmVfdHJhbnNmZXJhYmxlKCk7CiAgICAgIHZhciBtZXNzYWdlc18xID0gcmVxdWlyZV9tZXNzYWdlczIoKTsKICAgICAgdmFyIGltcGxlbWVudGF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9pbXBsZW1lbnRhdGlvbl9icm93c2VyKCkpOwogICAgICB2YXIgY29tbW9uXzIgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAicmVnaXN0ZXJTZXJpYWxpemVyIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBjb21tb25fMi5yZWdpc3RlclNlcmlhbGl6ZXI7CiAgICAgIH0gfSk7CiAgICAgIHZhciB0cmFuc2ZlcmFibGVfMiA9IHJlcXVpcmVfdHJhbnNmZXJhYmxlKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIlRyYW5zZmVyIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMi5UcmFuc2ZlcjsKICAgICAgfSB9KTsKICAgICAgZXhwb3J0czIuaXNXb3JrZXJSdW50aW1lID0gaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZTsKICAgICAgdmFyIGV4cG9zZUNhbGxlZCA9IGZhbHNlOwogICAgICB2YXIgYWN0aXZlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTsKICAgICAgdmFyIGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZSA9ICh0aGluZykgPT4gdGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gbWVzc2FnZXNfMS5NYXN0ZXJNZXNzYWdlVHlwZS5jYW5jZWw7CiAgICAgIHZhciBpc01hc3RlckpvYlJ1bk1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUucnVuOwogICAgICB2YXIgaXNPYnNlcnZhYmxlID0gKHRoaW5nKSA9PiBpc19vYnNlcnZhYmxlXzEuZGVmYXVsdCh0aGluZykgfHwgaXNaZW5PYnNlcnZhYmxlKHRoaW5nKTsKICAgICAgZnVuY3Rpb24gaXNaZW5PYnNlcnZhYmxlKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIHRoaW5nLnN1YnNjcmliZSA9PT0gImZ1bmN0aW9uIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWNvbnN0cnVjdFRyYW5zZmVyKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRyYW5zZmVyYWJsZV8xLmlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSA/IHsgcGF5bG9hZDogdGhpbmcuc2VuZCwgdHJhbnNmZXJhYmxlczogdGhpbmcudHJhbnNmZXJhYmxlcyB9IDogeyBwYXlsb2FkOiB0aGluZywgdHJhbnNmZXJhYmxlczogdm9pZCAwIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEZ1bmN0aW9uSW5pdE1lc3NhZ2UoKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJmdW5jdGlvbiIKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGluaXRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0TW9kdWxlSW5pdE1lc3NhZ2UobWV0aG9kTmFtZXMpIHsKICAgICAgICBjb25zdCBpbml0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuaW5pdCwKICAgICAgICAgIGV4cG9zZWQ6IHsKICAgICAgICAgICAgdHlwZTogIm1vZHVsZSIsCiAgICAgICAgICAgIG1ldGhvZHM6IG1ldGhvZE5hbWVzCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYkVycm9yTWVzc2FnZSh1aWQsIHJhd0Vycm9yKSB7CiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiBlcnJvciwgdHJhbnNmZXJhYmxlcyB9ID0gZGVjb25zdHJ1Y3RUcmFuc2ZlcihyYXdFcnJvcik7CiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5lcnJvciwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGVycm9yOiBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JSZXN1bHRNZXNzYWdlKHVpZCwgY29tcGxldGVkLCByZXN1bHRWYWx1ZSkgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZCwgdHJhbnNmZXJhYmxlcyB9ID0gZGVjb25zdHJ1Y3RUcmFuc2ZlcihyZXN1bHRWYWx1ZSk7CiAgICAgICAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUucmVzdWx0LAogICAgICAgICAgdWlkLAogICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlZCA/IHRydWUgOiB2b2lkIDAsCiAgICAgICAgICBwYXlsb2FkCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihyZXN1bHRNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iU3RhcnRNZXNzYWdlKHVpZCwgcmVzdWx0VHlwZSkgewogICAgICAgIGNvbnN0IHN0YXJ0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUucnVubmluZywKICAgICAgICAgIHVpZCwKICAgICAgICAgIHJlc3VsdFR5cGUKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKHN0YXJ0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS51bmNhdWdodEVycm9yLAogICAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgICAgfTsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGVycm9yTWVzc2FnZSk7CiAgICAgICAgfSBjYXRjaCAoc3ViRXJyb3IpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIk5vdCByZXBvcnRpbmcgdW5jYXVnaHQgZXJyb3IgYmFjayB0byBtYXN0ZXIgdGhyZWFkIGFzIGl0IG9jY3VyZWQgd2hpbGUgcmVwb3J0aW5nIGFuIHVuY2F1Z2h0IGVycm9yIGFscmVhZHkuXG5MYXRlc3QgZXJyb3I6Iiwgc3ViRXJyb3IsICJcbk9yaWdpbmFsIGVycm9yOiIsIGVycm9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcnVuRnVuY3Rpb24oam9iVUlELCBmbiwgYXJncykgewogICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7CiAgICAgICAgICBsZXQgc3luY1Jlc3VsdDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHN5bmNSZXN1bHQgPSBmbiguLi5hcmdzKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIHJldHVybiBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgZXJyb3IpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgcmVzdWx0VHlwZSA9IGlzT2JzZXJ2YWJsZShzeW5jUmVzdWx0KSA/ICJvYnNlcnZhYmxlIiA6ICJwcm9taXNlIjsKICAgICAgICAgIHBvc3RKb2JTdGFydE1lc3NhZ2Uoam9iVUlELCByZXN1bHRUeXBlKTsKICAgICAgICAgIGlmIChpc09ic2VydmFibGUoc3luY1Jlc3VsdCkpIHsKICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3luY1Jlc3VsdC5zdWJzY3JpYmUoKHZhbHVlKSA9PiBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIGZhbHNlLCBjb21tb25fMS5zZXJpYWxpemUodmFsdWUpKSwgKGVycm9yKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgICBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIHRydWUpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLnNldChqb2JVSUQsIHN1YnNjcmlwdGlvbik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHN5bmNSZXN1bHQ7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlLCBjb21tb25fMS5zZXJpYWxpemUocmVzdWx0KSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZXhwb3NlMihleHBvc2VkKSB7CiAgICAgICAgaWYgKCFpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICAgIHRocm93IEVycm9yKCJleHBvc2UoKSBjYWxsZWQgaW4gdGhlIG1hc3RlciB0aHJlYWQuIik7CiAgICAgICAgfQogICAgICAgIGlmIChleHBvc2VDYWxsZWQpIHsKICAgICAgICAgIHRocm93IEVycm9yKCJleHBvc2UoKSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgaXMgbm90IHBvc3NpYmxlLiBQYXNzIGFuIG9iamVjdCB0byBleHBvc2UoKSBpZiB5b3Ugd2FudCB0byBleHBvc2UgbXVsdGlwbGUgZnVuY3Rpb25zLiIpOwogICAgICAgIH0KICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlOwogICAgICAgIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmICFtZXNzYWdlRGF0YS5tZXRob2QpIHsKICAgICAgICAgICAgICBydW5GdW5jdGlvbihtZXNzYWdlRGF0YS51aWQsIGV4cG9zZWQsIG1lc3NhZ2VEYXRhLmFyZ3MubWFwKGNvbW1vbl8xLmRlc2VyaWFsaXplKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgcG9zdEZ1bmN0aW9uSW5pdE1lc3NhZ2UoKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvc2VkID09PSAib2JqZWN0IiAmJiBleHBvc2VkKSB7CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgICAgaWYgKGlzTWFzdGVySm9iUnVuTWVzc2FnZShtZXNzYWdlRGF0YSkgJiYgbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkW21lc3NhZ2VEYXRhLm1ldGhvZF0sIG1lc3NhZ2VEYXRhLmFyZ3MubWFwKGNvbW1vbl8xLmRlc2VyaWFsaXplKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgY29uc3QgbWV0aG9kTmFtZXMgPSBPYmplY3Qua2V5cyhleHBvc2VkKS5maWx0ZXIoKGtleSkgPT4gdHlwZW9mIGV4cG9zZWRba2V5XSA9PT0gImZ1bmN0aW9uIik7CiAgICAgICAgICBwb3N0TW9kdWxlSW5pdE1lc3NhZ2UobWV0aG9kTmFtZXMpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8gZXhwb3NlKCkuIEV4cGVjdGVkIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LCBnb3Q6ICR7ZXhwb3NlZH1gKTsKICAgICAgICB9CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JDYW5jZWxNZXNzYWdlKG1lc3NhZ2VEYXRhKSkgewogICAgICAgICAgICBjb25zdCBqb2JVSUQgPSBtZXNzYWdlRGF0YS51aWQ7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdGl2ZVN1YnNjcmlwdGlvbnMuZ2V0KGpvYlVJRCk7CiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHsKICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZXhwb3NlID0gZXhwb3NlMjsKICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2Ygc2VsZi5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iICYmIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigiZXJyb3IiLCAoZXZlbnQpID0+IHsKICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGV2ZW50LmVycm9yIHx8IGV2ZW50KSwgMjUwKTsKICAgICAgICB9KTsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoInVuaGFuZGxlZHJlamVjdGlvbiIsIChldmVudCkgPT4gewogICAgICAgICAgY29uc3QgZXJyb3IgPSBldmVudC5yZWFzb247CiAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBwcm9jZXNzLm9uID09PSAiZnVuY3Rpb24iICYmIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgIHByb2Nlc3Mub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwgKGVycm9yKSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgcHJvY2Vzcy5vbigidW5oYW5kbGVkUmVqZWN0aW9uIiwgKGVycm9yKSA9PiB7CiAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmVkL2VzbS9hdXRvU3FsLmpzCiAgdmFyIHJlcXVpcmVfYXV0b1NxbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL2F1dG9TcWwuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkgewogICAgICAgIGZ1bmN0aW9uIGN0b3IoKSB7CiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7CiAgICAgICAgfQogICAgICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsKICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7CiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7CiAgICAgICAgdGhpcy5mb3VuZCA9IGZvdW5kOwogICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjsKICAgICAgICB0aGlzLm5hbWUgPSAiU3ludGF4RXJyb3IiOwogICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHBlZyRTeW50YXhFcnJvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHBlZyRzdWJjbGFzcyhwZWckU3ludGF4RXJyb3IsIEVycm9yKTsKICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZSA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCkgewogICAgICAgIHZhciBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlMgPSB7CiAgICAgICAgICBsaXRlcmFsOiBmdW5jdGlvbihleHBlY3RhdGlvbikgewogICAgICAgICAgICByZXR1cm4gJyInICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArICciJzsKICAgICAgICAgIH0sCiAgICAgICAgICAiY2xhc3MiOiBmdW5jdGlvbihleHBlY3RhdGlvbikgewogICAgICAgICAgICB2YXIgZXNjYXBlZFBhcnRzID0gIiIsIGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RhdGlvbi5wYXJ0cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cyArPSBleHBlY3RhdGlvbi5wYXJ0c1tpXSBpbnN0YW5jZW9mIEFycmF5ID8gY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMF0pICsgIi0iICsgY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMV0pIDogY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAiWyIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyAiXiIgOiAiIikgKyBlc2NhcGVkUGFydHMgKyAiXSI7CiAgICAgICAgICB9LAogICAgICAgICAgYW55OiBmdW5jdGlvbihleHBlY3RhdGlvbikgewogICAgICAgICAgICByZXR1cm4gImFueSBjaGFyYWN0ZXIiOwogICAgICAgICAgfSwKICAgICAgICAgIGVuZDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHsKICAgICAgICAgICAgcmV0dXJuICJlbmQgb2YgaW5wdXQiOwogICAgICAgICAgfSwKICAgICAgICAgIG90aGVyOiBmdW5jdGlvbihleHBlY3RhdGlvbikgewogICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsKICAgICAgICAgIHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHsKICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcL2csICJcXFxcIikucmVwbGFjZSgvIi9nLCAnXFwiJykucmVwbGFjZSgvXDAvZywgIlxcMCIpLnJlcGxhY2UoL1x0L2csICJcXHQiKS5yZXBsYWNlKC9cbi9nLCAiXFxuIikucmVwbGFjZSgvXHIvZywgIlxcciIpLnJlcGxhY2UoL1tceDAwLVx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7CiAgICAgICAgICAgIHJldHVybiAiXFx4MCIgKyBoZXgoY2gpOwogICAgICAgICAgfSkucmVwbGFjZSgvW1x4MTAtXHgxRlx4N0YtXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsKICAgICAgICAgICAgcmV0dXJuICJcXHgiICsgaGV4KGNoKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBjbGFzc0VzY2FwZShzKSB7CiAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXC9nLCAiXFxcXCIpLnJlcGxhY2UoL1xdL2csICJcXF0iKS5yZXBsYWNlKC9cXi9nLCAiXFxeIikucmVwbGFjZSgvLS9nLCAiXFwtIikucmVwbGFjZSgvXDAvZywgIlxcMCIpLnJlcGxhY2UoL1x0L2csICJcXHQiKS5yZXBsYWNlKC9cbi9nLCAiXFxuIikucmVwbGFjZSgvXHIvZywgIlxcciIpLnJlcGxhY2UoL1tceDAwLVx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7CiAgICAgICAgICAgIHJldHVybiAiXFx4MCIgKyBoZXgoY2gpOwogICAgICAgICAgfSkucmVwbGFjZSgvW1x4MTAtXHgxRlx4N0YtXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsKICAgICAgICAgICAgcmV0dXJuICJcXHgiICsgaGV4KGNoKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7CiAgICAgICAgICByZXR1cm4gREVTQ1JJQkVfRVhQRUNUQVRJT05fRk5TW2V4cGVjdGF0aW9uLnR5cGVdKGV4cGVjdGF0aW9uKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZDIpIHsKICAgICAgICAgIHZhciBkZXNjcmlwdGlvbnMgPSBuZXcgQXJyYXkoZXhwZWN0ZWQyLmxlbmd0aCksIGksIGo7CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGRlc2NyaXB0aW9uc1tpXSA9IGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0ZWQyW2ldKTsKICAgICAgICAgIH0KICAgICAgICAgIGRlc2NyaXB0aW9ucy5zb3J0KCk7CiAgICAgICAgICBpZiAoZGVzY3JpcHRpb25zLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7CiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbnNbal0gPSBkZXNjcmlwdGlvbnNbaV07CiAgICAgICAgICAgICAgICBqKys7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqOwogICAgICAgICAgfQogICAgICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7CiAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdOwogICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArICIgb3IgIiArIGRlc2NyaXB0aW9uc1sxXTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKCIsICIpICsgIiwgb3IgIiArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlRm91bmQoZm91bmQyKSB7CiAgICAgICAgICByZXR1cm4gZm91bmQyID8gJyInICsgbGl0ZXJhbEVzY2FwZShmb3VuZDIpICsgJyInIDogImVuZCBvZiBpbnB1dCI7CiAgICAgICAgfQogICAgICAgIHJldHVybiAiRXhwZWN0ZWQgIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgIiBidXQgIiArIGRlc2NyaWJlRm91bmQoZm91bmQpICsgIiBmb3VuZC4iOwogICAgICB9OwogICAgICBmdW5jdGlvbiBwZWckcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9OwogICAgICAgIHZhciBwZWckRkFJTEVEID0ge30sIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IGRlY2xhcmF0aW9uOiBwZWckcGFyc2VkZWNsYXJhdGlvbiB9LCBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckcGFyc2VkZWNsYXJhdGlvbiwgcGVnJGMwID0gIigiLCBwZWckYzEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCIoIiwgZmFsc2UpLCBwZWckYzIgPSAiKSIsIHBlZyRjMyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIikiLCBmYWxzZSksIHBlZyRjNCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGNvbW1lbnQsIGZpZWxkcykgewogICAgICAgICAgcmV0dXJuIHsgdHlwZSwgbmFtZSwgY29tbWVudCwgZmllbGRzIH07CiAgICAgICAgfSwgcGVnJGM1ID0gInNpbXBsZSIsIHBlZyRjNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInNpbXBsZSIsIGZhbHNlKSwgcGVnJGM3ID0gIm9iamVjdCIsIHBlZyRjOCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIm9iamVjdCIsIGZhbHNlKSwgcGVnJGM5ID0gInRhYmxlIiwgcGVnJGMxMCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInRhYmxlIiwgZmFsc2UpLCBwZWckYzExID0gImF1dG8iLCBwZWckYzEyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiYXV0byIsIGZhbHNlKSwgcGVnJGMxMyA9ICJwcmltYXJ5IiwgcGVnJGMxNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInByaW1hcnkiLCBmYWxzZSksIHBlZyRjMTUgPSAiaW5kZXgiLCBwZWckYzE2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiaW5kZXgiLCBmYWxzZSksIHBlZyRjMTcgPSAidW5pcXVlIiwgcGVnJGMxOCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInVuaXF1ZSIsIGZhbHNlKSwgcGVnJGMxOSA9IGZ1bmN0aW9uKGYxLCB3KSB7CiAgICAgICAgICByZXR1cm4gdzsKICAgICAgICB9LCBwZWckYzIwID0gZnVuY3Rpb24oZjEsIGZkcykgewogICAgICAgICAgaWYgKGYxLm5hbWUpIHsKICAgICAgICAgICAgZmRzLnVuc2hpZnQoZjEpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZkczsKICAgICAgICB9LCBwZWckYzIxID0gIiMiLCBwZWckYzIyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiIyIsIGZhbHNlKSwgcGVnJGMyMyA9ICI7IiwgcGVnJGMyNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIjsiLCBmYWxzZSksIHBlZyRjMjUgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBjb21tZW50KSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlLCBuYW1lLCBjb21tZW50IH07CiAgICAgICAgfSwgcGVnJGMyNiA9ICJbIiwgcGVnJGMyNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIlsiLCBmYWxzZSksIHBlZyRjMjggPSAiXSIsIHBlZyRjMjkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJdIiwgZmFsc2UpLCBwZWckYzMwID0gZnVuY3Rpb24odHlwZSwgc2l6ZSwgbmFtZSwgY29tbWVudCkgewogICAgICAgICAgcmV0dXJuIHsgdHlwZSwgc2l6ZSwgbmFtZSwgY29tbWVudCB9OwogICAgICAgIH0sIHBlZyRjMzEgPSBmdW5jdGlvbih0eXBlLCB2YWxzLCBuYW1lLCBjb21tZW50KSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlLCB2YWxzLCBuYW1lLCBjb21tZW50IH07CiAgICAgICAgfSwgcGVnJGMzMiA9ICIsIiwgcGVnJGMzMyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIiwiLCBmYWxzZSksIHBlZyRjMzQgPSBmdW5jdGlvbihmMSwgZmRzKSB7CiAgICAgICAgICBmZHMudW5zaGlmdChmMSk7CiAgICAgICAgICByZXR1cm4gZmRzOwogICAgICAgIH0sIHBlZyRjMzUgPSAiaW50IiwgcGVnJGMzNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oImludCIsIGZhbHNlKSwgcGVnJGMzNyA9ICJ1aW50IiwgcGVnJGMzOCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInVpbnQiLCBmYWxzZSksIHBlZyRjMzkgPSAic2hvcnQiLCBwZWckYzQwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigic2hvcnQiLCBmYWxzZSksIHBlZyRjNDEgPSAidXNob3J0IiwgcGVnJGM0MiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInVzaG9ydCIsIGZhbHNlKSwgcGVnJGM0MyA9ICJieXRlIiwgcGVnJGM0NCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oImJ5dGUiLCBmYWxzZSksIHBlZyRjNDUgPSAidWJ5dGUiLCBwZWckYzQ2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigidWJ5dGUiLCBmYWxzZSksIHBlZyRjNDcgPSAiZmxvYXQiLCBwZWckYzQ4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiZmxvYXQiLCBmYWxzZSksIHBlZyRjNDkgPSAiY2hhciIsIHBlZyRjNTAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJjaGFyIiwgZmFsc2UpLCBwZWckYzUxID0gInN0cmluZyIsIHBlZyRjNTIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJzdHJpbmciLCBmYWxzZSksIHBlZyRjNTMgPSAibHN0cmluZyIsIHBlZyRjNTQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJsc3RyaW5nIiwgZmFsc2UpLCBwZWckYzU1ID0gImVudW0iLCBwZWckYzU2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiZW51bSIsIGZhbHNlKSwgcGVnJGM1NyA9ICJkb3VibGUiLCBwZWckYzU4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiZG91YmxlIiwgZmFsc2UpLCBwZWckYzU5ID0gImJpZ2ludCIsIHBlZyRjNjAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJiaWdpbnQiLCBmYWxzZSksIHBlZyRjNjEgPSAic2V0IiwgcGVnJGM2MiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInNldCIsIGZhbHNlKSwgcGVnJGM2MyA9IGZ1bmN0aW9uKHQsIG4pIHsKICAgICAgICAgIHJldHVybiB0ICsgIiAiICsgbjsKICAgICAgICB9LCBwZWckYzY0ID0gL15bYS16QS1aX10vLCBwZWckYzY1ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1siYSIsICJ6Il0sIFsiQSIsICJaIl0sICJfIl0sIGZhbHNlLCBmYWxzZSksIHBlZyRjNjYgPSAvXlthLXpBLVowLTlfXS8sIHBlZyRjNjcgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbWyJhIiwgInoiXSwgWyJBIiwgIloiXSwgWyIwIiwgIjkiXSwgIl8iXSwgZmFsc2UsIGZhbHNlKSwgcGVnJGM2OCA9IGZ1bmN0aW9uKHQpIHsKICAgICAgICAgIHJldHVybiB0ZXh0KCk7CiAgICAgICAgfSwgcGVnJGM2OSA9ICciJywgcGVnJGM3MCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oJyInLCBmYWxzZSksIHBlZyRjNzEgPSAvXlteIl0vLCBwZWckYzcyID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oWyciJ10sIHRydWUsIGZhbHNlKSwgcGVnJGM3MyA9IGZ1bmN0aW9uKHQpIHsKICAgICAgICAgIHJldHVybiB0LmpvaW4oIiIpOwogICAgICAgIH0sIHBlZyRjNzQgPSAvXlteXG5ccl0vLCBwZWckYzc1ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oWyJcbiIsICJcciJdLCB0cnVlLCBmYWxzZSksIHBlZyRjNzYgPSBmdW5jdGlvbih0KSB7CiAgICAgICAgICByZXR1cm4gdC5qb2luKCIiKS5yZXBsYWNlKC9eIi8sICIiKS5yZXBsYWNlKC8iJC8sICIiKTsKICAgICAgICB9LCBwZWckYzc3ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oImludGVnZXIiKSwgcGVnJGM3OCA9IC9eWzAtOV0vLCBwZWckYzc5ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1siMCIsICI5Il1dLCBmYWxzZSwgZmFsc2UpLCBwZWckYzgwID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCgpLCAxMCk7CiAgICAgICAgfSwgcGVnJGM4MSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKCJ3aGl0ZXNwYWNlIiksIHBlZyRjODIgPSAvXlsgXHRcblxyXS8sIHBlZyRjODMgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbIiAiLCAiCSIsICJcbiIsICJcciJdLCBmYWxzZSwgZmFsc2UpLCBwZWckY3VyclBvcyA9IDAsIHBlZyRzYXZlZFBvcyA9IDAsIHBlZyRwb3NEZXRhaWxzQ2FjaGUgPSBbeyBsaW5lOiAxLCBjb2x1bW46IDEgfV0sIHBlZyRtYXhGYWlsUG9zID0gMCwgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdLCBwZWckc2lsZW50RmFpbHMgPSAwLCBwZWckcmVzdWx0OwogICAgICAgIGlmICgic3RhcnRSdWxlIiBpbiBvcHRpb25zKSB7CiAgICAgICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlICJgICsgb3B0aW9ucy5zdGFydFJ1bGUgKyAnIi4nKTsKICAgICAgICAgIH0KICAgICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0ZXh0KCkgewogICAgICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbG9jYXRpb24oKSB7CiAgICAgICAgICByZXR1cm4gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24sIGxvY2F0aW9uMikgewogICAgICAgICAgbG9jYXRpb24yID0gbG9jYXRpb24yICE9PSB2b2lkIDAgPyBsb2NhdGlvbjIgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpOwogICAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLCBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksIGxvY2F0aW9uMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMikgewogICAgICAgICAgbG9jYXRpb24yID0gbG9jYXRpb24yICE9PSB2b2lkIDAgPyBsb2NhdGlvbjIgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpOwogICAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24yKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbih0ZXh0MiwgaWdub3JlQ2FzZSkgewogICAgICAgICAgcmV0dXJuIHsgdHlwZTogImxpdGVyYWwiLCB0ZXh0OiB0ZXh0MiwgaWdub3JlQ2FzZSB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHsKICAgICAgICAgIHJldHVybiB7IHR5cGU6ICJjbGFzcyIsIHBhcnRzLCBpbnZlcnRlZCwgaWdub3JlQ2FzZSB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckYW55RXhwZWN0YXRpb24oKSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlOiAiYW55IiB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlOiAiZW5kIiB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbikgewogICAgICAgICAgcmV0dXJuIHsgdHlwZTogIm90aGVyIiwgZGVzY3JpcHRpb24gfTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykgewogICAgICAgICAgdmFyIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10sIHA7CiAgICAgICAgICBpZiAoZGV0YWlscykgewogICAgICAgICAgICByZXR1cm4gZGV0YWlsczsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHAgPSBwb3MgLSAxOwogICAgICAgICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHsKICAgICAgICAgICAgICBwLS07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07CiAgICAgICAgICAgIGRldGFpbHMgPSB7CiAgICAgICAgICAgICAgbGluZTogZGV0YWlscy5saW5lLAogICAgICAgICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW4KICAgICAgICAgICAgfTsKICAgICAgICAgICAgd2hpbGUgKHAgPCBwb3MpIHsKICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHsKICAgICAgICAgICAgICAgIGRldGFpbHMubGluZSsrOwogICAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlsczsKICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykgewogICAgICAgICAgdmFyIHN0YXJ0UG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhzdGFydFBvcyksIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHN0YXJ0OiB7CiAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydFBvcywKICAgICAgICAgICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSwKICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW4KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZW5kOiB7CiAgICAgICAgICAgICAgb2Zmc2V0OiBlbmRQb3MsCiAgICAgICAgICAgICAgbGluZTogZW5kUG9zRGV0YWlscy5saW5lLAogICAgICAgICAgICAgIGNvbHVtbjogZW5kUG9zRGV0YWlscy5jb2x1bW4KICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQyKSB7CiAgICAgICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykgewogICAgICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107CiAgICAgICAgICB9CiAgICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQyKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24yKSB7CiAgICAgICAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbjIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQyLCBmb3VuZCwgbG9jYXRpb24yKSB7CiAgICAgICAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkMiwgZm91bmQpLCBleHBlY3RlZDIsIGZvdW5kLCBsb2NhdGlvbjIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VkZWNsYXJhdGlvbigpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwLCBzMTEsIHMxMiwgczEzOwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIHMxID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlZGVjbGFyZVR5cGUoKTsKICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWRlY2xhcmVOYW1lKCk7CiAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlY29tbWVudCgpOwogICAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJGMwOwogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgczEwID0gcGVnJHBhcnNlZmllbGRMaXN0KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMiA9IHBlZyRjMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMiA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMyA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0KHMyLCBzNCwgczYsIHMxMCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWRlY2xhcmVUeXBlKCkgewogICAgICAgICAgdmFyIHMwOwogICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjNSkgewogICAgICAgICAgICBzMCA9IHBlZyRjNTsKICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGM3KSB7CiAgICAgICAgICAgICAgczAgPSBwZWckYzc7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM4KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjOSkgewogICAgICAgICAgICAgICAgczAgPSBwZWckYzk7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMTApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VkZWNsYXJlTmFtZSgpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyLCBzMzsKICAgICAgICAgIHMwID0gcGVnJHBhcnNlbmFtZSgpOwogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbmFtZSgpOwogICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMiA9IHBlZyRwYXJzZWluZGV4VHlwZSgpOwogICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczEgPSBbczEsIHMyXTsKICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA0KSA9PT0gcGVnJGMxMSkgewogICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjMTE7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzEyKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIHMxID0gW3MxLCBzMl07CiAgICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbmFtZSgpOwogICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlaW5kZXhUeXBlKCk7CiAgICAgICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzExKSB7CiAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMTE7CiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA0OwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMTIpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdOwogICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlaW5kZXhUeXBlKCkgewogICAgICAgICAgdmFyIHMwOwogICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjMTMpIHsKICAgICAgICAgICAgczAgPSBwZWckYzEzOwogICAgICAgICAgICBwZWckY3VyclBvcyArPSA3OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMxNCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGMxNSkgewogICAgICAgICAgICAgIHMwID0gcGVnJGMxNTsKICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzE2KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMTcpIHsKICAgICAgICAgICAgICAgIHMwID0gcGVnJGMxNzsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMxOCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNvbW1lbnQoKSB7CiAgICAgICAgICB2YXIgczA7CiAgICAgICAgICBzMCA9IHBlZyRwYXJzZW5vblF1b3RlZFN0cmluZygpOwogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VmaWVsZExpc3QoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgczEgPSBwZWckcGFyc2VmaWVsZCgpOwogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMyA9IFtdOwogICAgICAgICAgICAgIHM0ID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZWZpZWxkKCk7CiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczQ7CiAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJGMxOShzMSwgczYpOwogICAgICAgICAgICAgICAgICBzNCA9IHM1OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDsKICAgICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0OwogICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHMzLnB1c2goczQpOwogICAgICAgICAgICAgICAgczQgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlZmllbGQoKTsKICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczQ7CiAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckYzE5KHMxLCBzNik7CiAgICAgICAgICAgICAgICAgICAgczQgPSBzNTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0OwogICAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDsKICAgICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjAoczEsIHMzKTsKICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlY29tbWVudFN0YXJ0KCkgewogICAgICAgICAgdmFyIHMwOwogICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNSkgewogICAgICAgICAgICBzMCA9IHBlZyRjMjE7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzIyKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VpbnRlcm5hbENvbW1lbnQoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0OwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIHMxID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlY29tbWVudFN0YXJ0KCk7CiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlbm9uUXVvdGVkU3RyaW5nKCk7CiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzLCBzNF07CiAgICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZpZWxkKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTAsIHMxMSwgczEyLCBzMTM7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgczEgPSBwZWckcGFyc2VmaWVsZFR5cGUoKTsKICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7CiAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckYzIzOwogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMjQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlY29tbWVudCgpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjUoczEsIHMzLCBzNyk7CiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgczEgPSBwZWckcGFyc2VmaWVsZFR5cGUoKTsKICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7CiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMyNjsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMjcpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlZmllbGRTaXplKCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckYzI4OwogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMjkpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJHBhcnNlbmFtZSgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRjMjM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzI0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTMgPSBwZWckcGFyc2Vjb21tZW50KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMzAoczEsIHM1LCBzOSwgczEzKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VmaWVsZFR5cGUoKTsKICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHsKICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMDsKICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzEpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlZmllbGRWYWx1ZXMoKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckYzI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRjMjM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMyNCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEzID0gcGVnJHBhcnNlY29tbWVudCgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzMxKHMxLCBzNSwgczksIHMxMyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlaW50ZXJuYWxDb21tZW50KCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZpZWxkVmFsdWVzKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2OwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIHMxID0gcGVnJHBhcnNlbmFtZSgpOwogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gW107CiAgICAgICAgICAgIHMzID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHsKICAgICAgICAgICAgICBzNCA9IHBlZyRjMzI7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMzMyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczM7CiAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJGMxOShzMSwgczYpOwogICAgICAgICAgICAgICAgICBzMyA9IHM0OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMzsKICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzOwogICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzOwogICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMi5wdXNoKHMzKTsKICAgICAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJGMzMjsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMzMyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMzOwogICAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJGMxOShzMSwgczYpOwogICAgICAgICAgICAgICAgICAgIHMzID0gczQ7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMzsKICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7CiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMzsKICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgczEgPSBwZWckYzM0KHMxLCBzMik7CiAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VmaWVsZFR5cGUoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7CiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGMzNSkgewogICAgICAgICAgICBzMCA9IHBlZyRjMzU7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzM2KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzM3KSB7CiAgICAgICAgICAgICAgczAgPSBwZWckYzM3OwogICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMzgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGMzOSkgewogICAgICAgICAgICAgICAgczAgPSBwZWckYzM5OwogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzQwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGM0MSkgewogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDE7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzQyKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzQzKSB7CiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQzOwogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNDQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0NSkgewogICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ1OwogICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzQ2KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0NykgewogICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDc7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzQ4KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzQ5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ5OwogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNTApOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGM1MSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzUxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzUyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGM1MykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzU0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzU1KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU1OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNTYpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGM1NykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU3OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzU4KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGM1OSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzYwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDMpID09PSBwZWckYzYxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNjIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlZGVjbGFyZVR5cGUoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlZGVjbGFyZU5hbWUoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzYzKHMxLCBzMyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VmaWVsZFNpemUoKSB7CiAgICAgICAgICB2YXIgczA7CiAgICAgICAgICBzMCA9IHBlZyRwYXJzZW51bWJlcigpOwogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlbmFtZSgpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VuYW1lKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDsKICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICBzMSA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgaWYgKHBlZyRjNjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkgewogICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzY1KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMzID0gW107CiAgICAgICAgICAgIGlmIChwZWckYzY2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM2Nyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMzLnB1c2goczQpOwogICAgICAgICAgICAgIGlmIChwZWckYzY2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM2Nyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMyID0gW3MyLCBzM107CiAgICAgICAgICAgICAgczEgPSBzMjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMxOwogICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTsKICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwOwogICAgICAgICAgICBzMSA9IHBlZyRjNjgoczEpOwogICAgICAgICAgfQogICAgICAgICAgczAgPSBzMTsKICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlcXVvdGVkU3RyaW5nKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzOwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHsKICAgICAgICAgICAgczEgPSBwZWckYzY5OwogICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEOwogICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3MCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMiA9IFtdOwogICAgICAgICAgICBpZiAocGVnJGM3MS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpOwogICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNzIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMi5wdXNoKHMzKTsKICAgICAgICAgICAgICBpZiAocGVnJGM3MS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNzIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7CiAgICAgICAgICAgICAgICBzMyA9IHBlZyRjNjk7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNzApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwOwogICAgICAgICAgICAgICAgczEgPSBwZWckYzczKHMyKTsKICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW5vblF1b3RlZFN0cmluZygpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyOwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIHMxID0gW107CiAgICAgICAgICBpZiAocGVnJGM3NC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNzUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczEucHVzaChzMik7CiAgICAgICAgICAgIGlmIChwZWckYzc0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3NSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgIHMxID0gcGVnJGM3NihzMSk7CiAgICAgICAgICB9CiAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VudW1iZXIoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7CiAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKzsKICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICBzMSA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMiA9IFtdOwogICAgICAgICAgICBpZiAocGVnJGM3OC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpOwogICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNzkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHMyLnB1c2goczMpOwogICAgICAgICAgICAgICAgaWYgKHBlZyRjNzgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkgewogICAgICAgICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzc5KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgczEgPSBwZWckYzgwKCk7CiAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgfQogICAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07CiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEOwogICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3Nyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlXygpIHsKICAgICAgICAgIHZhciBzMCwgczE7CiAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKzsKICAgICAgICAgIHMwID0gW107CiAgICAgICAgICBpZiAocGVnJGM4Mi50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjODMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczAucHVzaChzMSk7CiAgICAgICAgICAgIGlmIChwZWckYzgyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM4Myk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTsKICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzgxKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7CiAgICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7CiAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwZWckbWF4RmFpbFBvcykgOiBudWxsLCBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zICsgMSkgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcykpOwogICAgICAgIH0KICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgU3ludGF4RXJyb3I6IHBlZyRTeW50YXhFcnJvciwKICAgICAgICBwYXJzZTogcGVnJHBhcnNlCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL2JlZC9iZWQtd29ya2VyLnRzP3dvcmtlciZpbmxpbmU/d29ya2VyX2ZpbGUKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGFiaXhJbmRleGVkRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlID0gX190b01vZHVsZShyZXF1aXJlX2VzbSgpKTsKICB2YXIgaW1wb3J0X3F1aWNrX2xydSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9xdWlja19scnUoKSk7CiAgdmFyIGltcG9ydF9idWZmZXI3ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb2NhbEZpbGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9jYWxGaWxlKCkpOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9yZW1vdGVGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgdmFyIG15R2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogeyBmZXRjaDogdm9pZCAwIH07CiAgdmFyIFJlbW90ZUZpbGUgPSBjbGFzcyB7CiAgICBhc3luYyBnZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpIHsKICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5idWZmZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICByZXR1cm4gcmVzcG9uc2UuYnVmZmVyKCk7CiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlLmFycmF5QnVmZmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7CiAgICAgICAgcmV0dXJuIGltcG9ydF9idWZmZXIyLkJ1ZmZlci5mcm9tKHJlc3ApOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImludmFsaWQgSFRUUCByZXNwb25zZSBvYmplY3QsIGhhcyBubyBidWZmZXIgbWV0aG9kLCBhbmQgbm8gYXJyYXlCdWZmZXIgbWV0aG9kIik7CiAgICAgIH0KICAgIH0KICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0cyA9IHt9KSB7CiAgICAgIHRoaXMuYmFzZU92ZXJyaWRlcyA9IHt9OwogICAgICB0aGlzLnVybCA9IHNvdXJjZTsKICAgICAgY29uc3QgZmV0Y2ggPSBvcHRzLmZldGNoIHx8IG15R2xvYmFsLmZldGNoICYmIG15R2xvYmFsLmZldGNoLmJpbmQobXlHbG9iYWwpOwogICAgICBpZiAoIWZldGNoKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8gZmV0Y2ggZnVuY3Rpb24gc3VwcGxpZWQsIGFuZCBub25lIGZvdW5kIGluIGdsb2JhbCBlbnZpcm9ubWVudGApOwogICAgICB9CiAgICAgIGlmIChvcHRzLm92ZXJyaWRlcykgewogICAgICAgIHRoaXMuYmFzZU92ZXJyaWRlcyA9IG9wdHMub3ZlcnJpZGVzOwogICAgICB9CiAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoOwogICAgfQogICAgYXN5bmMgZmV0Y2goaW5wdXQsIGluaXQyKSB7CiAgICAgIGxldCByZXNwb25zZTsKICAgICAgdHJ5IHsKICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgaW5pdDIpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKGAke2V9YC5pbmNsdWRlcygiRmFpbGVkIHRvIGZldGNoIikpIHsKICAgICAgICAgIGNvbnNvbGUud2FybihgZ2VuZXJpYy1maWxlaGFuZGxlOiByZWZldGNoaW5nICR7aW5wdXR9IHRvIGF0dGVtcHQgdG8gd29yayBhcm91bmQgY2hyb21lIENPUlMgaGVhZGVyIGNhY2hpbmcgYnVnYCk7CiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgewogICAgICAgICAgICAuLi5pbml0MiwKICAgICAgICAgICAgY2FjaGU6ICJyZWxvYWQiCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc3BvbnNlOwogICAgfQogICAgYXN5bmMgcmVhZChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgcG9zaXRpb24gPT09IDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCIke3RoaXMudXJsfSBmZXRjaCByZXR1cm5lZCBzdGF0dXMgMjAwLCBleHBlY3RlZCAyMDYiKTsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCk7CiAgICB9CiAgICBhc3luYyByZWFkRmlsZShvcHRpb25zID0ge30pIHsKICAgICAgbGV0IGVuY29kaW5nOwogICAgICBsZXQgb3B0czsKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAic3RyaW5nIikgewogICAgICAgIGVuY29kaW5nID0gb3B0aW9uczsKICAgICAgICBvcHRzID0ge307CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogICAgICAgIG9wdHMgPSBvcHRpb25zOwogICAgICAgIGRlbGV0ZSBvcHRzLmVuY29kaW5nOwogICAgICB9CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIGhlYWRlcnMsCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbCwKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImdlbmVyaWMtZmlsZWhhbmRsZSBmYWlsZWQgdG8gZmV0Y2giKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHsKICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKSwgewogICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IikgewogICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7CiAgICAgIH0KICAgICAgaWYgKGVuY29kaW5nKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgfQogICAgYXN5bmMgc3RhdCgpIHsKICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7CiAgICAgICAgY29uc3QgYnVmID0gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmFsbG9jVW5zYWZlKDEwKTsKICAgICAgICBhd2FpdCB0aGlzLnJlYWQoYnVmLCAwLCAxMCwgMCk7CiAgICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBkZXRlcm1pbmUgc2l6ZSBvZiBmaWxlIGF0ICR7dGhpcy51cmx9YCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9zdGF0OwogICAgfQogICAgYXN5bmMgY2xvc2UoKSB7CiAgICAgIHJldHVybjsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9ibG9iRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjMgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9maWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9lc20vYmd6RmlsZWhhbmRsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjYgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS91bnppcC1wYWtvLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgdmFyIGltcG9ydF9wYWtvID0gX190b01vZHVsZShyZXF1aXJlX3Bha28oKSk7CiAgYXN5bmMgZnVuY3Rpb24gdW56aXAoaW5wdXREYXRhKSB7CiAgICB0cnkgewogICAgICBsZXQgc3RybTsKICAgICAgbGV0IHBvcyA9IDA7CiAgICAgIGxldCBpID0gMDsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGxldCB0b3RhbFNpemUgPSAwOwogICAgICBsZXQgaW5mbGF0b3I7CiAgICAgIGRvIHsKICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zdWJhcnJheShwb3MpOwogICAgICAgIGluZmxhdG9yID0gbmV3IGltcG9ydF9wYWtvLkluZmxhdGUoKTsKICAgICAgICAoeyBzdHJtIH0gPSBpbmZsYXRvcik7CiAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgaW1wb3J0X3Bha28uWl9TWU5DX0ZMVVNIKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICB9CiAgICAgICAgcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICBjaHVua3NbaV0gPSBpbmZsYXRvci5yZXN1bHQ7CiAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgaSArPSAxOwogICAgICB9IHdoaWxlIChzdHJtLmF2YWlsX2luKTsKICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTsKICAgICAgZm9yIChsZXQgaTIgPSAwLCBvZmZzZXQgPSAwOyBpMiA8IGNodW5rcy5sZW5ndGg7IGkyKyspIHsKICAgICAgICByZXN1bHQuc2V0KGNodW5rc1tpMl0sIG9mZnNldCk7CiAgICAgICAgb2Zmc2V0ICs9IGNodW5rc1tpMl0ubGVuZ3RoOwogICAgICB9CiAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgfSBjYXRjaCAoZSkgewogICAgICBpZiAoYCR7ZX1gLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgIH0KICAgICAgdGhyb3cgZTsKICAgIH0KICB9CiAgYXN5bmMgZnVuY3Rpb24gdW56aXBDaHVua1NsaWNlKGlucHV0RGF0YSwgY2h1bmspIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBjb25zdCB7IG1pbnYsIG1heHYgfSA9IGNodW5rOwogICAgICBsZXQgY3BvcyA9IG1pbnYuYmxvY2tQb3NpdGlvbjsKICAgICAgbGV0IGRwb3MgPSBtaW52LmRhdGFQb3NpdGlvbjsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGNvbnN0IGNwb3NpdGlvbnMgPSBbXTsKICAgICAgY29uc3QgZHBvc2l0aW9ucyA9IFtdOwogICAgICBsZXQgdG90YWxTaXplID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBkbyB7CiAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXQgPSBpbnB1dERhdGEuc3ViYXJyYXkoY3BvcyAtIG1pbnYuYmxvY2tQb3NpdGlvbik7CiAgICAgICAgY29uc3QgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIyID0gaW5mbGF0b3IucmVzdWx0OwogICAgICAgIGNodW5rcy5wdXNoKGJ1ZmZlcjIpOwogICAgICAgIGxldCBsZW4gPSBidWZmZXIyLmxlbmd0aDsKICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAxICYmIG1pbnYuZGF0YVBvc2l0aW9uKSB7CiAgICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc3ViYXJyYXkobWludi5kYXRhUG9zaXRpb24pOwogICAgICAgICAgbGVuID0gY2h1bmtzWzBdLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgY29uc3Qgb3JpZ0Nwb3MgPSBjcG9zOwogICAgICAgIGNwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGRwb3MgKz0gbGVuOwogICAgICAgIGlmIChvcmlnQ3BvcyA+PSBtYXh2LmJsb2NrUG9zaXRpb24pIHsKICAgICAgICAgIGNodW5rc1tpXSA9IGNodW5rc1tpXS5zdWJhcnJheSgwLCBtYXh2LmJsb2NrUG9zaXRpb24gPT09IG1pbnYuYmxvY2tQb3NpdGlvbiA/IG1heHYuZGF0YVBvc2l0aW9uIC0gbWludi5kYXRhUG9zaXRpb24gKyAxIDogbWF4di5kYXRhUG9zaXRpb24gKyAxKTsKICAgICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgIGkrKzsKICAgICAgfSB3aGlsZSAoc3RybS5hdmFpbF9pbik7CiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7CiAgICAgIGZvciAobGV0IGkyID0gMCwgb2Zmc2V0ID0gMDsgaTIgPCBjaHVua3MubGVuZ3RoOyBpMisrKSB7CiAgICAgICAgcmVzdWx0LnNldChjaHVua3NbaTJdLCBvZmZzZXQpOwogICAgICAgIG9mZnNldCArPSBjaHVua3NbaTJdLmxlbmd0aDsKICAgICAgfQogICAgICBjb25zdCBidWZmZXIgPSBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgICByZXR1cm4geyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9nemlJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9ub2RlX21vZHVsZXMvbG9uZy9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgd2FzbSA9IG51bGw7CiAgdHJ5IHsKICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgIDAsCiAgICAgIDk3LAogICAgICAxMTUsCiAgICAgIDEwOSwKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMTMsCiAgICAgIDIsCiAgICAgIDk2LAogICAgICAwLAogICAgICAxLAogICAgICAxMjcsCiAgICAgIDk2LAogICAgICA0LAogICAgICAxMjcsCiAgICAgIDEyNywKICAgICAgMTI3LAogICAgICAxMjcsCiAgICAgIDEsCiAgICAgIDEyNywKICAgICAgMywKICAgICAgNywKICAgICAgNiwKICAgICAgMCwKICAgICAgMSwKICAgICAgMSwKICAgICAgMSwKICAgICAgMSwKICAgICAgMSwKICAgICAgNiwKICAgICAgNiwKICAgICAgMSwKICAgICAgMTI3LAogICAgICAxLAogICAgICA2NSwKICAgICAgMCwKICAgICAgMTEsCiAgICAgIDcsCiAgICAgIDUwLAogICAgICA2LAogICAgICAzLAogICAgICAxMDksCiAgICAgIDExNywKICAgICAgMTA4LAogICAgICAwLAogICAgICAxLAogICAgICA1LAogICAgICAxMDAsCiAgICAgIDEwNSwKICAgICAgMTE4LAogICAgICA5NSwKICAgICAgMTE1LAogICAgICAwLAogICAgICAyLAogICAgICA1LAogICAgICAxMDAsCiAgICAgIDEwNSwKICAgICAgMTE4LAogICAgICA5NSwKICAgICAgMTE3LAogICAgICAwLAogICAgICAzLAogICAgICA1LAogICAgICAxMTQsCiAgICAgIDEwMSwKICAgICAgMTA5LAogICAgICA5NSwKICAgICAgMTE1LAogICAgICAwLAogICAgICA0LAogICAgICA1LAogICAgICAxMTQsCiAgICAgIDEwMSwKICAgICAgMTA5LAogICAgICA5NSwKICAgICAgMTE3LAogICAgICAwLAogICAgICA1LAogICAgICA4LAogICAgICAxMDMsCiAgICAgIDEwMSwKICAgICAgMTE2LAogICAgICA5NSwKICAgICAgMTA0LAogICAgICAxMDUsCiAgICAgIDEwMywKICAgICAgMTA0LAogICAgICAwLAogICAgICAwLAogICAgICAxMCwKICAgICAgMTkxLAogICAgICAxLAogICAgICA2LAogICAgICA0LAogICAgICAwLAogICAgICAzNSwKICAgICAgMCwKICAgICAgMTEsCiAgICAgIDM2LAogICAgICAxLAogICAgICAxLAogICAgICAxMjYsCiAgICAgIDMyLAogICAgICAwLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAxLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDMyLAogICAgICAyLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAzLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDEyNiwKICAgICAgMzQsCiAgICAgIDQsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM1LAogICAgICAxNjcsCiAgICAgIDM2LAogICAgICAwLAogICAgICAzMiwKICAgICAgNCwKICAgICAgMTY3LAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTI3LAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExLAogICAgICAzNiwKICAgICAgMSwKICAgICAgMSwKICAgICAgMTI2LAogICAgICAzMiwKICAgICAgMCwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMSwKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAzMiwKICAgICAgMiwKICAgICAgMTczLAogICAgICAzMiwKICAgICAgMywKICAgICAgMTczLAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNCwKICAgICAgMTMyLAogICAgICAxMjgsCiAgICAgIDM0LAogICAgICA0LAogICAgICA2NiwKICAgICAgMzIsCiAgICAgIDEzNSwKICAgICAgMTY3LAogICAgICAzNiwKICAgICAgMCwKICAgICAgMzIsCiAgICAgIDQsCiAgICAgIDE2NywKICAgICAgMTEsCiAgICAgIDM2LAogICAgICAxLAogICAgICAxLAogICAgICAxMjYsCiAgICAgIDMyLAogICAgICAwLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAxLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDMyLAogICAgICAyLAogICAgICAxNzMsCiAgICAgIDMyLAogICAgICAzLAogICAgICAxNzMsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM0LAogICAgICAxMzIsCiAgICAgIDEyOSwKICAgICAgMzQsCiAgICAgIDQsCiAgICAgIDY2LAogICAgICAzMiwKICAgICAgMTM1LAogICAgICAxNjcsCiAgICAgIDM2LAogICAgICAwLAogICAgICAzMiwKICAgICAgNCwKICAgICAgMTY3LAogICAgICAxMSwKICAgICAgMzYsCiAgICAgIDEsCiAgICAgIDEsCiAgICAgIDEyNiwKICAgICAgMzIsCiAgICAgIDAsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDEsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMzIsCiAgICAgIDIsCiAgICAgIDE3MywKICAgICAgMzIsCiAgICAgIDMsCiAgICAgIDE3MywKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzQsCiAgICAgIDEzMiwKICAgICAgMTMwLAogICAgICAzNCwKICAgICAgNCwKICAgICAgNjYsCiAgICAgIDMyLAogICAgICAxMzUsCiAgICAgIDE2NywKICAgICAgMzYsCiAgICAgIDAsCiAgICAgIDMyLAogICAgICA0LAogICAgICAxNjcsCiAgICAgIDExCiAgICBdKSksIHt9KS5leHBvcnRzOwogIH0gY2F0Y2ggKGUpIHsKICB9CiAgZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7CiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDsKICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogIH0KICBMb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgIl9faXNMb25nX18iLCB7IHZhbHVlOiB0cnVlIH0pOwogIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHsKICAgIHJldHVybiAob2JqICYmIG9ialsiX19pc0xvbmdfXyJdKSA9PT0gdHJ1ZTsKICB9CiAgZnVuY3Rpb24gY3R6MzIodmFsdWUpIHsKICAgIHZhciBjID0gTWF0aC5jbHozMih2YWx1ZSAmIC12YWx1ZSk7CiAgICByZXR1cm4gdmFsdWUgPyAzMSAtIGMgOiBjOwogIH0KICBMb25nLmlzTG9uZyA9IGlzTG9uZzsKICB2YXIgSU5UX0NBQ0hFID0ge307CiAgdmFyIFVJTlRfQ0FDSEUgPSB7fTsKICBmdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkgewogICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTsKICAgIGlmICh1bnNpZ25lZCkgewogICAgICB2YWx1ZSA+Pj49IDA7CiAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHsKICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICBpZiAoY2FjaGVkT2JqKQogICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgfQogICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgMCwgdHJ1ZSk7CiAgICAgIGlmIChjYWNoZSkKICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgcmV0dXJuIG9iajsKICAgIH0gZWxzZSB7CiAgICAgIHZhbHVlIHw9IDA7CiAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdOwogICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICB9CiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTsKICAgICAgaWYgKGNhY2hlKQogICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7CiAgICAgIHJldHVybiBvYmo7CiAgICB9CiAgfQogIExvbmcuZnJvbUludCA9IGZyb21JbnQ7CiAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHsKICAgIGlmIChpc05hTih2YWx1ZSkpCiAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgIGlmICh1bnNpZ25lZCkgewogICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgIHJldHVybiBVWkVSTzsKICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKQogICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7CiAgICB9IGVsc2UgewogICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKQogICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpCiAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTsKICAgIH0KICAgIGlmICh2YWx1ZSA8IDApCiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpOwogICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpOwogIH0KICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyOwogIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkgewogICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7CiAgfQogIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0czsKICB2YXIgcG93X2RibCA9IE1hdGgucG93OwogIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHsKICAgIGlmIChzdHIubGVuZ3RoID09PSAwKQogICAgICB0aHJvdyBFcnJvcigiZW1wdHkgc3RyaW5nIik7CiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAibnVtYmVyIikgewogICAgICByYWRpeCA9IHVuc2lnbmVkOwogICAgICB1bnNpZ25lZCA9IGZhbHNlOwogICAgfSBlbHNlIHsKICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgfQogICAgaWYgKHN0ciA9PT0gIk5hTiIgfHwgc3RyID09PSAiSW5maW5pdHkiIHx8IHN0ciA9PT0gIitJbmZpbml0eSIgfHwgc3RyID09PSAiLUluZmluaXR5IikKICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgIHZhciBwOwogICAgaWYgKChwID0gc3RyLmluZGV4T2YoIi0iKSkgPiAwKQogICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICBlbHNlIGlmIChwID09PSAwKSB7CiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICB9CiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7CiAgICB2YXIgcmVzdWx0ID0gWkVSTzsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7CiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLCB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7CiAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpOwogICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpOwogICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpOwogICAgICB9CiAgICB9CiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDsKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7CiAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHsKICAgIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikKICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7CiAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpCiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpOwogICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICB9CiAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7CiAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjsKICB2YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0OwogIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7CiAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDsKICB2YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7CiAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTsKICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7CiAgTG9uZy5aRVJPID0gWkVSTzsKICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpOwogIExvbmcuVVpFUk8gPSBVWkVSTzsKICB2YXIgT05FID0gZnJvbUludCgxKTsKICBMb25nLk9ORSA9IE9ORTsKICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7CiAgTG9uZy5VT05FID0gVU9ORTsKICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpOwogIExvbmcuTkVHX09ORSA9IE5FR19PTkU7CiAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDQyOTQ5NjcyOTUgfCAwLCAyMTQ3NDgzNjQ3IHwgMCwgZmFsc2UpOwogIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFOwogIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgNDI5NDk2NzI5NSB8IDAsIHRydWUpOwogIExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFOwogIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAyMTQ3NDgzNjQ4IHwgMCwgZmFsc2UpOwogIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFOwogIHZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7CiAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkgewogICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkgewogICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHsKICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpCiAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgcmV0dXJuICIwIjsKICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7CiAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLCBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLCByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTsKICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgIH0gZWxzZQogICAgICAgIHJldHVybiAiLSIgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTsKICAgIH0KICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgIHZhciByZXN1bHQgPSAiIjsKICAgIHdoaWxlICh0cnVlKSB7CiAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICByZW0gPSByZW1EaXY7CiAgICAgIGlmIChyZW0uaXNaZXJvKCkpCiAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgZWxzZSB7CiAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KQogICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgIHJlc3VsdCA9ICIiICsgZGlnaXRzICsgcmVzdWx0OwogICAgICB9CiAgICB9CiAgfTsKICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7CiAgICByZXR1cm4gdGhpcy5oaWdoOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHsKICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkgewogICAgcmV0dXJuIHRoaXMubG93OwogIH07CiAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7CiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkgewogICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKQogICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTsKICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93OwogICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKQogICAgICBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKQogICAgICAgIGJyZWFrOwogICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7CiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybzsKICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkgewogICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkgewogICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7CiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7CiAgfTsKICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHsKICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICByZXR1cm4gZmFsc2U7CiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7CiAgfTsKICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7CiAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHsKICAgIHJldHVybiAhdGhpcy5lcShvdGhlcik7CiAgfTsKICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogIExvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFsczsKICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHsKICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDsKICB9OwogIExvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuOwogIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7CiAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8PSAwOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7CiAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7CiAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+IDA7CiAgfTsKICBMb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjsKICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikgewogICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICB9OwogIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsOwogIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHsKICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgaWYgKHRoaXMuZXEob3RoZXIpKQogICAgICByZXR1cm4gMDsKICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpOwogICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKQogICAgICByZXR1cm4gLTE7CiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpCiAgICAgIHJldHVybiAxOwogICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsKICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTsKICB9OwogIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTsKICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHsKICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpCiAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTsKICB9OwogIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7CiAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7CiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKQogICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTsKICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2OwogICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDY1NTM1OwogICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjsKICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2OwogICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiA2NTUzNTsKICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgYzAwICs9IGEwMCArIGIwMDsKICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgYzAwICY9IDY1NTM1OwogICAgYzE2ICs9IGExNiArIGIxNjsKICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgYzE2ICY9IDY1NTM1OwogICAgYzMyICs9IGEzMiArIGIzMjsKICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgYzMyICY9IDY1NTM1OwogICAgYzQ4ICs9IGE0OCArIGI0ODsKICAgIGM0OCAmPSA2NTUzNTsKICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkgewogICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpCiAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7CiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7CiAgfTsKICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7CiAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHsKICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKQogICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpOwogICAgaWYgKHdhc20pIHsKICAgICAgdmFyIGxvdyA9IHdhc21bIm11bCJdKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpOwogICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtWyJnZXRfaGlnaCJdKCksIHRoaXMudW5zaWduZWQpOwogICAgfQogICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpCiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87CiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKQogICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpOwogICAgICBlbHNlCiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpOwogICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpOwogICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkKICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsKICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2OwogICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDY1NTM1OwogICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7CiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgNjU1MzU7CiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2OwogICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgNjU1MzU7CiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgIGMwMCArPSBhMDAgKiBiMDA7CiAgICBjMTYgKz0gYzAwID4+PiAxNjsKICAgIGMwMCAmPSA2NTUzNTsKICAgIGMxNiArPSBhMTYgKiBiMDA7CiAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgIGMxNiAmPSA2NTUzNTsKICAgIGMxNiArPSBhMDAgKiBiMTY7CiAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgIGMxNiAmPSA2NTUzNTsKICAgIGMzMiArPSBhMzIgKiBiMDA7CiAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgIGMzMiAmPSA2NTUzNTsKICAgIGMzMiArPSBhMTYgKiBiMTY7CiAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgIGMzMiAmPSA2NTUzNTsKICAgIGMzMiArPSBhMDAgKiBiMzI7CiAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgIGMzMiAmPSA2NTUzNTsKICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7CiAgICBjNDggJj0gNjU1MzU7CiAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5OwogIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHsKICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOwogICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpCiAgICAgIHRocm93IEVycm9yKCJkaXZpc2lvbiBieSB6ZXJvIik7CiAgICBpZiAod2FzbSkgewogICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoID09PSAtMjE0NzQ4MzY0OCAmJiBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkgewogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9CiAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bImRpdl91Il0gOiB3YXNtWyJkaXZfcyJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTsKICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVsiZ2V0X2hpZ2giXSgpLCB0aGlzLnVuc2lnbmVkKTsKICAgIH0KICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgIHZhciBhcHByb3gsIHJlbSwgcmVzOwogICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7CiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpCiAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOwogICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiBPTkU7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTsKICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7CiAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7CiAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTsKICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTsKICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7CiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpOwogICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTsKICAgICAgcmVzID0gWkVSTzsKICAgIH0gZWxzZSB7CiAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkKICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7CiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKQogICAgICAgIHJldHVybiBVWkVSTzsKICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkKICAgICAgICByZXR1cm4gVU9ORTsKICAgICAgcmVzID0gVVpFUk87CiAgICB9CiAgICByZW0gPSB0aGlzOwogICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHsKICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpOwogICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7CiAgICAgICAgYXBwcm94IC09IGRlbHRhOwogICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICB9CiAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpCiAgICAgICAgYXBwcm94UmVzID0gT05FOwogICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7CiAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgIH0KICAgIHJldHVybiByZXM7CiAgfTsKICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlOwogIExvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHsKICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOwogICAgaWYgKHdhc20pIHsKICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVsicmVtX3UiXSA6IHdhc21bInJlbV9zIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtWyJnZXRfaGlnaCJdKCksIHRoaXMudW5zaWduZWQpOwogICAgfQogICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7CiAgfTsKICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvOwogIExvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7CiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHsKICAgIHJldHVybiB0aGlzLmhpZ2ggPyBNYXRoLmNsejMyKHRoaXMuaGlnaCkgOiBNYXRoLmNsejMyKHRoaXMubG93KSArIDMyOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zOwogIExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkgewogICAgcmV0dXJuIHRoaXMubG93ID8gY3R6MzIodGhpcy5sb3cpIDogY3R6MzIodGhpcy5oaWdoKSArIDMyOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5jdHogPSBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvczsKICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikgewogICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7CiAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikgewogICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykgewogICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgIGVsc2UKICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IG51bUJpdHMgLSAzMiwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0OwogIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykgewogICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICBlbHNlCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gbnVtQml0cyAtIDMyLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDsKICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBpZiAobnVtQml0cyA8IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7CiAgICB2YXIgYjsKICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChudW1CaXRzID09PSAzMikKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpOwogICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICBiID0gMzIgLSBudW1CaXRzOwogICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7CiAgICB9CiAgICBudW1CaXRzIC09IDMyOwogICAgYiA9IDMyIC0gbnVtQml0czsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLnVuc2lnbmVkKTsKICB9OwogIExvbmdQcm90b3R5cGUucm90bCA9IExvbmdQcm90b3R5cGUucm90YXRlTGVmdDsKICBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykgewogICAgdmFyIGI7CiAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBpZiAobnVtQml0cyA9PT0gMzIpCiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTsKICAgIGlmIChudW1CaXRzIDwgMzIpIHsKICAgICAgYiA9IDMyIC0gbnVtQml0czsKICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA8PCBiIHwgdGhpcy5sb3cgPj4+IG51bUJpdHMsIHRoaXMubG93IDw8IGIgfCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgfQogICAgbnVtQml0cyAtPSAzMjsKICAgIGIgPSAzMiAtIG51bUJpdHM7CiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgfTsKICBMb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0OwogIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHsKICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHsKICAgIGlmICh0aGlzLnVuc2lnbmVkKQogICAgICByZXR1cm4gdGhpczsKICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTsKICB9OwogIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHsKICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpOwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7CiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICByZXR1cm4gWwogICAgICBsbyAmIDI1NSwKICAgICAgbG8gPj4+IDggJiAyNTUsCiAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgbG8gPj4+IDI0LAogICAgICBoaSAmIDI1NSwKICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgaGkgPj4+IDI0CiAgICBdOwogIH07CiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7CiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICByZXR1cm4gWwogICAgICBoaSA+Pj4gMjQsCiAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgIGhpICYgMjU1LAogICAgICBsbyA+Pj4gMjQsCiAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgbG8gPj4+IDggJiAyNTUsCiAgICAgIGxvICYgMjU1CiAgICBdOwogIH07CiAgTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkgewogICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpOwogIH07CiAgTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgewogICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTsKICB9OwogIExvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHsKICAgIHJldHVybiBuZXcgTG9uZyhieXRlc1s0XSA8PCAyNCB8IGJ5dGVzWzVdIDw8IDE2IHwgYnl0ZXNbNl0gPDwgOCB8IGJ5dGVzWzddLCBieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9lc20vZ3ppSW5kZXguanMKICB2YXIgaW1wb3J0X2J1ZmZlcjUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3V0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gbG9uZ1RvTnVtYmVyKGxvbmcpIHsKICAgIGlmIChsb25nLmdyZWF0ZXJUaGFuKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB8fCBsb25nLmxlc3NUaGFuKE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoImludGVnZXIgb3ZlcmZsb3ciKTsKICAgIH0KICAgIHJldHVybiBsb25nLnRvTnVtYmVyKCk7CiAgfQogIHZhciBBYm9ydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7CiAgfTsKICBmdW5jdGlvbiBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCkgewogICAgaWYgKCFzaWduYWwpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgIGlmICh0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAidW5kZWZpbmVkIikgewogICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oImFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGUgPSBuZXcgQWJvcnRFcnJvcigiYWJvcnRlZCIpOwogICAgICAgIGUuY29kZSA9ICJFUlJfQUJPUlRFRCI7CiAgICAgICAgdGhyb3cgZTsKICAgICAgfQogICAgfQogIH0KICBmdW5jdGlvbiBjYW5NZXJnZUJsb2NrcyhjaHVuazEsIGNodW5rMikgewogICAgcmV0dXJuIGNodW5rMi5taW52LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWF4di5ibG9ja1Bvc2l0aW9uIDwgNjVlMyAmJiBjaHVuazIubWF4di5ibG9ja1Bvc2l0aW9uIC0gY2h1bmsxLm1pbnYuYmxvY2tQb3NpdGlvbiA8IDVlNjsKICB9CiAgZnVuY3Rpb24gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBsb3dlc3QpIHsKICAgIGNvbnN0IG1lcmdlZENodW5rcyA9IFtdOwogICAgbGV0IGxhc3RDaHVuayA9IG51bGw7CiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gY2h1bmtzOwogICAgfQogICAgY2h1bmtzLnNvcnQoZnVuY3Rpb24oYzAsIGMxKSB7CiAgICAgIGNvbnN0IGRpZiA9IGMwLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGMxLm1pbnYuYmxvY2tQb3NpdGlvbjsKICAgICAgaWYgKGRpZiAhPT0gMCkgewogICAgICAgIHJldHVybiBkaWY7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIGMwLm1pbnYuZGF0YVBvc2l0aW9uIC0gYzEubWludi5kYXRhUG9zaXRpb247CiAgICAgIH0KICAgIH0pOwogICAgY2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiB7CiAgICAgIGlmICghbG93ZXN0IHx8IGNodW5rLm1heHYuY29tcGFyZVRvKGxvd2VzdCkgPiAwKSB7CiAgICAgICAgaWYgKGxhc3RDaHVuayA9PT0gbnVsbCkgewogICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY2h1bmspOwogICAgICAgICAgbGFzdENodW5rID0gY2h1bms7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChjYW5NZXJnZUJsb2NrcyhsYXN0Q2h1bmssIGNodW5rKSkgewogICAgICAgICAgICBpZiAoY2h1bmsubWF4di5jb21wYXJlVG8obGFzdENodW5rLm1heHYpID4gMCkgewogICAgICAgICAgICAgIGxhc3RDaHVuay5tYXh2ID0gY2h1bmsubWF4djsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY2h1bmspOwogICAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIG1lcmdlZENodW5rczsKICB9CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGJpLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZzIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS92aXJ0dWFsT2Zmc2V0LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBWaXJ0dWFsT2Zmc2V0ID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoYmxvY2tQb3NpdGlvbiwgZGF0YVBvc2l0aW9uKSB7CiAgICAgIHRoaXMuYmxvY2tQb3NpdGlvbiA9IGJsb2NrUG9zaXRpb247CiAgICAgIHRoaXMuZGF0YVBvc2l0aW9uID0gZGF0YVBvc2l0aW9uOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLmJsb2NrUG9zaXRpb259OiR7dGhpcy5kYXRhUG9zaXRpb259YDsKICAgIH0KICAgIGNvbXBhcmVUbyhiKSB7CiAgICAgIHJldHVybiB0aGlzLmJsb2NrUG9zaXRpb24gLSBiLmJsb2NrUG9zaXRpb24gfHwgdGhpcy5kYXRhUG9zaXRpb24gLSBiLmRhdGFQb3NpdGlvbjsKICAgIH0KICAgIHN0YXRpYyBtaW4oLi4uYXJncykgewogICAgICBsZXQgbWluOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGZvciAoOyAhbWluOyBpICs9IDEpIHsKICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICB9CiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmIChtaW4uY29tcGFyZVRvKGFyZ3NbaV0pID4gMCkgewogICAgICAgICAgbWluID0gYXJnc1tpXTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG1pbjsKICAgIH0KICB9OwogIGZ1bmN0aW9uIGZyb21CeXRlczIoYnl0ZXMsIG9mZnNldCA9IDAsIGJpZ2VuZGlhbiA9IGZhbHNlKSB7CiAgICBpZiAoYmlnZW5kaWFuKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiYmlnLWVuZGlhbiB2aXJ0dWFsIGZpbGUgb2Zmc2V0cyBub3QgaW1wbGVtZW50ZWQiKTsKICAgIH0KICAgIHJldHVybiBuZXcgVmlydHVhbE9mZnNldChieXRlc1tvZmZzZXQgKyA3XSAqIDEwOTk1MTE2Mjc3NzYgKyBieXRlc1tvZmZzZXQgKyA2XSAqIDQyOTQ5NjcyOTYgKyBieXRlc1tvZmZzZXQgKyA1XSAqIDE2Nzc3MjE2ICsgYnl0ZXNbb2Zmc2V0ICsgNF0gKiA2NTUzNiArIGJ5dGVzW29mZnNldCArIDNdICogMjU2ICsgYnl0ZXNbb2Zmc2V0ICsgMl0sIGJ5dGVzW29mZnNldCArIDFdIDw8IDggfCBieXRlc1tvZmZzZXRdKTsKICB9CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vY2h1bmsuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIENodW5rID0gY2xhc3MgewogICAgY29uc3RydWN0b3IobWludiwgbWF4diwgYmluLCBmZXRjaGVkU2l6ZSA9IHZvaWQgMCkgewogICAgICB0aGlzLm1pbnYgPSBtaW52OwogICAgICB0aGlzLm1heHYgPSBtYXh2OwogICAgICB0aGlzLmJpbiA9IGJpbjsKICAgICAgdGhpcy5fZmV0Y2hlZFNpemUgPSBmZXRjaGVkU2l6ZTsKICAgIH0KICAgIHRvVW5pcXVlU3RyaW5nKCkgewogICAgICByZXR1cm4gYCR7dGhpcy5taW52fS4uJHt0aGlzLm1heHZ9IChiaW4gJHt0aGlzLmJpbn0sIGZldGNoZWRTaXplICR7dGhpcy5mZXRjaGVkU2l6ZSgpfSlgOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLnRvVW5pcXVlU3RyaW5nKCk7CiAgICB9CiAgICBjb21wYXJlVG8oYikgewogICAgICByZXR1cm4gdGhpcy5taW52LmNvbXBhcmVUbyhiLm1pbnYpIHx8IHRoaXMubWF4di5jb21wYXJlVG8oYi5tYXh2KSB8fCB0aGlzLmJpbiAtIGIuYmluOwogICAgfQogICAgZmV0Y2hlZFNpemUoKSB7CiAgICAgIGlmICh0aGlzLl9mZXRjaGVkU2l6ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoZWRTaXplOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLm1heHYuYmxvY2tQb3NpdGlvbiArICgxIDw8IDE2KSAtIHRoaXMubWludi5ibG9ja1Bvc2l0aW9uOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vaW5kZXhGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBJbmRleEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IGZpbGVoYW5kbGUsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiB9KSB7CiAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgIH0KICAgIGFzeW5jIGdldE1ldGFkYXRhKG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGluZGljZXMsIC4uLnJlc3QgfSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIHJldHVybiByZXN0OwogICAgfQogICAgX2ZpbmRGaXJzdERhdGEoY3VycmVudEZkbCwgdmlydHVhbE9mZnNldCkgewogICAgICBpZiAoY3VycmVudEZkbCkgewogICAgICAgIHJldHVybiBjdXJyZW50RmRsLmNvbXBhcmVUbyh2aXJ0dWFsT2Zmc2V0KSA+IDAgPyB2aXJ0dWFsT2Zmc2V0IDogY3VycmVudEZkbDsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdmlydHVhbE9mZnNldDsKICAgICAgfQogICAgfQogICAgYXN5bmMgcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGlmICghdGhpcy5wYXJzZVApIHsKICAgICAgICB0aGlzLnBhcnNlUCA9IHRoaXMuX3BhcnNlKG9wdHMpLmNhdGNoKChlKSA9PiB7CiAgICAgICAgICB0aGlzLnBhcnNlUCA9IHZvaWQgMDsKICAgICAgICAgIHRocm93IGU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMucGFyc2VQOwogICAgfQogICAgYXN5bmMgaGFzUmVmU2VxKHNlcUlkLCBvcHRzID0ge30pIHsKICAgICAgcmV0dXJuICEhKChhd2FpdCB0aGlzLnBhcnNlKG9wdHMpKS5pbmRpY2VzW3NlcUlkXSB8fCB7fSkuYmluSW5kZXg7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YmkuanMKICB2YXIgVEJJX01BR0lDID0gMjE1NzgzMjQ7CiAgdmFyIFRBRF9MSURYX1NISUZUID0gMTQ7CiAgZnVuY3Rpb24gcmVnMmJpbnMoYmVnLCBlbmQpIHsKICAgIGJlZyArPSAxOwogICAgZW5kIC09IDE7CiAgICByZXR1cm4gWwogICAgICBbMCwgMF0sCiAgICAgIFsxICsgKGJlZyA+PiAyNiksIDEgKyAoZW5kID4+IDI2KV0sCiAgICAgIFs5ICsgKGJlZyA+PiAyMyksIDkgKyAoZW5kID4+IDIzKV0sCiAgICAgIFs3MyArIChiZWcgPj4gMjApLCA3MyArIChlbmQgPj4gMjApXSwKICAgICAgWzU4NSArIChiZWcgPj4gMTcpLCA1ODUgKyAoZW5kID4+IDE3KV0sCiAgICAgIFs0NjgxICsgKGJlZyA+PiAxNCksIDQ2ODEgKyAoZW5kID4+IDE0KV0KICAgIF07CiAgfQogIHZhciBUYWJpeEluZGV4ID0gY2xhc3MgZXh0ZW5kcyBJbmRleEZpbGUgewogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXTsKICAgICAgY29uc3QgaWR4ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWlkeCkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCB7IHN0YXRzIH0gPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmIChzdGF0cykgewogICAgICAgIHJldHVybiBzdGF0cy5saW5lQ291bnQ7CiAgICAgIH0KICAgICAgcmV0dXJuIC0xOwogICAgfQogICAgYXN5bmMgX3BhcnNlKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBidWYgPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZEZpbGUob3B0cyk7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoYnVmKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgIT09IFRCSV9NQUdJQykgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTm90IGEgVEJJIGZpbGUiKTsKICAgICAgfQogICAgICBjb25zdCByZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICBjb25zdCBmb3JtYXRGbGFncyA9IGJ5dGVzLnJlYWRJbnQzMkxFKDgpOwogICAgICBjb25zdCBjb29yZGluYXRlVHlwZSA9IGZvcm1hdEZsYWdzICYgNjU1MzYgPyAiemVyby1iYXNlZC1oYWxmLW9wZW4iIDogIjEtYmFzZWQtY2xvc2VkIjsKICAgICAgY29uc3QgZm9ybWF0T3B0cyA9IHsKICAgICAgICAwOiAiZ2VuZXJpYyIsCiAgICAgICAgMTogIlNBTSIsCiAgICAgICAgMjogIlZDRiIKICAgICAgfTsKICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0T3B0c1tmb3JtYXRGbGFncyAmIDE1XTsKICAgICAgaWYgKCFmb3JtYXQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgVGFiaXggcHJlc2V0IGZvcm1hdCBmbGFncyAke2Zvcm1hdEZsYWdzfWApOwogICAgICB9CiAgICAgIGNvbnN0IGNvbHVtbk51bWJlcnMgPSB7CiAgICAgICAgcmVmOiBieXRlcy5yZWFkSW50MzJMRSgxMiksCiAgICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKDE2KSwKICAgICAgICBlbmQ6IGJ5dGVzLnJlYWRJbnQzMkxFKDIwKQogICAgICB9OwogICAgICBjb25zdCBtZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRSgyNCk7CiAgICAgIGNvbnN0IGRlcHRoID0gNTsKICAgICAgY29uc3QgbWF4QmluTnVtYmVyID0gKCgxIDw8IChkZXB0aCArIDEpICogMykgLSAxKSAvIDc7CiAgICAgIGNvbnN0IG1heFJlZkxlbmd0aCA9IDIgKiogKDE0ICsgZGVwdGggKiAzKTsKICAgICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiBudWxsOwogICAgICBjb25zdCBza2lwTGluZXMgPSBieXRlcy5yZWFkSW50MzJMRSgyOCk7CiAgICAgIGNvbnN0IG5hbWVTZWN0aW9uTGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUoMzIpOwogICAgICBjb25zdCB7IHJlZk5hbWVUb0lkLCByZWZJZFRvTmFtZSB9ID0gdGhpcy5fcGFyc2VOYW1lQnl0ZXMoYnl0ZXMuc2xpY2UoMzYsIDM2ICsgbmFtZVNlY3Rpb25MZW5ndGgpKTsKICAgICAgbGV0IGN1cnJPZmZzZXQgPSAzNiArIG5hbWVTZWN0aW9uTGVuZ3RoOwogICAgICBsZXQgZmlyc3REYXRhTGluZTsKICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShyZWZDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4gewogICAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGJpbkluZGV4ID0ge307CiAgICAgICAgbGV0IHN0YXRzOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmluQ291bnQ7IGogKz0gMSkgewogICAgICAgICAgY29uc3QgYmluID0gYnl0ZXMucmVhZFVJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgaWYgKGJpbiA+IG1heEJpbk51bWJlciArIDEpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ0YWJpeCBpbmRleCBjb250YWlucyB0b28gbWFueSBiaW5zLCBwbGVhc2UgdXNlIGEgQ1NJIGluZGV4Iik7CiAgICAgICAgICB9IGVsc2UgaWYgKGJpbiA9PT0gbWF4QmluTnVtYmVyICsgMSkgewogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgPT09IDIpIHsKICAgICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTYgKiBjaHVua0NvdW50OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGZyb21CeXRlczIoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIHUpOwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxpbmVhckNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGxpbmVhckluZGV4ID0gbmV3IEFycmF5KGxpbmVhckNvdW50KTsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbmVhckNvdW50OyBrICs9IDEpIHsKICAgICAgICAgIGxpbmVhckluZGV4W2tdID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDg7CiAgICAgICAgICBmaXJzdERhdGFMaW5lID0gdGhpcy5fZmluZEZpcnN0RGF0YShmaXJzdERhdGFMaW5lLCBsaW5lYXJJbmRleFtrXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJpbkluZGV4LCBsaW5lYXJJbmRleCwgc3RhdHMgfTsKICAgICAgfSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgaW5kaWNlcywKICAgICAgICBtZXRhQ2hhciwKICAgICAgICBtYXhCaW5OdW1iZXIsCiAgICAgICAgbWF4UmVmTGVuZ3RoLAogICAgICAgIHNraXBMaW5lcywKICAgICAgICBmaXJzdERhdGFMaW5lLAogICAgICAgIGNvbHVtbk51bWJlcnMsCiAgICAgICAgY29vcmRpbmF0ZVR5cGUsCiAgICAgICAgZm9ybWF0LAogICAgICAgIHJlZklkVG9OYW1lLAogICAgICAgIHJlZk5hbWVUb0lkLAogICAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNgogICAgICB9OwogICAgfQogICAgcGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBsaW5lQ291bnQgPSBsb25nVG9OdW1iZXIoaW1wb3J0X2xvbmcyLmRlZmF1bHQuZnJvbUJ5dGVzTEUoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMTYsIG9mZnNldCArIDI0KSwgdHJ1ZSkpOwogICAgICByZXR1cm4geyBsaW5lQ291bnQgfTsKICAgIH0KICAgIF9wYXJzZU5hbWVCeXRlcyhuYW1lc0J5dGVzKSB7CiAgICAgIGxldCBjdXJyUmVmSWQgPSAwOwogICAgICBsZXQgY3Vyck5hbWVTdGFydCA9IDA7CiAgICAgIGNvbnN0IHJlZklkVG9OYW1lID0gW107CiAgICAgIGNvbnN0IHJlZk5hbWVUb0lkID0ge307CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmICghbmFtZXNCeXRlc1tpXSkgewogICAgICAgICAgaWYgKGN1cnJOYW1lU3RhcnQgPCBpKSB7CiAgICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygidXRmOCIsIGN1cnJOYW1lU3RhcnQsIGkpOwogICAgICAgICAgICByZWZOYW1lID0gdGhpcy5yZW5hbWVSZWZTZXEocmVmTmFtZSk7CiAgICAgICAgICAgIHJlZklkVG9OYW1lW2N1cnJSZWZJZF0gPSByZWZOYW1lOwogICAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZDsKICAgICAgICAgIH0KICAgICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMTsKICAgICAgICAgIGN1cnJSZWZJZCArPSAxOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIG1pbiwgbWF4LCBvcHRzID0ge30pIHsKICAgICAgaWYgKG1pbiA8IDApIHsKICAgICAgICBtaW4gPSAwOwogICAgICB9CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBtaW5PZmZzZXQgPSBiYS5saW5lYXJJbmRleC5sZW5ndGggPyBiYS5saW5lYXJJbmRleFttaW4gPj4gVEFEX0xJRFhfU0hJRlQgPj0gYmEubGluZWFySW5kZXgubGVuZ3RoID8gYmEubGluZWFySW5kZXgubGVuZ3RoIC0gMSA6IG1pbiA+PiBUQURfTElEWF9TSElGVF0gOiBuZXcgVmlydHVhbE9mZnNldCgwLCAwKTsKICAgICAgaWYgKCFtaW5PZmZzZXQpIHsKICAgICAgICBjb25zb2xlLndhcm4oInF1ZXJ5aW5nIG91dHNpZGUgb2YgcG9zc2libGUgdGFiaXggcmFuZ2UiKTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSByZWcyYmlucyhtaW4sIG1heCk7CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBvdmVybGFwcGluZ0JpbnMpIHsKICAgICAgICBmb3IgKGxldCBiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHsKICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7CiAgICAgICAgICAgIGNvbnN0IGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl07CiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYmluQ2h1bmtzLmxlbmd0aDsgKytjKSB7CiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IENodW5rKGJpbkNodW5rc1tjXS5taW52LCBiaW5DaHVua3NbY10ubWF4diwgYmluKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgbmludHYgPSBiYS5saW5lYXJJbmRleC5sZW5ndGg7CiAgICAgIGxldCBsb3dlc3QgPSBudWxsOwogICAgICBjb25zdCBtaW5MaW4gPSBNYXRoLm1pbihtaW4gPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgIGNvbnN0IG1heExpbiA9IE1hdGgubWluKG1heCA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgZm9yIChsZXQgaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkgewogICAgICAgIGNvbnN0IHZwID0gYmEubGluZWFySW5kZXhbaV07CiAgICAgICAgaWYgKHZwKSB7CiAgICAgICAgICBpZiAoIWxvd2VzdCB8fCB2cC5jb21wYXJlVG8obG93ZXN0KSA8IDApIHsKICAgICAgICAgICAgbG93ZXN0ID0gdnA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCk7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9jc2kuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwogIHZhciBDU0kxX01BR0lDID0gMjE1ODI2NTk7CiAgdmFyIENTSTJfTUFHSUMgPSAzODM1OTg3NTsKICBmdW5jdGlvbiBsc2hpZnQobnVtLCBiaXRzKSB7CiAgICByZXR1cm4gbnVtICogMiAqKiBiaXRzOwogIH0KICBmdW5jdGlvbiByc2hpZnQobnVtLCBiaXRzKSB7CiAgICByZXR1cm4gTWF0aC5mbG9vcihudW0gLyAyICoqIGJpdHMpOwogIH0KICB2YXIgQ1NJID0gY2xhc3MgZXh0ZW5kcyBJbmRleEZpbGUgewogICAgY29uc3RydWN0b3IoYXJncykgewogICAgICBzdXBlcihhcmdzKTsKICAgICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAwOwogICAgICB0aGlzLmRlcHRoID0gMDsKICAgICAgdGhpcy5taW5TaGlmdCA9IDA7CiAgICB9CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBpbmRleENvdigpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDU0kgaW5kZXhlcyBkbyBub3Qgc3VwcG9ydCBpbmRleGNvdiIpOwogICAgfQogICAgcGFyc2VBdXhEYXRhKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQpOwogICAgICBjb25zdCBjb29yZGluYXRlVHlwZSA9IGZvcm1hdEZsYWdzICYgNjU1MzYgPyAiemVyby1iYXNlZC1oYWxmLW9wZW4iIDogIjEtYmFzZWQtY2xvc2VkIjsKICAgICAgY29uc3QgZm9ybWF0ID0geyAwOiAiZ2VuZXJpYyIsIDE6ICJTQU0iLCAyOiAiVkNGIiB9W2Zvcm1hdEZsYWdzICYgMTVdOwogICAgICBpZiAoIWZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7Zm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHsKICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpLAogICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyA4KSwKICAgICAgICBlbmQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDEyKQogICAgICB9OwogICAgICBjb25zdCBtZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxNik7CiAgICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogbnVsbDsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjApOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KTsKICAgICAgY29uc3QgeyByZWZJZFRvTmFtZSwgcmVmTmFtZVRvSWQgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKG9mZnNldCArIDI4LCBvZmZzZXQgKyAyOCArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIGNvbHVtbk51bWJlcnMsCiAgICAgICAgZm9ybWF0LAogICAgICAgIGNvb3JkaW5hdGVUeXBlCiAgICAgIH07CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpKTsKICAgICAgbGV0IGNzaVZlcnNpb247CiAgICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTFfTUFHSUMpIHsKICAgICAgICBjc2lWZXJzaW9uID0gMTsKICAgICAgfSBlbHNlIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTJfTUFHSUMpIHsKICAgICAgICBjc2lWZXJzaW9uID0gMjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIENTSSBmaWxlIik7CiAgICAgIH0KICAgICAgdGhpcy5taW5TaGlmdCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICB0aGlzLmRlcHRoID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gKCgxIDw8ICh0aGlzLmRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAodGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzKTsKICAgICAgY29uc3QgYXV4TGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUoMTIpOwogICAgICBjb25zdCBhdXggPSBhdXhMZW5ndGggJiYgYXV4TGVuZ3RoID49IDMwID8gdGhpcy5wYXJzZUF1eERhdGEoYnl0ZXMsIDE2KSA6IHsKICAgICAgICByZWZJZFRvTmFtZTogW10sCiAgICAgICAgcmVmTmFtZVRvSWQ6IHt9LAogICAgICAgIG1ldGFDaGFyOiBudWxsLAogICAgICAgIGNvbHVtbk51bWJlcnM6IHsgcmVmOiAwLCBzdGFydDogMSwgZW5kOiAyIH0sCiAgICAgICAgY29vcmRpbmF0ZVR5cGU6ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIsCiAgICAgICAgZm9ybWF0OiAiZ2VuZXJpYyIKICAgICAgfTsKICAgICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSgxNiArIGF1eExlbmd0aCk7CiAgICAgIGxldCBmaXJzdERhdGFMaW5lOwogICAgICBsZXQgY3Vyck9mZnNldCA9IDE2ICsgYXV4TGVuZ3RoICsgNDsKICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShyZWZDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4gewogICAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGJpbkluZGV4ID0ge307CiAgICAgICAgbGV0IHN0YXRzOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmluQ291bnQ7IGogKz0gMSkgewogICAgICAgICAgY29uc3QgYmluID0gYnl0ZXMucmVhZFVJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgaWYgKGJpbiA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQgKyA4ICsgNCArIDE2ICsgMTY7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBsb2Zmc2V0ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICBmaXJzdERhdGFMaW5lID0gdGhpcy5fZmluZEZpcnN0RGF0YShmaXJzdERhdGFMaW5lLCBsb2Zmc2V0KTsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQgKyAxMik7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzMihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGZyb21CeXRlczIoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJpbkluZGV4LCBzdGF0cyB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIHsKICAgICAgICAuLi5hdXgsCiAgICAgICAgY3NpOiB0cnVlLAogICAgICAgIHJlZkNvdW50LAogICAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNiwKICAgICAgICBmaXJzdERhdGFMaW5lLAogICAgICAgIGNzaVZlcnNpb24sCiAgICAgICAgaW5kaWNlcywKICAgICAgICBkZXB0aDogdGhpcy5kZXB0aCwKICAgICAgICBtYXhCaW5OdW1iZXI6IHRoaXMubWF4QmluTnVtYmVyLAogICAgICAgIG1heFJlZkxlbmd0aAogICAgICB9OwogICAgfQogICAgcGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBsaW5lQ291bnQgPSBsb25nVG9OdW1iZXIoaW1wb3J0X2xvbmczLmRlZmF1bHQuZnJvbUJ5dGVzTEUoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMjgsIG9mZnNldCArIDM2KSwgdHJ1ZSkpOwogICAgICByZXR1cm4geyBsaW5lQ291bnQgfTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIG1pbiwgbWF4LCBvcHRzID0ge30pIHsKICAgICAgaWYgKG1pbiA8IDApIHsKICAgICAgICBtaW4gPSAwOwogICAgICB9CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSB0aGlzLnJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBuZXcgVmlydHVhbE9mZnNldCgwLCAwKSk7CiAgICB9CiAgICByZWcyYmlucyhiZWcsIGVuZCkgewogICAgICBiZWcgLT0gMTsKICAgICAgaWYgKGJlZyA8IDEpIHsKICAgICAgICBiZWcgPSAxOwogICAgICB9CiAgICAgIGlmIChlbmQgPiAyICoqIDUwKSB7CiAgICAgICAgZW5kID0gMiAqKiAzNDsKICAgICAgfQogICAgICBlbmQgLT0gMTsKICAgICAgbGV0IGwgPSAwOwogICAgICBsZXQgdCA9IDA7CiAgICAgIGxldCBzID0gdGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzOwogICAgICBjb25zdCBiaW5zID0gW107CiAgICAgIGZvciAoOyBsIDw9IHRoaXMuZGVwdGg7IHMgLT0gMywgdCArPSBsc2hpZnQoMSwgbCAqIDMpLCBsICs9IDEpIHsKICAgICAgICBjb25zdCBiID0gdCArIHJzaGlmdChiZWcsIHMpOwogICAgICAgIGNvbnN0IGUgPSB0ICsgcnNoaWZ0KGVuZCwgcyk7CiAgICAgICAgaWYgKGUgLSBiICsgYmlucy5sZW5ndGggPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBxdWVyeSAke2JlZ30tJHtlbmR9IGlzIHRvbyBsYXJnZSBmb3IgY3VycmVudCBiaW5uaW5nIHNjaGVtZSAoc2hpZnQgJHt0aGlzLm1pblNoaWZ0fSwgZGVwdGggJHt0aGlzLmRlcHRofSksIHRyeSBhIHNtYWxsZXIgcXVlcnkgb3IgYSBjb2Fyc2VyIGluZGV4IGJpbm5pbmcgc2NoZW1lYCk7CiAgICAgICAgfQogICAgICAgIGJpbnMucHVzaChbYiwgZV0pOwogICAgICB9CiAgICAgIHJldHVybiBiaW5zOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGFiaXhJbmRleGVkRmlsZS5qcwogIHZhciBkZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAidW5kZWZpbmVkIiA/IG5ldyBUZXh0RGVjb2RlcigidXRmLTgiKSA6IHZvaWQgMDsKICBmdW5jdGlvbiB0aW1lb3V0KHRpbWUpIHsKICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKSk7CiAgfQogIHZhciBUYWJpeEluZGV4ZWRGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoeyBwYXRoLCBmaWxlaGFuZGxlLCB0YmlQYXRoLCB0YmlGaWxlaGFuZGxlLCBjc2lQYXRoLCBjc2lGaWxlaGFuZGxlLCB5aWVsZFRpbWUgPSA1MDAsIGNodW5rU2l6ZUxpbWl0ID0gNWU3LCByZW5hbWVSZWZTZXFzID0gKG4pID0+IG4sIGNodW5rQ2FjaGVTaXplID0gNSAqIDIgKiogMjAgfSkgewogICAgICBpZiAoZmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgIH0gZWxzZSBpZiAocGF0aCkgewogICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQocGF0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwcm92aWRlIGVpdGhlciBmaWxlaGFuZGxlIG9yIHBhdGgiKTsKICAgICAgfQogICAgICBpZiAodGJpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgVGFiaXhJbmRleCh7CiAgICAgICAgICBmaWxlaGFuZGxlOiB0YmlGaWxlaGFuZGxlLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaUZpbGVoYW5kbGUpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBjc2lGaWxlaGFuZGxlLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHRiaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdCh0YmlQYXRoKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChjc2lQYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChjc2lQYXRoKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQoYCR7cGF0aH0udGJpYCksCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwcm92aWRlIG9uZSBvZiB0YmlGaWxlaGFuZGxlLCB0YmlQYXRoLCBjc2lGaWxlaGFuZGxlLCBvciBjc2lQYXRoIik7CiAgICAgIH0KICAgICAgdGhpcy5jaHVua1NpemVMaW1pdCA9IGNodW5rU2l6ZUxpbWl0OwogICAgICB0aGlzLnJlbmFtZVJlZlNlcSA9IHJlbmFtZVJlZlNlcXM7CiAgICAgIHRoaXMueWllbGRUaW1lID0geWllbGRUaW1lOwogICAgICB0aGlzLmNodW5rQ2FjaGUgPSBuZXcgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlLmRlZmF1bHQoewogICAgICAgIGNhY2hlOiBuZXcgaW1wb3J0X3F1aWNrX2xydS5kZWZhdWx0KHsgbWF4U2l6ZTogTWF0aC5mbG9vcihjaHVua0NhY2hlU2l6ZSAvICgxIDw8IDE2KSkgfSksCiAgICAgICAgZmlsbDogKGFyZ3MsIHNpZ25hbCkgPT4gdGhpcy5yZWFkQ2h1bmsoYXJncywgeyBzaWduYWwgfSkKICAgICAgfSk7CiAgICB9CiAgICBhc3luYyBnZXRMaW5lcyhyZWZOYW1lLCBzdGFydCwgZW5kLCBvcHRzKSB7CiAgICAgIGxldCBzaWduYWw7CiAgICAgIGxldCBvcHRpb25zID0ge307CiAgICAgIGxldCBjYWxsYmFjazsKICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAidW5kZWZpbmVkIikgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImxpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCIpOwogICAgICB9CiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNhbGxiYWNrID0gb3B0czsKICAgICAgfSBlbHNlIHsKICAgICAgICBvcHRpb25zID0gb3B0czsKICAgICAgICBjYWxsYmFjayA9IG9wdHMubGluZUNhbGxiYWNrOwogICAgICB9CiAgICAgIGlmIChyZWZOYW1lID09PSB2b2lkIDApIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgYSByZWZlcmVuY2Ugc2VxdWVuY2UgbmFtZSIpOwogICAgICB9CiAgICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJsaW5lIGNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQiKTsKICAgICAgfQogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0aW9ucyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgaWYgKCFzdGFydCkgewogICAgICAgIHN0YXJ0ID0gMDsKICAgICAgfQogICAgICBpZiAoIWVuZCkgewogICAgICAgIGVuZCA9IG1ldGFkYXRhLm1heFJlZkxlbmd0aDsKICAgICAgfQogICAgICBpZiAoIShzdGFydCA8PSBlbmQpKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzLiBzdGFydCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBlbmQiKTsKICAgICAgfQogICAgICBpZiAoc3RhcnQgPT09IGVuZCkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgY29uc3Qgc2l6ZSA9IGNodW5rc1tpXS5mZXRjaGVkU2l6ZSgpOwogICAgICAgIGlmIChzaXplID4gdGhpcy5jaHVua1NpemVMaW1pdCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbXVjaCBkYXRhLiBDaHVuayBzaXplICR7c2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlcyBleGNlZWRzIGNodW5rU2l6ZUxpbWl0IG9mICR7dGhpcy5jaHVua1NpemVMaW1pdC50b0xvY2FsZVN0cmluZygpfS5gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgbGV0IGxhc3QgPSBEYXRlLm5vdygpOwogICAgICBmb3IgKGxldCBjaHVua051bSA9IDA7IGNodW5rTnVtIDwgY2h1bmtzLmxlbmd0aDsgY2h1bmtOdW0gKz0gMSkgewogICAgICAgIGxldCBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZTsKICAgICAgICBjb25zdCBjID0gY2h1bmtzW2NodW5rTnVtXTsKICAgICAgICBjb25zdCB7IGJ1ZmZlciwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9ID0gYXdhaXQgdGhpcy5jaHVua0NhY2hlLmdldChjLnRvU3RyaW5nKCksIGMpOwogICAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgICBsZXQgYmxvY2tTdGFydCA9IDA7CiAgICAgICAgbGV0IHBvcyA9IDA7CiAgICAgICAgd2hpbGUgKGJsb2NrU3RhcnQgPCBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBuID0gYnVmZmVyLmluZGV4T2YoIlxuIiwgYmxvY2tTdGFydCk7CiAgICAgICAgICBpZiAobiA9PT0gLTEpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBiID0gYnVmZmVyLnNsaWNlKGJsb2NrU3RhcnQsIG4pOwogICAgICAgICAgY29uc3QgbGluZSA9IChkZWNvZGVyID09PSBudWxsIHx8IGRlY29kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29kZXIuZGVjb2RlKGIpKSB8fCBiLnRvU3RyaW5nKCk7CiAgICAgICAgICBpZiAoZHBvc2l0aW9ucykgewogICAgICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCArIGMubWludi5kYXRhUG9zaXRpb24gPj0gZHBvc2l0aW9uc1twb3MrK10pIHsKICAgICAgICAgICAgfQogICAgICAgICAgICBwb3MtLTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwcyB9ID0gdGhpcy5jaGVja0xpbmUobWV0YWRhdGEsIHJlZk5hbWUsIHN0YXJ0LCBlbmQsIGxpbmUpOwogICAgICAgICAgaWYgKHByZXZpb3VzU3RhcnRDb29yZGluYXRlICE9PSB2b2lkIDAgJiYgc3RhcnRDb29yZGluYXRlICE9PSB2b2lkIDAgJiYgcHJldmlvdXNTdGFydENvb3JkaW5hdGUgPiBzdGFydENvb3JkaW5hdGUpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lcyBub3Qgc29ydGVkIGJ5IHN0YXJ0IGNvb3JkaW5hdGUgKCR7cHJldmlvdXNTdGFydENvb3JkaW5hdGV9ID4gJHtzdGFydENvb3JkaW5hdGV9KSwgdGhpcyBmaWxlIGlzIG5vdCB1c2FibGUgd2l0aCBUYWJpeC5gKTsKICAgICAgICAgIH0KICAgICAgICAgIHByZXZpb3VzU3RhcnRDb29yZGluYXRlID0gc3RhcnRDb29yZGluYXRlOwogICAgICAgICAgaWYgKG92ZXJsYXBzKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGxpbmUudHJpbSgpLCBjcG9zaXRpb25zW3Bvc10gKiAoMSA8PCA4KSArIChibG9ja1N0YXJ0IC0gZHBvc2l0aW9uc1twb3NdKSArIGMubWludi5kYXRhUG9zaXRpb24gKyAxKTsKICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRDb29yZGluYXRlICE9PSB2b2lkIDAgJiYgc3RhcnRDb29yZGluYXRlID49IGVuZCkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy55aWVsZFRpbWUgJiYgbGFzdCAtIERhdGUubm93KCkgPiB0aGlzLnlpZWxkVGltZSkgewogICAgICAgICAgICBsYXN0ID0gRGF0ZS5ub3coKTsKICAgICAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEpOwogICAgICAgICAgfQogICAgICAgICAgYmxvY2tTdGFydCA9IG4gKyAxOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgYXN5bmMgZ2V0TWV0YWRhdGEob3B0cyA9IHt9KSB7CiAgICAgIHJldHVybiB0aGlzLmluZGV4LmdldE1ldGFkYXRhKG9wdHMpOwogICAgfQogICAgYXN5bmMgZ2V0SGVhZGVyQnVmZmVyKG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGZpcnN0RGF0YUxpbmUsIG1ldGFDaGFyLCBtYXhCbG9ja1NpemUgfSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpOwogICAgICBjb25zdCBtYXhGZXRjaCA9ICgoZmlyc3REYXRhTGluZSA9PT0gbnVsbCB8fCBmaXJzdERhdGFMaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdERhdGFMaW5lLmJsb2NrUG9zaXRpb24pIHx8IDApICsgbWF4QmxvY2tTaXplOwogICAgICBsZXQgYnl0ZXMgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKDAsIG1heEZldGNoLCBvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIHRyeSB7CiAgICAgICAgYnl0ZXMgPSBhd2FpdCB1bnppcChieXRlcyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3IgZGVjb21wcmVzc2luZyBibG9jayAke2UuY29kZX0gYXQgMCAobGVuZ3RoICR7bWF4RmV0Y2h9KSAke2V9YCk7CiAgICAgIH0KICAgICAgaWYgKG1ldGFDaGFyKSB7CiAgICAgICAgbGV0IGxhc3ROZXdsaW5lID0gLTE7CiAgICAgICAgY29uc3QgbmV3bGluZUJ5dGUgPSAiXG4iLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgY29uc3QgbWV0YUJ5dGUgPSBtZXRhQ2hhci5jaGFyQ29kZUF0KDApOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgIGlmIChpID09PSBsYXN0TmV3bGluZSArIDEgJiYgYnl0ZXNbaV0gIT09IG1ldGFCeXRlKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJ5dGVzW2ldID09PSBuZXdsaW5lQnl0ZSkgewogICAgICAgICAgICBsYXN0TmV3bGluZSA9IGk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMCwgbGFzdE5ld2xpbmUgKyAxKTsKICAgICAgfQogICAgICByZXR1cm4gYnl0ZXM7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJCdWZmZXIob3B0cyk7CiAgICAgIHJldHVybiBieXRlcy50b1N0cmluZygidXRmOCIpOwogICAgfQogICAgYXN5bmMgZ2V0UmVmZXJlbmNlU2VxdWVuY2VOYW1lcyhvcHRzID0ge30pIHsKICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKG9wdHMpOwogICAgICByZXR1cm4gbWV0YWRhdGEucmVmSWRUb05hbWU7CiAgICB9CiAgICBjaGVja0xpbmUobWV0YWRhdGEsIHJlZ2lvblJlZk5hbWUsIHJlZ2lvblN0YXJ0LCByZWdpb25FbmQsIGxpbmUpIHsKICAgICAgY29uc3QgeyBjb2x1bW5OdW1iZXJzLCBtZXRhQ2hhciwgY29vcmRpbmF0ZVR5cGUsIGZvcm1hdCB9ID0gbWV0YWRhdGE7CiAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gbWV0YUNoYXIpIHsKICAgICAgICByZXR1cm4geyBvdmVybGFwczogZmFsc2UgfTsKICAgICAgfQogICAgICBsZXQgeyByZWYsIHN0YXJ0LCBlbmQgfSA9IGNvbHVtbk51bWJlcnM7CiAgICAgIGlmICghcmVmKSB7CiAgICAgICAgcmVmID0gMDsKICAgICAgfQogICAgICBpZiAoIXN0YXJ0KSB7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9CiAgICAgIGlmICghZW5kKSB7CiAgICAgICAgZW5kID0gMDsKICAgICAgfQogICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgIGVuZCA9IDg7CiAgICAgIH0KICAgICAgY29uc3QgbWF4Q29sdW1uID0gTWF0aC5tYXgocmVmLCBzdGFydCwgZW5kKTsKICAgICAgbGV0IGN1cnJlbnRDb2x1bW5OdW1iZXIgPSAxOwogICAgICBsZXQgY3VycmVudENvbHVtblN0YXJ0ID0gMDsKICAgICAgbGV0IHJlZlNlcSA9ICIiOwogICAgICBsZXQgc3RhcnRDb29yZGluYXRlID0gLUluZmluaXR5OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoICsgMTsgaSArPSAxKSB7CiAgICAgICAgaWYgKGxpbmVbaV0gPT09ICIJIiB8fCBpID09PSBsaW5lLmxlbmd0aCkgewogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IHJlZikgewogICAgICAgICAgICBpZiAodGhpcy5yZW5hbWVSZWZTZXEobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpKSAhPT0gcmVnaW9uUmVmTmFtZSkgewogICAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IHN0YXJ0KSB7CiAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICBpZiAoY29vcmRpbmF0ZVR5cGUgPT09ICIxLWJhc2VkLWNsb3NlZCIpIHsKICAgICAgICAgICAgICBzdGFydENvb3JkaW5hdGUgLT0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlID49IHJlZ2lvbkVuZCkgewogICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVuZCA9PT0gMCB8fCBlbmQgPT09IHN0YXJ0KSB7CiAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29vcmRpbmF0ZSArIDEgPD0gcmVnaW9uU3RhcnQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gIlZDRiIgJiYgY3VycmVudENvbHVtbk51bWJlciA9PT0gNCkgewogICAgICAgICAgICByZWZTZXEgPSBsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSk7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IGVuZCkgewogICAgICAgICAgICBsZXQgZW5kQ29vcmRpbmF0ZTsKICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gIlZDRiIpIHsKICAgICAgICAgICAgICBlbmRDb29yZGluYXRlID0gdGhpcy5fZ2V0VmNmRW5kKHN0YXJ0Q29vcmRpbmF0ZSwgcmVmU2VxLCBsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSBwYXJzZUludChsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSksIDEwKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kQ29vcmRpbmF0ZSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyZW50Q29sdW1uU3RhcnQgPSBpICsgMTsKICAgICAgICAgIGN1cnJlbnRDb2x1bW5OdW1iZXIgKz0gMTsKICAgICAgICAgIGlmIChjdXJyZW50Q29sdW1uTnVtYmVyID4gbWF4Q29sdW1uKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzOiB0cnVlIH07CiAgICB9CiAgICBfZ2V0VmNmRW5kKHN0YXJ0Q29vcmRpbmF0ZSwgcmVmU2VxLCBpbmZvKSB7CiAgICAgIGxldCBlbmRDb29yZGluYXRlID0gc3RhcnRDb29yZGluYXRlICsgcmVmU2VxLmxlbmd0aDsKICAgICAgY29uc3QgaXNUUkEgPSBpbmZvLmluZGV4T2YoIlNWVFlQRT1UUkEiKSAhPT0gLTE7CiAgICAgIGlmIChpbmZvWzBdICE9PSAiLiIgJiYgIWlzVFJBKSB7CiAgICAgICAgbGV0IHByZXZDaGFyID0gIjsiOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby5sZW5ndGg7IGogKz0gMSkgewogICAgICAgICAgaWYgKHByZXZDaGFyID09PSAiOyIgJiYgaW5mby5zbGljZShqLCBqICsgNCkgPT09ICJFTkQ9IikgewogICAgICAgICAgICBsZXQgdmFsdWVFbmQgPSBpbmZvLmluZGV4T2YoIjsiLCBqKTsKICAgICAgICAgICAgaWYgKHZhbHVlRW5kID09PSAtMSkgewogICAgICAgICAgICAgIHZhbHVlRW5kID0gaW5mby5sZW5ndGg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGluZm8uc2xpY2UoaiArIDQsIHZhbHVlRW5kKSwgMTApOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHByZXZDaGFyID0gaW5mb1tqXTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoaXNUUkEpIHsKICAgICAgICByZXR1cm4gc3RhcnRDb29yZGluYXRlICsgMTsKICAgICAgfQogICAgICByZXR1cm4gZW5kQ29vcmRpbmF0ZTsKICAgIH0KICAgIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lLCBvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGluZUNvdW50KHJlZk5hbWUsIG9wdHMpOwogICAgfQogICAgYXN5bmMgX3JlYWRSZWdpb24ocG9zLCBzaXplLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgYiA9IGltcG9ydF9idWZmZXI3LkJ1ZmZlci5hbGxvYyhzaXplKTsKICAgICAgY29uc3QgeyBieXRlc1JlYWQsIGJ1ZmZlciB9ID0gYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWQoYiwgMCwgc2l6ZSwgcG9zLCBvcHRzKTsKICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBieXRlc1JlYWQpOwogICAgfQogICAgYXN5bmMgcmVhZENodW5rKGMsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcmVhZFJlZ2lvbihjLm1pbnYuYmxvY2tQb3NpdGlvbiwgYy5mZXRjaGVkU2l6ZSgpLCBvcHRzKTsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gdW56aXBDaHVua1NsaWNlKGRhdGEsIGMpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBkZWNvbXByZXNzaW5nIGMgJHtjLnRvU3RyaW5nKCl9ICR7ZX1gKTsKICAgICAgfQogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbG9kYXNoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsOwogIHZhciBmcmVlR2xvYmFsX2RlZmF1bHQgPSBmcmVlR2xvYmFsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gIm9iamVjdCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsX2RlZmF1bHQgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICB2YXIgcm9vdF9kZWZhdWx0ID0gcm9vdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzCiAgdmFyIFN5bWJvbDIgPSByb290X2RlZmF1bHQuU3ltYm9sOwogIHZhciBTeW1ib2xfZGVmYXVsdCA9IFN5bWJvbDI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5OwogIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nOwogIHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbF9kZWZhdWx0ID8gU3ltYm9sX2RlZmF1bHQudG9TdHJpbmdUYWcgOiB2b2lkIDA7CiAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7CiAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgIHRyeSB7CiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHZvaWQgMDsKICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgIH0KICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTsKICAgIGlmICh1bm1hc2tlZCkgewogICAgICBpZiAoaXNPd24pIHsKICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGdldFJhd1RhZ19kZWZhdWx0ID0gZ2V0UmF3VGFnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8yID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nOwogIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcyLmNhbGwodmFsdWUpOwogIH0KICB2YXIgb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgdmFyIG51bGxUYWcgPSAiW29iamVjdCBOdWxsXSI7CiAgdmFyIHVuZGVmaW5lZFRhZyA9ICJbb2JqZWN0IFVuZGVmaW5lZF0iOwogIHZhciBzeW1Ub1N0cmluZ1RhZzIgPSBTeW1ib2xfZGVmYXVsdCA/IFN5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdm9pZCAwOwogIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHsKICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZzsKICAgIH0KICAgIHJldHVybiBzeW1Ub1N0cmluZ1RhZzIgJiYgc3ltVG9TdHJpbmdUYWcyIGluIE9iamVjdCh2YWx1ZSkgPyBnZXRSYXdUYWdfZGVmYXVsdCh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZ19kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGJhc2VHZXRUYWdfZGVmYXVsdCA9IGJhc2VHZXRUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICJvYmplY3QiOwogIH0KICB2YXIgaXNPYmplY3RMaWtlX2RlZmF1bHQgPSBpc09iamVjdExpa2U7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanMKICB2YXIgc3ltYm9sVGFnID0gIltvYmplY3QgU3ltYm9sXSI7CiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gInN5bWJvbCIgfHwgaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSkgPT0gc3ltYm9sVGFnOwogIH0KICB2YXIgaXNTeW1ib2xfZGVmYXVsdCA9IGlzU3ltYm9sOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlNYXBfZGVmYXVsdCA9IGFycmF5TWFwOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwogIHZhciBpc0FycmF5X2RlZmF1bHQgPSBpc0FycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xzLzsKICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7CiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoOwogICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7CiAgICB9CiAgICByZXR1cm4gaW5kZXg7CiAgfQogIHZhciB0cmltbWVkRW5kSW5kZXhfZGVmYXVsdCA9IHRyaW1tZWRFbmRJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICB2YXIgcmVUcmltU3RhcnQgPSAvXlxzKy87CiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7CiAgICByZXR1cm4gc3RyaW5nID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleF9kZWZhdWx0KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAiIikgOiBzdHJpbmc7CiAgfQogIHZhciBiYXNlVHJpbV9kZWZhdWx0ID0gYmFzZVRyaW07CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gIm9iamVjdCIgfHwgdHlwZSA9PSAiZnVuY3Rpb24iKTsKICB9CiAgdmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIHZhciBOQU4gPSAwIC8gMDsKICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pOwogIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pOwogIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pOwogIHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDsKICBmdW5jdGlvbiB0b051bWJlcjIodmFsdWUpIHsKICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIpIHsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogICAgaWYgKGlzU3ltYm9sX2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBOQU47CiAgICB9CiAgICBpZiAoaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gImZ1bmN0aW9uIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlOwogICAgICB2YWx1ZSA9IGlzT2JqZWN0X2RlZmF1bHQob3RoZXIpID8gb3RoZXIgKyAiIiA6IG90aGVyOwogICAgfQogICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAic3RyaW5nIikgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTsKICAgIH0KICAgIHZhbHVlID0gYmFzZVRyaW1fZGVmYXVsdCh2YWx1ZSk7CiAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpOwogICAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlOwogIH0KICB2YXIgdG9OdW1iZXJfZGVmYXVsdCA9IHRvTnVtYmVyMjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIHZhciBJTkZJTklUWSA9IDEgLyAwOwogIHZhciBNQVhfSU5URUdFUiA9IDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MjsKICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkgewogICAgaWYgKCF2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7CiAgICB9CiAgICB2YWx1ZSA9IHRvTnVtYmVyX2RlZmF1bHQodmFsdWUpOwogICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7CiAgICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxOwogICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSOwogICAgfQogICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDsKICB9CiAgdmFyIHRvRmluaXRlX2RlZmF1bHQgPSB0b0Zpbml0ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0ludGVnZXIuanMKICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHsKICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZV9kZWZhdWx0KHZhbHVlKSwgcmVtYWluZGVyID0gcmVzdWx0ICUgMTsKICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCA6IDA7CiAgfQogIHZhciB0b0ludGVnZXJfZGVmYXVsdCA9IHRvSW50ZWdlcjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBhc3luY1RhZyA9ICJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dIjsKICB2YXIgZnVuY1RhZyA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIGdlblRhZyA9ICJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSI7CiAgdmFyIHByb3h5VGFnID0gIltvYmplY3QgUHJveHldIjsKICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7CiAgICBpZiAoIWlzT2JqZWN0X2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpOwogICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZzsKICB9CiAgdmFyIGlzRnVuY3Rpb25fZGVmYXVsdCA9IGlzRnVuY3Rpb247CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7CiAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07CiAgICB9CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBjb3B5QXJyYXlfZGVmYXVsdCA9IGNvcHlBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXGQqKSQvOwogIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkgewogICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7CiAgICByZXR1cm4gISFsZW5ndGggJiYgKHR5cGUgPT0gIm51bWJlciIgfHwgdHlwZSAhPSAic3ltYm9sIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpOwogIH0KICB2YXIgaXNJbmRleF9kZWZhdWx0ID0gaXNJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHsKICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjsKICB9CiAgdmFyIGVxX2RlZmF1bHQgPSBlcTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIyID0gOTAwNzE5OTI1NDc0MDk5MTsKICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkgewogICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAibnVtYmVyIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVIyOwogIH0KICB2YXIgaXNMZW5ndGhfZGVmYXVsdCA9IGlzTGVuZ3RoOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoX2RlZmF1bHQodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl9kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGlzQXJyYXlMaWtlX2RlZmF1bHQgPSBpc0FycmF5TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkgewogICAgaWYgKCFpc09iamVjdF9kZWZhdWx0KG9iamVjdCkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7CiAgICBpZiAodHlwZSA9PSAibnVtYmVyIiA/IGlzQXJyYXlMaWtlX2RlZmF1bHQob2JqZWN0KSAmJiBpc0luZGV4X2RlZmF1bHQoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSAic3RyaW5nIiAmJiBpbmRleCBpbiBvYmplY3QpIHsKICAgICAgcmV0dXJuIGVxX2RlZmF1bHQob2JqZWN0W2luZGV4XSwgdmFsdWUpOwogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgaXNJdGVyYXRlZUNhbGxfZGVmYXVsdCA9IGlzSXRlcmF0ZWVDYWxsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8zID0gT2JqZWN0LnByb3RvdHlwZTsKICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkgewogICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAiZnVuY3Rpb24iICYmIEN0b3IucHJvdG90eXBlIHx8IG9iamVjdFByb3RvMzsKICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87CiAgfQogIHZhciBpc1Byb3RvdHlwZV9kZWZhdWx0ID0gaXNQcm90b3R5cGU7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkgewogICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG4pOwogICAgd2hpbGUgKCsraW5kZXggPCBuKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYmFzZVRpbWVzX2RlZmF1bHQgPSBiYXNlVGltZXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYXJnc1RhZyA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpID09IGFyZ3NUYWc7CiAgfQogIHZhciBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdCA9IGJhc2VJc0FyZ3VtZW50czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcwogIHZhciBvYmplY3RQcm90bzQgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTIgPSBvYmplY3RQcm90bzQuaGFzT3duUHJvcGVydHk7CiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG80LnByb3BlcnR5SXNFbnVtZXJhYmxlOwogIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50c19kZWZhdWx0KGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIGFyZ3VtZW50czsKICB9KCkpID8gYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQgOiBmdW5jdGlvbih2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eTIuY2FsbCh2YWx1ZSwgImNhbGxlZSIpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAiY2FsbGVlIik7CiAgfTsKICB2YXIgaXNBcmd1bWVudHNfZGVmYXVsdCA9IGlzQXJndW1lbnRzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciBzdHViRmFsc2VfZGVmYXVsdCA9IHN0dWJGYWxzZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcwogIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gIm9iamVjdCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwogIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzOwogIHZhciBCdWZmZXI5ID0gbW9kdWxlRXhwb3J0cyA/IHJvb3RfZGVmYXVsdC5CdWZmZXIgOiB2b2lkIDA7CiAgdmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyOSA/IEJ1ZmZlcjkuaXNCdWZmZXIgOiB2b2lkIDA7CiAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlX2RlZmF1bHQ7CiAgdmFyIGlzQnVmZmVyX2RlZmF1bHQgPSBpc0J1ZmZlcjsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcyID0gIltvYmplY3QgQXJndW1lbnRzXSI7CiAgdmFyIGFycmF5VGFnID0gIltvYmplY3QgQXJyYXldIjsKICB2YXIgYm9vbFRhZyA9ICJbb2JqZWN0IEJvb2xlYW5dIjsKICB2YXIgZGF0ZVRhZyA9ICJbb2JqZWN0IERhdGVdIjsKICB2YXIgZXJyb3JUYWcgPSAiW29iamVjdCBFcnJvcl0iOwogIHZhciBmdW5jVGFnMiA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIG1hcFRhZyA9ICJbb2JqZWN0IE1hcF0iOwogIHZhciBudW1iZXJUYWcgPSAiW29iamVjdCBOdW1iZXJdIjsKICB2YXIgb2JqZWN0VGFnID0gIltvYmplY3QgT2JqZWN0XSI7CiAgdmFyIHJlZ2V4cFRhZyA9ICJbb2JqZWN0IFJlZ0V4cF0iOwogIHZhciBzZXRUYWcgPSAiW29iamVjdCBTZXRdIjsKICB2YXIgc3RyaW5nVGFnID0gIltvYmplY3QgU3RyaW5nXSI7CiAgdmFyIHdlYWtNYXBUYWcgPSAiW29iamVjdCBXZWFrTWFwXSI7CiAgdmFyIGFycmF5QnVmZmVyVGFnID0gIltvYmplY3QgQXJyYXlCdWZmZXJdIjsKICB2YXIgZGF0YVZpZXdUYWcgPSAiW29iamVjdCBEYXRhVmlld10iOwogIHZhciBmbG9hdDMyVGFnID0gIltvYmplY3QgRmxvYXQzMkFycmF5XSI7CiAgdmFyIGZsb2F0NjRUYWcgPSAiW29iamVjdCBGbG9hdDY0QXJyYXldIjsKICB2YXIgaW50OFRhZyA9ICJbb2JqZWN0IEludDhBcnJheV0iOwogIHZhciBpbnQxNlRhZyA9ICJbb2JqZWN0IEludDE2QXJyYXldIjsKICB2YXIgaW50MzJUYWcgPSAiW29iamVjdCBJbnQzMkFycmF5XSI7CiAgdmFyIHVpbnQ4VGFnID0gIltvYmplY3QgVWludDhBcnJheV0iOwogIHZhciB1aW50OENsYW1wZWRUYWcgPSAiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iOwogIHZhciB1aW50MTZUYWcgPSAiW29iamVjdCBVaW50MTZBcnJheV0iOwogIHZhciB1aW50MzJUYWcgPSAiW29iamVjdCBVaW50MzJBcnJheV0iOwogIHZhciB0eXBlZEFycmF5VGFncyA9IHt9OwogIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7CiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZzJdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7CiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBpc0xlbmd0aF9kZWZhdWx0KHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpXTsKICB9CiAgdmFyIGJhc2VJc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGJhc2VJc1R5cGVkQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykgewogICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTsKICAgIH07CiAgfQogIHZhciBiYXNlVW5hcnlfZGVmYXVsdCA9IGJhc2VVbmFyeTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVFeHBvcnRzMiA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZTIgPSBmcmVlRXhwb3J0czIgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMyID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMyOwogIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMyICYmIGZyZWVHbG9iYWxfZGVmYXVsdC5wcm9jZXNzOwogIHZhciBub2RlVXRpbCA9IGZ1bmN0aW9uKCkgewogICAgdHJ5IHsKICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIucmVxdWlyZSAmJiBmcmVlTW9kdWxlMi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7CiAgICAgIGlmICh0eXBlcykgewogICAgICAgIHJldHVybiB0eXBlczsKICAgICAgfQogICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCJ1dGlsIik7CiAgICB9IGNhdGNoIChlKSB7CiAgICB9CiAgfSgpOwogIHZhciBub2RlVXRpbF9kZWZhdWx0ID0gbm9kZVV0aWw7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzCiAgdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbF9kZWZhdWx0ICYmIG5vZGVVdGlsX2RlZmF1bHQuaXNUeXBlZEFycmF5OwogIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5X2RlZmF1bHQobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQ7CiAgdmFyIGlzVHlwZWRBcnJheV9kZWZhdWx0ID0gaXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNSA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5MyA9IG9iamVjdFByb3RvNS5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHsKICAgIHZhciBpc0FyciA9IGlzQXJyYXlfZGVmYXVsdCh2YWx1ZSksIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzX2RlZmF1bHQodmFsdWUpLCBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyX2RlZmF1bHQodmFsdWUpLCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5X2RlZmF1bHQodmFsdWUpLCBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzX2RlZmF1bHQodmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7CiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHsKICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkzLmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAibGVuZ3RoIiB8fCBpc0J1ZmYgJiYgKGtleSA9PSAib2Zmc2V0IiB8fCBrZXkgPT0gInBhcmVudCIpIHx8IGlzVHlwZSAmJiAoa2V5ID09ICJidWZmZXIiIHx8IGtleSA9PSAiYnl0ZUxlbmd0aCIgfHwga2V5ID09ICJieXRlT2Zmc2V0IikgfHwgaXNJbmRleF9kZWZhdWx0KGtleSwgbGVuZ3RoKSkpKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGFycmF5TGlrZUtleXNfZGVmYXVsdCA9IGFycmF5TGlrZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7CiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTsKICAgIH07CiAgfQogIHZhciBvdmVyQXJnX2RlZmF1bHQgPSBvdmVyQXJnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgdmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnX2RlZmF1bHQoT2JqZWN0LmtleXMsIE9iamVjdCk7CiAgdmFyIG5hdGl2ZUtleXNfZGVmYXVsdCA9IG5hdGl2ZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNiA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5NCA9IG9iamVjdFByb3RvNi5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHsKICAgIGlmICghaXNQcm90b3R5cGVfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBuYXRpdmVLZXlzX2RlZmF1bHQob2JqZWN0KTsKICAgIH0KICAgIHZhciByZXN1bHQgPSBbXTsKICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgICBpZiAoaGFzT3duUHJvcGVydHk0LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAiY29uc3RydWN0b3IiKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGJhc2VLZXlzX2RlZmF1bHQgPSBiYXNlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzCiAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsKICAgIHJldHVybiBpc0FycmF5TGlrZV9kZWZhdWx0KG9iamVjdCkgPyBhcnJheUxpa2VLZXlzX2RlZmF1bHQob2JqZWN0KSA6IGJhc2VLZXlzX2RlZmF1bHQob2JqZWN0KTsKICB9CiAgdmFyIGtleXNfZGVmYXVsdCA9IGtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbGFtcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHsKICAgIGlmIChudW1iZXIgPT09IG51bWJlcikgewogICAgICBpZiAodXBwZXIgIT09IHZvaWQgMCkgewogICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyOwogICAgICB9CiAgICAgIGlmIChsb3dlciAhPT0gdm9pZCAwKSB7CiAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBudW1iZXI7CiAgfQogIHZhciBiYXNlQ2xhbXBfZGVmYXVsdCA9IGJhc2VDbGFtcDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7CiAgICByZXR1cm4gYXJyYXlNYXBfZGVmYXVsdChwcm9wcywgZnVuY3Rpb24oa2V5KSB7CiAgICAgIHJldHVybiBvYmplY3Rba2V5XTsKICAgIH0pOwogIH0KICB2YXIgYmFzZVZhbHVlc19kZWZhdWx0ID0gYmFzZVZhbHVlczsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXNfZGVmYXVsdChvYmplY3QsIGtleXNfZGVmYXVsdChvYmplY3QpKTsKICB9CiAgdmFyIHZhbHVlc19kZWZhdWx0ID0gdmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3I7CiAgdmFyIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tOwogIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7CiAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpOwogIH0KICB2YXIgYmFzZVJhbmRvbV9kZWZhdWx0ID0gYmFzZVJhbmRvbTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxOwogICAgc2l6ZSA9IHNpemUgPT09IHZvaWQgMCA/IGxlbmd0aCA6IHNpemU7CiAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHsKICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tX2RlZmF1bHQoaW5kZXgsIGxhc3RJbmRleCksIHZhbHVlID0gYXJyYXlbcmFuZF07CiAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdOwogICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTsKICAgIH0KICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBzaHVmZmxlU2VsZl9kZWZhdWx0ID0gc2h1ZmZsZVNlbGY7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2FtcGxlU2l6ZS5qcwogIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikgewogICAgcmV0dXJuIHNodWZmbGVTZWxmX2RlZmF1bHQoY29weUFycmF5X2RlZmF1bHQoYXJyYXkpLCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0ID0gYXJyYXlTYW1wbGVTaXplOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7CiAgICB2YXIgYXJyYXkgPSB2YWx1ZXNfZGVmYXVsdChjb2xsZWN0aW9uKTsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGFycmF5LCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGJhc2VTYW1wbGVTaXplX2RlZmF1bHQgPSBiYXNlU2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkgewogICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGxfZGVmYXVsdChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB2b2lkIDApIHsKICAgICAgbiA9IDE7CiAgICB9IGVsc2UgewogICAgICBuID0gdG9JbnRlZ2VyX2RlZmF1bHQobik7CiAgICB9CiAgICB2YXIgZnVuYyA9IGlzQXJyYXlfZGVmYXVsdChjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0IDogYmFzZVNhbXBsZVNpemVfZGVmYXVsdDsKICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pOwogIH0KICB2YXIgc2FtcGxlU2l6ZV9kZWZhdWx0ID0gc2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvd29ya2VyLm1qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X3dvcmtlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV93b3JrZXIoKSk7CiAgdmFyIGV4cG9zZSA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5leHBvc2U7CiAgdmFyIHJlZ2lzdGVyU2VyaWFsaXplciA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5yZWdpc3RlclNlcmlhbGl6ZXI7CiAgdmFyIFRyYW5zZmVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LlRyYW5zZmVyOwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy91dGlscy50cwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYXNjZW5kaW5nX2RlZmF1bHQoYSwgYikgewogICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiaXNlY3Rvcl9kZWZhdWx0KGYpIHsKICAgIGxldCBkZWx0YSA9IGY7CiAgICBsZXQgY29tcGFyZTIgPSBmOwogICAgaWYgKGYubGVuZ3RoID09PSAxKSB7CiAgICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4OwogICAgICBjb21wYXJlMiA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoZik7CiAgICB9CiAgICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA8IDApCiAgICAgICAgICBsbyA9IG1pZCArIDE7CiAgICAgICAgZWxzZQogICAgICAgICAgaGkgPSBtaWQ7CiAgICAgIH0KICAgICAgcmV0dXJuIGxvOwogICAgfQogICAgZnVuY3Rpb24gcmlnaHQoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgd2hpbGUgKGxvIDwgaGkpIHsKICAgICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxOwogICAgICAgIGlmIChjb21wYXJlMihhW21pZF0sIHgpID4gMCkKICAgICAgICAgIGhpID0gbWlkOwogICAgICAgIGVsc2UKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7CiAgICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpOwogICAgfQogICAgcmV0dXJuIHsgbGVmdCwgY2VudGVyLCByaWdodCB9OwogIH0KICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHsKICAgIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nX2RlZmF1bHQoZihkKSwgeCk7CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy91dGlscy50cwogIHZhciBEYXRhU291cmNlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoZmlsZSwgY2hyb21TaXplcywgb3B0aW9ucykgewogICAgICB0aGlzLmZpbGUgPSBmaWxlOwogICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwogICAgICB0aGlzLmNocm9tSW5mbyA9IHNpemVzVG9DaHJvbUluZm8oY2hyb21TaXplcyk7CiAgICAgIHRoaXMudGlsZXNldEluZm8gPSB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8odGhpcy5jaHJvbUluZm8pOwogICAgfQogICAgY2hyb21JbmZvOwogICAgdGlsZXNldEluZm87CiAgfTsKICB2YXIgY2hyb21JbmZvQmlzZWN0b3IgPSBiaXNlY3Rvcl9kZWZhdWx0KChkKSA9PiBkLnBvcykubGVmdDsKICB2YXIgY2hyVG9BYnMgPSAoY2hyb20sIGNocm9tUG9zLCBjaHJvbUluZm8pID0+IGNocm9tSW5mby5jaHJQb3NpdGlvbnNbY2hyb21dLnBvcyArIGNocm9tUG9zOwogIHZhciBhYnNUb0NociA9IChhYnNQb3NpdGlvbiwgY2hyb21JbmZvKSA9PiB7CiAgICBpZiAoIWNocm9tSW5mbyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGgpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBsZXQgaW5zZXJ0UG9pbnQgPSBjaHJvbUluZm9CaXNlY3RvcihjaHJvbUluZm8uY3VtUG9zaXRpb25zLCBhYnNQb3NpdGlvbik7CiAgICBjb25zdCBsYXN0Q2hyID0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDFdLmNocjsKICAgIGNvbnN0IGxhc3RMZW5ndGggPSBjaHJvbUluZm8uY2hyb21MZW5ndGhzW2xhc3RDaHJdOwogICAgaW5zZXJ0UG9pbnQgLT0gaW5zZXJ0UG9pbnQgPiAwICYmIDE7CiAgICBsZXQgY2hyUG9zaXRpb24gPSBNYXRoLmZsb29yKGFic1Bvc2l0aW9uIC0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0ucG9zKTsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgaWYgKGNoclBvc2l0aW9uIDwgMCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIDE7CiAgICAgIGNoclBvc2l0aW9uID0gMTsKICAgIH0KICAgIGlmIChpbnNlcnRQb2ludCA9PT0gY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxICYmIGNoclBvc2l0aW9uID4gbGFzdExlbmd0aCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIGxhc3RMZW5ndGg7CiAgICAgIGNoclBvc2l0aW9uID0gbGFzdExlbmd0aDsKICAgIH0KICAgIHJldHVybiBbY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0uY2hyLCBjaHJQb3NpdGlvbiwgb2Zmc2V0LCBpbnNlcnRQb2ludF07CiAgfTsKICBmdW5jdGlvbiB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8oY2hyb21JbmZvLCB0aWxlU2l6ZSA9IDEwMjQpIHsKICAgIHJldHVybiB7CiAgICAgIHRpbGVfc2l6ZTogdGlsZVNpemUsCiAgICAgIGJpbnNfcGVyX2RpbWVuc2lvbjogdGlsZVNpemUsCiAgICAgIG1heF96b29tOiBNYXRoLmNlaWwoTWF0aC5sb2coY2hyb21JbmZvLnRvdGFsTGVuZ3RoIC8gdGlsZVNpemUpIC8gTWF0aC5sb2coMikpLAogICAgICBtYXhfd2lkdGg6IGNocm9tSW5mby50b3RhbExlbmd0aCwKICAgICAgbWluX3BvczogWzBdLAogICAgICBtYXhfcG9zOiBbY2hyb21JbmZvLnRvdGFsTGVuZ3RoXQogICAgfTsKICB9CiAgZnVuY3Rpb24gc2l6ZXNUb0Nocm9tSW5mbyhzaXplcykgewogICAgY29uc3QgaW5mbyA9IHsKICAgICAgY3VtUG9zaXRpb25zOiBbXSwKICAgICAgY2hyb21MZW5ndGhzOiB7fSwKICAgICAgY2hyUG9zaXRpb25zOiB7fSwKICAgICAgdG90YWxMZW5ndGg6IDAKICAgIH07CiAgICBzaXplcy5mb3JFYWNoKChbY2hyLCBsZW5ndGhdLCBpKSA9PiB7CiAgICAgIGNvbnN0IGNoclBvc2l0aW9uID0geyBpZDogaSwgY2hyLCBwb3M6IGluZm8udG90YWxMZW5ndGggfTsKICAgICAgaW5mby5jaHJQb3NpdGlvbnNbY2hyXSA9IGNoclBvc2l0aW9uOwogICAgICBpbmZvLmNocm9tTGVuZ3Roc1tjaHJdID0gbGVuZ3RoOwogICAgICBpbmZvLmN1bVBvc2l0aW9ucy5wdXNoKGNoclBvc2l0aW9uKTsKICAgICAgaW5mby50b3RhbExlbmd0aCArPSBsZW5ndGg7CiAgICB9KTsKICAgIHJldHVybiB7CiAgICAgIC4uLmluZm8sCiAgICAgIGFic1RvQ2hyOiAoYWJzUG9zKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGFic1RvQ2hyKGFic1BvcywgaW5mbykgOiBudWxsLAogICAgICBjaHJUb0FiczogKFtjaHJOYW1lLCBjaHJQb3NdKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGNoclRvQWJzKGNock5hbWUsIGNoclBvcywgaW5mbykgOiBudWxsCiAgICB9OwogIH0KICB2YXIgUmVtb3RlRmlsZTIgPSBjbGFzcyBleHRlbmRzIFJlbW90ZUZpbGUgewogICAgcmVhZCA9IGFzeW5jIChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pID0+IHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApOwogICAgfTsKICB9OwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iZWQvYmVkLXBhcnNlci50cwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL3BhcnNlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2F1dG9TcWwyID0gX190b01vZHVsZShyZXF1aXJlX2F1dG9TcWwoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL2RlZmF1bHRUeXBlcy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2F1dG9TcWwgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYXV0b1NxbCgpKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vYXMvYXV0b1NxbFNjaGVtYXMuanMKICB2YXIgYXV0b1NxbFNjaGVtYXNfZXhwb3J0cyA9IHt9OwogIF9fZXhwb3J0KGF1dG9TcWxTY2hlbWFzX2V4cG9ydHMsIHsKICAgIGJpZ0NoYWluOiAoKSA9PiBiaWdDaGFpbiwKICAgIGJpZ0dlbmVQcmVkOiAoKSA9PiBiaWdHZW5lUHJlZCwKICAgIGJpZ0ludGVyYWN0OiAoKSA9PiBiaWdJbnRlcmFjdCwKICAgIGJpZ0xpbms6ICgpID0+IGJpZ0xpbmssCiAgICBiaWdNYWY6ICgpID0+IGJpZ01hZiwKICAgIGJpZ05hcnJvd1BlYWs6ICgpID0+IGJpZ05hcnJvd1BlYWssCiAgICBiaWdQc2w6ICgpID0+IGJpZ1BzbCwKICAgIGRlZmF1bHRCZWRTY2hlbWE6ICgpID0+IGRlZmF1bHRCZWRTY2hlbWEsCiAgICBtYWZGcmFtZXM6ICgpID0+IG1hZkZyYW1lcywKICAgIG1hZlN1bW1hcnk6ICgpID0+IG1hZlN1bW1hcnkKICB9KTsKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGJpZ0NoYWluID0gYHRhYmxlIGJpZ0NoYWluCiJiaWdDaGFpbiBwYWlyd2lzZSBhbGlnbm1lbnQiCiAgICAoCiAgICBzdHJpbmcgY2hyb207ICAgICAgICJSZWZlcmVuY2Ugc2VxdWVuY2UgY2hyb21vc29tZSBvciBzY2FmZm9sZCIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAgIlN0YXJ0IHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICB1aW50ICAgY2hyb21FbmQ7ICAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHN0cmluZyBuYW1lOyAgICAgICAgIk5hbWUgb3IgSUQgb2YgaXRlbSwgaWRlYWxseSBib3RoIGh1bWFuIHJlYWRhYmxlIGFuZCB1bmlxdWUiCiAgICB1aW50IHNjb3JlOyAgICAgICAgICJTY29yZSAoMC0xMDAwKSIKICAgIGNoYXJbMV0gc3RyYW5kOyAgICAgIisgb3IgLSBmb3Igc3RyYW5kIgogICAgdWludCB0U2l6ZTsgICAgICAgICAic2l6ZSBvZiB0YXJnZXQgc2VxdWVuY2UiCiAgICBzdHJpbmcgcU5hbWU7ICAgICAgICJuYW1lIG9mIHF1ZXJ5IHNlcXVlbmNlIgogICAgdWludCBxU2l6ZTsgICAgICAgICAic2l6ZSBvZiBxdWVyeSBzZXF1ZW5jZSIKICAgIHVpbnQgcVN0YXJ0OyAgICAgICAgInN0YXJ0IG9mIGFsaWdubWVudCBvbiBxdWVyeSBzZXF1ZW5jZSIKICAgIHVpbnQgcUVuZDsgICAgICAgICAgImVuZCBvZiBhbGlnbm1lbnQgb24gcXVlcnkgc2VxdWVuY2UiCiAgICB1aW50IGNoYWluU2NvcmU7ICAgICJzY29yZSBmcm9tIGNoYWluIgogICAgKWA7CiAgdmFyIGJpZ0dlbmVQcmVkID0gYHRhYmxlIGJpZ0dlbmVQcmVkCiJiaWdHZW5lUHJlZCBnZW5lIG1vZGVscyIKICAgKAogICBzdHJpbmcgY2hyb207ICAgICAgICJSZWZlcmVuY2Ugc2VxdWVuY2UgY2hyb21vc29tZSBvciBzY2FmZm9sZCIKICAgdWludCAgIGNocm9tU3RhcnQ7ICAiU3RhcnQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgdWludCAgIGNocm9tRW5kOyAgICAiRW5kIHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgIHN0cmluZyBuYW1lOyAgICAgICAgIk5hbWUgb3IgSUQgb2YgaXRlbSwgaWRlYWxseSBib3RoIGh1bWFuIHJlYWRhYmxlIGFuZCB1bmlxdWUiCiAgIHVpbnQgc2NvcmU7ICAgICAgICAgIlNjb3JlICgwLTEwMDApIgogICBjaGFyWzFdIHN0cmFuZDsgICAgICIrIG9yIC0gZm9yIHN0cmFuZCIKICAgdWludCB0aGlja1N0YXJ0OyAgICAiU3RhcnQgb2Ygd2hlcmUgZGlzcGxheSBzaG91bGQgYmUgdGhpY2sgKHN0YXJ0IGNvZG9uKSIKICAgdWludCB0aGlja0VuZDsgICAgICAiRW5kIG9mIHdoZXJlIGRpc3BsYXkgc2hvdWxkIGJlIHRoaWNrIChzdG9wIGNvZG9uKSIKICAgdWludCByZXNlcnZlZDsgICAgICAgIlJHQiB2YWx1ZSAodXNlIFIsRyxCIHN0cmluZyBpbiBpbnB1dCBmaWxlKSIKICAgaW50IGJsb2NrQ291bnQ7ICAgICAiTnVtYmVyIG9mIGJsb2NrcyIKICAgaW50W2Jsb2NrQ291bnRdIGJsb2NrU2l6ZXM7ICJDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBibG9jayBzaXplcyIKICAgaW50W2Jsb2NrQ291bnRdIGNocm9tU3RhcnRzOyAiU3RhcnQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIGNocm9tU3RhcnQiCiAgIHN0cmluZyBuYW1lMjsgICAgICAgIkFsdGVybmF0aXZlL2h1bWFuIHJlYWRhYmxlIG5hbWUiCiAgIHN0cmluZyBjZHNTdGFydFN0YXQ7ICJTdGF0dXMgb2YgQ0RTIHN0YXJ0IGFubm90YXRpb24gKG5vbmUsIHVua25vd24sIGluY29tcGxldGUsIG9yIGNvbXBsZXRlKSIKICAgc3RyaW5nIGNkc0VuZFN0YXQ7ICAgIlN0YXR1cyBvZiBDRFMgZW5kIGFubm90YXRpb24gKG5vbmUsIHVua25vd24sIGluY29tcGxldGUsIG9yIGNvbXBsZXRlKSIKICAgaW50W2Jsb2NrQ291bnRdIGV4b25GcmFtZXM7ICJFeG9uIGZyYW1lIHswLDEsMn0sIG9yIC0xIGlmIG5vIGZyYW1lIGZvciBleG9uIgogICBzdHJpbmcgdHlwZTsgICAgICAgICJUcmFuc2NyaXB0IHR5cGUiCiAgIHN0cmluZyBnZW5lTmFtZTsgICAgIlByaW1hcnkgaWRlbnRpZmllciBmb3IgZ2VuZSIKICAgc3RyaW5nIGdlbmVOYW1lMjsgICAiQWx0ZXJuYXRpdmUvaHVtYW4gcmVhZGFibGUgZ2VuZSBuYW1lIgogICBzdHJpbmcgZ2VuZVR5cGU7ICAgICJHZW5lIHR5cGUiCiAgIClgOwogIHZhciBiaWdJbnRlcmFjdCA9IGB0YWJsZSBpbnRlcmFjdAoiaW50ZXJhY3Rpb24gYmV0d2VlbiB0d28gcmVnaW9ucyIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAgICJDaHJvbW9zb21lIChvciBjb250aWcsIHNjYWZmb2xkLCBldGMuKS4gRm9yIGludGVyY2hyb21vc29tYWwsIHVzZSAyIHJlY29yZHMiCiAgICB1aW50IGNocm9tU3RhcnQ7ICAgICAiU3RhcnQgcG9zaXRpb24gb2YgbG93ZXIgcmVnaW9uLiBGb3IgaW50ZXJjaHJvbW9zb21hbCwgc2V0IHRvIGNocm9tU3RhcnQgb2YgdGhpcyByZWdpb24iCiAgICB1aW50IGNocm9tRW5kOyAgICAgICAiRW5kIHBvc2l0aW9uIG9mIHVwcGVyIHJlZ2lvbi4gRm9yIGludGVyY2hyb21vc29tYWwsIHNldCB0byBjaHJvbUVuZCBvZiB0aGlzIHJlZ2lvbiIKICAgIHN0cmluZyBuYW1lOyAgICAgICAgICJOYW1lIG9mIGl0ZW0sIGZvciBkaXNwbGF5LiAgVXN1YWxseSAnc291cmNlTmFtZS90YXJnZXROYW1lL2V4cCcgb3IgZW1wdHkiCiAgICB1aW50IHNjb3JlOyAgICAgICAgICAiU2NvcmUgKDAtMTAwMCkiCiAgICBkb3VibGUgdmFsdWU7ICAgICAgICAiU3RyZW5ndGggb2YgaW50ZXJhY3Rpb24gb3Igb3RoZXIgZGF0YSB2YWx1ZS4gVHlwaWNhbGx5IGJhc2lzIGZvciBzY29yZSIKICAgIHN0cmluZyBleHA7ICAgICAgICAgICJFeHBlcmltZW50IG5hbWUgKG1ldGFkYXRhIGZvciBmaWx0ZXJpbmcpLiBVc2UgLiBpZiBub3QgYXBwbGljYWJsZSIKICAgIHN0cmluZyBjb2xvcjsgICAgICAgICJJdGVtIGNvbG9yLiAgU3BlY2lmaWVkIGFzIHIsZyxiIG9yIGhleGFkZWNpbWFsICNSUkdHQkIgb3IgaHRtbCBjb2xvciBuYW1lLCBhcyBpbiAvL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHRtbDQuIFVzZSAwIGFuZCBzcGVjdHJ1bSBzZXR0aW5nIHRvIHNoYWRlIGJ5IHNjb3JlIgogICAgc3RyaW5nIHNvdXJjZUNocm9tOyAgIkNocm9tb3NvbWUgb2Ygc291cmNlIHJlZ2lvbiAoZGlyZWN0aW9uYWwpIG9yIGxvd2VyIHJlZ2lvbi4gRm9yIG5vbi1kaXJlY3Rpb25hbCBpbnRlcmNocm9tb3NvbWFsLCBjaHJvbSBvZiB0aGlzIHJlZ2lvbi4iCiAgICB1aW50IHNvdXJjZVN0YXJ0OyAgICAiU3RhcnQgcG9zaXRpb24gaW4gY2hyb21vc29tZSBvZiBzb3VyY2UvbG93ZXIvdGhpcyByZWdpb24iCiAgICB1aW50IHNvdXJjZUVuZDsgICAgICAiRW5kIHBvc2l0aW9uIGluIGNocm9tb3NvbWUgb2Ygc291cmNlL2xvd2VyL3RoaXMgcmVnaW9uIgogICAgc3RyaW5nIHNvdXJjZU5hbWU7ICAgIklkZW50aWZpZXIgb2Ygc291cmNlL2xvd2VyL3RoaXMgcmVnaW9uIgogICAgc3RyaW5nIHNvdXJjZVN0cmFuZDsgIk9yaWVudGF0aW9uIG9mIHNvdXJjZS9sb3dlci90aGlzIHJlZ2lvbjogKyBvciAtLiAgVXNlIC4gaWYgbm90IGFwcGxpY2FibGUiCiAgICBzdHJpbmcgdGFyZ2V0Q2hyb207ICAiQ2hyb21vc29tZSBvZiB0YXJnZXQgcmVnaW9uIChkaXJlY3Rpb25hbCkgb3IgdXBwZXIgcmVnaW9uLiBGb3Igbm9uLWRpcmVjdGlvbmFsIGludGVyY2hyb21vc29tYWwsIGNocm9tIG9mIG90aGVyIHJlZ2lvbiIKICAgIHVpbnQgdGFyZ2V0U3RhcnQ7ICAgICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIG9mIHRhcmdldC91cHBlci90aGlzIHJlZ2lvbiIKICAgIHVpbnQgdGFyZ2V0RW5kOyAgICAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSBvZiB0YXJnZXQvdXBwZXIvdGhpcyByZWdpb24iCiAgICBzdHJpbmcgdGFyZ2V0TmFtZTsgICAiSWRlbnRpZmllciBvZiB0YXJnZXQvdXBwZXIvdGhpcyByZWdpb24iCiAgICBzdHJpbmcgdGFyZ2V0U3RyYW5kOyAiT3JpZW50YXRpb24gb2YgdGFyZ2V0L3VwcGVyL3RoaXMgcmVnaW9uOiArIG9yIC0uICBVc2UgLiBpZiBub3QgYXBwbGljYWJsZSIKCiAgICApYDsKICB2YXIgYmlnTGluayA9IGB0YWJsZSBiaWdMaW5rCiJiaWdMaW5rIHBhaXJ3aXNlIGFsaWdubWVudCIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICAiU3RhcnQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHVpbnQgICBjaHJvbUVuZDsgICAgIkVuZCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgc3RyaW5nIG5hbWU7ICAgICAgICAiTmFtZSBvciBJRCBvZiBpdGVtLCBpZGVhbGx5IGJvdGggaHVtYW4gcmVhZGFibGUgYW5kIHVuaXF1ZSIKICAgIHVpbnQgcVN0YXJ0OyAgICAgICAgInN0YXJ0IG9mIGFsaWdubWVudCBvbiBxdWVyeSBzZXF1ZW5jZSIKICAgIClgOwogIHZhciBiaWdNYWYgPSBgdGFibGUgYmVkTWFmCiJCZWQzIHdpdGggTUFGIGJsb2NrIgogICAgKAogICAgc3RyaW5nIGNocm9tOyAgICAgICJSZWZlcmVuY2Ugc2VxdWVuY2UgY2hyb21vc29tZSBvciBzY2FmZm9sZCIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAiU3RhcnQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHVpbnQgICBjaHJvbUVuZDsgICAiRW5kIHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICBsc3RyaW5nIG1hZkJsb2NrOyAgICJNQUYgYmxvY2siCiAgICApYDsKICB2YXIgYmlnTmFycm93UGVhayA9IGB0YWJsZSBiaWdOYXJyb3dQZWFrCiJCRUQ2KzQgUGVha3Mgb2Ygc2lnbmFsIGVucmljaG1lbnQgYmFzZWQgb24gcG9vbGVkLCBub3JtYWxpemVkIChpbnRlcnByZXRlZCkgZGF0YS4iCigKICAgIHN0cmluZyBjaHJvbTsgICAgICAgICJSZWZlcmVuY2Ugc2VxdWVuY2UgY2hyb21vc29tZSBvciBzY2FmZm9sZCIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAgICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgdWludCAgIGNocm9tRW5kOyAgICAgIkVuZCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgc3RyaW5nIG5hbWU7CSAiTmFtZSBnaXZlbiB0byBhIHJlZ2lvbiAocHJlZmVyYWJseSB1bmlxdWUpLiBVc2UgLiBpZiBubyBuYW1lIGlzIGFzc2lnbmVkIgogICAgdWludCAgIHNjb3JlOyAgICAgICAgIkluZGljYXRlcyBob3cgZGFyayB0aGUgcGVhayB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgYnJvd3NlciAoMC0xMDAwKSAiCiAgICBjaGFyWzFdICBzdHJhbmQ7ICAgICAiKyBvciAtIG9yIC4gZm9yIHVua25vd24iCiAgICBmbG9hdCAgc2lnbmFsVmFsdWU7ICAiTWVhc3VyZW1lbnQgb2YgYXZlcmFnZSBlbnJpY2htZW50IGZvciB0aGUgcmVnaW9uIgogICAgZmxvYXQgIHBWYWx1ZTsgICAgICAgIlN0YXRpc3RpY2FsIHNpZ25pZmljYW5jZSBvZiBzaWduYWwgdmFsdWUgKC1sb2cxMCkuIFNldCB0byAtMSBpZiBub3QgdXNlZC4iCiAgICBmbG9hdCAgcVZhbHVlOyAgICAgICAiU3RhdGlzdGljYWwgc2lnbmlmaWNhbmNlIHdpdGggbXVsdGlwbGUtdGVzdCBjb3JyZWN0aW9uIGFwcGxpZWQgKEZEUiAtbG9nMTApLiBTZXQgdG8gLTEgaWYgbm90IHVzZWQuIgogICAgaW50ICAgcGVhazsgICAgICAgICAiUG9pbnQtc291cmNlIGNhbGxlZCBmb3IgdGhpcyBwZWFrOyAwLWJhc2VkIG9mZnNldCBmcm9tIGNocm9tU3RhcnQuIFNldCB0byAtMSBpZiBubyBwb2ludC1zb3VyY2UgY2FsbGVkLiIKKWA7CiAgdmFyIGJpZ1BzbCA9IGB0YWJsZSBiaWdQc2wKImJpZ1BzbCBwYWlyd2lzZSBhbGlnbm1lbnQiCiAgICAoCiAgICBzdHJpbmcgY2hyb207ICAgICAgICJSZWZlcmVuY2Ugc2VxdWVuY2UgY2hyb21vc29tZSBvciBzY2FmZm9sZCIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAgIlN0YXJ0IHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICB1aW50ICAgY2hyb21FbmQ7ICAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHN0cmluZyBuYW1lOyAgICAgICAgIk5hbWUgb3IgSUQgb2YgaXRlbSwgaWRlYWxseSBib3RoIGh1bWFuIHJlYWRhYmxlIGFuZCB1bmlxdWUiCiAgICB1aW50IHNjb3JlOyAgICAgICAgICJTY29yZSAoMC0xMDAwKSIKICAgIGNoYXJbMV0gc3RyYW5kOyAgICAgIisgb3IgLSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcXVlcnkgYWxpZ25zIHRvIHRoZSArIG9yIC0gc3RyYW5kIG9uIHRoZSByZWZlcmVuY2UiCiAgICB1aW50IHRoaWNrU3RhcnQ7ICAgICJTdGFydCBvZiB3aGVyZSBkaXNwbGF5IHNob3VsZCBiZSB0aGljayAoc3RhcnQgY29kb24pIgogICAgdWludCB0aGlja0VuZDsgICAgICAiRW5kIG9mIHdoZXJlIGRpc3BsYXkgc2hvdWxkIGJlIHRoaWNrIChzdG9wIGNvZG9uKSIKICAgIHVpbnQgcmVzZXJ2ZWQ7ICAgICAgICJSR0IgdmFsdWUgKHVzZSBSLEcsQiBzdHJpbmcgaW4gaW5wdXQgZmlsZSkiCiAgICBpbnQgYmxvY2tDb3VudDsgICAgICJOdW1iZXIgb2YgYmxvY2tzIgogICAgaW50W2Jsb2NrQ291bnRdIGJsb2NrU2l6ZXM7ICJDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBibG9jayBzaXplcyIKICAgIGludFtibG9ja0NvdW50XSBjaHJvbVN0YXJ0czsgIlN0YXJ0IHBvc2l0aW9ucyByZWxhdGl2ZSB0byBjaHJvbVN0YXJ0IgoKICAgIHVpbnQgICAgb0Nocm9tU3RhcnQ7IlN0YXJ0IHBvc2l0aW9uIGluIG90aGVyIGNocm9tb3NvbWUiCiAgICB1aW50ICAgIG9DaHJvbUVuZDsgICJFbmQgcG9zaXRpb24gaW4gb3RoZXIgY2hyb21vc29tZSIKICAgIGNoYXJbMV0gb1N0cmFuZDsgICAgIisgb3IgLSwgLSBtZWFucyB0aGF0IHBzbCB3YXMgcmV2ZXJzZWQgaW50byBCRUQtY29tcGF0aWJsZSBjb29yZGluYXRlcyIKICAgIHVpbnQgICAgb0Nocm9tU2l6ZTsgIlNpemUgb2Ygb3RoZXIgY2hyb21vc29tZS4iCiAgICBpbnRbYmxvY2tDb3VudF0gb0Nocm9tU3RhcnRzOyAiU3RhcnQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIG9DaHJvbVN0YXJ0IG9yIGZyb20gb0Nocm9tU3RhcnQrb0Nocm9tU2l6ZSBkZXBlbmRpbmcgb24gc3RyYW5kIgoKICAgIGxzdHJpbmcgIG9TZXF1ZW5jZTsgICJTZXF1ZW5jZSBvbiBvdGhlciBjaHJvbSAob3IgZW1wdHkpIgogICAgc3RyaW5nICAgb0NEUzsgICAgICAgIkNEUyBpbiBOQ0JJIGZvcm1hdCIKCiAgICB1aW50ICAgIGNocm9tU2l6ZTsiU2l6ZSBvZiB0YXJnZXQgY2hyb21vc29tZSIKCiAgICB1aW50IG1hdGNoOyAgICAgICAgIk51bWJlciBvZiBiYXNlcyBtYXRjaGVkLiIKICAgIHVpbnQgbWlzTWF0Y2g7ICIgTnVtYmVyIG9mIGJhc2VzIHRoYXQgZG9uJ3QgbWF0Y2ggIgogICAgdWludCByZXBNYXRjaDsgIiBOdW1iZXIgb2YgYmFzZXMgdGhhdCBtYXRjaCBidXQgYXJlIHBhcnQgb2YgcmVwZWF0cyAiCiAgICB1aW50IG5Db3VudDsgICAiIE51bWJlciBvZiAnTicgYmFzZXMgIgogICAgdWludCBzZXFUeXBlOyAgICAiMD1lbXB0eSwgMT1udWNsZW90aWRlLCAyPWFtaW5vX2FjaWQiCiAgICApYDsKICB2YXIgZGVmYXVsdEJlZFNjaGVtYSA9IGB0YWJsZSBkZWZhdWx0QmVkU2NoZW1hCiJCRUQxMiIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAiVGhlIG5hbWUgb2YgdGhlIGNocm9tb3NvbWUgKGUuZy4gY2hyMywgY2hyWSwgY2hyMl9yYW5kb20pIG9yIHNjYWZmb2xkIChlLmcuIHNjYWZmb2xkMTA2NzEpLiIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAiVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSBmZWF0dXJlIGluIHRoZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkLiBUaGUgZmlyc3QgYmFzZSBpbiBhIGNocm9tb3NvbWUgaXMgbnVtYmVyZWQgMC4iCiAgICB1aW50ICAgY2hyb21FbmQ7ICAgIlRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIGZlYXR1cmUgaW4gdGhlIGNocm9tb3NvbWUgb3Igc2NhZmZvbGQuIFRoZSBjaHJvbUVuZCBiYXNlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgZGlzcGxheSBvZiB0aGUgZmVhdHVyZS4gRm9yIGV4YW1wbGUsIHRoZSBmaXJzdCAxMDAgYmFzZXMgb2YgYSBjaHJvbW9zb21lIGFyZSBkZWZpbmVkIGFzIGNocm9tU3RhcnQ9MCwgY2hyb21FbmQ9MTAwLCBhbmQgc3BhbiB0aGUgYmFzZXMgbnVtYmVyZWQgMC05OS4iCiAgICBzdHJpbmcgICBuYW1lOyAgICJEZWZpbmVzIHRoZSBuYW1lIG9mIHRoZSBCRUQgbGluZS4iCiAgICBmbG9hdCAgIHNjb3JlOyAgICJGZWF0dXJlIHNjb3JlLCBkb2Vzbid0IGNhcmUgYWJvdXQgdGhlIDAtMTAwMCBsaW1pdCBhcyBpbiBiZWQiCiAgICBjaGFyICAgc3RyYW5kOyAgICJEZWZpbmVzIHRoZSBzdHJhbmQuIEVpdGhlciAnLicgKD1ubyBzdHJhbmQpIG9yICcrJyBvciAnLSciCiAgICB1aW50IHRoaWNrU3RhcnQ7ICJUaGUgc3RhcnRpbmcgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGZlYXR1cmUgaXMgZHJhd24gdGhpY2tseSAoZm9yIGV4YW1wbGUsIHRoZSBzdGFydCBjb2RvbiBpbiBnZW5lIGRpc3BsYXlzKS4gV2hlbiB0aGVyZSBpcyBubyB0aGljayBwYXJ0LCB0aGlja1N0YXJ0IGFuZCB0aGlja0VuZCBhcmUgdXN1YWxseSBzZXQgdG8gdGhlIGNocm9tU3RhcnQgcG9zaXRpb24uIgogICAgdWludCB0aGlja0VuZDsgIlRoZSBlbmRpbmcgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGZlYXR1cmUgaXMgZHJhd24gdGhpY2tseSAoZm9yIGV4YW1wbGUgdGhlIHN0b3AgY29kb24gaW4gZ2VuZSBkaXNwbGF5cykuIgogICAgc3RyaW5nIGl0ZW1SZ2I7ICJBbiBSR0IgdmFsdWUgb2YgdGhlIGZvcm0gUixHLEIgKGUuZy4gMjU1LDAsMCkuICIKICAgIHVpbnQgYmxvY2tDb3VudDsgIiBUaGUgbnVtYmVyIG9mIGJsb2NrcyAoZXhvbnMpIGluIHRoZSBCRUQgbGluZS4iCiAgICB1aW50W2Jsb2NrQ291bnRdIGJsb2NrU2l6ZXM7ICIgQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgYmxvY2sgc2l6ZXMuIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhpcyBsaXN0IHNob3VsZCBjb3JyZXNwb25kIHRvIGJsb2NrQ291bnQuIgogICAgdWludFtibG9ja0NvdW50XSBibG9ja1N0YXJ0czsgIkEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYmxvY2sgc3RhcnRzLiBBbGwgb2YgdGhlIGJsb2NrU3RhcnQgcG9zaXRpb25zIHNob3VsZCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGNocm9tU3RhcnQuIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhpcyBsaXN0IHNob3VsZCBjb3JyZXNwb25kIHRvIGJsb2NrQ291bnQuIgogICAgKWA7CiAgdmFyIG1hZkZyYW1lcyA9IGB0YWJsZSBtYWZGcmFtZXMKImNvZG9uIGZyYW1lIGFzc2lnbm1lbnQgZm9yIE1BRiBjb21wb25lbnRzIgogICAgKAogICAgc3RyaW5nIGNocm9tOyAgICAgICJSZWZlcmVuY2Ugc2VxdWVuY2UgY2hyb21vc29tZSBvciBzY2FmZm9sZCIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAiU3RhcnQgcmFuZ2UgaW4gY2hyb21vc29tZSIKICAgIHVpbnQgICBjaHJvbUVuZDsgICAiRW5kIHJhbmdlIGluIGNocm9tb3NvbWUiCiAgICBzdHJpbmcgc3JjOyAgICAgICAgIk5hbWUgb2Ygc2VxdWVuY2Ugc291cmNlIGluIE1BRiIKICAgIHVieXRlIGZyYW1lOyAgICAgICAiZnJhbWUgKDAsMSwyKSBmb3IgZmlyc3QgYmFzZSgrKSBvciBsYXN0IGJhc3QoLSkiCiAgICBjaGFyWzFdIHN0cmFuZDsgICAgIisgb3IgLSIKICAgIHN0cmluZyBuYW1lOyAgICAgICAiTmFtZSBvZiBnZW5lIHVzZWQgdG8gZGVmaW5lIGZyYW1lIgogICAgaW50ICAgIHByZXZGcmFtZVBvczsgICJ0YXJnZXQgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIGJhc2UgKGluIHRyYW5zY3JpcHRpb24gZGlyZWN0aW9uKSB0aGF0IGNvbnRpbnVlcyB0aGlzIGZyYW1lLCBvciAtMSBpZiBub25lLCBvciBmcmFtZSBub3QgY29udGlndW91cyIKICAgIGludCAgICBuZXh0RnJhbWVQb3M7ICAidGFyZ2V0IHBvc2l0aW9uIG9mIHRoZSBuZXh0IGJhc2UgKGluIHRyYW5zY3JpcHRpb24gZGlyZWN0aW9uKSB0aGF0IGNvbnRpbnVlcyB0aGlzIGZyYW1lLCBvciAtMSBpZiBub25lLCBvciBmcmFtZSBub3QgY29udGlndW91cyIKICAgIHVieXRlICBpc0V4b25TdGFydDsgICJkb2VzIHRoaXMgc3RhcnQgdGhlIENEUyBwb3J0aW9uIG9mIGFuIGV4b24/IgogICAgdWJ5dGUgIGlzRXhvbkVuZDsgICAgImRvZXMgdGhpcyBlbmQgdGhlIENEUyBwb3J0aW9uIG9mIGFuIGV4b24/IgogICAgKWA7CiAgdmFyIG1hZlN1bW1hcnkgPSBgdGFibGUgbWFmU3VtbWFyeQoiUG9zaXRpb25zIGFuZCBzY29yZXMgZm9yIGFsaWdubWVudCBibG9ja3MiCiAgICAoCiAgICBzdHJpbmcgY2hyb207ICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgdWludCAgIGNocm9tRW5kOyAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHN0cmluZyBzcmM7ICAgICAgICAiU2VxdWVuY2UgbmFtZSBvciBkYXRhYmFzZSBvZiBhbGlnbm1lbnQiCiAgICBmbG9hdCAgc2NvcmU7ICAgICAgIkZsb2F0aW5nIHBvaW50IHNjb3JlLiIKICAgIGNoYXJbMV0gbGVmdFN0YXR1czsgICJHYXAvYnJlYWsgYW5ub3RhdGlvbiBmb3IgcHJlY2VkaW5nIGJsb2NrIgogICAgY2hhclsxXSByaWdodFN0YXR1czsgIkdhcC9icmVhayBhbm5vdGF0aW9uIGZvciBmb2xsb3dpbmcgYmxvY2siCiAgICApYDsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vZGVmYXVsdFR5cGVzLmpzCiAgdmFyIGRlZmF1bHRUeXBlc19kZWZhdWx0ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGF1dG9TcWxTY2hlbWFzX2V4cG9ydHMpLm1hcCgoW2tleSwgdmFsXSkgPT4gWwogICAga2V5LAogICAgKDAsIGltcG9ydF9hdXRvU3FsLnBhcnNlKSh2YWwudHJpbSgpKQogIF0pKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBkZXRlY3RUeXBlcyhhdXRvU3FsKSB7CiAgICBjb25zdCBudW1lcmljVHlwZXMgPSBbInVpbnQiLCAiaW50IiwgImZsb2F0IiwgImxvbmciXTsKICAgIHJldHVybiB7CiAgICAgIC4uLmF1dG9TcWwsCiAgICAgIGZpZWxkczogYXV0b1NxbC5maWVsZHMubWFwKChhdXRvRmllbGQpID0+ICh7CiAgICAgICAgLi4uYXV0b0ZpZWxkLAogICAgICAgIGlzQXJyYXk6IGF1dG9GaWVsZC5zaXplICYmIGF1dG9GaWVsZC50eXBlICE9PSAiY2hhciIsCiAgICAgICAgYXJyYXlJc051bWVyaWM6IGF1dG9GaWVsZC5zaXplICYmIG51bWVyaWNUeXBlcy5pbmNsdWRlcyhhdXRvRmllbGQudHlwZSksCiAgICAgICAgaXNOdW1lcmljOiAhYXV0b0ZpZWxkLnNpemUgJiYgbnVtZXJpY1R5cGVzLmluY2x1ZGVzKGF1dG9GaWVsZC50eXBlKQogICAgICB9KSkKICAgIH07CiAgfQoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmVkL2VzbS9wYXJzZXIuanMKICB2YXIgc3RyYW5kTWFwID0geyAiLiI6IDAsICItIjogLTEsICIrIjogMSB9OwogIGZ1bmN0aW9uIGlzQmVkMTJMaWtlKGZpZWxkcykgewogICAgdmFyIF9hOwogICAgcmV0dXJuIGZpZWxkcy5sZW5ndGggPj0gMTIgJiYgIU51bWJlci5pc05hTihwYXJzZUludChmaWVsZHNbOV0sIDEwKSkgJiYgKChfYSA9IGZpZWxkc1sxMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgiLCIpLmZpbHRlcigoZikgPT4gISFmKS5sZW5ndGgpID09PSBwYXJzZUludChmaWVsZHNbOV0sIDEwKTsKICB9CiAgdmFyIEJFRCA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkgewogICAgICBpZiAoYXJncy5hdXRvU3FsKSB7CiAgICAgICAgdGhpcy5hdXRvU3FsID0gZGV0ZWN0VHlwZXMoaW1wb3J0X2F1dG9TcWwyLmRlZmF1bHQucGFyc2UoYXJncy5hdXRvU3FsKSk7CiAgICAgIH0gZWxzZSBpZiAoYXJncy50eXBlKSB7CiAgICAgICAgaWYgKCFkZWZhdWx0VHlwZXNfZGVmYXVsdFthcmdzLnR5cGVdKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlR5cGUgbm90IGZvdW5kIik7CiAgICAgICAgfQogICAgICAgIHRoaXMuYXV0b1NxbCA9IGRldGVjdFR5cGVzKGRlZmF1bHRUeXBlc19kZWZhdWx0W2FyZ3MudHlwZV0pOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYXV0b1NxbCA9IGRldGVjdFR5cGVzKGRlZmF1bHRUeXBlc19kZWZhdWx0LmRlZmF1bHRCZWRTY2hlbWEpOwogICAgICAgIHRoaXMuYXR0ZW1wdERlZmF1bHRCZWQgPSB0cnVlOwogICAgICB9CiAgICB9CiAgICBwYXJzZUxpbmUobGluZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgYXV0b1NxbCB9ID0gdGhpczsKICAgICAgY29uc3QgeyB1bmlxdWVJZCB9ID0gb3B0czsKICAgICAgY29uc3QgZmllbGRzID0gQXJyYXkuaXNBcnJheShsaW5lKSA/IGxpbmUgOiBsaW5lLnNwbGl0KCIJIik7CiAgICAgIGxldCBmZWF0dXJlID0ge307CiAgICAgIGlmICghdGhpcy5hdHRlbXB0RGVmYXVsdEJlZCB8fCB0aGlzLmF0dGVtcHREZWZhdWx0QmVkICYmIGlzQmVkMTJMaWtlKGZpZWxkcykpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1dG9TcWwuZmllbGRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBhdXRvRmllbGQgPSBhdXRvU3FsLmZpZWxkc1tpXTsKICAgICAgICAgIGxldCBjb2x1bW5WYWwgPSBmaWVsZHNbaV07CiAgICAgICAgICBjb25zdCB7IGlzTnVtZXJpYywgaXNBcnJheTogaXNBcnJheTIsIGFycmF5SXNOdW1lcmljLCBuYW1lIH0gPSBhdXRvRmllbGQ7CiAgICAgICAgICBpZiAoY29sdW1uVmFsID09PSBudWxsIHx8IGNvbHVtblZhbCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvbHVtblZhbCAhPT0gIi4iKSB7CiAgICAgICAgICAgIGlmIChpc051bWVyaWMpIHsKICAgICAgICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIoY29sdW1uVmFsKTsKICAgICAgICAgICAgICBjb2x1bW5WYWwgPSBOdW1iZXIuaXNOYU4obnVtKSA/IGNvbHVtblZhbCA6IG51bTsKICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5MikgewogICAgICAgICAgICAgIGNvbHVtblZhbCA9IGNvbHVtblZhbC5zcGxpdCgiLCIpOwogICAgICAgICAgICAgIGlmIChjb2x1bW5WYWxbY29sdW1uVmFsLmxlbmd0aCAtIDFdID09PSAiIikgewogICAgICAgICAgICAgICAgY29sdW1uVmFsLnBvcCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoYXJyYXlJc051bWVyaWMpIHsKICAgICAgICAgICAgICAgIGNvbHVtblZhbCA9IGNvbHVtblZhbC5tYXAoKHN0cikgPT4gTnVtYmVyKHN0cikpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBmZWF0dXJlW25hbWVdID0gY29sdW1uVmFsOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gWyJjaHJvbSIsICJjaHJvbVN0YXJ0IiwgImNocm9tRW5kIiwgIm5hbWUiXTsKICAgICAgICBmZWF0dXJlID0gT2JqZWN0LmZyb21FbnRyaWVzKGZpZWxkcy5tYXAoKGYsIGkpID0+IFtmaWVsZE5hbWVzW2ldIHx8ICJmaWVsZCIgKyBpLCBmXSkpOwogICAgICAgIGZlYXR1cmUuY2hyb21TdGFydCA9ICtmZWF0dXJlLmNocm9tU3RhcnQ7CiAgICAgICAgZmVhdHVyZS5jaHJvbUVuZCA9ICtmZWF0dXJlLmNocm9tRW5kOwogICAgICAgIGlmICghTnVtYmVyLmlzTmFOKE51bWJlci5wYXJzZUZsb2F0KGZlYXR1cmUuZmllbGQ0KSkpIHsKICAgICAgICAgIGZlYXR1cmUuc2NvcmUgPSArZmVhdHVyZS5maWVsZDQ7CiAgICAgICAgICBkZWxldGUgZmVhdHVyZS5maWVsZDQ7CiAgICAgICAgfQogICAgICAgIGlmIChmZWF0dXJlLmZpZWxkNSA9PT0gIisiIHx8IGZlYXR1cmUuZmllbGQ1ID09PSAiLSIpIHsKICAgICAgICAgIGZlYXR1cmUuc3RyYW5kID0gZmVhdHVyZS5maWVsZDU7CiAgICAgICAgICBkZWxldGUgZmVhdHVyZS5maWVsZDU7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICh1bmlxdWVJZCkgewogICAgICAgIGZlYXR1cmUudW5pcXVlSWQgPSB1bmlxdWVJZDsKICAgICAgfQogICAgICBmZWF0dXJlLnN0cmFuZCA9IHN0cmFuZE1hcFtmZWF0dXJlLnN0cmFuZF0gfHwgMDsKICAgICAgZmVhdHVyZS5jaHJvbSA9IGRlY29kZVVSSUNvbXBvbmVudChmZWF0dXJlLmNocm9tKTsKICAgICAgcmV0dXJuIGZlYXR1cmU7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vaW5kZXguanMKICB2YXIgZXNtX2RlZmF1bHQgPSBCRUQ7CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL2JlZC9iZWQtcGFyc2VyLnRzCiAgdmFyIERFRkFVTFRfQkVEX1NDSEVNQSA9IGB0YWJsZSBkZWZhdWx0QmVkU2NoZW1hCiJCRUQxMiIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAiVGhlIG5hbWUgb2YgdGhlIGNocm9tb3NvbWUgKGUuZy4gY2hyMywgY2hyWSwgY2hyMl9yYW5kb20pIG9yIHNjYWZmb2xkIChlLmcuIHNjYWZmb2xkMTA2NzEpLiIKICAgIHVpbnQgICBjaHJvbVN0YXJ0OyAiVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSBmZWF0dXJlIGluIHRoZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkLiBUaGUgZmlyc3QgYmFzZSBpbiBhIGNocm9tb3NvbWUgaXMgbnVtYmVyZWQgMC4iCiAgICB1aW50ICAgY2hyb21FbmQ7ICAgIlRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIGZlYXR1cmUgaW4gdGhlIGNocm9tb3NvbWUgb3Igc2NhZmZvbGQuIFRoZSBjaHJvbUVuZCBiYXNlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgZGlzcGxheSBvZiB0aGUgZmVhdHVyZS4gRm9yIGV4YW1wbGUsIHRoZSBmaXJzdCAxMDAgYmFzZXMgb2YgYSBjaHJvbW9zb21lIGFyZSBkZWZpbmVkIGFzIGNocm9tU3RhcnQ9MCwgY2hyb21FbmQ9MTAwLCBhbmQgc3BhbiB0aGUgYmFzZXMgbnVtYmVyZWQgMC05OS4iCiAgICBzdHJpbmcgICBuYW1lOyAgICJEZWZpbmVzIHRoZSBuYW1lIG9mIHRoZSBCRUQgbGluZS4iCiAgICBmbG9hdCAgIHNjb3JlOyAgICJGZWF0dXJlIHNjb3JlLCBkb2Vzbid0IGNhcmUgYWJvdXQgdGhlIDAtMTAwMCBsaW1pdCBhcyBpbiBiZWQiCiAgICBjaGFyICAgc3RyYW5kOyAgICJEZWZpbmVzIHRoZSBzdHJhbmQuIEVpdGhlciAnLicgKD1ubyBzdHJhbmQpIG9yICcrJyBvciAnLSciCiAgICB1aW50IHRoaWNrU3RhcnQ7ICJUaGUgc3RhcnRpbmcgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGZlYXR1cmUgaXMgZHJhd24gdGhpY2tseSAoZm9yIGV4YW1wbGUsIHRoZSBzdGFydCBjb2RvbiBpbiBnZW5lIGRpc3BsYXlzKS4gV2hlbiB0aGVyZSBpcyBubyB0aGljayBwYXJ0LCB0aGlja1N0YXJ0IGFuZCB0aGlja0VuZCBhcmUgdXN1YWxseSBzZXQgdG8gdGhlIGNocm9tU3RhcnQgcG9zaXRpb24uIgogICAgdWludCB0aGlja0VuZDsgIlRoZSBlbmRpbmcgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGZlYXR1cmUgaXMgZHJhd24gdGhpY2tseSAoZm9yIGV4YW1wbGUgdGhlIHN0b3AgY29kb24gaW4gZ2VuZSBkaXNwbGF5cykuIgogICAgc3RyaW5nIGl0ZW1SZ2I7ICJBbiBSR0IgdmFsdWUgb2YgdGhlIGZvcm0gUixHLEIgKGUuZy4gMjU1LDAsMCkuICIKICAgIHVpbnQgYmxvY2tDb3VudDsgIiBUaGUgbnVtYmVyIG9mIGJsb2NrcyAoZXhvbnMpIGluIHRoZSBCRUQgbGluZS4iCiAgICB1aW50W2Jsb2NrQ291bnRdIGJsb2NrU2l6ZXM7ICIgQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgYmxvY2sgc2l6ZXMuIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhpcyBsaXN0IHNob3VsZCBjb3JyZXNwb25kIHRvIGJsb2NrQ291bnQuIgogICAgdWludFtibG9ja0NvdW50XSBibG9ja1N0YXJ0czsgIkEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYmxvY2sgc3RhcnRzLiBBbGwgb2YgdGhlIGJsb2NrU3RhcnQgcG9zaXRpb25zIHNob3VsZCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGNocm9tU3RhcnQuIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhpcyBsaXN0IHNob3VsZCBjb3JyZXNwb25kIHRvIGJsb2NrQ291bnQuIgogICAgKWA7CiAgdmFyIEJlZFBhcnNlciA9IGNsYXNzIHsKICAgICNjdXN0b21GaWVsZHM7CiAgICAjbl9jb2x1bW5zOwogICAgI3BhcnNlcjsKICAgIGNvbnN0cnVjdG9yKG9wdCkgewogICAgICB0aGlzLiNjdXN0b21GaWVsZHMgPSBvcHQ/LmN1c3RvbUZpZWxkczsKICAgICAgdGhpcy4jbl9jb2x1bW5zID0gb3B0Py5uX2NvbHVtbnM7CiAgICAgIGlmICh0aGlzLiNjdXN0b21GaWVsZHMpIHsKICAgICAgICBjb25zdCBjdXN0b21BdXRvU3FsU2NoZW1hID0gdGhpcy5jb25zdHJ1Y3RCZWRBdXRvU3FsKCk7CiAgICAgICAgdGhpcy4jcGFyc2VyID0gbmV3IGVzbV9kZWZhdWx0KHsgYXV0b1NxbDogY3VzdG9tQXV0b1NxbFNjaGVtYSB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLiNwYXJzZXIgPSBuZXcgZXNtX2RlZmF1bHQoeyBhdXRvU3FsOiBERUZBVUxUX0JFRF9TQ0hFTUEgfSk7CiAgICAgIH0KICAgIH0KICAgIHBhcnNlTGluZShsaW5lLCBjaHJvbVN0YXJ0KSB7CiAgICAgIGZ1bmN0aW9uIHJlbGF0aXZlVG9DdW11bGF0aXZlKHBvcywgY2hyb21TdGFydDIpIHsKICAgICAgICByZXR1cm4gY2hyb21TdGFydDIgKyBwb3MgKyAxOwogICAgICB9CiAgICAgIGNvbnN0IGJlZFJlY29yZCA9IHRoaXMuI3BhcnNlci5wYXJzZUxpbmUobGluZSk7CiAgICAgIGNvbnN0IGZpZWxkc1RvQ29udmVydCA9IFsiY2hyb21TdGFydCIsICJjaHJvbUVuZCIsICJ0aGlja0VuZCIsICJ0aGlja1N0YXJ0Il07CiAgICAgIGZpZWxkc1RvQ29udmVydC5mb3JFYWNoKChmaWVsZCkgPT4gewogICAgICAgIGlmIChiZWRSZWNvcmRbZmllbGRdKQogICAgICAgICAgYmVkUmVjb3JkW2ZpZWxkXSA9IHJlbGF0aXZlVG9DdW11bGF0aXZlKGJlZFJlY29yZFtmaWVsZF0sIGNocm9tU3RhcnQpOwogICAgICB9KTsKICAgICAgcmV0dXJuIGJlZFJlY29yZDsKICAgIH0KICAgIGNvbnN0cnVjdEJlZEF1dG9TcWwoKSB7CiAgICAgIGNvbnN0IEFVVE9fU1FMX0hFQURFUiA9IGB0YWJsZSBjdXN0b21CZWRTY2hlbWEKIkJFRDEyIgogICAgKApgOwogICAgICBjb25zdCBBVVRPX1NRTF9GT09URVIgPSAiXG4gICAgKSI7CiAgICAgIGNvbnN0IGF1dG9TcWxGaWVsZHMgPSB0aGlzLiNnZW5lcmF0ZUF1dG9TUUxGaWVsZHMoKTsKICAgICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuY29uY2F0KEFVVE9fU1FMX0hFQURFUiwgYXV0b1NxbEZpZWxkcywgQVVUT19TUUxfRk9PVEVSKTsKICAgIH0KICAgICNnZW5lcmF0ZUF1dG9TUUxGaWVsZHMoKSB7CiAgICAgIGNvbnN0IEJFRDEyRmllbGRzID0gWwogICAgICAgIFsic3RyaW5nIiwgImNocm9tIl0sCiAgICAgICAgWyJ1aW50IiwgImNocm9tU3RhcnQiXSwKICAgICAgICBbInVpbnQiLCAiY2hyb21FbmQiXSwKICAgICAgICBbInN0cmluZyIsICJuYW1lIl0sCiAgICAgICAgWyJmbG9hdCIsICJzY29yZSJdLAogICAgICAgIFsiY2hhciIsICJzdHJhbmQiXSwKICAgICAgICBbInVpbnQiLCAidGhpY2tTdGFydCJdLAogICAgICAgIFsidWludCIsICJ0aGlja0VuZCJdLAogICAgICAgIFsic3RyaW5nIiwgIml0ZW1SZ2IiXSwKICAgICAgICBbInVpbnQiLCAiYmxvY2tDb3VudCJdLAogICAgICAgIFsidWludFtibG9ja0NvdW50XSIsICJibG9ja1NpemVzIl0sCiAgICAgICAgWyJ1aW50W2Jsb2NrQ291bnRdIiwgImJsb2NrU3RhcnRzIl0KICAgICAgXTsKICAgICAgaWYgKCF0aGlzLiNuX2NvbHVtbnMpCiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOdW1iZXIgb2YgY29sdW1ucyB3YXMgbm90IGFibGUgdG8gYmUgZGV0ZXJtaW5lZCIpOwogICAgICBpZiAoIXRoaXMuI2N1c3RvbUZpZWxkcykKICAgICAgICByZXR1cm4gIiI7CiAgICAgIGNvbnN0IGN1c3RvbUZpZWxkVHlwZSA9ICJzdHJpbmciOwogICAgICBjb25zdCBjdXN0b21GaWVsZHNXaXRoVHlwZXMgPSB0aGlzLiNjdXN0b21GaWVsZHMubWFwKChjb2x1bW4pID0+IFtjdXN0b21GaWVsZFR5cGUsIGNvbHVtbl0pOwogICAgICBsZXQgYWxsRmllbGRzOwogICAgICBjb25zdCBSRVFVSVJFRF9DT0xTID0gMzsKICAgICAgaWYgKHRoaXMuI25fY29sdW1ucyA+IEJFRDEyRmllbGRzLmxlbmd0aCkgewogICAgICAgIGlmICh0aGlzLiNuX2NvbHVtbnMgIT09IEJFRDEyRmllbGRzLmxlbmd0aCArIHRoaXMuI2N1c3RvbUZpZWxkcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQkVEIGZpbGUgZXJyb3I6IHVuZXhwZWN0ZWQgbnVtYmVyIG9mIGN1c3RvbSBmaWVsZHMuIEZvdW5kICR7dGhpcy4jbl9jb2x1bW5zfSBjb2x1bW5zIAogICAgICAgICAgICAgICAgICAgIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBleHBlY3RlZCAke0JFRDEyRmllbGRzLmxlbmd0aCArIHRoaXMuI2N1c3RvbUZpZWxkcy5sZW5ndGh9YCk7CiAgICAgICAgfQogICAgICAgIGFsbEZpZWxkcyA9IEJFRDEyRmllbGRzLmNvbmNhdChjdXN0b21GaWVsZHNXaXRoVHlwZXMpOwogICAgICB9IGVsc2UgaWYgKHRoaXMuI25fY29sdW1ucyA+PSBSRVFVSVJFRF9DT0xTICsgdGhpcy4jY3VzdG9tRmllbGRzLmxlbmd0aCkgewogICAgICAgIGFsbEZpZWxkcyA9IEJFRDEyRmllbGRzLnNsaWNlKDAsIHRoaXMuI25fY29sdW1ucyAtIHRoaXMuI2N1c3RvbUZpZWxkcy5sZW5ndGgpLmNvbmNhdChjdXN0b21GaWVsZHNXaXRoVHlwZXMpOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtSRVFVSVJFRF9DT0xTICsgdGhpcy4jY3VzdG9tRmllbGRzLmxlbmd0aH0gY29sdW1ucyAoJHtSRVFVSVJFRF9DT0xTfSByZXF1aXJlZCBjb2x1bW5zIGFuZCAke3RoaXMuI2N1c3RvbUZpZWxkcy5sZW5ndGh9IGN1c3RvbSBjb2x1bW5zKSBidXQgZm91bmQgJHt0aGlzLiNuX2NvbHVtbnN9IGNvbHVtbnNgKTsKICAgICAgfQogICAgICBjb25zdCBmaWVsZERlc2NyaXB0aW9uID0gImN1c3RvbSBpbnB1dCI7CiAgICAgIGNvbnN0IGF1dG9TcWxGaWVsZHMgPSBhbGxGaWVsZHMubWFwKChmaWVsZEluZm8pID0+IGAgICAgJHtmaWVsZEluZm9bMF19ICR7ZmllbGRJbmZvWzFdfTsgIiR7ZmllbGREZXNjcmlwdGlvbn0iYCkuam9pbigiXG4iKTsKICAgICAgcmV0dXJuIGF1dG9TcWxGaWVsZHM7CiAgICB9CiAgfTsKICB2YXIgYmVkX3BhcnNlcl9kZWZhdWx0ID0gQmVkUGFyc2VyOwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iZWQvYmVkLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgdmFyIEJlZEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih0YmksIHVpZCkgewogICAgICB0aGlzLnRiaSA9IHRiaTsKICAgICAgdGhpcy4jdWlkID0gdWlkOwogICAgfQogICAgI3BhcnNlcjsKICAgICNjdXN0b21GaWVsZHM7CiAgICAjdWlkOwogICAgc3RhdGljIGZyb21VcmwodXJsLCBpbmRleFVybCwgdWlkLCB1cmxGZXRjaE9wdGlvbnMsIGluZGV4VXJsRmV0Y2hPcHRpb25zKSB7CiAgICAgIGNvbnN0IHRiaSA9IG5ldyBUYWJpeEluZGV4ZWRGaWxlKHsKICAgICAgICBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZTIodXJsLCB7IG92ZXJyaWRlczogdXJsRmV0Y2hPcHRpb25zIH0pLAogICAgICAgIHRiaUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMihpbmRleFVybCwgeyBvdmVycmlkZXM6IGluZGV4VXJsRmV0Y2hPcHRpb25zIH0pCiAgICAgIH0pOwogICAgICByZXR1cm4gbmV3IEJlZEZpbGUodGJpLCB1aWQpOwogICAgfQogICAgc2V0IGN1c3RvbUZpZWxkcyhjdXN0b20pIHsKICAgICAgdGhpcy4jY3VzdG9tRmllbGRzID0gY3VzdG9tOwogICAgfQogICAgYXN5bmMgZ2V0UGFyc2VyKCkgewogICAgICBpZiAoIXRoaXMuI3BhcnNlcikgewogICAgICAgIGNvbnN0IG9wdCA9IHRoaXMuI2N1c3RvbUZpZWxkcyA/IHsgY3VzdG9tRmllbGRzOiB0aGlzLiNjdXN0b21GaWVsZHMsIG5fY29sdW1uczogYXdhaXQgdGhpcy4jY2FsY05Db2x1bW5zKCkgfSA6IHZvaWQgMDsKICAgICAgICB0aGlzLiNwYXJzZXIgPSBuZXcgYmVkX3BhcnNlcl9kZWZhdWx0KG9wdCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuI3BhcnNlcjsKICAgIH0KICAgIGFzeW5jICNjYWxjTkNvbHVtbnMoKSB7CiAgICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh0aGlzLiN1aWQpOwogICAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBzb3VyY2UuY2hyb21JbmZvOwogICAgICBsZXQgbl9jb2xzID0gMDsKICAgICAgZm9yIChjb25zdCBjdW1Qb3Mgb2YgY3VtUG9zaXRpb25zKSB7CiAgICAgICAgY29uc3QgY2hyb21OYW1lID0gY3VtUG9zLmNocjsKICAgICAgICBjb25zdCBjaHJvbVN0YXJ0ID0gY3VtUG9zLnBvczsKICAgICAgICBjb25zdCBjaHJvbUVuZCA9IGN1bVBvcy5wb3MgKyBjaHJvbUxlbmd0aHNbY2hyb21OYW1lXTsKICAgICAgICBuX2NvbHMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gewogICAgICAgICAgc291cmNlLmZpbGUudGJpLmdldExpbmVzKGNocm9tTmFtZSwgY2hyb21TdGFydCwgY2hyb21FbmQsIChsaW5lKSA9PiB7CiAgICAgICAgICAgIHJlc29sdmUobGluZS5zcGxpdCgiCSIpLmxlbmd0aCk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgICBpZiAobl9jb2xzID4gMCkKICAgICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIHJldHVybiBuX2NvbHM7CiAgICB9CiAgICBhc3luYyBnZXRUaWxlRGF0YShtaW5YLCBtYXhYKSB7CiAgICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh0aGlzLiN1aWQpOwogICAgICBjb25zdCBwYXJzZXIyID0gYXdhaXQgdGhpcy5nZXRQYXJzZXIoKTsKICAgICAgbGV0IGN1ck1pblggPSBtaW5YOwogICAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBzb3VyY2UuY2hyb21JbmZvOwogICAgICBjb25zdCBhbGxUaWxlcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IGN1bVBvcyBvZiBjdW1Qb3NpdGlvbnMpIHsKICAgICAgICBjb25zdCBjaHJvbU5hbWUgPSBjdW1Qb3MuY2hyOwogICAgICAgIGNvbnN0IGNocm9tU3RhcnQgPSBjdW1Qb3MucG9zOwogICAgICAgIGNvbnN0IGNocm9tRW5kID0gY3VtUG9zLnBvcyArIGNocm9tTGVuZ3Roc1tjaHJvbU5hbWVdOwogICAgICAgIGxldCBzdGFydFBvcywgZW5kUG9zOwogICAgICAgIGlmIChjaHJvbVN0YXJ0ID4gY3VyTWluWCB8fCBjdXJNaW5YID49IGNocm9tRW5kKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdGlsZXNQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIGNvbnN0IHRpbGVzID0gW107CiAgICAgICAgICBjb25zdCBsaW5lQ2FsbGJhY2sgPSAobGluZSkgPT4gewogICAgICAgICAgICBjb25zdCBiZWRUaWxlID0gcGFyc2VyMi5wYXJzZUxpbmUobGluZSwgY2hyb21TdGFydCk7CiAgICAgICAgICAgIHRpbGVzLnB1c2goYmVkVGlsZSk7CiAgICAgICAgICB9OwogICAgICAgICAgaWYgKG1heFggPiBjaHJvbUVuZCkgewogICAgICAgICAgICBzdGFydFBvcyA9IGN1ck1pblggLSBjaHJvbVN0YXJ0OwogICAgICAgICAgICBlbmRQb3MgPSBjaHJvbUVuZCAtIGNocm9tU3RhcnQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGFydFBvcyA9IE1hdGguZmxvb3IoY3VyTWluWCAtIGNocm9tU3RhcnQpOwogICAgICAgICAgICBlbmRQb3MgPSBNYXRoLmNlaWwobWF4WCAtIGNocm9tU3RhcnQpOwogICAgICAgICAgfQogICAgICAgICAgc291cmNlLmZpbGUudGJpLmdldExpbmVzKGNocm9tTmFtZSwgc3RhcnRQb3MsIGVuZFBvcywgbGluZUNhbGxiYWNrKS50aGVuKCgpID0+IHsKICAgICAgICAgICAgcmVzb2x2ZSh0aWxlcyk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgICBhbGxUaWxlcy5wdXNoKHRpbGVzUHJvbWlzZSk7CiAgICAgICAgaWYgKG1heFggPD0gY2hyb21FbmQpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBjdXJNaW5YID0gY2hyb21FbmQ7CiAgICAgIH0KICAgICAgY29uc3QgdGlsZUFycmF5cyA9IGF3YWl0IFByb21pc2UuYWxsKGFsbFRpbGVzKTsKICAgICAgcmV0dXJuIHRpbGVBcnJheXMuZmxhdCgpOwogICAgfQogIH07CiAgdmFyIGJlZEZpbGVzID0gbmV3IE1hcCgpOwogIHZhciB0aWxlVmFsdWVzID0ge307CiAgdmFyIGRhdGFTb3VyY2VzID0gbmV3IE1hcCgpOwogIGZ1bmN0aW9uIGluaXQodWlkLCBiZWQsIGNocm9tU2l6ZXMsIG9wdGlvbnMgPSB7fSkgewogICAgbGV0IGJlZEZpbGUgPSBiZWRGaWxlcy5nZXQoYmVkLnVybCk7CiAgICBpZiAoIWJlZEZpbGUpIHsKICAgICAgYmVkRmlsZSA9IEJlZEZpbGUuZnJvbVVybChiZWQudXJsLCBiZWQuaW5kZXhVcmwsIHVpZCwgb3B0aW9ucy51cmxGZXRjaE9wdGlvbnMsIG9wdGlvbnMuaW5kZXhVcmxGZXRjaE9wdGlvbnMpOwogICAgICBpZiAob3B0aW9ucy5jdXN0b21GaWVsZHMpCiAgICAgICAgYmVkRmlsZS5jdXN0b21GaWVsZHMgPSBvcHRpb25zLmN1c3RvbUZpZWxkczsKICAgIH0KICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZShiZWRGaWxlLCBjaHJvbVNpemVzLCB7CiAgICAgIHNhbXBsZUxlbmd0aDogMWUzLAogICAgICAuLi5vcHRpb25zCiAgICB9KTsKICAgIGRhdGFTb3VyY2VzLnNldCh1aWQsIGRhdGFTb3VyY2UpOwogIH0KICB2YXIgdGlsZXNldEluZm8gPSAodWlkKSA9PiB7CiAgICByZXR1cm4gZGF0YVNvdXJjZXMuZ2V0KHVpZCkudGlsZXNldEluZm87CiAgfTsKICB2YXIgdGlsZSA9IGFzeW5jICh1aWQsIHosIHgpID0+IHsKICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh1aWQpOwogICAgY29uc3QgQ0FDSEVfS0VZID0gYCR7dWlkfS4ke3p9LiR7eH1gOwogICAgdGlsZVZhbHVlc1tDQUNIRV9LRVldID0gW107CiAgICBjb25zdCB0aWxlV2lkdGggPSArc291cmNlLnRpbGVzZXRJbmZvLm1heF93aWR0aCAvIDIgKiogK3o7CiAgICBjb25zdCBtaW5YID0gc291cmNlLnRpbGVzZXRJbmZvLm1pbl9wb3NbMF0gKyB4ICogdGlsZVdpZHRoOwogICAgY29uc3QgbWF4WCA9IHNvdXJjZS50aWxlc2V0SW5mby5taW5fcG9zWzBdICsgKHggKyAxKSAqIHRpbGVXaWR0aDsKICAgIHRpbGVWYWx1ZXNbQ0FDSEVfS0VZXSA9IGF3YWl0IHNvdXJjZS5maWxlLmdldFRpbGVEYXRhKG1pblgsIG1heFgpOwogICAgcmV0dXJuIHRpbGVWYWx1ZXNbQ0FDSEVfS0VZXTsKICB9OwogIHZhciBmZXRjaFRpbGVzRGVib3VuY2VkID0gYXN5bmMgKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgdGlsZXMgPSB7fTsKICAgIGNvbnN0IHZhbGlkVGlsZUlkcyA9IFtdOwogICAgY29uc3QgdGlsZVByb21pc2VzID0gW107CiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiB0aWxlSWRzKSB7CiAgICAgIGNvbnN0IHBhcnRzID0gdGlsZUlkLnNwbGl0KCIuIik7CiAgICAgIGNvbnN0IHogPSBwYXJzZUludChwYXJ0c1swXSwgMTApOwogICAgICBjb25zdCB4ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeikpIHsKICAgICAgICBjb25zb2xlLndhcm4oIkludmFsaWQgdGlsZSB6b29tIG9yIHBvc2l0aW9uOiIsIHosIHgpOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHZhbGlkVGlsZUlkcy5wdXNoKHRpbGVJZCk7CiAgICAgIHRpbGVQcm9taXNlcy5wdXNoKHRpbGUodWlkLCB6LCB4KSk7CiAgICB9CiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGlsZVByb21pc2VzKS50aGVuKCh2YWx1ZXMyKSA9PiB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzMi5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IHZhbGlkVGlsZUlkID0gdmFsaWRUaWxlSWRzW2ldOwogICAgICAgIHRpbGVzW3ZhbGlkVGlsZUlkXSA9IHsgdGlsZVBvc2l0aW9uSWQ6IHZhbGlkVGlsZUlkIH07CiAgICAgIH0KICAgICAgcmV0dXJuIHRpbGVzOwogICAgfSk7CiAgfTsKICB2YXIgZ2V0VGFidWxhckRhdGEgPSAodWlkLCB0aWxlSWRzKSA9PiB7CiAgICBjb25zdCBkYXRhID0gW107CiAgICB0aWxlSWRzLmZvckVhY2goKHRpbGVJZCkgPT4gewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGNvbnN0IHRpbGVWYWx1ZSA9IHRpbGVWYWx1ZXNbYCR7dWlkfS4ke3p9LiR7eH1gXTsKICAgICAgaWYgKCF0aWxlVmFsdWUpIHsKICAgICAgICBjb25zb2xlLndhcm4oYE5vIHRpbGUgZGF0YSBjb25zdHJ1Y3RlZCAoJHt0aWxlSWR9KWApOwogICAgICB9CiAgICAgIGRhdGEucHVzaCh0aWxlVmFsdWUpOwogICAgfSk7CiAgICBsZXQgb3V0cHV0ID0gT2JqZWN0LnZhbHVlcyhkYXRhKS5mbGF0KCk7CiAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBkYXRhU291cmNlcy5nZXQodWlkKS5vcHRpb25zLnNhbXBsZUxlbmd0aDsKICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNhbXBsZUxlbmd0aCkgewogICAgICBvdXRwdXQgPSBzYW1wbGVTaXplX2RlZmF1bHQob3V0cHV0LCBzYW1wbGVMZW5ndGggLyAyKTsKICAgIH0KICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShKU09OLnN0cmluZ2lmeShvdXRwdXQpKS5idWZmZXI7CiAgICByZXR1cm4gVHJhbnNmZXIoYnVmZmVyLCBbYnVmZmVyXSk7CiAgfTsKICB2YXIgdGlsZUZ1bmN0aW9ucyA9IHsKICAgIGluaXQsCiAgICB0aWxlc2V0SW5mbywKICAgIGZldGNoVGlsZXNEZWJvdW5jZWQsCiAgICB0aWxlLAogICAgZ2V0VGFidWxhckRhdGEKICB9OwogIGV4cG9zZSh0aWxlRnVuY3Rpb25zKTsKfSkoKTsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwovKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqLwovKioKICogQGxpY2Vuc2UKICogQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzCiAqIENvcHlyaWdodCAyMDIwIERhbmllbCBXaXJ0eiAvIFRoZSBsb25nLmpzIEF1dGhvcnMuCiAqCiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwogKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAogKgogKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiAqCiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiAqCiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wCiAqLwovKioKICogQGxpY2Vuc2UKICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPgogKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9ImVzIiAtbyAuL2AKICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPgogKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+CiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+CiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9ycwogKi8K";
const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function Worker$1() {
  const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME = 200;
class BedDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "prevRequestTime");
    __publicField(this, "track");
    __publicField(this, "toFetch");
    __publicField(this, "fetchTimeout");
    __publicField(this, "worker");
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$1()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  /**
   * Called by GoslingTrack. This is how the track gets data
   * @param tileIds The position of the tile
   * @returns A promise to the BedTiles
   */
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    const parsed = JSON.parse(new TextDecoder().decode(buf));
    return parsed;
  }
}
__publicField(BedDataFetcher, "config", { type: "bed" });
const dataFetchers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BamDataFetcher,
  BedDataFetcher,
  BigWigDataFetcher,
  CsvDataFetcher,
  GffDataFetcher,
  JsonDataFetcher,
  VcfDataFetcher
}, Symbol.toStringTag, { value: "Module" }));
const GOSLING_DATA_ROW_UID_FIELD = "gosling-data-row-uid";
function getTabularData(spec, data2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const tabularData = [];
  if (!IsDataDeepTileset(spec.data)) {
    console.warn("No data is specified");
    return;
  }
  if (spec.data.type === "vector" || spec.data.type === "bigwig") {
    if (!("dense" in data2)) {
      return;
    }
    const bin = (_a = spec.data.binSize) != null ? _a : 1;
    const numericValues = data2.dense;
    const numOfGenomicPositions = data2.tileSize;
    const tileUnitSize = data2.tileWidth / data2.tileSize;
    const valueName = (_b = spec.data.value) != null ? _b : "value";
    const columnName = (_c = spec.data.column) != null ? _c : "position";
    const startName = (_d = spec.data.start) != null ? _d : "start";
    const endName = (_e = spec.data.end) != null ? _e : "end";
    const minValueName = `${valueName}_min`;
    const maxValueName = `${valueName}_max`;
    const agg = (_f = spec.data.aggregation) != null ? _f : "mean";
    let cumVal = 0;
    let minVal = Number.MAX_SAFE_INTEGER;
    let maxVal = Number.MIN_SAFE_INTEGER;
    let binStart = Number.MIN_SAFE_INTEGER;
    let binEnd = Number.MAX_SAFE_INTEGER;
    Array.from(Array(numOfGenomicPositions).keys()).forEach((g, j) => {
      if (bin === 1) {
        const value = numericValues[j] / (agg === "mean" ? tileUnitSize : 1);
        tabularData.push({
          [valueName]: value,
          [columnName]: data2.tileX + (j + 0.5) * tileUnitSize,
          [startName]: data2.tileX + j * tileUnitSize,
          [endName]: data2.tileX + (j + 1) * tileUnitSize,
          [minValueName]: value,
          [maxValueName]: value
        });
      } else {
        if (j % bin === 0) {
          cumVal = minVal = maxVal = numericValues[j];
          binStart = j;
          binEnd = j + bin;
        } else if (j % bin === bin - 1) {
          tabularData.push({
            [valueName]: cumVal / bin / (agg === "mean" ? tileUnitSize : 1),
            [columnName]: data2.tileX + (binStart + bin / 2) * tileUnitSize,
            [startName]: data2.tileX + binStart * tileUnitSize,
            [endName]: data2.tileX + binEnd * tileUnitSize,
            [minValueName]: minVal,
            [maxValueName]: maxVal
          });
        } else if (j === numOfGenomicPositions - 1) {
          const smallBin = numOfGenomicPositions % bin;
          const correctedBinEnd = binStart + smallBin;
          tabularData.push({
            [valueName]: cumVal / smallBin / (agg === "mean" ? tileUnitSize : 1),
            [columnName]: data2.tileX + (binStart + smallBin / 2) * tileUnitSize,
            [startName]: data2.tileX + binStart * tileUnitSize,
            [endName]: data2.tileX + correctedBinEnd * tileUnitSize,
            [minValueName]: minVal,
            [maxValueName]: maxVal
          });
        } else {
          cumVal += numericValues[j];
          if (minVal > numericValues[j])
            minVal = numericValues[j];
          if (maxVal < numericValues[j])
            maxVal = numericValues[j];
        }
      }
    });
  } else if (spec.data.type === "multivec") {
    if (!("dense" in data2) || data2.shape === void 0) {
      return;
    }
    const bin = (_g = spec.data.binSize) != null ? _g : 1;
    const numOfTotalCategories = data2.shape[0];
    const categories = (_h = spec.data.categories) != null ? _h : [...Array(numOfTotalCategories).keys()];
    const numericValues = data2.dense;
    const numOfGenomicPositions = data2.shape[1];
    const tileUnitSize = data2.tileWidth / data2.tileSize;
    const rowName = (_i = spec.data.row) != null ? _i : "category";
    const valueName = (_j = spec.data.value) != null ? _j : "value";
    const columnName = (_k = spec.data.column) != null ? _k : "position";
    const startName = (_l = spec.data.start) != null ? _l : "start";
    const endName = (_m = spec.data.end) != null ? _m : "end";
    const minValueName = `${valueName}_min`;
    const maxValueName = `${valueName}_max`;
    const agg = (_n = spec.data.aggregation) != null ? _n : "mean";
    categories.forEach((c, i) => {
      let cumVal = 0;
      let binStart = Number.MIN_SAFE_INTEGER;
      let binEnd = Number.MAX_SAFE_INTEGER;
      let minVal = Number.MAX_SAFE_INTEGER;
      let maxVal = Number.MIN_SAFE_INTEGER;
      Array.from(Array(numOfGenomicPositions).keys()).forEach((g, j) => {
        if (bin === 1) {
          const value = numericValues[numOfGenomicPositions * i + j] / (agg === "mean" ? tileUnitSize : 1);
          tabularData.push({
            [rowName]: c,
            [valueName]: value,
            [columnName]: data2.tileX + (j + 0.5) * tileUnitSize,
            [startName]: data2.tileX + j * tileUnitSize,
            [endName]: data2.tileX + (j + 1) * tileUnitSize,
            [minValueName]: value,
            [maxValueName]: value
          });
        } else {
          if (j % bin === 0) {
            cumVal = minVal = maxVal = numericValues[numOfGenomicPositions * i + j];
            binStart = j;
            binEnd = j + bin;
          } else if (j % bin === bin - 1) {
            tabularData.push({
              [rowName]: c,
              [valueName]: agg === "mean" ? cumVal / bin / tileUnitSize : cumVal,
              [columnName]: data2.tileX + (binStart + bin / 2) * tileUnitSize,
              [startName]: data2.tileX + binStart * tileUnitSize,
              [endName]: data2.tileX + binEnd * tileUnitSize,
              [minValueName]: minVal,
              [maxValueName]: maxVal
            });
          } else if (j === numOfGenomicPositions - 1) {
            const smallBin = numOfGenomicPositions % bin;
            const correctedBinEnd = binStart + smallBin;
            tabularData.push({
              [rowName]: c,
              [valueName]: agg === "mean" ? cumVal / smallBin / tileUnitSize : cumVal,
              [columnName]: data2.tileX + (binStart + smallBin / 2) * tileUnitSize,
              [startName]: data2.tileX + binStart * tileUnitSize,
              [endName]: data2.tileX + correctedBinEnd * tileUnitSize,
              [minValueName]: minVal,
              [maxValueName]: maxVal
            });
          } else {
            const value = numericValues[numOfGenomicPositions * i + j];
            cumVal += value;
            if (minVal > value)
              minVal = value;
            if (maxVal < value)
              maxVal = value;
          }
        }
      });
    });
  } else if (spec.data.type === "matrix") {
    if (!("dense" in data2) || typeof data2.tileY === "undefined" || typeof data2.tileHeight === "undefined") {
      return;
    }
    const numBins = Math.sqrt(data2.dense.length);
    const { tileX, tileY, tileWidth, tileHeight } = data2;
    const numericValues = data2.dense;
    const tileXUnitSize = tileWidth / numBins;
    const tileYUnitSize = tileHeight / numBins;
    const columnField = (_o = spec.data.column) != null ? _o : "x";
    const rowField = (_p = spec.data.row) != null ? _p : "y";
    const aggSize = 16;
    for (let i = 0; i < numericValues.length / aggSize; i++) {
      const aggLen = Math.sqrt(aggSize);
      const xIndex = i * aggLen % numBins;
      const yIndex = Math.floor(i * aggLen / numBins) * aggLen;
      let value = NaN;
      for (let c = 0; c < aggLen; c++) {
        for (let r = 0; r < aggLen; r++) {
          const curVal = numericValues[(yIndex + r) * numBins + (xIndex + c)];
          if (!isNaN(+curVal)) {
            if (isNaN(value)) {
              value = 0;
            }
            value += curVal;
          }
        }
      }
      if (isNaN(value)) {
        continue;
      }
      const xs = tileX + xIndex * tileXUnitSize;
      const xe = tileX + (xIndex + aggLen) * tileXUnitSize;
      const ys = tileY + yIndex * tileYUnitSize;
      const ye = tileY + (yIndex + aggLen) * tileYUnitSize;
      const x = (xs + xe) / 2;
      const y = (ys + ye) / 2;
      tabularData.push({
        value,
        [columnField]: x,
        [`${columnField}s`]: xs,
        [`${columnField}e`]: xe,
        [rowField]: y,
        [`${rowField}s`]: ys,
        [`${rowField}e`]: ye
      });
    }
  } else if (spec.data.type === "beddb") {
    if (!data2.sparse) {
      return;
    }
    const { genomicFields, exonIntervalFields, valueFields } = spec.data;
    data2.sparse.forEach((d, i) => {
      const { chrOffset, fields } = d;
      const datum = {};
      datum[GOSLING_DATA_ROW_UID_FIELD] = `${i}`;
      genomicFields.forEach((g) => {
        datum[g.name] = +fields[g.index] + chrOffset;
      });
      valueFields == null ? void 0 : valueFields.forEach((v) => {
        datum[v.name] = v.type === "quantitative" ? +fields[v.index] : fields[v.index];
      });
      tabularData.push({
        ...datum,
        type: "gene"
        // this should be described in the spec
      });
      if (exonIntervalFields) {
        const [exonStartField, exonEndField] = exonIntervalFields;
        const exonStartStrs = fields[exonStartField.index].split(",");
        const exonEndStrs = fields[exonEndField.index].split(",");
        exonStartStrs.forEach((es, i2) => {
          const ee = exonEndStrs[i2];
          tabularData.push({
            ...datum,
            [exonStartField.name]: +es + chrOffset,
            [exonEndField.name]: +ee + chrOffset,
            type: "exon"
          });
          if (i2 + 1 < exonStartStrs.length) {
            const nextEs = exonStartStrs[i2 + 1];
            tabularData.push({
              ...datum,
              [exonStartField.name]: +ee + chrOffset,
              [exonEndField.name]: +nextEs + chrOffset,
              type: "intron"
            });
          }
        });
      }
    });
  }
  return tabularData;
}
const $ref = "#/definitions/HiGlassSpec";
const $schema = "http://json-schema.org/draft-07/schema#";
const definitions = {
  Assembly: {
    anyOf: [
      {
        "const": "hg38",
        type: "string"
      },
      {
        "const": "hg19",
        type: "string"
      },
      {
        "const": "hg18",
        type: "string"
      },
      {
        "const": "hg17",
        type: "string"
      },
      {
        "const": "hg16",
        type: "string"
      },
      {
        "const": "mm10",
        type: "string"
      },
      {
        "const": "mm9",
        type: "string"
      },
      {
        "const": "unknown",
        type: "string"
      },
      {
        $ref: "#/definitions/ChromSizes"
      }
    ]
  },
  ChromSizes: {
    description: 'Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]]',
    items: {
      items: [
        {
          type: "string"
        },
        {
          type: "number"
        }
      ],
      maxItems: 2,
      minItems: 2,
      type: "array"
    },
    type: "array"
  },
  CombinedTrack: {
    additionalProperties: false,
    properties: {
      contents: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      height: {
        type: "number"
      },
      options: {},
      position: {
        type: "string"
      },
      type: {
        "const": "combined",
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      }
    },
    required: [
      "type",
      "contents"
    ],
    type: "object"
  },
  Data: {
    additionalProperties: false,
    properties: {
      assembly: {
        $ref: "#/definitions/Assembly"
      },
      children: {
        items: {},
        type: "array"
      },
      filter: {
        items: {
          $ref: "#/definitions/FilterTransform"
        },
        type: "array"
      },
      indexUrl: {
        type: "string"
      },
      indexUrlFetchOptions: {
        $ref: "#/definitions/RequestInit"
      },
      tiles: {},
      tilesetInfo: {},
      type: {
        type: "string"
      },
      url: {
        type: "string"
      },
      urlFetchOptions: {
        $ref: "#/definitions/RequestInit"
      }
    },
    type: "object"
  },
  EnumTrack: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      data: {
        $ref: "#/definitions/Data"
      },
      fromViewUid: {
        type: [
          "null",
          "string"
        ]
      },
      height: {
        type: "number"
      },
      options: {},
      server: {
        type: "string"
      },
      tilesetUid: {
        type: "string"
      },
      type: {
        $ref: "#/definitions/EnumTrackType"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  EnumTrackType: {
    "enum": [
      "heatmap",
      "2d-annotations",
      "2d-chromosome-annotations",
      "2d-chromosome-grid",
      "2d-chromosome-labels",
      "2d-rectangle-domains",
      "2d-tiles",
      "arrowhead-domains",
      "bedlike",
      "cross-rule",
      "dummy",
      "horizontal-1d-annotations",
      "horizontal-1d-heatmap",
      "horizontal-1d-tiles",
      "horizontal-1d-value-interval",
      "horizontal-2d-rectangle-domains",
      "horizontal-bar",
      "horizontal-chromosome-grid",
      "horizontal-chromosome-labels",
      "horizontal-divergent-bar",
      "horizontal-gene-annotations",
      "horizontal-heatmap",
      "horizontal-line",
      "horizontal-multivec",
      "horizontal-point",
      "horizontal-rule",
      "horizontal-vector-heatmap",
      "image-tiles",
      "left-axis",
      "left-stacked-interval",
      "mapbox-tiles",
      "osm-2d-tile-ids",
      "osm-tiles",
      "raster-tiles",
      "simple-svg",
      "square-markers",
      "top-axis",
      "top-stacked-interval",
      "vertical-1d-annotations",
      "vertical-1d-heatmap",
      "vertical-1d-tiles",
      "vertical-1d-value-interval",
      "vertical-2d-rectangle-domains",
      "vertical-bar",
      "vertical-bedlike",
      "vertical-chromosome-grid",
      "vertical-chromosome-labels",
      "vertical-gene-annotations",
      "vertical-heatmap",
      "vertical-line",
      "vertical-multivec",
      "vertical-point",
      "vertical-rule",
      "vertical-vector-heatmap",
      "viewport-projection-center",
      "viewport-projection-horizontal",
      "viewport-projection-vertical",
      "gosling-track",
      "gosling-2d-track",
      "axis-track",
      "text",
      "dummy-track"
    ],
    type: "string"
  },
  FilterTransform: {
    anyOf: [
      {
        $ref: "#/definitions/OneOfFilter"
      },
      {
        $ref: "#/definitions/RangeFilter"
      },
      {
        $ref: "#/definitions/IncludeFilter"
      }
    ]
  },
  GenericLocks: {
    additionalProperties: false,
    properties: {
      locksByViewUid: {
        $ref: "#/definitions/LocksByViewUid"
      },
      locksDict: {}
    },
    required: [
      "locksByViewUid",
      "locksDict"
    ],
    type: "object"
  },
  GenomePositionSearchBox: {
    additionalProperties: false,
    properties: {
      autocompleteId: {
        type: "string"
      },
      autocompleteServer: {
        type: "string"
      },
      chromInfoId: {
        type: "string"
      },
      chromInfoServer: {
        type: "string"
      },
      visible: {
        type: "boolean"
      }
    },
    required: [
      "chromInfoId",
      "chromInfoServer"
    ],
    type: "object"
  },
  HeatmapTrack: {
    additionalProperties: false,
    properties: {
      data: {
        $ref: "#/definitions/Data"
      },
      height: {
        type: "number"
      },
      options: {},
      position: {
        type: "string"
      },
      server: {
        type: "string"
      },
      tilesetUid: {
        type: "string"
      },
      type: {
        "const": "heatmap",
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  HiGlassSpec: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      compactLayout: {
        type: "boolean"
      },
      editable: {
        type: "boolean"
      },
      exportViewUrl: {
        type: "string"
      },
      locationLocks: {
        $ref: "#/definitions/GenericLocks"
      },
      trackSourceServers: {
        items: {
          type: "string"
        },
        type: "array"
      },
      tracksEditable: {
        type: "boolean"
      },
      valueScaleLocks: {
        $ref: "#/definitions/ValueScaleLocks"
      },
      viewEditable: {
        type: "boolean"
      },
      views: {
        items: {
          $ref: "#/definitions/View"
        },
        type: "array"
      },
      zoomFixed: {
        type: "boolean"
      },
      zoomLocks: {
        $ref: "#/definitions/GenericLocks"
      }
    },
    required: [
      "views",
      "zoomLocks",
      "locationLocks"
    ],
    type: "object"
  },
  IncludeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      include: {
        description: "Check whether the value includes a substring.",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "include",
      "type"
    ],
    type: "object"
  },
  IndependentViewportProjectionTrack: {
    additionalProperties: false,
    properties: {
      fromViewUid: {
        type: "null"
      },
      options: {},
      projectionXDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      projectionYDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      transforms: {
        items: {},
        type: "array"
      },
      type: {
        "enum": [
          "viewport-projection-horizontal",
          "viewport-projection-vertical",
          "viewport-projection-center"
        ],
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  Layout: {
    additionalProperties: false,
    properties: {
      h: {
        type: "number"
      },
      w: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "h",
      "w",
      "x",
      "y"
    ],
    type: "object"
  },
  LocksByViewUid: {
    additionalProperties: {
      type: "string"
    },
    type: "object"
  },
  OneOfFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      oneOf: {
        description: "Check whether the value is an element in the provided list.",
        items: {
          type: [
            "string",
            "number",
            "null"
          ]
        },
        type: "array"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "oneOf",
      "type"
    ],
    type: "object"
  },
  Overlay: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      includes: {
        items: {},
        type: "array"
      },
      options: {
        $ref: "#/definitions/OverlayOptions"
      },
      type: {
        type: "string"
      },
      uid: {
        type: "string"
      }
    },
    type: "object"
  },
  OverlayOptions: {
    additionalProperties: false,
    properties: {
      extent: {
        items: {},
        type: "array"
      },
      fill: {
        type: "string"
      },
      fillOpacity: {
        type: "number"
      },
      minWidth: {
        type: "number"
      },
      outline: {
        type: "string"
      },
      outlineOpacity: {
        type: "number"
      },
      outlinePos: {
        anyOf: [
          {
            items: {},
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      outlineWidth: {
        type: "number"
      },
      stroke: {
        type: "string"
      },
      strokeOpacity: {
        type: "number"
      },
      strokePos: {
        anyOf: [
          {
            items: {},
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      strokeWidth: {
        type: "number"
      }
    },
    type: "object"
  },
  RangeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      inRange: {
        description: "Check whether the value is in a number range.",
        items: {
          type: "number"
        },
        type: "array"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "inRange",
      "type"
    ],
    type: "object"
  },
  RequestInit: {
    additionalProperties: false,
    properties: {
      headers: {
        type: "object"
      }
    },
    type: "object"
  },
  Track: {
    anyOf: [
      {
        $ref: "#/definitions/HeatmapTrack"
      },
      {
        $ref: "#/definitions/CombinedTrack"
      },
      {
        $ref: "#/definitions/IndependentViewportProjectionTrack"
      },
      {
        $ref: "#/definitions/EnumTrack"
      }
    ]
  },
  Tracks: {
    additionalProperties: false,
    properties: {
      bottom: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      center: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      gallery: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      left: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      right: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      top: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      whole: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      }
    },
    required: [
      "top",
      "left",
      "center",
      "right",
      "bottom",
      "gallery",
      "whole"
    ],
    type: "object"
  },
  ValueScaleLocks: {
    additionalProperties: false,
    properties: {
      locksByViewUid: {
        $ref: "#/definitions/LocksByViewUid"
      },
      locksDict: {}
    },
    required: [
      "locksByViewUid"
    ],
    type: "object"
  },
  View: {
    additionalProperties: false,
    properties: {
      autocompleteSource: {
        type: "string"
      },
      chromInfoPath: {
        type: "string"
      },
      genomePositionSearchBox: {
        $ref: "#/definitions/GenomePositionSearchBox"
      },
      genomePositionSearchBoxVisible: {
        type: "boolean"
      },
      initialXDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      initialYDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      layout: {
        $ref: "#/definitions/Layout"
      },
      overlays: {
        items: {
          $ref: "#/definitions/Overlay"
        },
        type: "array"
      },
      selectionView: {
        type: "boolean"
      },
      tracks: {
        $ref: "#/definitions/Tracks"
      },
      uid: {
        type: "string"
      },
      zoomFixed: {
        type: "boolean"
      },
      zoomLimits: {
        items: {
          type: [
            "number",
            "null"
          ]
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "tracks",
      "layout"
    ],
    type: "object"
  }
};
const HiGlassSchema = {
  $ref,
  $schema,
  definitions
};
function getNumericDomain(domain, assembly) {
  const chromInterval = computeChromSizes(assembly).interval;
  if ("chromosome" in domain) {
    const isThereChr = Object.keys(chromInterval).find((chr) => chr === domain.chromosome);
    if (!isThereChr) {
      return;
    }
  }
  if (IsDomainChr(domain)) {
    return [chromInterval[domain.chromosome][0] + 1, chromInterval[domain.chromosome][1]];
  } else if (IsDomainInterval(domain)) {
    return domain.interval;
  } else if (IsDomainChrInterval(domain)) {
    const chrStart = chromInterval[domain.chromosome][0];
    const [start, end] = domain.interval;
    return [chrStart + start, chrStart + end];
  }
}
function shareScaleAcrossTracks(trackModels, force) {
  const globalDomain = {};
  const channelKeys = SUPPORTED_CHANNELS;
  trackModels.forEach((model) => {
    channelKeys.forEach((channelKey) => {
      const channel = model.spec()[channelKey];
      if (!IsChannelDeep(channel) || channel.domain === void 0) {
        return;
      }
      const { domain, type: type2 } = channel;
      if (type2 === "quantitative") {
        const numericDomain = Array.from(domain);
        if (!globalDomain[channelKey]) {
          globalDomain[channelKey] = numericDomain;
        } else {
          const channelGlobalDomain = globalDomain[channelKey];
          if (channelGlobalDomain[0] > numericDomain[0]) {
            channelGlobalDomain[0] = numericDomain[0];
          }
          if (channelGlobalDomain[1] < numericDomain[1]) {
            channelGlobalDomain[1] = numericDomain[1];
          }
        }
      } else if (type2 === "nominal") {
        const nominalDomain = Array.from(domain);
        if (!globalDomain[channelKey]) {
          globalDomain[channelKey] = nominalDomain;
        } else {
          globalDomain[channelKey] = Array.from(
            /* @__PURE__ */ new Set([...globalDomain[channelKey], ...nominalDomain])
          );
        }
      }
    });
  });
  trackModels.forEach((model) => {
    channelKeys.forEach((channelKey) => {
      const channel = model.spec()[channelKey];
      if (IsChannelDeep(channel) && channel.type === "genomic")
        return;
      model.setChannelDomain(channelKey, globalDomain[channelKey], force);
      model.generateScales();
    });
    model.updateChannelValue();
  });
}
const example = {
  compactLayout: false,
  trackSourceServers: ["https://server.gosling-lang.org/api/v1/"],
  views: [
    {
      genomePositionSearchBoxVisible: false,
      genomePositionSearchBox: {
        autocompleteServer: "https://higlass.io/api/v1",
        autocompleteId: "P0PLbQMwTYGy-5uPIQid7A",
        chromInfoServer: "https://higlass.io/api/v1",
        chromInfoId: "hg38"
      },
      layout: { x: 0, y: 0, w: 6.4, h: 600 },
      tracks: {
        top: [],
        left: [
          {
            type: "combined",
            width: 130,
            height: 600,
            contents: [
              {
                type: "gosling-track",
                server: "https://server.gosling-lang.org/api/v1/",
                tilesetUid: "cistrome-multivec",
                width: 130,
                height: 600,
                options: {
                  showMousePosition: true,
                  mousePositionColor: "#000000",
                  fontSize: 24,
                  labelPosition: "none",
                  labelShowResolution: false,
                  labelColor: "black",
                  labelBackgroundColor: "white",
                  labelTextOpacity: 1,
                  labelLeftMargin: 1,
                  labelTopMargin: 1,
                  labelRightMargin: 0,
                  labelBottomMargin: 0,
                  backgroundColor: "transparent",
                  spec: {
                    spacing: 10,
                    orientation: "vertical",
                    assembly: "hg38",
                    layout: "linear",
                    static: false,
                    xDomain: { interval: [0, 1e9] },
                    centerRadius: 0.3,
                    xOffset: 0,
                    yOffset: 0,
                    style: { outlineWidth: 0.5 },
                    data: {
                      url: "https://server.gosling-lang.org/api/v1/tileset_info/?d=cistrome-multivec",
                      type: "multivec",
                      row: "sample",
                      column: "position",
                      value: "peak",
                      categories: ["sample 1", "sample 2", "sample 3", "sample 4"],
                      binSize: 4
                    },
                    mark: "rect",
                    x: {
                      field: "start",
                      type: "genomic",
                      axis: "left",
                      domain: { interval: [0, 1e9] },
                      linkingId: "7f94b74e-25ec-4e67-8c75-3dc0f1b0d6bd"
                    },
                    xe: { field: "end", type: "genomic" },
                    row: {
                      field: "sample",
                      type: "nominal",
                      legend: true
                    },
                    color: {
                      field: "peak",
                      type: "quantitative",
                      legend: true
                    },
                    tooltip: [
                      {
                        field: "start",
                        type: "genomic",
                        alt: "Start Position"
                      },
                      {
                        field: "end",
                        type: "genomic",
                        alt: "End Position"
                      },
                      {
                        field: "peak",
                        type: "quantitative",
                        alt: "Value",
                        format: ".2"
                      },
                      { field: "sample", type: "nominal", alt: "Sample" }
                    ],
                    width: 160,
                    height: 600,
                    overlayOnPreviousTrack: false
                  },
                  theme: {
                    base: "light",
                    root: {
                      background: "white",
                      titleColor: "black",
                      titleBackgroundColor: "transparent",
                      titleFontSize: 18,
                      titleFontFamily: "Arial",
                      titleAlign: "left",
                      titleFontWeight: "bold",
                      subtitleColor: "gray",
                      subtitleBackgroundColor: "transparent",
                      subtitleFontSize: 16,
                      subtitleFontFamily: "Arial",
                      subtitleFontWeight: "normal",
                      subtitleAlign: "left",
                      mousePositionColor: "#000000"
                    },
                    track: {
                      background: "transparent",
                      alternatingBackground: "transparent",
                      titleColor: "black",
                      titleBackground: "white",
                      titleFontSize: 24,
                      titleAlign: "left",
                      outline: "black",
                      outlineWidth: 1
                    },
                    legend: {
                      position: "top",
                      background: "white",
                      backgroundOpacity: 0.7,
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      backgroundStroke: "#DBDBDB",
                      tickColor: "black"
                    },
                    axis: {
                      tickColor: "black",
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      baselineColor: "black",
                      gridColor: "#E3E3E3",
                      gridStrokeWidth: 1,
                      gridStrokeType: "solid",
                      gridStrokeDash: [4, 4]
                    },
                    markCommon: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    point: {
                      color: "#E79F00",
                      size: 3,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rect: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    triangle: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    area: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    line: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    bar: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rule: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    link: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    text: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6],
                      textAnchor: "middle",
                      textFontWeight: "normal"
                    },
                    brush: {
                      color: "gray",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 0.3,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    }
                  }
                }
              }
            ]
          },
          {
            uid: "15483511-f6fb-11eb-914b-976b6ecda162",
            type: "axis-track",
            chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes",
            options: {
              layout: "linear",
              outerRadius: null,
              width: 160,
              height: 600,
              theme: {
                base: "light",
                root: {
                  background: "white",
                  titleColor: "black",
                  titleBackgroundColor: "transparent",
                  titleFontSize: 18,
                  titleFontFamily: "Arial",
                  titleAlign: "left",
                  titleFontWeight: "bold",
                  subtitleColor: "gray",
                  subtitleBackgroundColor: "transparent",
                  subtitleFontSize: 16,
                  subtitleFontFamily: "Arial",
                  subtitleFontWeight: "normal",
                  subtitleAlign: "left",
                  mousePositionColor: "#000000"
                },
                track: {
                  background: "transparent",
                  alternatingBackground: "transparent",
                  titleColor: "black",
                  titleBackground: "white",
                  titleFontSize: 24,
                  titleAlign: "left",
                  outline: "black",
                  outlineWidth: 1
                },
                legend: {
                  position: "top",
                  background: "white",
                  backgroundOpacity: 0.7,
                  labelColor: "black",
                  labelFontSize: 12,
                  labelFontWeight: "normal",
                  labelFontFamily: "Arial",
                  backgroundStroke: "#DBDBDB",
                  tickColor: "black"
                },
                axis: {
                  tickColor: "black",
                  labelColor: "black",
                  labelFontSize: 12,
                  labelFontWeight: "normal",
                  labelFontFamily: "Arial",
                  baselineColor: "black",
                  gridColor: "#E3E3E3",
                  gridStrokeWidth: 1,
                  gridStrokeType: "solid",
                  gridStrokeDash: [4, 4]
                },
                markCommon: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                point: {
                  color: "#E79F00",
                  size: 3,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                rect: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                triangle: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                area: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                line: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                bar: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                rule: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                link: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                text: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6],
                  textAnchor: "middle",
                  textFontWeight: "normal"
                },
                brush: {
                  color: "gray",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 0.3,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                }
              },
              assembly: "hg38",
              stroke: "transparent",
              color: "black",
              fontSize: 12,
              fontFamily: "Arial",
              fontWeight: "normal",
              tickColor: "black",
              tickFormat: "plain",
              tickPositions: "even",
              reverseOrientation: false
            },
            width: 30
          }
        ],
        center: [],
        right: [],
        bottom: [],
        gallery: [],
        whole: []
      },
      initialXDomain: [0, 1e9],
      initialYDomain: [0, 1e9],
      zoomFixed: false,
      zoomLimits: [1, null],
      uid: "15483510-f6fb-11eb-914b-976b6ecda162",
      chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes"
    },
    {
      genomePositionSearchBoxVisible: false,
      genomePositionSearchBox: {
        autocompleteServer: "https://higlass.io/api/v1",
        autocompleteId: "P0PLbQMwTYGy-5uPIQid7A",
        chromInfoServer: "https://higlass.io/api/v1",
        chromInfoId: "hg38"
      },
      layout: { x: 6.8, y: 0, w: 5.2, h: 600 },
      tracks: {
        top: [],
        left: [
          {
            type: "combined",
            width: 130,
            height: 600,
            contents: [
              {
                type: "gosling-track",
                server: "https://server.gosling-lang.org/api/v1/",
                tilesetUid: "cistrome-multivec",
                width: 130,
                height: 600,
                options: {
                  showMousePosition: true,
                  mousePositionColor: "#000000",
                  fontSize: 24,
                  labelPosition: "none",
                  labelShowResolution: false,
                  labelColor: "black",
                  labelBackgroundColor: "white",
                  labelTextOpacity: 1,
                  labelLeftMargin: 1,
                  labelTopMargin: 1,
                  labelRightMargin: 0,
                  labelBottomMargin: 0,
                  backgroundColor: "transparent",
                  spec: {
                    spacing: 10,
                    orientation: "vertical",
                    assembly: "hg38",
                    layout: "linear",
                    static: false,
                    xDomain: { interval: [0, 1e9] },
                    centerRadius: 0.3,
                    xOffset: 0,
                    yOffset: 0,
                    style: { outlineWidth: 0.5 },
                    data: {
                      url: "https://server.gosling-lang.org/api/v1/tileset_info/?d=cistrome-multivec",
                      type: "multivec",
                      row: "sample",
                      column: "position",
                      value: "peak",
                      categories: ["sample 1", "sample 2", "sample 3", "sample 4"],
                      binSize: 4
                    },
                    mark: "rect",
                    x: {
                      field: "start",
                      type: "genomic",
                      domain: { interval: [0, 1e9] },
                      linkingId: "7f94b74e-25ec-4e67-8c75-3dc0f1b0d6bd"
                    },
                    xe: { field: "end", type: "genomic" },
                    row: {
                      field: "sample",
                      type: "nominal",
                      legend: true
                    },
                    color: {
                      field: "peak",
                      type: "quantitative",
                      legend: true
                    },
                    tooltip: [
                      {
                        field: "start",
                        type: "genomic",
                        alt: "Start Position"
                      },
                      {
                        field: "end",
                        type: "genomic",
                        alt: "End Position"
                      },
                      {
                        field: "peak",
                        type: "quantitative",
                        alt: "Value",
                        format: ".2"
                      },
                      { field: "sample", type: "nominal", alt: "Sample" }
                    ],
                    width: 130,
                    height: 600
                  },
                  theme: {
                    base: "light",
                    root: {
                      background: "white",
                      titleColor: "black",
                      titleBackgroundColor: "transparent",
                      titleFontSize: 18,
                      titleFontFamily: "Arial",
                      titleAlign: "left",
                      titleFontWeight: "bold",
                      subtitleColor: "gray",
                      subtitleBackgroundColor: "transparent",
                      subtitleFontSize: 16,
                      subtitleFontFamily: "Arial",
                      subtitleFontWeight: "normal",
                      subtitleAlign: "left",
                      mousePositionColor: "#000000"
                    },
                    track: {
                      background: "transparent",
                      alternatingBackground: "transparent",
                      titleColor: "black",
                      titleBackground: "white",
                      titleFontSize: 24,
                      titleAlign: "left",
                      outline: "black",
                      outlineWidth: 1
                    },
                    legend: {
                      position: "top",
                      background: "white",
                      backgroundOpacity: 0.7,
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      backgroundStroke: "#DBDBDB",
                      tickColor: "black"
                    },
                    axis: {
                      tickColor: "black",
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      baselineColor: "black",
                      gridColor: "#E3E3E3",
                      gridStrokeWidth: 1,
                      gridStrokeType: "solid",
                      gridStrokeDash: [4, 4]
                    },
                    markCommon: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    point: {
                      color: "#E79F00",
                      size: 3,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rect: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    triangle: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    area: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    line: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    bar: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rule: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    link: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    text: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6],
                      textAnchor: "middle",
                      textFontWeight: "normal"
                    },
                    brush: {
                      color: "gray",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 0.3,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    }
                  }
                }
              }
            ]
          }
        ],
        center: [],
        right: [],
        bottom: [],
        gallery: [],
        whole: []
      },
      initialXDomain: [0, 1e9],
      initialYDomain: [0, 1e9],
      zoomFixed: false,
      zoomLimits: [1, null],
      uid: "154b1b40-f6fb-11eb-914b-976b6ecda162"
    }
  ],
  zoomLocks: { locksByViewUid: {}, locksDict: {} },
  locationLocks: { locksByViewUid: {}, locksDict: {} },
  editable: false,
  chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes"
};
const HIGLASS_AXIS_SIZE = 30;
const getViewTemplate = (assembly) => {
  return {
    genomePositionSearchBoxVisible: false,
    genomePositionSearchBox: {
      autocompleteServer: "https://higlass.io/api/v1",
      autocompleteId: getAutoCompleteId(assembly),
      chromInfoServer: "https://higlass.io/api/v1",
      chromInfoId: assembly != null ? assembly : "hg38"
    },
    layout: { w: 12, h: 12, x: 0, y: 0 },
    tracks: {
      top: [],
      left: [],
      center: [],
      right: [],
      bottom: [],
      gallery: [],
      whole: []
    },
    initialXDomain: [0, computeChromSizes(assembly).total],
    initialYDomain: [0, computeChromSizes(assembly).total],
    zoomFixed: false
  };
};
class HiGlassModel {
  constructor() {
    __publicField(this, "assembly");
    __publicField(this, "orientation");
    __publicField(this, "hg");
    this.assembly = "hg38";
    this.hg = {
      compactLayout: false,
      trackSourceServers: [],
      views: [],
      zoomLocks: {
        locksByViewUid: {},
        locksDict: {}
      },
      locationLocks: {
        locksByViewUid: {},
        locksDict: {}
      }
    };
    this.setEditable(false);
  }
  spec() {
    return this.hg;
  }
  setViewOrientation(orientation) {
    this.orientation = orientation;
    return this;
  }
  addDefaultView(uid, assembly) {
    this.hg.views.push(JSON.parse(JSON.stringify({ ...getViewTemplate(assembly), uid })));
    return this;
  }
  setAssembly(assembly) {
    this.assembly = assembly;
    this.setChromInfoPath(computeChromSizes(this.assembly).path);
    return this;
  }
  getAssembly() {
    return this.assembly;
  }
  setTextTrack(width, height, text, textColor = "black", fontSize = 14, fontWeight = "normal", align = "left", backgroundColor = "transparent", fontFamily = "Arial") {
    var _a;
    if (this.getLastView()) {
      (_a = this.getLastView().tracks.top) == null ? void 0 : _a.push({
        type: "text",
        width,
        height,
        options: {
          backgroundColor,
          textColor,
          fontSize,
          fontWeight,
          fontFamily,
          offsetY: 0,
          // offset from the top of the track
          align,
          text
        }
      });
    }
    return this;
  }
  /**
   * Add a dummy track to the last view
   * @param track
   */
  setDummyTrack(track) {
    var _a;
    if (this.getLastView()) {
      (_a = this.getLastView().tracks.top) == null ? void 0 : _a.push({
        type: "dummy-track",
        width: track.width,
        height: track.height,
        options: {
          width: track.width,
          height: track.height,
          title: track.title,
          ...track.style
        }
      });
    }
    return this;
  }
  addBrush(layout, viewId, theme, fromViewUid, style) {
    var _a, _b, _c, _d, _e, _f;
    if (!fromViewUid)
      return;
    (_f = this.getView(viewId)) == null ? void 0 : _f.tracks.whole.push({
      // type: 'viewport-projection-center',
      type: layout === "circular" ? "brush-track" : "viewport-projection-horizontal",
      uid: uuid(),
      fromViewUid,
      options: {
        projectionFillColor: (_a = style == null ? void 0 : style.color) != null ? _a : theme.brush.color,
        projectionStrokeColor: (_b = style == null ? void 0 : style.stroke) != null ? _b : theme.brush.stroke,
        projectionFillOpacity: (_c = style == null ? void 0 : style.opacity) != null ? _c : theme.brush.opacity,
        projectionStrokeOpacity: (_d = style == null ? void 0 : style.opacity) != null ? _d : theme.brush.opacity,
        strokeWidth: (_e = style == null ? void 0 : style.strokeWidth) != null ? _e : theme.brush.strokeWidth,
        startAngle: style == null ? void 0 : style.startAngle,
        endAngle: style == null ? void 0 : style.endAngle,
        innerRadius: style == null ? void 0 : style.innerRadius,
        outerRadius: style == null ? void 0 : style.outerRadius
      }
    });
    return this;
  }
  getLastView() {
    return this.hg.views[this.hg.views.length - 1];
  }
  getMainTrackPosition() {
    return this.orientation === "vertical" ? "left" : "center";
  }
  /**
   * Get the last view that renders any visualization, so skiping empty tracks.
   */
  getLastVisView() {
    const vs = this.hg.views.filter((v) => {
      var _a, _b;
      return ((_b = (_a = v.tracks[this.getMainTrackPosition()]) == null ? void 0 : _a[0]) == null ? void 0 : _b.type) === "combined";
    });
    return vs[vs.length - 1];
  }
  getView(viewId) {
    return this.hg.views.find((d) => d.uid === viewId);
  }
  validateSpec(silence = false) {
    return validateSpec(HiGlassSchema, this.spec(), silence).state === "success";
  }
  setDomain(xDomain, yDomain) {
    if (xDomain) {
      this.getLastView().initialXDomain = getNumericDomain(xDomain, this.getAssembly());
    }
    if (yDomain) {
      this.getLastView().initialYDomain = getNumericDomain(yDomain, this.getAssembly());
    }
    return this;
  }
  /**
   * This is a hacky function that adjust x domain to properly show vertical tracks.
   *
   * In HiGlass, the range of vertical tracks is affected by a center track. For example, if a center track is small, the vertical tracks become small as well.
   * Currently, the actual size of center track for vertical gosling tracks is `1px`. So, we re-scale the x domain so that gosling's vertical tracks properly use the entire height of a view.
   * @param orientation
   * @param width
   * @returns
   */
  adjustDomain(orientation = "horizontal", width, height) {
    if (orientation !== "vertical") {
      return this;
    }
    const domain = this.getLastView().initialXDomain;
    if (!domain) {
      return this;
    }
    const [start, end] = domain;
    const size = end - start;
    const center = (start + end) / 2;
    this.getLastView().initialXDomain = [
      center - size / width / 2 / height * width,
      center + size / width / 2 / height * width
    ];
    return this;
  }
  /**
   * Allow a zoom interaction?
   */
  setZoomFixed(zoomFixed) {
    this.getLastView().zoomFixed = zoomFixed;
    return this;
  }
  /**
   * Set limits of zoom levels in base pairs.
   */
  setZoomLimits(zoomLimits) {
    this.getLastView().zoomLimits = zoomLimits;
    return this;
  }
  setLayout(layout) {
    this.getLastView().layout = layout;
    return this;
  }
  setEditable(editable) {
    this.hg.editable = editable;
    return this;
  }
  setChromInfoPath(chromInfoPath) {
    if (this.getLastView()) {
      this.getLastView().chromInfoPath = chromInfoPath;
    }
    this.hg.chromInfoPath = chromInfoPath;
    return this;
  }
  addTrackSourceServers(trackSourceServers) {
    var _a, _b;
    if (trackSourceServers && ((_a = this.hg.trackSourceServers) == null ? void 0 : _a.indexOf(trackSourceServers)) === -1)
      (_b = this.hg.trackSourceServers) == null ? void 0 : _b.push(trackSourceServers);
    return this;
  }
  setMainTrack(track) {
    var _a;
    if (!this.getLastView())
      return this;
    this.getLastView().tracks[this.getMainTrackPosition()] = [
      {
        type: "combined",
        uid: `${(_a = track.uid) != null ? _a : uuid()}-${this.getMainTrackPosition()}-combined`,
        // !! Hacky, but it is important to subtract 1px. Currently, HiGlass does not well handle a case where a center track is zero width (e.g., linking between views that contain zero-width center tracks).
        // https://github.com/higlass/higlass/pull/1041
        width: track.width - 1,
        height: track.height,
        contents: [track]
      }
    ];
    return this;
  }
  addTrackToCombined(track) {
    var _a;
    if (!this.getLastVisView())
      return this;
    (_a = this.getLastVisView().tracks[this.getMainTrackPosition()][0]) == null ? void 0 : _a.contents.push(track);
    return this;
  }
  setAxisTrack(position, type2 = "regular", options) {
    if (!this.hg.views)
      return this;
    const widthOrHeight = position === "left" || position === "right" ? "width" : "height";
    const axisTrackTemplate = {
      // uid: options.id ?? uuid(), // TODO: turning this on makes some tick labels hidden
      type: "axis-track",
      chromInfoPath: this.hg.chromInfoPath,
      options: {
        ...options,
        assembly: this.getAssembly(),
        stroke: "transparent",
        // text outline
        color: options.theme.axis.labelColor,
        fontSize: options.theme.axis.labelFontSize,
        fontFamily: options.theme.axis.labelFontFamily,
        fontWeight: options.theme.axis.labelFontWeight,
        tickColor: options.theme.axis.tickColor,
        tickFormat: type2 === "narrower" ? "si" : "plain",
        tickPositions: type2 === "regular" ? "even" : "ends",
        reverseOrientation: position === "bottom" || position === "right" ? true : false
      }
    };
    if (options.layout === "circular") {
      this.addTrackToCombined({
        ...axisTrackTemplate,
        options: { ...axisTrackTemplate.options, layout: "circular" }
      });
    } else {
      const axisTrack = { ...axisTrackTemplate, [widthOrHeight]: HIGLASS_AXIS_SIZE };
      if (position === "left") {
        if (this.getLastView().tracks.left.filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks.left = insertItemToArray(this.getLastView().tracks.left, 0, axisTrack);
      } else if (position === "right") {
        if (this.getLastView().tracks.right.filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks.right.push(axisTrack);
      } else {
        if (this.getLastView().tracks[position].filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks[position].push(axisTrack);
      }
    }
    return this;
  }
  setExampleHiglassViewConfig() {
    this.hg = example;
  }
}
function logicalComparison(value, op, ref2, transitionPadding) {
  const padding = transitionPadding && transitionPadding !== 0 ? transitionPadding : void 0;
  let alpha = 0;
  switch (op) {
    case "less-than":
    case "LT":
    case "lt":
      alpha = ref2 > value ? padding ? (ref2 - value) / padding : 1 : 0;
      break;
    case "less-than-or-equal-to":
    case "LTET":
    case "ltet":
      alpha = ref2 >= value ? padding ? (ref2 - value) / padding : 1 : 0;
      break;
    case "greater-than":
    case "GT":
    case "gt":
      alpha = ref2 < value ? padding ? (value - ref2) / padding : 1 : 0;
      break;
    case "greater-than-or-equal-to":
    case "GTET":
    case "gtet":
      alpha = ref2 <= value ? padding ? (value - ref2) / padding : 1 : 0;
      break;
  }
  return Math.max(Math.min(1, alpha), 0);
}
const CHANNEL_DEFAULTS = {
  // https://mikemol.github.io/technique/colorblind/2018/02/11/color-safe-palette.html
  NOMINAL_COLOR: [
    "#E79F00",
    "#029F73",
    "#0072B2",
    "#CB7AA7",
    "#D45E00",
    "#57B4E9",
    "#EFE441"
    /*'#000000'*/
  ],
  // https://colorcet.holoviz.org/user_guide/Categorical.html
  NOMINAL_COLOR_EXTENDED: [
    "#d60000",
    "#018700",
    "#b500ff",
    "#05acc6",
    "#97ff00",
    "#ffa52f",
    "#ff8ec8",
    "#79525e",
    "#00fdcf",
    "#afa5ff",
    "#93ac83",
    "#9a6900",
    "#366962",
    "#d3008c",
    "#fdf490",
    "#c86e66",
    "#9ee2ff",
    "#00c846",
    "#a877ac",
    "#b8ba01",
    "#f4bfb1",
    "#ff28fd",
    "#f2cdff",
    "#009e7c",
    "#ff6200",
    "#56642a",
    "#953f1f",
    "#90318e",
    "#ff3464",
    "#a0e491",
    "#8c9ab1",
    "#829026",
    "#ae083f",
    "#77c6ba",
    "#bc9157",
    "#e48eff",
    "#72b8ff",
    "#c6a5c1",
    "#ff9070",
    "#d3c37c",
    "#bceddb",
    "#6b8567",
    "#916e56",
    "#f9ff00",
    "#bac1df",
    "#ac567c",
    "#ffcd03",
    "#ff49b1",
    "#c15603",
    "#5d8c90",
    "#c144bc",
    "#00753f",
    "#ba6efd",
    "#00d493",
    "#00ff75",
    "#49a150",
    "#cc9790",
    "#00ebed",
    "#db7e01",
    "#f77589",
    "#b89500",
    "#c84248",
    "#00cff9",
    "#755726",
    "#85d401",
    "#ebffd4",
    "#a77b87",
    "#db72c8",
    "#cae256",
    "#8abf5d",
    "#a1216b",
    "#855b89",
    "#89bacf",
    "#ffbad6",
    "#b6cfaa",
    "#97414d",
    "#67aa00",
    "#fde1b1",
    "#ff3628",
    "#80793d",
    "#d6e8ff",
    "#a795c6",
    "#7ea59a",
    "#d182a3",
    "#54823b",
    "#e6a872",
    "#9cffff",
    "#da5480",
    "#05b3aa",
    "#ffaaf6",
    "#d1afef",
    "#da015d",
    "#ac1a13",
    "#60b385",
    "#d442fd",
    "#acaa59",
    "#fb9ca7",
    "#b3723b",
    "#f26952",
    "#aed1d4",
    "#9affc3",
    "#dbb333",
    "#eb01c3",
    "#9900c4",
    "#cfff9e",
    "#a55949",
    "#3b6d01",
    "#008579",
    "#959167",
    "#89dbb3",
    "#6d7400",
    "#aa5dca",
    "#07ef00",
    "#804f3d",
    "#d88052",
    "#ffc862",
    "#b8009e",
    "#99acdd",
    "#904f00",
    "#8c4470",
    "#4f6e52",
    "#ff8734",
    "#c68ecd",
    "#d4e29e",
    "#b1826d",
    "#9cfb75",
    "#56dd77",
    "#f90087",
    "#a1cdff",
    "#13cad1",
    "#118e54",
    "#d154a5",
    "#00dfc3",
    "#a3832f",
    "#77975b",
    "#baaa80",
    "#70a3af",
    "#d6fbff",
    "#e8013a",
    "#d84621",
    "#ff82ed",
    "#b63862",
    "#b6cd72",
    "#97626b",
    "#897490",
    "#00a316",
    "#00f4a1",
    "#bf90f2",
    "#89e4d8",
    "#a34d95",
    "#6e5d00",
    "#8cc68e",
    "#95aa2a",
    "#c672dd",
    "#b33b01",
    "#d69a36",
    "#dfacb6",
    "#009aa0",
    "#599000",
    "#97bca8",
    "#ac8ca8",
    "#dad4ff",
    "#547c72",
    "#00ba69",
    "#ffc38e",
    "#b800d4",
    "#dfcf5b",
    "#629a7b",
    "#bfedbc",
    "#c1bdfd",
    "#80d3dd",
    "#e2857e",
    "#f9eb4d",
    "#bf6d82",
    "#caff4f",
    "#ef72aa",
    "#ed67ff",
    "#9946ae",
    "#6d6942",
    "#e25660",
    "#dd662d",
    "#9cdb5d",
    "#e29ccf",
    "#b87500",
    "#c6002d",
    "#dfbcda",
    "#59b5df",
    "#ff59da",
    "#38c1a1",
    "#9e698c",
    "#acaac8",
    "#95622f",
    "#b55662",
    "#2b7e60",
    "#b1e400",
    "#eda590",
    "#95fde2",
    "#ff548e",
    "#bd6ea1",
    "#aa3b36",
    "#d8cf00",
    "#aa80cd",
    "#a08052",
    "#e100e8",
    "#c35b3d",
    "#b53a85",
    "#8c7700",
    "#dbbc95",
    "#529e93",
    "#afbc82",
    "#91b5b6",
    "#a75423",
    "#ffd4ef",
    "#79ae6b",
    "#5db54b",
    "#80fb9a",
    "#48ffef",
    "#979548",
    "#9387a7",
    "#31d400",
    "#6ee956",
    "#b6d4eb",
    "#705470",
    "#f2db8a",
    "#aad4c1",
    "#7ecdf2",
    "#89ba00",
    "#64b6ba",
    "#ffb500",
    "#c38285",
    "#caaa5e",
    "#647748",
    "#59e2ff",
    "#df4dcd",
    "#e9ff79",
    "#bc66b8",
    "#c395a5",
    "#64c674",
    "#d19570",
    "#70cf4f",
    "#aa6e66",
    "#9c60a5",
    "#00b800",
    "#e299b3",
    "#bc006b",
    "#b3e8ef",
    "#cdbfe4",
    "#77a342",
    "#856277",
    "#568e5b",
    "#9eafc4",
    "#e82fa0",
    "#247c2a",
    "#826723",
    "#bfbc4d",
    "#ddd3a5"
  ],
  QUANTITATIVE_COLOR: "viridis",
  SIZE: 3,
  SIZE_RANGE: [2, 6]
};
function getTheme(theme = "light") {
  if (typeof theme === "string") {
    if (gt.isThereTheme(theme)) {
      return gt.getTheme(theme);
    } else if (theme === "dark" || theme === "light") {
      return THEMES[theme];
    } else {
      return THEMES["light"];
    }
  } else {
    let baseSpec = JSON.parse(JSON.stringify(THEMES["light"]));
    if (gt.isThereTheme(theme.base)) {
      baseSpec = gt.getTheme(theme.base);
    } else if (theme.base === "light" || theme.base === "dark") {
      baseSpec = JSON.parse(JSON.stringify(THEMES[theme.base]));
    }
    Object.keys(baseSpec).forEach((k) => {
      if (theme[k] && k !== "base") {
        baseSpec[k] = Object.assign(
          JSON.parse(JSON.stringify(baseSpec[k])),
          JSON.parse(JSON.stringify(theme[k]))
        );
      }
    });
    return baseSpec;
  }
}
const LightThemeMarkCommonStyle = {
  color: CHANNEL_DEFAULTS.NOMINAL_COLOR[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: CHANNEL_DEFAULTS.NOMINAL_COLOR,
  quantitativeSizeRange: [2, 6]
};
const DarkThemeMarkCommonStyle = { ...LightThemeMarkCommonStyle, stroke: "white" };
const THEMES = {
  light: {
    base: "light",
    root: {
      background: "white",
      titleColor: "black",
      titleBackgroundColor: "transparent",
      titleFontSize: 18,
      titleFontFamily: "Arial",
      titleAlign: "left",
      titleFontWeight: "bold",
      subtitleColor: "gray",
      subtitleBackgroundColor: "transparent",
      subtitleFontSize: 16,
      subtitleFontFamily: "Arial",
      subtitleFontWeight: "normal",
      subtitleAlign: "left",
      showMousePosition: true,
      mousePositionColor: "#000000"
    },
    track: {
      background: "transparent",
      alternatingBackground: "transparent",
      titleColor: "black",
      titleBackground: "white",
      titleFontSize: 24,
      titleAlign: "left",
      outline: "black",
      outlineWidth: 1
    },
    legend: {
      position: "top",
      background: "white",
      backgroundOpacity: 0.7,
      labelColor: "black",
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      backgroundStroke: "#DBDBDB",
      tickColor: "black"
    },
    axis: {
      tickColor: "black",
      labelColor: "black",
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      baselineColor: "black",
      gridColor: "#E3E3E3",
      gridStrokeWidth: 1,
      gridStrokeType: "solid",
      gridStrokeDash: [4, 4]
    },
    markCommon: {
      ...LightThemeMarkCommonStyle
    },
    point: {
      ...LightThemeMarkCommonStyle,
      size: 3
    },
    rect: {
      ...LightThemeMarkCommonStyle
    },
    triangle: {
      ...LightThemeMarkCommonStyle
    },
    area: {
      ...LightThemeMarkCommonStyle
    },
    line: {
      ...LightThemeMarkCommonStyle
    },
    bar: {
      ...LightThemeMarkCommonStyle
    },
    rule: {
      ...LightThemeMarkCommonStyle,
      strokeWidth: 1
    },
    link: {
      ...LightThemeMarkCommonStyle,
      strokeWidth: 1
    },
    text: {
      ...LightThemeMarkCommonStyle,
      textAnchor: "middle",
      textFontWeight: "normal"
    },
    brush: {
      ...LightThemeMarkCommonStyle,
      color: "gray",
      opacity: 0.3,
      stroke: "black",
      strokeWidth: 1
    }
  },
  dark: {
    base: "dark",
    root: {
      background: "black",
      titleColor: "white",
      titleBackgroundColor: "transparent",
      titleFontSize: 18,
      titleFontFamily: "Arial",
      titleAlign: "middle",
      titleFontWeight: "bold",
      subtitleColor: "lightgray",
      subtitleBackgroundColor: "transparent",
      subtitleFontSize: 16,
      subtitleFontFamily: "Arial",
      subtitleAlign: "middle",
      subtitleFontWeight: "normal",
      showMousePosition: true,
      mousePositionColor: "#FFFFFF"
    },
    track: {
      background: "transparent",
      alternatingBackground: "transparent",
      titleColor: "white",
      titleBackground: "black",
      titleFontSize: 18,
      titleAlign: "left",
      outline: "white",
      outlineWidth: 1
    },
    legend: {
      position: "right",
      background: "black",
      backgroundOpacity: 0.7,
      labelColor: "white",
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      backgroundStroke: "#DBDBDB",
      tickColor: "white"
    },
    axis: {
      tickColor: "white",
      labelColor: "white",
      labelFontSize: 10,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      baselineColor: "white",
      gridColor: "gray",
      gridStrokeWidth: 1,
      gridStrokeType: "solid",
      gridStrokeDash: [4, 4]
    },
    markCommon: {
      ...DarkThemeMarkCommonStyle
    },
    point: {
      ...DarkThemeMarkCommonStyle,
      size: 3
    },
    rect: {
      ...DarkThemeMarkCommonStyle
    },
    triangle: {
      ...DarkThemeMarkCommonStyle
    },
    area: {
      ...DarkThemeMarkCommonStyle
    },
    line: {
      ...DarkThemeMarkCommonStyle
    },
    bar: {
      ...DarkThemeMarkCommonStyle
    },
    rule: {
      ...DarkThemeMarkCommonStyle,
      strokeWidth: 1
    },
    link: {
      ...DarkThemeMarkCommonStyle,
      strokeWidth: 1
    },
    text: {
      ...DarkThemeMarkCommonStyle,
      textAnchor: "middle",
      textFontWeight: "normal"
    },
    brush: {
      ...DarkThemeMarkCommonStyle,
      color: "lightgray",
      opacity: 0.3,
      stroke: "white",
      strokeWidth: 1
    }
  }
};
class GoslingTrackModel {
  constructor(spec, data2, theme) {
    __publicField(this, "id");
    __publicField(this, "theme");
    /* spec */
    __publicField(this, "specOriginal");
    // original spec of users
    __publicField(this, "specComplete");
    // processed spec, being used in visualizations
    /* data */
    __publicField(this, "dataOriginal");
    __publicField(this, "dataAggregated");
    /* channel scales */
    __publicField(this, "channelScales");
    /* mouse events */
    __publicField(this, "mouseEventModel");
    this.id = uuid();
    this.theme = theme != null ? theme : getTheme();
    this.dataOriginal = JSON.parse(JSON.stringify(data2));
    this.dataAggregated = JSON.parse(JSON.stringify(data2));
    this.specOriginal = JSON.parse(JSON.stringify(spec));
    this.specComplete = JSON.parse(JSON.stringify(spec));
    this.channelScales = {};
    this.mouseEventModel = new MouseEventModel();
    const validity = this.validateSpec();
    if (!validity.valid) {
      console.warn("Gosling specification is not valid!", validity.errorMessages);
      return;
    }
    this.generateCompleteSpec(this.specComplete);
    this.flipRanges(this.specComplete);
    this.generateScales();
    this.dataAggregated = aggregateData(this.spec(), this.dataAggregated);
  }
  getId() {
    return this.id;
  }
  originalSpec() {
    return this.specOriginal;
  }
  spec() {
    return this.specComplete;
  }
  data() {
    return this.dataAggregated;
  }
  getMouseEventModel() {
    return this.mouseEventModel;
  }
  /**
   * Fill the missing options with default values or with the values calculated based on the data.
   */
  generateCompleteSpec(spec) {
    if (!spec.width || !spec.height) {
      console.warn("Size of track is not determined yet.");
      return;
    }
    if (spec.orientation === "vertical") {
      const width = spec.width;
      spec.width = spec.height;
      spec.height = width;
    }
    const xOrY = this.getGenomicChannelKey();
    let isAxisShown = false;
    if (xOrY === "x") {
      isAxisShown = IsChannelDeep(spec.x) && spec.x.axis !== void 0 && spec.x.axis !== "none";
    }
    if (xOrY === "y") {
      isAxisShown = IsChannelDeep(spec.y) && spec.y.axis !== void 0 && spec.y.axis !== "none";
    }
    if (spec.layout !== "circular") {
      if (IsChannelDeep(spec.x) && spec.x.axis !== void 0 && spec.x.axis !== "none") {
        spec.height -= HIGLASS_AXIS_SIZE;
      }
    } else {
      if (xOrY === "x" && isAxisShown && IsChannelDeep(spec.x) && spec.x.axis === "top") {
        spec["outerRadius"] = spec["outerRadius"] - HIGLASS_AXIS_SIZE;
      } else if (xOrY === "x" && isAxisShown && IsChannelDeep(spec.x) && spec.x.axis === "bottom") {
        spec["innerRadius"] = spec["innerRadius"] + HIGLASS_AXIS_SIZE;
      }
    }
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      const channel = spec[channelKey];
      if (IsChannelDeep(channel) && !("zeroBaseline" in channel) && channel.type === "quantitative") {
        channel.zeroBaseline = true;
      }
    });
    this.addScaleMaterials(spec);
  }
  /**
   * TODO: This is experimental. For bar charts, for example, additional care should be taken to correctly flip the visual marks.
   * Flip the y scales when `flip` options is used.
   */
  flipRanges(spec) {
    if (IsChannelDeep(spec.y) && spec.y.flip && Array.isArray(spec.y.range)) {
      spec.y.range = spec.y.range.reverse();
    }
  }
  /**
   * Find an axis channel that is encoded with genomic coordinate and return the key (e.g., 'x').
   * `undefined` if not found.
   */
  getGenomicChannelKey() {
    return getGenomicChannelKeyFromTrack(this.spec());
  }
  /**
   * Find a genomic field from the track specification.
   * `undefined` if not found.
   */
  getGenomicChannel() {
    return getGenomicChannelFromTrack(this.spec());
  }
  /**
   * Replace a domain with a new one in the complete spec(s) if the original spec does not define the domain.
   * A domain is replaced only when the channel is bound with data (i.e., `ChannelDeep`).
   */
  setChannelDomain(channelKey, domain, force) {
    const channelRaw = this.originalSpec()[channelKey];
    if (!force && IsChannelDeep(channelRaw) && channelRaw.domain !== void 0) {
      return;
    }
    const channel = this.specComplete[channelKey];
    if (IsChannelDeep(channel)) {
      channel.domain = domain;
    }
  }
  /**
   * Update default constant values by looking up other channels' scales.
   */
  updateChannelValue() {
    if (this.originalSpec().y === void 0) {
      const y = this.spec().y;
      const rowCategories = this.getChannelDomainArray("row");
      if (y && IsChannelValue(y) && rowCategories && this.spec().mark !== "withinLink") {
        y.value = this.spec().height / rowCategories.length / 2;
      }
    }
  }
  /**
   * Get the encoded value using the scales already constructed.
   */
  encodedValue(channelKey, value) {
    var _a;
    if (channelKey === "text" && value !== void 0) {
      return `${+value ? ~~value : value}`;
    }
    const channel = this.spec()[channelKey];
    const channelFieldType = IsChannelDeep(channel) ? channel.type : IsChannelValue(channel) ? "constant" : void 0;
    if (!channelFieldType) {
      return void 0;
    }
    if (channelFieldType === "constant") {
      return this.channelScales[channelKey]();
    }
    if (value === void 0) {
      return void 0;
    }
    if (value === null) {
      if (channelFieldType === "quantitative") {
        value = 0;
      } else if (channelFieldType === "nominal") {
        value = "null";
      }
    }
    if (typeof this.channelScales[channelKey] !== "function") {
      return void 0;
    }
    switch (channelKey) {
      case "x":
      case "y":
      case "x1":
      case "y1":
      case "xe":
      case "ye":
      case "x1e":
        if (channelFieldType === "quantitative" || channelFieldType === "genomic") {
          return this.channelScales[channelKey](value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "stroke":
      case "color":
        if (channelFieldType === "quantitative") {
          const s = this.channelScales[channelKey].copy();
          const d = s.domain();
          const e = d[1] - d[0];
          const so = Array.from((_a = channel.scaleOffset) != null ? _a : [0, 1]);
          return s.domain([d[0] + e * so.sort()[0], d[0] + e * so.sort()[1]])(value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "size":
        if (channelFieldType === "quantitative") {
          return this.channelScales[channelKey](value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "row":
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "strokeWidth":
      case "opacity":
        if (channelFieldType === "quantitative") {
          return this.channelScales[channelKey](value);
        }
        break;
      default:
        console.warn(`${channelKey} is not supported for encoding values, so returning a undefined value`);
        return void 0;
    }
  }
  trackVisibility(currentStage) {
    const spec = this.spec();
    if (!spec.visibility || spec.visibility.length === 0 || spec.visibility.filter((d) => d.target === "track").length === 0) {
      return true;
    }
    let visibility = true;
    spec.visibility.filter((d) => d.target === "track").forEach((d) => {
      const { operation, measure, threshold } = d;
      let compareValue;
      if (measure === "zoomLevel") {
        compareValue = currentStage[measure];
      } else {
        compareValue = spec[measure];
      }
      if (compareValue !== void 0) {
        visibility = visibility && logicalComparison(compareValue, operation, threshold) === 1;
      }
    });
    return visibility;
  }
  /**
   * Check whether the visual mark should be visible or not.
   * Return 0 (invisible) only when the predefined condition is correct.
   */
  markVisibility(datum, metrics) {
    const spec = this.spec();
    if (!spec.visibility || spec.visibility.length === 0 || spec.visibility.filter((d) => d.target === "mark").length === 0) {
      return 1;
    }
    let visibility = 1;
    spec.visibility.filter((d) => d.target === "mark").forEach((d) => {
      const { operation, threshold, conditionPadding, transitionPadding, measure } = d;
      const padding = conditionPadding != null ? conditionPadding : 0;
      const mark = spec.mark;
      let newVisibility = 1;
      if (mark === "text" && threshold === "|xe-x|" && measure === "width") {
        const xe = this.encodedPIXIProperty("xe", datum);
        const x = this.encodedPIXIProperty("x", datum);
        if (xe !== void 0 && (metrics == null ? void 0 : metrics.width)) {
          newVisibility = logicalComparison(
            metrics.width + padding,
            operation,
            Math.abs(xe - x),
            transitionPadding
          );
        }
      } else if (measure === "width" && typeof threshold === "number" && (metrics == null ? void 0 : metrics.width)) {
        newVisibility = logicalComparison(metrics.width + padding, operation, threshold, transitionPadding);
      } else if (measure === "zoomLevel" && typeof threshold === "number" && (metrics == null ? void 0 : metrics.zoomLevel)) {
        newVisibility = logicalComparison(metrics.zoomLevel, operation, threshold, transitionPadding);
      }
      if (visibility > newVisibility) {
        visibility = newVisibility;
      }
    });
    return visibility;
  }
  /**
   *
   */
  visualPropertyByChannel(channelKey, datum) {
    const value = datum !== void 0 ? getValueUsingChannel(datum, this.spec()[channelKey]) : void 0;
    return this.encodedValue(channelKey, value);
  }
  /**
   * Retrieve an encoded visual property of a visual mark.
   */
  encodedPIXIProperty(propertyKey, datum, additionalInfo) {
    const mark = this.spec().mark;
    if ([
      "text",
      "color",
      "row",
      "stroke",
      "opacity",
      "strokeWidth",
      "x",
      "y",
      "xe",
      "x1",
      "x1e",
      "ye",
      "size"
    ].includes(propertyKey)) {
      return this.visualPropertyByChannel(propertyKey, datum);
    }
    switch (mark) {
      case "bar":
        return barProperty(this, propertyKey, datum, additionalInfo);
      case "point":
      case "text":
        return pointProperty(this, propertyKey, datum);
      case "rect":
        return rectProperty(this, propertyKey, datum, additionalInfo);
      default:
        return void 0;
    }
  }
  // TODO: better organize this, perhaps, by combining several if statements
  /**
   * Set missing `range`, `domain`, and/or `value` of each channel by looking into data.
   */
  addScaleMaterials(spec) {
    const data2 = this.data();
    const genomicChannel = this.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    if (typeof spec.width === "undefined" || typeof spec.height === "undefined") {
      console.warn("Track size is not determined yet");
      return;
    }
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      var _a, _b, _c, _d;
      const channel = spec[channelKey];
      if (IsStackedChannel(spec, channelKey) && IsChannelDeep(channel)) {
        const pivotedData = group(data2, (d) => d[genomicChannel.field]);
        const xKeys = [...pivotedData.keys()];
        if (!channel.domain) {
          const min$1 = "zeroBaseline" in channel && channel.zeroBaseline ? 0 : min(
            xKeys.map(
              (d) => sum(
                pivotedData.get(d).map(
                  (_d2) => channel.field ? _d2[channel.field] : void 0
                )
              )
            )
          );
          const max$1 = max(
            xKeys.map(
              (d) => sum(
                pivotedData.get(d).map(
                  (_d2) => channel.field ? _d2[channel.field] : void 0
                )
              )
            )
          );
          channel.domain = [min$1, max$1];
        }
        if (!channel.range) {
          const rowChannel = spec.row;
          const rowField = IsChannelDeep(rowChannel) ? rowChannel.field : void 0;
          const rowCategories = (_a = this.getChannelDomainArray("row")) != null ? _a : rowField ? Array.from(new Set(data2.map((d) => d[rowField]))) : [1];
          const rowHeight = spec.height / rowCategories.length;
          switch (channelKey) {
            case "x":
              channel.range = [0, spec.width];
              break;
            case "y":
              channel.range = [0, rowHeight];
              break;
          }
        }
      } else {
        const rowChannel = spec.row;
        const rowField = IsChannelDeep(rowChannel) ? rowChannel.field : void 0;
        const rowCategories = (_b = this.getChannelDomainArray("row")) != null ? _b : rowField ? Array.from(new Set(data2.map((d) => d[rowField]))) : [1];
        const rowHeight = spec.height / rowCategories.length;
        if (!channel) {
          let value;
          switch (channelKey) {
            case "x":
              value = spec.width / 2;
              break;
            case "y":
              if (spec.mark === "withinLink")
                value = rowHeight;
              else
                value = rowHeight / 2;
              break;
            case "size":
              if (spec.mark === "line")
                value = this.theme.line.size;
              else if (spec.mark === "bar")
                value = void 0;
              else if (spec.mark === "rect")
                value = void 0;
              else if (spec.mark === "triangleRight")
                value = void 0;
              else if (spec.mark === "triangleLeft")
                value = void 0;
              else if (spec.mark === "triangleBottom")
                value = void 0;
              else if (spec.stretch && spec.mark === "point" && IsChannelDeep(spec.x) && IsChannelDeep(spec.xe))
                value = void 0;
              else if (spec.mark === "text")
                value = 12;
              else
                value = this.theme.point.size;
              break;
            case "color":
              value = this.theme.markCommon.color;
              break;
            case "row":
              value = 0;
              break;
            case "stroke":
              if (spec.mark === "text")
                value = this.theme.text.stroke;
              else
                value = this.theme.markCommon.stroke;
              break;
            case "strokeWidth":
              if (spec.mark === "rule")
                value = this.theme.rule.strokeWidth;
              else if (spec.mark === "withinLink" || spec.mark === "betweenLink")
                value = this.theme.link.strokeWidth;
              else if (spec.mark === "text")
                value = this.theme.text.strokeWidth;
              else
                value = this.theme.markCommon.strokeWidth;
              break;
            case "opacity":
              value = this.theme.markCommon.opacity;
              break;
            case "text":
              value = "";
              break;
          }
          if (typeof value !== "undefined") {
            spec[channelKey] = { value };
          }
        } else if (IsChannelDeep(channel) && (channel.type === "quantitative" || channel.type === "genomic")) {
          if (channel.domain === void 0) {
            const min$1 = "zeroBaseline" in channel && channel.zeroBaseline ? 0 : (_c = min(data2.map((d) => +d[channel.field]))) != null ? _c : 0;
            const max$1 = (_d = max(data2.map((d) => +d[channel.field]))) != null ? _d : 0;
            channel.domain = [min$1, max$1];
          } else if (channel.type === "genomic" && !IsDomainArray(channel.domain)) {
            channel.domain = getNumericDomain(channel.domain);
          }
          if ((channelKey === "color" || channelKey === "stroke") && channel.type === "quantitative" && !channel.scaleOffset) {
            channel.scaleOffset = [0, 1];
          }
          if (!channel.range) {
            let range;
            switch (channelKey) {
              case "x":
              case "xe":
              case "x1":
              case "x1e":
                range = [0, spec.width];
                break;
              case "y":
              case "ye":
                range = [0, rowHeight];
                break;
              case "color":
              case "stroke":
                range = CHANNEL_DEFAULTS.QUANTITATIVE_COLOR;
                break;
              case "size":
                range = this.theme.markCommon.quantitativeSizeRange;
                break;
              case "strokeWidth":
                range = [1, 3];
                break;
              case "opacity":
                range = [0, 1];
                break;
            }
            if (range) {
              channel.range = range;
            }
          }
        } else if (IsChannelDeep(channel) && channel.type === "nominal") {
          if (channel.domain === void 0) {
            channel.domain = Array.from(
              new Set(data2.map((d) => {
                var _a2;
                return (_a2 = d[channel.field]) != null ? _a2 : "null";
              }))
            );
          }
          if (!channel.range) {
            let startSize = 2;
            let range;
            switch (channelKey) {
              case "x":
              case "xe":
                range = [0, spec.width];
                break;
              case "y":
              case "ye":
                range = [rowHeight, 0];
                break;
              case "color":
              case "stroke":
                range = this.theme.markCommon.nominalColorRange;
                break;
              case "row":
                range = [0, spec.height];
                break;
              case "size":
                range = channel.domain.map(() => startSize++);
                break;
            }
            if (range) {
              channel.range = range;
            }
          }
        }
      }
    });
    [
      ["x", "xe"],
      ["y", "ye"]
    ].forEach((pair) => {
      const [k1, k2] = pair;
      const c1 = spec[k1], c2 = spec[k2];
      if (IsChannelDeep(c1) && IsChannelDeep(c2) && c1.type === c2.type && c1.domain && c2.domain && Array.isArray(c1.domain) && Array.isArray(c2.domain)) {
        if (c1.type === "genomic" || c1.type === "quantitative") {
          const min$1 = min([c1.domain[0], c2.domain[0]]);
          const max$1 = max([c1.domain[1], c2.domain[1]]);
          c1.domain = c2.domain = [min$1, max$1];
        } else if (c1.type === "nominal") {
          const range = Array.from(/* @__PURE__ */ new Set([...c1.domain, ...c2.domain]));
          c1.range = c2.range = range;
        }
      }
    });
  }
  /**
   * Store the scale of individual visual channels based on the `complete` spec.
   */
  generateScales() {
    const spec = this.spec();
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      const channel = spec[channelKey];
      if (IsChannelValue(channel)) {
        this.channelScales[channelKey] = () => channel.value;
      } else if (IsChannelDeep(channel)) {
        if (channelKey === "text") {
          return;
        }
        const domain = channel.domain;
        const range = channel.range;
        if (domain === void 0 || range === void 0) {
          return;
        }
        if (channel.type === "quantitative" || channel.type === "genomic") {
          switch (channelKey) {
            case "x":
            case "x1":
            case "xe":
            case "x1e":
            case "y":
            case "ye":
            case "size":
            case "opacity":
            case "strokeWidth":
              this.channelScales[channelKey] = scaleLinear().domain(domain).range(range);
              break;
            case "color":
            case "stroke":
              let interpolate = interpolateViridis;
              if (Object.keys(PREDEFINED_COLOR_STR_MAP).includes(range)) {
                interpolate = PREDEFINED_COLOR_STR_MAP[range];
              }
              this.channelScales[channelKey] = scaleSequential(interpolate).domain(
                domain
              );
              break;
          }
        } else if (channel.type === "nominal") {
          switch (channelKey) {
            case "x":
            case "xe":
            case "y":
            case "ye":
            case "row":
              this.channelScales[channelKey] = scaleBand().domain(domain).range(range);
              break;
            case "size":
              this.channelScales[channelKey] = scaleOrdinal().domain(domain).range(range);
              break;
            case "color":
            case "stroke":
              this.channelScales[channelKey] = scaleOrdinal(range).domain(domain);
              break;
          }
        }
      }
    });
  }
  /**
   * Return the scale of a visual channel.
   * `undefined` if we do not have the scale.
   */
  getChannelScale(channelKey) {
    return this.channelScales[channelKey];
  }
  /**
   * Set a new scale for a certain channel. Usually called to replace the scale of a genomic axis with the one that is generated by the HiGlass data fetcher.
   */
  setChannelScale(channelKey, scale) {
    this.channelScales[channelKey] = scale;
  }
  /**
   * Return whether to show y-axis.
   */
  isShowYAxis() {
    const spec = this.spec();
    const yDomain = this.getChannelDomainArray("y");
    const yRange = this.getChannelRangeArray("y");
    return IsChannelDeep(spec.y) && spec.y.axis !== "none" && spec.y.type === "quantitative" && !!yDomain && !!yRange;
  }
  /**
   * Return the domain of a visual channel.
   * `undefined` if we do not have domain in array.
   */
  getChannelDomainArray(channelKey) {
    const c = this.spec()[channelKey];
    return IsChannelDeep(c) && IsDomainArray(c.domain) ? c.domain : void 0;
  }
  /**
   * Return the range of a visual channel.
   * `undefined` if we do not have domain in array.
   */
  getChannelRangeArray(channelKey) {
    const c = this.spec()[channelKey];
    return IsChannelDeep(c) && IsRangeArray(c.range) ? c.range : void 0;
  }
  /**
   * Validate the original spec.
   */
  validateSpec() {
    return validateTrack(this.originalSpec());
  }
}
function publish(name2, data2) {
  PubSub$1.publish(name2, data2);
}
function subscribe(name2, callback) {
  PubSub$1.subscribe(name2, callback);
}
function unsubscribe(name2) {
  PubSub$1.unsubscribe(name2);
}
const DEFAULT_MOUSE_EVENT_STYLE = {
  stroke: "black",
  strokeWidth: 1,
  strokeOpacity: 1,
  color: "none",
  opacity: 1,
  arrange: "front"
};
function initProcessedTileInfo() {
  return { goslingModels: [], tabularData: [], skipRendering: false };
}
const config$1 = {
  type: "gosling-track",
  datatype: ["multivec", "epilogos"],
  orientation: "1d-horizontal",
  // @ts-expect-error missing default spec
  defaultOptions: {
    // TODO: Are any of these used?
    // labelPosition: 'none',
    // labelColor: 'black',
    // labelTextOpacity: 0.4,
    // trackBorderWidth: 0,
    // trackBorderColor: 'black',
    // backgroundColor: 'white',
    // barBorder: false,
    // sortLargestOnTop: true,
    // axisPositionHorizontal: 'left',
    theme: getTheme$1("light")
  }
};
const factory$1 = (HGC, context, options) => {
  var _assembly2, _processedTileInfo, _mouseDownX, _mouseDownY, _isRangeBrushActivated, _gBrush, _loadingTextStyleObj, _loadingTextBg, _loadingText, _tilesToId, tilesToId_fn, _binsPerTile, binsPerTile_get, _getResolvedTracks, getResolvedTracks_fn, _generateTabularData, generateTabularData_fn, _onMouseDown, onMouseDown_fn, _onMouseMove, onMouseMove_fn, _onMouseUp, onMouseUp_fn, _onMouseOut, onMouseOut_fn, _getElementsWithinMouse, getElementsWithinMouse_fn, _publishTrackEvents, publishTrackEvents_fn, _onRangeBrush, onRangeBrush_fn, _highlightMarks, highlightMarks_fn, _publishOnNewTrack, publishOnNewTrack_fn;
  const { tileProxy } = HGC.services;
  const { BarTrack } = HGC.tracks;
  const loadingTextStyle = getTextStyle({ color: "black", size: 12 });
  const _GoslingTrackClass = class _GoslingTrackClass extends BarTrack {
    /* *
     *
     *  Constructor
     *
     * */
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(context, options);
      __privateAdd(this, _binsPerTile);
      /**
       * Creates an array of SingleTracks if there are overlaid tracks
       */
      __privateAdd(this, _getResolvedTracks);
      /**
       * Construct tabular data from a higlass tileset and a gosling track model.
       */
      __privateAdd(this, _generateTabularData);
      /* *
       *
       *  Mouse methods
       *
       * */
      __privateAdd(this, _onMouseDown);
      __privateAdd(this, _onMouseMove);
      __privateAdd(this, _onMouseUp);
      __privateAdd(this, _onMouseOut);
      /**
       * From all tiles and overlaid tracks, collect element(s) that are withing a mouse position.
       */
      __privateAdd(this, _getElementsWithinMouse);
      /**
       * Call track events (e.g., `trackClick` or `trackMouseOver`) based on a mouse position and the track display area.
       */
      __privateAdd(this, _publishTrackEvents);
      __privateAdd(this, _onRangeBrush);
      /**
       * Highlight marks that are either mouse overed or selected.
       */
      __privateAdd(this, _highlightMarks);
      /**
       * Javscript subscription API methods (besides for mouse)
       */
      /**
       * Publishes track information. Triggered when track gets created
       */
      __privateAdd(this, _publishOnNewTrack);
      /* *
       *
       *  Properties
       *
       * */
      __publicField(this, "tileSize");
      __publicField(this, "mRangeBrush");
      __privateAdd(this, _assembly2, void 0);
      // Used to get the relative genomic position
      __privateAdd(this, _processedTileInfo, void 0);
      __publicField(this, "firstDraw", true);
      // False if draw has been called once already. Used with onNewTrack API. Public because used in draw()
      // Used in mark/legend.ts
      __publicField(this, "gLegend", HGC.libraries.d3Selection.select(context.svgElement).append("g"));
      __publicField(this, "displayedLegends", []);
      // Store the color legends added so far so that we can avoid overlaps and redundancy
      // Used in mark/text.ts
      __publicField(this, "textGraphics", []);
      __publicField(this, "textsBeingUsed", 0);
      // Mouse fields
      __publicField(this, "pMouseHover", new HGC.libraries.PIXI.Graphics());
      __publicField(this, "pMouseSelection", new HGC.libraries.PIXI.Graphics());
      __privateAdd(this, _mouseDownX, 0);
      __privateAdd(this, _mouseDownY, 0);
      __privateAdd(this, _isRangeBrushActivated, false);
      __privateAdd(this, _gBrush, HGC.libraries.d3Selection.select(context.svgElement).append("g"));
      __privateAdd(this, _loadingTextStyleObj, new HGC.libraries.PIXI.TextStyle(loadingTextStyle));
      __privateAdd(this, _loadingTextBg, new HGC.libraries.PIXI.Graphics());
      __privateAdd(this, _loadingText, new HGC.libraries.PIXI.Text("", loadingTextStyle));
      __publicField(this, "prevVisibleAndFetchedTiles");
      __publicField(this, "hideMousePosition");
      context.dataFetcher.track = this;
      __privateSet(this, _processedTileInfo, {});
      __privateSet(this, _assembly2, this.options.spec.assembly);
      if ("overlay" in this.options.spec) {
        this.options.spec.overlay = this.options.spec._overlay.map((o) => {
          return { ...o, _renderingId: uuid() };
        });
      } else {
        this.options.spec._renderingId = uuid();
      }
      this.fetchedTiles = {};
      this.tileSize = (_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024;
      const { valid, errorMessages } = validateTrack(this.options.spec);
      if (!valid) {
        console.warn("The specification of the following track is invalid", errorMessages, this.options.spec);
      }
      this.pMain.addChild(this.pMouseHover);
      this.pMain.addChild(this.pMouseSelection);
      this.pMask.interactive = true;
      this.mRangeBrush = new LinearBrushModel(__privateGet(this, _gBrush), HGC.libraries, (_c = this.options.spec.style) == null ? void 0 : _c.brush);
      this.mRangeBrush.on("brush", __privateMethod(this, _onRangeBrush, onRangeBrush_fn).bind(this));
      this.pMask.on("mousedown", (e) => {
        const { x, y } = e.data.getLocalPosition(this.pMain);
        __privateMethod(this, _onMouseDown, onMouseDown_fn).call(this, x, y, e.data.originalEvent.altKey);
      });
      this.pMask.on("mouseup", (e) => {
        const { x, y } = e.data.getLocalPosition(this.pMain);
        __privateMethod(this, _onMouseUp, onMouseUp_fn).call(this, x, y);
      });
      this.pMask.on("mousemove", (e) => {
        const { x } = e.data.getLocalPosition(this.pMain);
        __privateMethod(this, _onMouseMove, onMouseMove_fn).call(this, x);
      });
      this.pMask.on("mouseout", __privateMethod(this, _onMouseOut, onMouseOut_fn).bind(this));
      this.flipText = this.options.spec.orientation === "vertical";
      if (this.hideMousePosition) {
        this.hideMousePosition();
        this.hideMousePosition = void 0;
      }
      if (((_d = this.options) == null ? void 0 : _d.showMousePosition) && !this.hideMousePosition) {
        this.hideMousePosition = HGC.utils.showMousePosition(
          this,
          Is2DTrack(resolveSuperposedTracks(this.options.spec)[0]),
          this.isShowGlobalMousePosition()
        );
      }
      this.pLabel.removeChild(this.trackNotFoundText);
      __privateGet(this, _loadingText).anchor.x = 1;
      __privateGet(this, _loadingText).anchor.y = 1;
      this.pLabel.addChild(__privateGet(this, _loadingTextBg));
      this.pLabel.addChild(__privateGet(this, _loadingText));
      HGC.libraries.PIXI.GRAPHICS_CURVES.adaptive = (_f = (_e = this.options.spec.style) == null ? void 0 : _e.enableSmoothPath) != null ? _f : false;
      if (HGC.libraries.PIXI.GRAPHICS_CURVES.adaptive) {
        HGC.libraries.PIXI.GRAPHICS_CURVES.maxLength = 1;
        HGC.libraries.PIXI.GRAPHICS_CURVES.maxSegments = 2048 * 10;
      }
    }
    /* *
     *
     *  Rendering Cycle Methods
     *
     * */
    /**
     * Draw all tiles from the bottom. Called from TiledPixiTrack constructor, so all methods called must be
     * public. https://github.com/higlass/higlass/blob/387a03e877dcfa4c2cfeabc0869375b58c0b362d/app/scripts/TiledPixiTrack.js#L216
     * Overrides draw() in BarTrack.
     * This means some class properties can be still `undefined`.
     */
    draw() {
      var _a, _b;
      this.clearMouseEventData();
      this.textsBeingUsed = 0;
      (_a = this.pMouseHover) == null ? void 0 : _a.clear();
      const processTilesAndDraw = () => {
        const isBamDataFetcher = this.dataFetcher instanceof BamDataFetcher;
        this.processAllTiles(isBamDataFetcher);
        super.draw();
        this.prevVisibleAndFetchedTiles = this.visibleAndFetchedTiles();
      };
      if (isTabularDataFetcher(this.dataFetcher) && !isEqual(this.visibleAndFetchedTiles(), this.prevVisibleAndFetchedTiles)) {
        this.updateTileAsync(this.dataFetcher, processTilesAndDraw);
      } else {
        processTilesAndDraw();
      }
      (_b = this.mRangeBrush) == null ? void 0 : _b.drawBrush(true);
      if (this.firstDraw) {
        __privateMethod(this, _publishOnNewTrack, publishOnNewTrack_fn).call(this);
        this.firstDraw = false;
      }
    }
    /*
     * Do whatever is necessary before rendering a new tile. This function is called from `receivedTiles()`.
     * Overrides initTile in BarTrack
     * (Refer to https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/HorizontalLine1DPixiTrack.js#L50)
     */
    initTile(tile) {
      this.drawTile(tile);
    }
    updateTile() {
    }
    // Never mind about this function for the simplicity.
    renderTile() {
    }
    // Never mind about this function for the simplicity.
    /**
     * Display a tile upon receiving a new one or when explicitly called by a developer, e.g., calling
     * `this.draw()`. Overrides drawTile in BarTrack
     */
    drawTile(tile) {
      var _a, _b;
      tile.drawnAtScale = this._xScale.copy();
      const tileInfo = __privateGet(this, _processedTileInfo)[tile.tileId];
      if (!tileInfo) {
        return;
      }
      (_a = tile.graphics) == null ? void 0 : _a.clear();
      (_b = tile.graphics) == null ? void 0 : _b.removeChildren();
      this.pBackground.clear();
      this.pBackground.removeChildren();
      this.pBorder.clear();
      this.pBorder.removeChildren();
      this.displayedLegends = [];
      tileInfo.goslingModels.forEach((model) => {
        const trackWidth = this.dimensions[0];
        const zoomLevel = this._xScale.invert(trackWidth) - this._xScale.invert(0);
        if (!model.trackVisibility({ zoomLevel })) {
          return;
        }
        drawPreEmbellishment(HGC, this, tile, model, this.options.theme);
        drawMark(HGC, this, tile, model);
        drawPostEmbellishment(HGC, this, tile, model, this.options.theme);
      });
      this.forceDraw();
    }
    /**
     * Render this track again using a new option when a user changed the option. Overrides rerender in BarTrack.
     */
    rerender(newOptions) {
      this.options = newOptions;
      if (this.options.spec.layout === "circular") {
        this.mRangeBrush.remove();
      }
      this.clearMouseEventData();
      this.textsBeingUsed = 0;
      this.processAllTiles(true);
      this.draw();
      this.forceDraw();
    }
    /**
     * Clears MouseEventModel from each GoslingTrackModel. Must be a public method because it is called from draw()
     */
    clearMouseEventData() {
      this.visibleAndFetchedGoslingModels().forEach((model) => model.getMouseEventModel().clear());
    }
    /**
     * Collect all gosling models that correspond to the tiles that are both visible and fetched.
     */
    visibleAndFetchedGoslingModels() {
      return this.visibleAndFetchedTiles().flatMap(
        (tile) => {
          var _a, _b;
          return (_b = (_a = __privateGet(this, _processedTileInfo)[tile.tileId]) == null ? void 0 : _a.goslingModels) != null ? _b : [];
        }
      );
    }
    /**
     * End of the rendering cycle. This function is called when the track is removed entirely.
     */
    remove() {
      super.remove();
      if (this.gLegend) {
        this.gLegend.remove();
        this.gLegend = void 0;
      }
      this.mRangeBrush.remove();
    }
    /*
     * Rerender all tiles when track size is changed. Overrides method in TiledPixiTrack
     * (Refer to https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/PixiTrack.js#L186).
     */
    setDimensions(newDimensions) {
      super.setDimensions(newDimensions);
      this.mRangeBrush.setSize(newDimensions[1]);
    }
    /**
     * Record new position.
     */
    setPosition(newPosition) {
      super.setPosition(newPosition);
      [this.pMain.position.x, this.pMain.position.y] = this.position;
      this.mRangeBrush.setOffset(...newPosition);
    }
    /**
     * A function to redraw this track. Typically called when an asynchronous event occurs (i.e. tiles loaded)
     * (Refer to https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/TiledPixiTrack.js#L71)
     */
    forceDraw() {
      this.animate();
    }
    /**
     * Called when location or zoom level has been changed by click-and-drag interaction
     * (https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/HorizontalLine1DPixiTrack.js#L215)
     * For brushing, refer to https://github.com/higlass/higlass/blob/caf230b5ee41168ea491572618612ac0cc804e5a/app/scripts/HeatmapTiledPixiTrack.js#L1493
     */
    zoomed(newXScale, newYScale) {
      const range = this.mRangeBrush.getRange();
      this.mRangeBrush.updateRange(
        range ? [newXScale(this._xScale.invert(range[0])), newXScale(this._xScale.invert(range[1]))] : null
      );
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.refreshTiles();
      this.draw();
      this.forceDraw();
      const genomicRange = newXScale.domain().map((absPos) => getRelativeGenomicPosition(absPos, __privateGet(this, _assembly2), true));
      publish("location", {
        id: context.viewUid,
        genomicRange
      });
    }
    /* *
     *
     *  Tile and data processing methods
     *
     * */
    /**
     * Gets all tiles and generates tabular data and GoslingTrackModels for each tile. Called by this.draw(), so
     * this method must be public.
     * @param force if true then tabular data gets regenerated
     */
    processAllTiles(force = false) {
      var _a, _b;
      this.tileSize = (_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024;
      const tiles = this.visibleAndFetchedTiles();
      tiles.forEach((tile) => __privateMethod(this, _generateTabularData, generateTabularData_fn).call(this, tile, force));
      this.combineAllTilesIfNeeded();
      const models = tiles.flatMap((tile) => this.transformDataAndCreateModels(tile));
      shareScaleAcrossTracks(models);
      const flatTileData = [].concat(...models.map((d) => d.data()));
      if (flatTileData.length !== 0) {
        this.options.siblingIds.forEach((id) => publish("rawData", { id, data: flatTileData }));
      }
    }
    /**
     * This is currently for testing the new way of rendering visual elements. Called by this.draw()
     */
    async updateTileAsync(tabularDataFetcher, callback) {
      if (!this.tilesetInfo)
        return;
      const tiles = this.visibleAndFetchedTiles();
      const tabularData = await tabularDataFetcher.getTabularData(Object.values(tiles).map((x) => x.remoteId));
      const tilesetInfo = this.tilesetInfo;
      tiles.forEach((tile, i) => {
        if (i === 0) {
          const [refTile] = HGC.utils.trackUtils.calculate1DVisibleTiles(tilesetInfo, this._xScale);
          tile.tileData.zoomLevel = refTile[0];
          tile.tileData.tilePos = [refTile[1], refTile[1]];
          tile.tileData.tabularData = tabularData;
        } else {
          tile.tileData.tabularData = [];
        }
      });
      callback();
    }
    /**
     * Overrides method in Tiled1DPixiTrack. It is called in the constructor, `super(context, options)`.
     * So be aware to use defined variables.
     */
    calculateVisibleTiles() {
      var _a, _b, _c, _d, _e;
      if (!this.tilesetInfo)
        return;
      if (isTabularDataFetcher(this.dataFetcher)) {
        const tiles = HGC.utils.trackUtils.calculate1DVisibleTiles(this.tilesetInfo, this._xScale);
        const maxTileWith = (_b = (_a = this.tilesetInfo.max_tile_width) != null ? _a : this.dataFetcher.MAX_TILE_WIDTH) != null ? _b : Number.MAX_SAFE_INTEGER;
        for (const tile of tiles) {
          const { tileWidth } = this.getTilePosAndDimensions(tile[0], [tile[1], tile[1]]);
          this.forceDraw();
          if (tileWidth > maxTileWith) {
            return;
          }
        }
        this.setVisibleTiles(tiles);
      } else {
        if (!this.tilesetInfo) {
          return;
        }
        const zoomLevel = this.calculateZoomLevel();
        if ("resolutions" in this.tilesetInfo) {
          const sortedResolutions = this.tilesetInfo.resolutions.map((x) => +x).sort((a, b) => b - a);
          const xTiles = tileProxy.calculateTilesFromResolution(
            sortedResolutions[zoomLevel],
            this._xScale,
            this.tilesetInfo.min_pos[0],
            this.tilesetInfo.max_pos[0]
          );
          let yTiles;
          if (Is2DTrack(resolveSuperposedTracks(this.options.spec)[0])) {
            yTiles = tileProxy.calculateTilesFromResolution(
              sortedResolutions[zoomLevel],
              this._yScale,
              this.tilesetInfo.min_pos[0],
              this.tilesetInfo.max_pos[0]
            );
          }
          const tiles = __privateMethod(_c = _GoslingTrackClass, _tilesToId, tilesToId_fn).call(_c, xTiles, yTiles, zoomLevel);
          this.setVisibleTiles(tiles);
        } else {
          const xTiles = tileProxy.calculateTiles(
            zoomLevel,
            this.relevantScale(),
            this.tilesetInfo.min_pos[0],
            this.tilesetInfo.max_pos[0],
            this.tilesetInfo.max_zoom,
            this.tilesetInfo.max_width
          );
          let yTiles;
          if (Is2DTrack(resolveSuperposedTracks(this.options.spec)[0])) {
            yTiles = tileProxy.calculateTiles(
              zoomLevel,
              this._yScale,
              this.tilesetInfo.min_pos[1],
              this.tilesetInfo.max_pos[1],
              this.tilesetInfo.max_zoom,
              // @ts-expect-error what is max_width1?
              (_d = this.tilesetInfo.max_width1) != null ? _d : this.tilesetInfo.max_width
            );
          }
          const tiles = __privateMethod(_e = _GoslingTrackClass, _tilesToId, tilesToId_fn).call(_e, xTiles, yTiles, zoomLevel);
          this.setVisibleTiles(tiles);
        }
      }
    }
    /**
     * Get the tile's position in its coordinate system. Overrides method in Tiled1DPixiTrack.
     */
    getTilePosAndDimensions(zoomLevel, tilePos) {
      if (!this.tilesetInfo) {
        throw Error("tilesetInfo not parsed");
      }
      if ("resolutions" in this.tilesetInfo) {
        const sortedResolutions = this.tilesetInfo.resolutions.map((x) => +x).sort((a, b) => b - a);
        const chosenResolution = sortedResolutions[zoomLevel];
        const [xTilePos, yTilePos] = tilePos;
        const tileWidth = chosenResolution * __privateGet(this, _binsPerTile, binsPerTile_get);
        const tileHeight = tileWidth;
        const tileX = tileWidth * xTilePos;
        const tileY = tileHeight * yTilePos;
        return {
          tileX,
          tileY,
          tileWidth,
          tileHeight
        };
      } else {
        const [xTilePos, yTilePos] = tilePos;
        const minX = this.tilesetInfo.min_pos[0];
        const minY = this.tilesetInfo.min_pos[1];
        const tileWidth = this.tilesetInfo.max_width / 2 ** zoomLevel;
        const tileHeight = this.tilesetInfo.max_width / 2 ** zoomLevel;
        const tileX = minX + xTilePos * tileWidth;
        const tileY = minY + yTilePos * tileHeight;
        return {
          tileX,
          tileY,
          tileWidth,
          tileHeight
        };
      }
    }
    /**
     * Gets the indices of the visible data a tile. Overrides method in Tiled1DPixiTrack
     */
    getIndicesOfVisibleDataInTile(tile) {
      const visible = this._xScale.range();
      if (!this.tilesetInfo || !tile.tileData.tilePos || !("dense" in tile.tileData)) {
        return [0, 0];
      }
      const { tileX, tileWidth } = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos);
      const tileXScale = HGC.libraries.d3Scale.scaleLinear().domain([0, __privateGet(this, _binsPerTile, binsPerTile_get)]).range([tileX, tileX + tileWidth]);
      const start = Math.max(0, Math.round(tileXScale.invert(this._xScale.invert(visible[0]))));
      const end = Math.min(
        tile.tileData.dense.length,
        Math.round(tileXScale.invert(this._xScale.invert(visible[1])))
      );
      return [start, end];
    }
    /**
     * Overrides method in TiledPixiTrack
     * @param loadedTiles
     */
    receivedTiles(loadedTiles) {
      super.receivedTiles(loadedTiles);
      isTabularDataFetcher(this.dataFetcher) && this.drawLoadingCue();
    }
    /**
     * Overrides method in TiledPixiTrack
     */
    removeOldTiles() {
      super.removeOldTiles();
      isTabularDataFetcher(this.dataFetcher) && this.drawLoadingCue();
    }
    /**
     * Combile multiple tiles into the last tile.
     * This is sometimes necessary, for example, when applying a displacement algorithm to all tiles at once.
     * Called by this.processAllTiles() so this method needs to be public.
     */
    combineAllTilesIfNeeded() {
      var _a, _b, _c;
      if (!this.shouldCombineTiles())
        return;
      const tiles = this.visibleAndFetchedTiles();
      if (!tiles || tiles.length <= 1) {
        return;
      }
      this.tileSize = ((_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024) * tiles.length;
      let merged = [];
      tiles.forEach((tile, i) => {
        const tileInfo = __privateGet(this, _processedTileInfo)[tile.tileId];
        if (tileInfo) {
          merged = [...merged, ...tileInfo.tabularData];
          tileInfo.skipRendering = i !== 0;
        }
      });
      const firstTileInfo = __privateGet(this, _processedTileInfo)[tiles[0].tileId];
      firstTileInfo.tabularData = merged;
      if ((_c = firstTileInfo.tabularData[0]) == null ? void 0 : _c.uid) {
        firstTileInfo.tabularData = uniqBy(firstTileInfo.tabularData, "uid");
      }
    }
    /**
     * Check whether tiles should be merged. Needs to be public since called by combineAllTilesIfNeeded()
     */
    shouldCombineTiles() {
      const includesDisplaceTransform = hasDataTransform(this.options.spec, "displace");
      const hasDenseTiles = () => {
        const tiles = this.visibleAndFetchedTiles();
        return tiles.length >= 1 && "dense" in tiles[0].tileData;
      };
      const isBamDataFetcher = this.dataFetcher instanceof BamDataFetcher;
      return includesDisplaceTransform && !hasDenseTiles() && !isBamDataFetcher;
    }
    /**
     * Apply data transformation to each of the overlaid tracks and generate GoslingTrackModels.
     */
    transformDataAndCreateModels(tile) {
      const tileInfo = __privateGet(this, _processedTileInfo)[tile.tileId];
      if (!tileInfo || tileInfo.skipRendering) {
        return [];
      }
      tileInfo.goslingModels = [];
      const resolvedTracks = __privateMethod(this, _getResolvedTracks, getResolvedTracks_fn).call(this);
      resolvedTracks.forEach((resolvedSpec) => {
        var _a;
        let tabularDataTransformed = Array.from(tileInfo.tabularData);
        (_a = resolvedSpec.dataTransform) == null ? void 0 : _a.forEach((t) => {
          switch (t.type) {
            case "filter":
              tabularDataTransformed = filterData(t, tabularDataTransformed);
              break;
            case "concat":
              tabularDataTransformed = concatString(t, tabularDataTransformed);
              break;
            case "replace":
              tabularDataTransformed = replaceString(t, tabularDataTransformed);
              break;
            case "log":
              tabularDataTransformed = calculateData(t, tabularDataTransformed);
              break;
            case "exonSplit":
              tabularDataTransformed = splitExon(t, tabularDataTransformed, resolvedSpec.assembly);
              break;
            case "genomicLength":
              tabularDataTransformed = calculateGenomicLength(t, tabularDataTransformed);
              break;
            case "svType":
              tabularDataTransformed = inferSvType(t, tabularDataTransformed);
              break;
            case "coverage":
              tabularDataTransformed = aggregateCoverage(t, tabularDataTransformed, this._xScale.copy());
              break;
            case "subjson":
              tabularDataTransformed = parseSubJSON(t, tabularDataTransformed);
              break;
            case "displace":
              tabularDataTransformed = displace(t, tabularDataTransformed, this._xScale.copy());
              break;
          }
        });
        try {
          if (PubSub) {
            const NUM_OF_ROWS_IN_PREVIEW = 100;
            const numOrRows = tabularDataTransformed.length;
            PubSub.publish("data-preview", {
              id: context.viewUid,
              dataConfig: JSON.stringify({ data: resolvedSpec.data }),
              data: NUM_OF_ROWS_IN_PREVIEW > numOrRows ? tabularDataTransformed : sampleSize(tabularDataTransformed, NUM_OF_ROWS_IN_PREVIEW)
              // ...
            });
          }
        } catch (e) {
        }
        const [trackWidth, trackHeight] = this.dimensions;
        const axisSize = IsXAxis(resolvedSpec) ? HIGLASS_AXIS_SIZE : 0;
        const [w, h] = [trackWidth, trackHeight + axisSize];
        const circularFactor = Math.min(w, h) / Math.min(resolvedSpec.width, resolvedSpec.height);
        if (resolvedSpec.innerRadius) {
          resolvedSpec.innerRadius = resolvedSpec.innerRadius * circularFactor;
        }
        if (resolvedSpec.outerRadius) {
          resolvedSpec.outerRadius = resolvedSpec.outerRadius * circularFactor;
        }
        resolvedSpec.width = w;
        resolvedSpec.height = h;
        const model = new GoslingTrackModel(resolvedSpec, tabularDataTransformed, this.options.theme);
        tileInfo.goslingModels.push(model);
      });
      return tileInfo.goslingModels;
    }
    // set in HorizontalTiled1DPixiTrack
    /**
     * Overrides method in HorizontalLine1DPixiTrack
     */
    getMouseOverHtml(mouseX, mouseY) {
      var _a, _b, _c, _d, _e;
      __privateMethod(this, _publishTrackEvents, publishTrackEvents_fn).call(this, "trackMouseOver", mouseX, mouseY);
      if (__privateGet(this, _isRangeBrushActivated)) {
        return "";
      }
      if (!this.tilesetInfo) {
        return "";
      }
      this.pMouseHover.clear();
      const genomicPosition = getRelativeGenomicPosition(Math.floor(this._xScale.invert(mouseX)), __privateGet(this, _assembly2));
      const capturedElements = __privateMethod(this, _getElementsWithinMouse, getElementsWithinMouse_fn).call(this, mouseX, mouseY);
      if (capturedElements.length !== 0) {
        document.body.style.cursor = "pointer";
      } else {
        document.body.style.cursor = "default";
      }
      if (capturedElements.length !== 0) {
        const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
        const mouseOverEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.mouseOver;
        if (mouseOverEnabled) {
          const g = this.pMouseHover;
          if (((_c = (_b = this.options.spec.style) == null ? void 0 : _b.mouseOver) == null ? void 0 : _c.arrange) !== "behind") {
            this.pMain.removeChild(g);
            this.pMain.addChild(g);
          }
          __privateMethod(this, _highlightMarks, highlightMarks_fn).call(this, g, capturedElements, Object.assign({}, DEFAULT_MOUSE_EVENT_STYLE, (_d = this.options.spec.style) == null ? void 0 : _d.mouseOver));
          publish("mouseOver", {
            id: context.viewUid,
            genomicPosition,
            data: capturedElements.map((d) => d.value)
          });
        }
        const models = this.visibleAndFetchedGoslingModels();
        const firstTooltipSpec = (_e = models.find((m2) => {
          var _a2;
          return m2.spec().tooltip && ((_a2 = m2.spec().tooltip) == null ? void 0 : _a2.length) !== 0;
        })) == null ? void 0 : _e.spec().tooltip;
        if (firstTooltipSpec) {
          let content = firstTooltipSpec.map((d) => {
            var _a2;
            const rawValue = capturedElements[0].value[d.field];
            let value = rawValue;
            if (d.type === "quantitative" && d.format) {
              value = HGC.libraries.d3Format.format(d.format)(+rawValue);
            } else if (d.type === "genomic") {
              const { chromosome, position } = getRelativeGenomicPosition(+rawValue, __privateGet(this, _assembly2));
              value = `${chromosome}:${HGC.libraries.d3Format.format(",")(position)}`;
            }
            return `<tr><td style='padding: 4px 8px'>${(_a2 = d.alt) != null ? _a2 : d.field}</td><td style='padding: 4px 8px'><b>${value}</b></td></tr>`;
          }).join("");
          content = `<table style='text-align: left; margin-top: 12px'>${content}</table>`;
          if (capturedElements.length > 1) {
            content += `<div style='padding: 4px 8px; margin-top: 4px; text-align: center; color: grey'>${capturedElements.length - 1} Additional Selections...</div>`;
          }
          return `<div>${content}</div>`;
        }
      }
      return "";
    }
    /* *
     *
     *  Other misc methods and overrides
     *
     * */
    /**
     * Returns the minimum in the visible area (not visible tiles).
     * Overrides method in Tiled1DPixiTrack
     */
    minVisibleValue() {
      return 0;
    }
    /**
     * Returns the maximum in the visible area (not visible tiles).
     * Overrides method in Tiled1DPixiTrack.
     */
    maxVisibleValue() {
      return 0;
    }
    /**
     * Overrides method in PixiTrack. SVG export is not supported.
     */
    exportSVG() {
      throw new Error("exportSVG() not supported for gosling-track");
    }
    /**
     * Show visual cue during waiting for visualizations being rendered. Also called by data fetchers
     */
    drawLoadingCue() {
      if (this.fetching.size) {
        const margin = 6;
        const text = `Fetching... ${Array.from(this.fetching).join(" ")}`;
        __privateGet(this, _loadingText).text = text;
        __privateGet(this, _loadingText).x = this.position[0] + this.dimensions[0] - margin / 2;
        __privateGet(this, _loadingText).y = this.position[1] + this.dimensions[1] - margin / 2;
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, __privateGet(this, _loadingTextStyleObj));
        const { width: w, height: h } = metric;
        __privateGet(this, _loadingTextBg).clear();
        __privateGet(this, _loadingTextBg).lineStyle(1, colorToHex("grey"), 1, 0.5);
        __privateGet(this, _loadingTextBg).beginFill(colorToHex("white"), 0.8);
        __privateGet(this, _loadingTextBg).drawRect(
          this.position[0] + this.dimensions[0] - w - margin - 1,
          this.position[1] + this.dimensions[1] - h - margin - 1,
          w + margin,
          h + margin
        );
        __privateGet(this, _loadingText).visible = true;
        __privateGet(this, _loadingTextBg).visible = true;
      } else {
        __privateGet(this, _loadingText).visible = false;
        __privateGet(this, _loadingTextBg).visible = false;
      }
    }
    /**
     * Called in legend.ts
     */
    updateScaleOffsetFromOriginalSpec(_renderingId, scaleOffset, channelKey) {
      resolveSuperposedTracks(this.options.spec).map((spec) => {
        if (spec._renderingId === _renderingId) {
          const channel = spec[channelKey];
          if (IsChannelDeep(channel)) {
            channel.scaleOffset = scaleOffset;
          }
        }
      });
    }
    /**
     * Called in legend.ts
     */
    shareScaleOffsetAcrossTracksAndTiles(scaleOffset, channelKey) {
      const models = this.visibleAndFetchedGoslingModels();
      models.forEach((d) => {
        const channel = d.spec()[channelKey];
        if (IsChannelDeep(channel)) {
          channel.scaleOffset = scaleOffset;
        }
        const channelOriginal = d.originalSpec()[channelKey];
        if (IsChannelDeep(channelOriginal)) {
          channelOriginal.scaleOffset = scaleOffset;
        }
      });
    }
  };
  _assembly2 = new WeakMap();
  _processedTileInfo = new WeakMap();
  _mouseDownX = new WeakMap();
  _mouseDownY = new WeakMap();
  _isRangeBrushActivated = new WeakMap();
  _gBrush = new WeakMap();
  _loadingTextStyleObj = new WeakMap();
  _loadingTextBg = new WeakMap();
  _loadingText = new WeakMap();
  _tilesToId = new WeakSet();
  tilesToId_fn = function(xTiles, yTiles, zoomLevel) {
    if (!yTiles) {
      return xTiles.map((x) => [zoomLevel, x]);
    }
    const tiles = [];
    xTiles.forEach((x) => yTiles.forEach((y) => tiles.push([zoomLevel, x, y])));
    return tiles;
  };
  _binsPerTile = new WeakSet();
  binsPerTile_get = function() {
    let maybeValue;
    if (this.tilesetInfo) {
      maybeValue = "bins_per_dimension" in this.tilesetInfo ? this.tilesetInfo.bins_per_dimension : this.tilesetInfo.tile_size;
    }
    return maybeValue != null ? maybeValue : 256;
  };
  _getResolvedTracks = new WeakSet();
  getResolvedTracks_fn = function() {
    const copy2 = structuredClone(this.options.spec);
    return resolveSuperposedTracks(copy2).filter((t) => t.mark !== "brush");
  };
  _generateTabularData = new WeakSet();
  generateTabularData_fn = function(tile, force = false) {
    if (__privateGet(this, _processedTileInfo)[tile.tileId] && !force) {
      return;
    }
    if (!tile.tileData.tilePos) {
      return;
    }
    const tileInfo = initProcessedTileInfo();
    const resolvedTracks = __privateMethod(this, _getResolvedTracks, getResolvedTracks_fn).call(this);
    if (resolvedTracks.length === 0) {
      return [];
    }
    const firstResolvedTrack = resolvedTracks[0];
    if ("tabularData" in tile.tileData) {
      tileInfo.tabularData = tile.tileData.tabularData;
    } else {
      const { tileX, tileY, tileWidth, tileHeight } = this.getTilePosAndDimensions(
        tile.tileData.zoomLevel,
        tile.tileData.tilePos
      );
      const sparse = "length" in tile.tileData ? Array.from(tile.tileData) : [];
      const extendedTileData = Object.assign({}, tile.tileData, {
        sparse,
        tileX,
        tileY,
        tileWidth,
        tileHeight,
        tileSize: this.tileSize
      });
      const tabularData = getTabularData(firstResolvedTrack, extendedTileData);
      if (tabularData) {
        tileInfo.tabularData = tabularData;
      }
    }
    __privateGet(this, _processedTileInfo)[tile.tileId] = tileInfo;
  };
  _onMouseDown = new WeakSet();
  onMouseDown_fn = function(mouseX, mouseY, isAltPressed) {
    var _a;
    __privateSet(this, _mouseDownX, mouseX);
    __privateSet(this, _mouseDownY, mouseY);
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const rangeSelectEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.rangeSelect;
    __privateSet(this, _isRangeBrushActivated, rangeSelectEnabled && isAltPressed);
    this.pMouseHover.clear();
  };
  _onMouseMove = new WeakSet();
  onMouseMove_fn = function(mouseX) {
    if (this.options.spec.layout === "circular") {
      return;
    }
    if (__privateGet(this, _isRangeBrushActivated)) {
      this.mRangeBrush.updateRange([mouseX, __privateGet(this, _mouseDownX)]).drawBrush().visible().disable();
    }
  };
  _onMouseUp = new WeakSet();
  onMouseUp_fn = function(mouseX, mouseY) {
    var _a;
    __privateMethod(this, _publishTrackEvents, publishTrackEvents_fn).call(this, "trackClick", mouseX, mouseY);
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const clickEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.click;
    const isDrag = Math.sqrt((__privateGet(this, _mouseDownX) - mouseX) ** 2 + (__privateGet(this, _mouseDownY) - mouseY) ** 2) > 1;
    if (!__privateGet(this, _isRangeBrushActivated) && !isDrag) {
      this.mRangeBrush.clear();
      this.pMouseSelection.clear();
    } else {
      this.mRangeBrush.enable();
    }
    __privateSet(this, _isRangeBrushActivated, false);
    if (!this.tilesetInfo) {
      return;
    }
    if (!isDrag && clickEnabled) {
      const genomicPosition = getRelativeGenomicPosition(
        Math.floor(this._xScale.invert(mouseX)),
        __privateGet(this, _assembly2)
      );
      const capturedElements = __privateMethod(this, _getElementsWithinMouse, getElementsWithinMouse_fn).call(this, mouseX, mouseY);
      if (capturedElements.length !== 0) {
        this.options.siblingIds.forEach(
          (id) => publish("click", {
            id,
            genomicPosition,
            data: capturedElements.map((d) => d.value)
          })
        );
      }
    }
  };
  _onMouseOut = new WeakSet();
  onMouseOut_fn = function() {
    __privateSet(this, _isRangeBrushActivated, false);
    document.body.style.cursor = "default";
    this.pMouseHover.clear();
  };
  _getElementsWithinMouse = new WeakSet();
  getElementsWithinMouse_fn = function(mouseX, mouseY) {
    var _a;
    const models = this.visibleAndFetchedGoslingModels();
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const multiHovering = IsMouseEventsDeep(mouseEvents) && mouseEvents.enableMouseOverOnMultipleMarks;
    const idField = IsMouseEventsDeep(mouseEvents) && mouseEvents.groupMarksByField;
    const mergedCapturedElements = models.map((model) => model.getMouseEventModel().findAll(mouseX, mouseY, true)).flat();
    if (!multiHovering) {
      mergedCapturedElements.splice(1, mergedCapturedElements.length - 1);
    }
    if (mergedCapturedElements.length !== 0 && idField) {
      const source = Array.from(mergedCapturedElements);
      models.forEach((model) => {
        const siblings = model.getMouseEventModel().getSiblings(source, idField);
        mergedCapturedElements.push(...siblings);
      });
    }
    return mergedCapturedElements;
  };
  _publishTrackEvents = new WeakSet();
  publishTrackEvents_fn = function(eventType, mouseX, mouseY) {
    const [x, y] = this.position;
    const [width, height] = this.dimensions;
    if (this.options.spec.layout === "circular") {
      const cx = x + width / 2;
      const cy = y + height / 2;
      const innerRadius = this.options.spec.innerRadius;
      const outerRadius = this.options.spec.outerRadius;
      const startAngle = this.options.spec.startAngle;
      const endAngle = this.options.spec.endAngle;
      if (isPointInsideDonutSlice(
        [mouseX, mouseY],
        [width / 2, height / 2],
        [innerRadius, outerRadius],
        [startAngle, endAngle]
      )) {
        publish(eventType, {
          id: context.viewUid,
          spec: structuredClone(this.options.spec),
          shape: { x, y, width, height, cx, cy, innerRadius, outerRadius, startAngle, endAngle }
        });
      }
    } else {
      publish(eventType, {
        id: context.viewUid,
        spec: structuredClone(this.options.spec),
        shape: { x, y, width, height }
      });
    }
  };
  _onRangeBrush = new WeakSet();
  onRangeBrush_fn = function(range, skipApiTrigger = false) {
    var _a, _b, _c, _d;
    this.pMouseSelection.clear();
    if (range === null) {
      if (!skipApiTrigger) {
        publish("rangeSelect", { id: context.viewUid, genomicRange: null, data: [] });
      }
      return;
    }
    const models = this.visibleAndFetchedGoslingModels();
    const [startX, endX] = range;
    let capturedElements = models.map((model) => model.getMouseEventModel().findAllWithinRange(startX, endX, true)).flat();
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const idField = IsMouseEventsDeep(mouseEvents) && mouseEvents.groupMarksByField;
    if (capturedElements.length !== 0 && idField) {
      models.forEach((model) => {
        const siblings = model.getMouseEventModel().getSiblings(capturedElements, idField);
        const siblingIds = Array.from(new Set(siblings.map((d) => d.value[idField])));
        capturedElements = capturedElements.filter((d) => siblingIds.indexOf(d.value[idField]) === -1);
      });
    }
    if (capturedElements.length !== 0) {
      const g = this.pMouseSelection;
      if (((_c = (_b = this.options.spec.style) == null ? void 0 : _b.select) == null ? void 0 : _c.arrange) !== "behind") {
        this.pMain.removeChild(g);
        this.pMain.addChild(g);
      }
      __privateMethod(this, _highlightMarks, highlightMarks_fn).call(this, g, capturedElements, Object.assign({}, DEFAULT_MOUSE_EVENT_STYLE, (_d = this.options.spec.style) == null ? void 0 : _d.select));
    }
    if (!skipApiTrigger) {
      const genomicRange = [
        getRelativeGenomicPosition(Math.floor(this._xScale.invert(startX)), __privateGet(this, _assembly2)),
        getRelativeGenomicPosition(Math.floor(this._xScale.invert(endX)), __privateGet(this, _assembly2))
      ];
      publish("rangeSelect", {
        id: context.viewUid,
        genomicRange,
        data: capturedElements.map((d) => d.value)
      });
    }
    this.forceDraw();
  };
  _highlightMarks = new WeakSet();
  highlightMarks_fn = function(g, marks, style) {
    g.lineStyle(
      style.strokeWidth,
      colorToHex(style.stroke),
      style.strokeOpacity,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(colorToHex(style.color), style.color === "none" ? 0 : style.opacity);
    marks.forEach((d) => {
      if (d.type === "point") {
        const [x, y, r = 3] = d.polygon;
        g.drawCircle(x, y, r);
      } else if (d.type === "line") {
        g.moveTo(d.polygon[0], d.polygon[1]);
        flatArrayToPairArray(d.polygon).map((d2) => g.lineTo(d2[0], d2[1]));
      } else {
        g.drawPolygon(d.polygon);
      }
    });
  };
  _publishOnNewTrack = new WeakSet();
  publishOnNewTrack_fn = function() {
    publish("onNewTrack", {
      id: context.viewUid
    });
  };
  /**
   * Convert tile positions to tile IDs
   */
  __privateAdd(_GoslingTrackClass, _tilesToId);
  let GoslingTrackClass = _GoslingTrackClass;
  return new GoslingTrackClass();
};
const GoslingTrack = createPluginTrack(config$1, factory$1);
const config = {
  type: "dummy-track",
  defaultOptions: {
    height: 0,
    // default height gets set in when spec is preprocessed
    width: 0,
    // default width gets set in when spec is preprocessed
    title: "",
    background: "#fff",
    textFontSize: 12,
    textFontWeight: "normal",
    textStroke: "#000",
    textStrokeWidth: 0.1,
    outline: "#fff"
  }
};
const factory = (HGC, context, options) => {
  var _drawBackground, drawBackground_fn, _drawText, drawText_fn;
  const { SVGTrack } = HGC.tracks;
  class DummyTrackClass extends SVGTrack {
    constructor() {
      super(context, options);
      __privateAdd(this, _drawBackground);
      /**
       * Draws the title of the dummy track
       */
      __privateAdd(this, _drawText);
      __privateMethod(this, _drawBackground, drawBackground_fn).call(this);
      __privateMethod(this, _drawText, drawText_fn).call(this);
      publish("onNewTrack", {
        id: context.viewUid
      });
    }
  }
  _drawBackground = new WeakSet();
  drawBackground_fn = function() {
    this.gMain.append("rect").attr("fill", options.background).attr("x", 0).attr("y", 0).attr("width", options.width).attr("height", options.height).style("stroke", options.outline);
  };
  _drawText = new WeakSet();
  drawText_fn = function() {
    this.gMain.append("text").attr("x", options.width / 2).attr("y", (options.height + options.textFontSize) / 2).style("text-anchor", "middle").style("font-size", `${options.textFontSize}px`).style("font-weight", options.textFontWeight).style("stroke", options.textStroke).style("stroke-width", options.textStrokeWidth).text(options.title);
  };
  return new DummyTrackClass();
};
const DummyTrack = createPluginTrack(config, factory);
let once = false;
function init() {
  if (once)
    return;
  higlassRegister({
    name: "GoslingTrack",
    track: GoslingTrack,
    config: GoslingTrack.config
  });
  higlassRegister({
    name: "Gosling2DTrack",
    track: GoslingTrack,
    config: {
      ...GoslingTrack.config,
      type: "gosling-2d-track",
      orientation: "2d"
    }
  });
  higlassRegister({
    name: "AxisTrack",
    track: AxisTrack,
    config: AxisTrack.config
  });
  higlassRegister({
    name: "TextTrack",
    track: TextTrack,
    config: TextTrack.config
  });
  higlassRegister({
    name: "BrushTrack",
    track: BrushTrack,
    config: BrushTrack.config
  });
  higlassRegister({
    name: "DummyTrack",
    track: DummyTrack,
    config: DummyTrack.config
  });
  for (const dataFetcher of Object.values(dataFetchers)) {
    const { config: config2 } = dataFetcher;
    higlassRegister({ dataFetcher, config: config2 }, { pluginType: "dataFetcher" });
  }
  once = true;
}
function getBoundingBox(trackInfos) {
  let width = 0;
  let height = 0;
  trackInfos.forEach((_) => {
    const w = _.boundingBox.x + _.boundingBox.width;
    const h = _.boundingBox.y + _.boundingBox.height;
    if (height < h) {
      height = h;
    }
    if (width < w) {
      width = w;
    }
  });
  return { width, height };
}
function getRelativeTrackInfo(spec, theme) {
  var _a, _b;
  let trackInfos = [];
  traverseAndCollectTrackInfo(spec, trackInfos);
  const size = getBoundingBox(trackInfos);
  if (spec.title || spec.subtitle) {
    const titleHeight = (spec.title ? ((_a = theme.root.titleFontSize) != null ? _a : 18) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM : 0) + (spec.subtitle ? ((_b = theme.root.subtitleFontSize) != null ? _b : 14) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM : 0);
    const marginBottom = 4;
    size.height += titleHeight + marginBottom;
    size.height = size.height + (8 - size.height % 8);
    trackInfos.forEach((_) => {
      _.boundingBox.y += titleHeight + marginBottom;
    });
    trackInfos = [
      {
        track: getTextTrack({ width: size.width, height: titleHeight }, spec.title, spec.subtitle),
        boundingBox: { x: 0, y: 0, width: size.width, height: titleHeight },
        layout: { x: 0, y: 0, w: 12, h: titleHeight / size.height * 12 }
      },
      ...trackInfos
    ];
  } else {
    size.height = size.height + (8 - size.height % 8);
  }
  const pixelPreciseMarginPadding = !(typeof spec.responsiveSize !== "object" ? spec.responsiveSize : spec.responsiveSize.height);
  trackInfos.forEach((_) => {
    _.layout.x = _.boundingBox.x / size.width * 12;
    _.layout.w = _.boundingBox.width / size.width * 12;
    _.layout.y = pixelPreciseMarginPadding ? _.boundingBox.y : _.boundingBox.y / size.height * 12;
    _.layout.h = pixelPreciseMarginPadding ? _.boundingBox.height : _.boundingBox.height / size.height * 12;
  });
  return { trackInfos, size };
}
function traverseAndCollectTrackInfo(spec, output, dx = 0, dy = 0, circularRootNotFound = true) {
  let cumWidth = 0;
  let cumHeight = 0;
  let allChildCircularLayout = true;
  let traversedAtLeastOnce = false;
  traverseTracksAndViews(spec, (tv) => {
    traversedAtLeastOnce = true;
    if (tv.layout !== "circular") {
      allChildCircularLayout = false;
    }
  });
  let noChildConcatArrangement = true;
  traverseViewArrangements(spec, (a) => {
    if (a.arrangement === "vertical" || a.arrangement === "horizontal") {
      noChildConcatArrangement = false;
    }
  });
  const isThisCircularRoot = circularRootNotFound && allChildCircularLayout && traversedAtLeastOnce && noChildConcatArrangement && ("views" in spec && (spec.arrangement === "parallel" || spec.arrangement === "serial") || "tracks" in spec);
  const numTracksBeforeInsert = output.length;
  if ("tracks" in spec) {
    const tracks = spec.tracks;
    if (spec.orientation === "vertical") {
      cumHeight = Math.max(...tracks.map((d) => d.height));
      tracks.forEach((track, i, array) => {
        if (getNumOfXAxes([track]) === 1) {
          track.width += HIGLASS_AXIS_SIZE;
        }
        track.height = cumHeight;
        output.push({
          track,
          boundingBox: {
            x: dx + cumWidth,
            y: dy,
            width: track.width,
            height: cumHeight
          },
          layout: { x: 0, y: 0, w: 0, h: 0 }
          // Just put a dummy info here, this should be added after entire bounding box has been determined
        });
        if (array[i + 1] && array[i + 1].overlayOnPreviousTrack)
          ;
        else {
          cumWidth += track.width;
          if (i !== array.length - 1) {
            cumWidth += spec.spacing !== void 0 ? spec.spacing : 0;
          }
        }
      });
    } else {
      cumWidth = Math.max(...tracks.map((d) => d.width));
      tracks.forEach((track, i, array) => {
        if (getNumOfXAxes([track]) === 1) {
          track.height += HIGLASS_AXIS_SIZE;
        }
        const singleTrack = resolveSuperposedTracks(track);
        if (singleTrack.length > 0 && Is2DTrack(singleTrack[0]) && getNumOfYAxes([track]) === 1) {
          cumWidth += HIGLASS_AXIS_SIZE;
        }
        track.width = cumWidth;
        output.push({
          track,
          boundingBox: {
            x: dx,
            y: dy + cumHeight,
            width: cumWidth,
            height: track.height
          },
          layout: { x: 0, y: 0, w: 0, h: 0 }
          // Just put a dummy info here, this should be added after entire bounding box has been determined
        });
        if (array[i + 1] && array[i + 1].overlayOnPreviousTrack)
          ;
        else {
          cumHeight += track.height;
          if (i !== array.length - 1) {
            cumHeight += spec.spacing !== void 0 ? spec.spacing : 0;
          }
        }
      });
    }
  } else {
    if (spec.arrangement === "parallel" || spec.arrangement === "vertical") {
      const spacing = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
      spec.views.forEach((v, i, array) => {
        var _a, _b, _c, _d, _e;
        const viewBB = traverseAndCollectTrackInfo(
          v,
          output,
          dx + ((_a = v.xOffset) != null ? _a : 0),
          dy + ((_b = v.yOffset) != null ? _b : 0) + cumHeight,
          !isThisCircularRoot && circularRootNotFound
        );
        if (cumWidth < ((_c = v.xOffset) != null ? _c : 0) + viewBB.width) {
          cumWidth = ((_d = v.xOffset) != null ? _d : 0) + viewBB.width;
        }
        if (i !== array.length - 1) {
          cumHeight += spacing;
        }
        cumHeight += ((_e = v.yOffset) != null ? _e : 0) + viewBB.height;
      });
    } else if (spec.arrangement === "serial" || spec.arrangement === "horizontal") {
      spec.views.forEach((v, i, array) => {
        var _a, _b, _c, _d, _e;
        const spacing = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
        const viewBB = traverseAndCollectTrackInfo(
          v,
          output,
          dx + ((_a = v.xOffset) != null ? _a : 0) + cumWidth,
          dy + ((_b = v.yOffset) != null ? _b : 0),
          !isThisCircularRoot && circularRootNotFound
        );
        if (cumHeight < ((_c = v.xOffset) != null ? _c : 0) + viewBB.height) {
          cumHeight = ((_d = v.xOffset) != null ? _d : 0) + viewBB.height;
        }
        if (i !== array.length - 1) {
          cumWidth += spacing;
        }
        cumWidth += ((_e = v.xOffset) != null ? _e : 0) + viewBB.width;
      });
    }
  }
  if (isThisCircularRoot) {
    const cTracks = output.slice(numTracksBeforeInsert);
    const ifMultipleViews = "views" in spec && (spec.arrangement === "parallel" || spec.arrangement === "serial") && spec.views.length > 1;
    const SPACING = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
    const PADDING = DEFAULT_CIRCULAR_VIEW_PADDING;
    const INNER_RADIUS = spec.centerRadius !== void 0 ? spec.centerRadius : DEFAULT_INNER_RADIUS_PROP;
    const TOTAL_RADIUS = cumWidth / 2 + PADDING;
    const TOTAL_RING_SIZE = TOTAL_RADIUS * (1 - INNER_RADIUS);
    cTracks.forEach((t, i) => {
      var _a, _b;
      if (IsDummyTrack(t.track)) {
        return;
      }
      t.track.layout = "circular";
      t.track.outerRadius = TOTAL_RADIUS - PADDING - (t.boundingBox.y - dy) / cumHeight * TOTAL_RING_SIZE;
      t.track.innerRadius = TOTAL_RADIUS - PADDING - (t.boundingBox.y + t.boundingBox.height - dy) / cumHeight * TOTAL_RING_SIZE;
      const spacingAngle = SPACING / cumWidth * 360;
      t.track.startAngle = spacingAngle + (t.boundingBox.x - dx) / cumWidth * (cumWidth - SPACING) / cumWidth * 360;
      t.track.endAngle = (t.boundingBox.x + t.boundingBox.width - dx) / cumWidth * (cumWidth - SPACING) / cumWidth * 360;
      t.boundingBox.x = dx + ((_a = t.track.xOffset) != null ? _a : 0);
      t.boundingBox.y = dy + ((_b = t.track.yOffset) != null ? _b : 0);
      t.boundingBox.height = t.track.height = t.boundingBox.width = t.track.width = TOTAL_RADIUS * 2;
      if (i !== 0) {
        t.track.overlayOnPreviousTrack = true;
      }
      if (ifMultipleViews) {
        if (IsOverlaidTrack(t.track)) {
          t.track._overlay = t.track._overlay.filter((o) => o.mark !== "brush");
        }
      }
    });
    cumHeight = TOTAL_RADIUS * 2;
  }
  spec._assignedWidth = cumWidth;
  spec._assignedHeight = cumHeight;
  return { x: dx, y: dy, width: cumWidth, height: cumHeight };
}
function getNumOfXAxes(tracks) {
  return tracks.filter((t) => IsXAxis(t)).length;
}
function getNumOfYAxes(tracks) {
  return tracks.filter((t) => IsYAxis(t)).length;
}
const getTextTrack = (size, title2, subtitle) => {
  return JSON.parse(
    JSON.stringify({
      mark: "header",
      width: size.width,
      height: size.height,
      title: title2,
      subtitle
    })
  );
};
function parseServerAndTilesetUidFromUrl(url) {
  if (!url.includes("tileset_info/?d=") || !url.includes("https:") && !url.includes("http:")) {
    return { server: void 0, tilesetUid: void 0 };
  }
  const server = url.split("tileset_info/?d=")[0];
  const tilesetUid = url.split("tileset_info/?d=")[1];
  return { server, tilesetUid };
}
function goslingToHiGlass(hgModel, gosTrack, bb, layout, theme, idMapper, urlToFetchOptions) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  if (IsDummyTrack(gosTrack)) {
    hgModel.addDefaultView(gosTrack.id).setDummyTrack(gosTrack).setLayout(layout);
    return hgModel;
  }
  const resolvedSpecs = resolveSuperposedTracks(gosTrack);
  const firstResolvedSpec = resolvedSpecs[0];
  const trackId = (_a = firstResolvedSpec.id) != null ? _a : uuid();
  if (!firstResolvedSpec.id) {
    firstResolvedSpec.id = trackId;
  }
  resolvedSpecs.forEach((spec) => {
    if (spec.id) {
      idMapper.addMapping(spec.id, trackId);
    }
  });
  const assembly = firstResolvedSpec.assembly;
  if (IsDataDeep(firstResolvedSpec.data)) {
    let server, tilesetUid;
    if (IsDataDeepTileset(firstResolvedSpec.data)) {
      const parsed = parseServerAndTilesetUidFromUrl(firstResolvedSpec.data.url);
      server = parsed.server;
      tilesetUid = parsed.tilesetUid;
    }
    const genomicChannel = getGenomicChannelFromTrack(firstResolvedSpec);
    const genomicChannelKey = getGenomicChannelKeyFromTrack(firstResolvedSpec);
    const isXGenomic = genomicChannelKey === "x" || genomicChannelKey === "xe";
    const xDomain = isXGenomic && IsChannelDeep(genomicChannel) ? genomicChannel.domain : void 0;
    const yDomain = Is2DTrack(firstResolvedSpec) && IsChannelDeep(firstResolvedSpec.y) ? firstResolvedSpec.y.domain : void 0;
    const width = bb.width - (firstResolvedSpec.layout !== "circular" && firstResolvedSpec.orientation === "vertical" && IsXAxis(firstResolvedSpec) ? HIGLASS_AXIS_SIZE : 0);
    const height = bb.height - (firstResolvedSpec.layout !== "circular" && firstResolvedSpec.orientation === "horizontal" && IsXAxis(firstResolvedSpec) ? HIGLASS_AXIS_SIZE : 0);
    const hgTrack = {
      uid: `${trackId}-track`,
      // This is being used to cache the visualization
      type: Is2DTrack(firstResolvedSpec) ? "gosling-2d-track" : "gosling-track",
      server,
      tilesetUid,
      width,
      height,
      options: {
        id: trackId,
        siblingIds: idMapper.getSiblingGoslingIds(trackId),
        /* Mouse hover position */
        showMousePosition: firstResolvedSpec.layout === "circular" ? false : theme.root.showMousePosition,
        // show mouse position only for linear tracks // TODO: or vertical
        mousePositionColor: theme.root.mousePositionColor,
        /* Track title */
        name: firstResolvedSpec.layout === "linear" ? firstResolvedSpec.title : " ",
        labelPosition: firstResolvedSpec.title ? theme.track.titleAlign === "left" ? "topLeft" : "topRight" : "none",
        labelShowResolution: false,
        labelColor: theme.track.titleColor,
        labelBackgroundColor: theme.track.titleBackground,
        labelBackgroundOpacity: 0.5,
        // TODO: Support `theme.track.titleBackgroundOpacity`
        labelTextOpacity: 1,
        labelLeftMargin: 1,
        labelTopMargin: 1,
        labelRightMargin: 0,
        labelBottomMargin: 0,
        // TODO: Use this eventually
        // trackBorderWidth: firstResolvedSpec.style?.outlineWidth ?? 3,
        // trackBorderColor: firstResolvedSpec.style?.outline ?? '#DBDBDB',
        /* Others */
        backgroundColor: "transparent",
        // in this way, we can superpose multiple tracks
        spec: { ...gosTrack },
        theme
      }
    };
    if (firstResolvedSpec.data && IsDataDeep(firstResolvedSpec.data) && (firstResolvedSpec.data.type === "csv" || firstResolvedSpec.data.type === "json" || firstResolvedSpec.data.type === "bigwig" || firstResolvedSpec.data.type === "bam" || firstResolvedSpec.data.type === "vcf" || firstResolvedSpec.data.type === "gff" || firstResolvedSpec.data.type === "bed")) {
      const getFieldName = (c) => {
        const cDef = firstResolvedSpec[c];
        return cDef && IsChannelDeep(cDef) ? cDef.field : void 0;
      };
      const xFields = {
        x: getFieldName("x"),
        xe: getFieldName("xe"),
        x1: getFieldName("x1"),
        x1e: getFieldName("x1e")
      };
      const urlFetchOptions = "url" in firstResolvedSpec.data && (urlToFetchOptions == null ? void 0 : urlToFetchOptions[firstResolvedSpec.data.url]) || {};
      const indexUrlFetchOptions = "indexUrl" in firstResolvedSpec.data && (urlToFetchOptions == null ? void 0 : urlToFetchOptions[firstResolvedSpec.data.indexUrl]) || {};
      hgTrack.data = {
        ...firstResolvedSpec.data,
        ...xFields,
        urlFetchOptions,
        indexUrlFetchOptions,
        // Additionally, add assembly, otherwise, a default genome build is used
        assembly
        // TODO: should look all sub tracks' `dataTransform` and apply OR operation.
        // Add a data transformation spec so that the fetcher can properly sample datasets
        // filter: (firstResolvedSpec as any).dataTransform?.filter((f: DataTransform) => f.type === 'filter')
      };
    }
    if (IsHiGlassMatrix(firstResolvedSpec)) {
      hgTrack.type = "heatmap";
      const colorStr = IsChannelDeep(firstResolvedSpec.color) && typeof firstResolvedSpec.color.range === "string" ? firstResolvedSpec.color.range : "viridis";
      hgTrack.options.colorRange = getHiGlassColorRange(colorStr);
      hgTrack.options.trackBorderWidth = (_c = (_b = firstResolvedSpec.style) == null ? void 0 : _b.outlineWidth) != null ? _c : theme.track.outlineWidth;
      hgTrack.options.trackBorderColor = (_e = (_d = firstResolvedSpec.style) == null ? void 0 : _d.outline) != null ? _e : theme.track.outline;
      hgTrack.options.extent = (_g = (_f = firstResolvedSpec.style) == null ? void 0 : _f.matrixExtent) != null ? _g : "full";
      hgTrack.options.colorbarPosition = ((_h = firstResolvedSpec.color) == null ? void 0 : _h.legend) ? hgTrack.options.extent === "lower-left" ? "bottomLeft" : "topRight" : "hidden";
    }
    if (firstResolvedSpec.overlayOnPreviousTrack) {
      hgModel.setViewOrientation(firstResolvedSpec.orientation).addTrackToCombined(hgTrack);
    } else {
      hgModel.setViewOrientation(firstResolvedSpec.orientation).setAssembly(assembly).addDefaultView(trackId, assembly).setDomain(xDomain, yDomain != null ? yDomain : xDomain).adjustDomain(firstResolvedSpec.orientation, width, height).setMainTrack(hgTrack).addTrackSourceServers(server).setZoomFixed(firstResolvedSpec.static === true).setZoomLimits((_i = firstResolvedSpec.zoomLimits) != null ? _i : [1, null]).setLayout(layout);
    }
    const getAxisNarrowType = (c, orientation = "horizontal", width2, height2) => {
      const narrowSizeThreshold = 400;
      const narrowerSizeThreshold = 200;
      if (orientation === "horizontal") {
        if (c === "x" && width2 <= narrowerSizeThreshold || c === "y" && height2 <= narrowerSizeThreshold) {
          return "narrower";
        } else if (c === "x" && width2 <= narrowSizeThreshold || c === "y" && height2 <= narrowSizeThreshold) {
          return "narrow";
        } else {
          return "regular";
        }
      } else {
        if (c === "x" && height2 <= narrowerSizeThreshold || c === "y" && width2 <= narrowerSizeThreshold) {
          return "narrower";
        } else if (c === "x" && height2 <= narrowSizeThreshold || c === "y" && width2 <= narrowSizeThreshold) {
          return "narrow";
        } else {
          return "regular";
        }
      }
    };
    ["x", "y"].forEach((c) => {
      const channel = firstResolvedSpec[c];
      if (IsChannelDeep(channel) && "axis" in channel && channel.axis && channel.axis !== "none" && channel.type === "genomic") {
        const narrowType = getAxisNarrowType(c, gosTrack.orientation, bb.width, bb.height);
        hgModel.setAxisTrack(channel.axis, narrowType, {
          id: `${trackId}-${channel.axis}-axis`,
          layout: firstResolvedSpec.layout,
          innerRadius: channel.axis === "top" ? firstResolvedSpec.outerRadius - HIGLASS_AXIS_SIZE : firstResolvedSpec.innerRadius,
          outerRadius: channel.axis === "top" ? firstResolvedSpec.outerRadius : firstResolvedSpec.innerRadius + HIGLASS_AXIS_SIZE,
          width: firstResolvedSpec.width,
          height: firstResolvedSpec.height,
          startAngle: firstResolvedSpec.startAngle,
          endAngle: firstResolvedSpec.endAngle,
          theme
        });
      }
    });
    hgModel.validateSpec(true);
  } else if (firstResolvedSpec.mark === "header") {
    hgModel.addDefaultView(`${trackId}-title`).setLayout(layout);
    if (typeof firstResolvedSpec.title === "string") {
      hgModel.setTextTrack(
        bb.width,
        ((_j = theme.root.titleFontSize) != null ? _j : 18) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM,
        firstResolvedSpec.title,
        theme.root.titleColor,
        (_k = theme.root.titleFontSize) != null ? _k : 18,
        theme.root.titleFontWeight,
        theme.root.titleAlign,
        theme.root.titleBackgroundColor,
        (_l = theme.root.titleFontFamily) != null ? _l : DEFAULT_TEXT_STYLE.fontFamily
      );
    }
    if (typeof firstResolvedSpec.subtitle === "string") {
      hgModel.setTextTrack(
        bb.width,
        // TODO: better way to safely get the value when undefined?
        ((_m = theme.root.subtitleFontSize) != null ? _m : 14) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM,
        firstResolvedSpec.subtitle,
        theme.root.subtitleColor,
        (_n = theme.root.subtitleFontSize) != null ? _n : 14,
        theme.root.subtitleFontWeight,
        theme.root.subtitleAlign,
        theme.root.subtitleBackgroundColor,
        (_o = theme.root.subtitleFontFamily) != null ? _o : DEFAULT_TEXT_STYLE.fontFamily
      );
    }
  }
  return hgModel;
}
function getLinkingInfo(hgModel) {
  const linkingInfo = [];
  hgModel.spec().views.forEach((v) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const hgViewId = v.uid;
    let spec = (
      /* TODO: */
      (_e = (_d = (_c = (_b = (_a = v.tracks.center) == null ? void 0 : _a[0]) == null ? void 0 : _b.contents) == null ? void 0 : _c[0]) == null ? void 0 : _d.options) == null ? void 0 : _e.spec
    );
    if (!spec) {
      spec = /* TODO: */
      (_j = (_i = (_h = (_g = (_f = v.tracks.left) == null ? void 0 : _f[0]) == null ? void 0 : _g.contents) == null ? void 0 : _h[0]) == null ? void 0 : _i.options) == null ? void 0 : _j.spec;
      if (!spec) {
        spec = /* TODO: */
        (_o = (_n = (_m = (_l = (_k = v.tracks.left) == null ? void 0 : _k[1]) == null ? void 0 : _l.contents) == null ? void 0 : _m[0]) == null ? void 0 : _n.options) == null ? void 0 : _o.spec;
      }
    }
    if (!hgViewId || !spec)
      return;
    const resolved = resolveSuperposedTracks(spec);
    resolved.forEach((spec2) => {
      SUPPORTED_CHANNELS.forEach((cKey) => {
        var _a2, _b2, _c2, _d2;
        const channel = spec2[cKey];
        if (IsChannelDeep(channel) && "linkingId" in channel && channel.linkingId) {
          linkingInfo.push({
            layout: spec2.layout === "circular" ? "circular" : "linear",
            hgViewId,
            linkId: channel.linkingId,
            isBrush: spec2.mark === "brush",
            style: {
              color: (_a2 = spec2.color) == null ? void 0 : _a2.value,
              stroke: (_b2 = spec2.stroke) == null ? void 0 : _b2.value,
              strokeWidth: (_c2 = spec2.strokeWidth) == null ? void 0 : _c2.value,
              opacity: (_d2 = spec2.opacity) == null ? void 0 : _d2.value,
              startAngle: spec2.startAngle,
              endAngle: spec2.endAngle,
              innerRadius: spec2.innerRadius,
              outerRadius: spec2.outerRadius
            }
          });
          return;
        }
      });
    });
  });
  return linkingInfo;
}
class GoslingToHiGlassIdMapper {
  constructor() {
    /** A mapping table between Gosling track IDs to HiGlass view IDs */
    __privateAdd(this, _table, {});
  }
  addMapping(gtId, hvId) {
    if (__privateGet(this, _table)[gtId] && __privateGet(this, _table)[gtId] !== hvId) {
      console.warn(`The track ID ${gtId} already exists but overwriting with a different ID.`);
    }
    __privateGet(this, _table)[gtId] = hvId;
  }
  getTable() {
    return __privateGet(this, _table);
  }
  getGoslingIds() {
    return Object.keys(__privateGet(this, _table));
  }
  getHiGlassId(gtId) {
    return __privateGet(this, _table)[gtId];
  }
  /**
   * Get IDs of Gosling tracks that became the same HiGlass view.
   * @param HiGlassId
   * @returns
   */
  getSiblingGoslingIds(HiGlassId) {
    return Object.entries(__privateGet(this, _table)).filter(([, hvId]) => hvId === HiGlassId).map(([gtId]) => gtId);
  }
}
_table = new WeakMap();
function getViewIds(spec) {
  const viewIds = /* @__PURE__ */ new Set();
  if (spec.id) {
    viewIds.add(spec.id);
  }
  traverseTracksAndViews(spec, (subSpec) => {
    if ("views" in subSpec || "tracks" in subSpec) {
      if (subSpec.id) {
        viewIds.add(subSpec.id);
      }
    }
  });
  return Array.from(viewIds);
}
function getTrackIds(spec) {
  const trackIds = /* @__PURE__ */ new Set();
  traverseTracksAndViews(spec, (subSpec) => {
    if (!("views" in subSpec) && !("tracks" in subSpec)) {
      if (subSpec.id) {
        trackIds.add(subSpec.id);
      }
    }
  });
  return Array.from(trackIds);
}
function getInternalSpecById(spec, id) {
  let internalSpec;
  if (spec.id === id) {
    internalSpec = spec;
  }
  traverseTracksAndViews(spec, (subSpec) => {
    if (subSpec.id === id) {
      internalSpec = subSpec;
    }
  });
  return internalSpec;
}
function getViewApiData(spec, tracks) {
  return getViewIds(spec).map((viewId) => {
    const internalSpec = getInternalSpecById(spec, viewId);
    const trackIds = getTrackIds(internalSpec);
    const bb = {
      x: Number.MAX_SAFE_INTEGER,
      y: Number.MAX_SAFE_INTEGER,
      xe: -Number.MAX_SAFE_INTEGER,
      ye: -Number.MAX_SAFE_INTEGER
    };
    trackIds.map((trackId) => tracks.find((t) => t.id === trackId)).forEach((track) => {
      if (!track)
        return;
      const { shape } = track;
      if (bb.x > shape.x) {
        bb.x = shape.x;
      }
      if (bb.y > shape.y) {
        bb.y = shape.y;
      }
      if (bb.xe < shape.x + shape.width) {
        bb.xe = shape.x + shape.width;
      }
      if (bb.ye < shape.y + shape.height) {
        bb.ye = shape.y + shape.height;
      }
    });
    return {
      id: viewId,
      spec: internalSpec,
      shape: { ...bb, width: bb.xe - bb.x, height: bb.ye - bb.y }
    };
  });
}
function renderHiGlass(spec, trackInfos, callback, theme, urlToFetchOptions) {
  if (trackInfos.length === 0) {
    return;
  }
  const hgModel = new HiGlassModel();
  const idMapper = new GoslingToHiGlassIdMapper();
  trackInfos.forEach((tb) => {
    const { track, boundingBox: bb, layout } = tb;
    goslingToHiGlass(hgModel, track, bb, layout, theme, idMapper, urlToFetchOptions);
  });
  const linkingInfos = getLinkingInfo(hgModel);
  linkingInfos.filter((d) => d.isBrush).forEach((info) => {
    var _a;
    hgModel.addBrush(
      info.layout,
      info.hgViewId,
      theme,
      (_a = linkingInfos.find((d) => !d.isBrush && d.linkId === info.linkId)) == null ? void 0 : _a.hgViewId,
      info.style
    );
  });
  linkingInfos.filter((d) => !d.isBrush).forEach((d) => {
    hgModel.spec().zoomLocks.locksByViewUid[d.hgViewId] = d.linkId;
    hgModel.spec().locationLocks.locksByViewUid[d.hgViewId] = d.linkId;
  });
  const uniqueLinkIds = Array.from(new Set(linkingInfos.map((d) => d.linkId)));
  uniqueLinkIds.forEach((linkId) => {
    hgModel.spec().zoomLocks.locksDict[linkId] = { uid: linkId };
    hgModel.spec().locationLocks.locksDict[linkId] = { uid: linkId };
    linkingInfos.filter((d) => !d.isBrush).filter((d) => d.linkId === linkId).forEach((d) => {
      hgModel.spec().zoomLocks.locksDict[linkId][d.hgViewId] = [1246253105e-1, 1246253105e-1, 249250.621];
      hgModel.spec().locationLocks.locksDict[linkId][d.hgViewId] = [1246253105e-1, 1246253105e-1, 249250.621];
    });
  });
  const tracks = trackInfos.map((d) => {
    return {
      id: d.track.id,
      spec: d.track,
      shape: d.track.layout === "linear" || IsDummyTrack(d.track) ? d.boundingBox : {
        ...d.boundingBox,
        cx: d.boundingBox.x + d.boundingBox.width / 2,
        cy: d.boundingBox.y + d.boundingBox.height / 2,
        innerRadius: d.track.innerRadius,
        outerRadius: d.track.outerRadius,
        startAngle: d.track.startAngle,
        endAngle: d.track.endAngle
      }
    };
  });
  const views = getViewApiData(spec, tracks);
  const tracksAndViews = [
    ...tracks.map((d) => ({ ...d, type: "track" })),
    ...views.map((d) => ({ ...d, type: "view" }))
  ];
  callback(hgModel.spec(), getBoundingBox(trackInfos), spec, tracksAndViews, idMapper.getTable());
}
function manageResponsiveSpecs(spec, wFactor, hFactor, parentWidth, parentHeight) {
  if (typeof spec._assignedWidth === "undefined" || typeof spec._assignedHeight === "undefined") {
    console.warn("Responsive spec cannot be used when width and height of a view is not determined yet.");
    return false;
  }
  let replaced = false;
  const { responsiveSpec } = spec;
  const width = spec._assignedWidth * wFactor;
  const height = spec._assignedHeight * hFactor;
  const dimensions = { width, height, aspectRatio: width / height };
  const parentDimensions = { width: parentWidth, height: parentHeight, aspectRatio: parentWidth / parentHeight };
  if (responsiveSpec) {
    responsiveSpec.forEach((specAndCondition) => {
      const { spec: alternativeSpec, selectivity } = specAndCondition;
      if (isSelectResponsiveSpec(selectivity, dimensions, parentDimensions) && !replaced) {
        Object.keys(alternativeSpec).forEach((k) => {
          spec[k] = alternativeSpec[k];
        });
        delete spec.responsiveSpec;
        replaced = true;
        return;
      }
    });
  }
  if ("views" in spec) {
    spec.views.forEach((view) => {
      replaced = manageResponsiveSpecs(view, wFactor, hFactor, parentWidth, parentHeight) || replaced;
    });
  }
  return replaced;
}
function isSelectResponsiveSpec(conditions, assignedDimensions, parentDimensions) {
  if (conditions.length === 0)
    return false;
  let isSelect = true;
  conditions.forEach((condition) => {
    const { measure, operation, threshold, target } = condition;
    isSelect = isSelect && logicalComparison(
      (target === "container" ? parentDimensions : assignedDimensions)[measure],
      operation,
      threshold
    ) === 1;
  });
  return isSelect;
}
function compile(spec, callback, templates, theme, containerStatus, urlToFetchOptions) {
  var _a, _b;
  const specCopy = JSON.parse(JSON.stringify(spec));
  overrideDataTemplates(specCopy);
  replaceTrackTemplates(specCopy, templates);
  traverseToFixSpecDownstream(specCopy);
  const trackInfosAndSize = getRelativeTrackInfo(specCopy, theme);
  let { trackInfos } = trackInfosAndSize;
  const { size } = trackInfosAndSize;
  const isResponsiveWidth = typeof spec.responsiveSize === "object" && ((_a = spec.responsiveSize) == null ? void 0 : _a.width) || spec.responsiveSize;
  const isResponsiveHeight = typeof spec.responsiveSize === "object" && ((_b = spec.responsiveSize) == null ? void 0 : _b.height) || spec.responsiveSize;
  const wFactor = isResponsiveWidth && containerStatus.containerSize ? containerStatus.containerSize.width / size.width : 1;
  const hFactor = isResponsiveHeight && containerStatus.containerSize ? containerStatus.containerSize.height / size.height : 1;
  const pWidth = containerStatus.containerParentSize ? containerStatus.containerParentSize.width : Number.MAX_SAFE_INTEGER;
  const pHeight = containerStatus.containerParentSize ? containerStatus.containerParentSize.height : Number.MAX_SAFE_INTEGER;
  const replaced = manageResponsiveSpecs(specCopy, wFactor, hFactor, pWidth, pHeight);
  if (replaced) {
    traverseToFixSpecDownstream(specCopy);
    trackInfos = getRelativeTrackInfo(specCopy, theme).trackInfos;
  }
  publish("specProcessed", {
    id: specCopy.id,
    spec: specCopy
  });
  renderHiGlass(specCopy, trackInfos, callback, theme, urlToFetchOptions);
}
init();
const HiGlassComponentWrapper = forwardRef(
  (props, ref2) => {
    var _a;
    const [wrapperDivId, setWrapperDivId] = useState((_a = props.id) != null ? _a : uuid());
    useEffect(() => {
      var _a2;
      setWrapperDivId((_a2 = props.id) != null ? _a2 : uuid());
    }, [props.id]);
    const viewConfig = props.viewConfig || {};
    const pixelPreciseMarginPadding = false;
    const higlassComponent = useMemo(
      () => /* @__PURE__ */ React.createElement(
        HiGlassComponent,
        {
          ref: ref2,
          options: {
            // This uses `rowHeight: 1` in react-grid-layout, allowing to set height precisely.
            // Since using this disallows responsive resizing of track heights in HiGlass,
            // we need to use this only when users do not want to use responsive height.
            // (See https://github.com/higlass/higlass/blob/2a3786e13c2415a52abc1227f75512f128e784a0/app/scripts/HiGlassComponent.js#L2199)
            pixelPreciseMarginPadding,
            containerPaddingX: 0,
            containerPaddingY: 0,
            viewMarginTop: 0,
            viewMarginBottom: 0,
            viewMarginLeft: 0,
            viewMarginRight: 0,
            viewPaddingTop: 0,
            viewPaddingBottom: 0,
            viewPaddingLeft: 0,
            viewPaddingRight: 0,
            sizeMode: "bounded",
            rangeSelectionOnAlt: true
            // this allows switching between `selection` and `zoom&pan` mode
          },
          viewConfig
        }
      ),
      [viewConfig, pixelPreciseMarginPadding]
    );
    const {
      padding = 60,
      margin = 0,
      border = "none",
      background,
      alt = "Gosling visualization"
    } = props.options || {};
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        id: wrapperDivId,
        className: `gosling-component ${props.className || ""}`,
        style: {
          position: "relative",
          padding,
          margin,
          border,
          background,
          width: props.options.responsiveWidth ? `calc(100% - ${padding * 2}px)` : props.size.width,
          height: props.options.responsiveHeight ? `calc(100% - ${padding * 2}px)` : props.size.height,
          textAlign: "left"
        },
        "aria-label": alt,
        role: "graphics-document",
        "aria-roledescription": "visualization"
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          key: JSON.stringify(viewConfig),
          id: "higlass-wrapper",
          className: "higlass-wrapper",
          style: {
            position: "relative",
            display: "block",
            background,
            margin: 0,
            padding: 0,
            // non-zero padding acts unexpectedly w/ HiGlassComponent
            width: props.options.responsiveWidth ? "100%" : props.size.width,
            height: props.options.responsiveHeight ? "100%" : props.size.height
          }
        },
        higlassComponent
      )
    ));
  }
);
HiGlassComponentWrapper.displayName = "HiGlassComponentWrapper";
function createApi(hg, hgSpec, tracksAndViews, theme, idTable) {
  const idTableCopy = structuredClone(idTable);
  const getHgViewId = (trackId) => {
    const viewId = idTableCopy[trackId];
    if (!viewId) {
      console.warn(`Unable to find the track ID, named ${trackId}.`);
    }
    return viewId != null ? viewId : trackId;
  };
  const getTrackIds2 = () => {
    return Object.keys(idTableCopy);
  };
  const getTracksAndViews = () => {
    return [...tracksAndViews];
  };
  const getTracks = () => {
    return [...getTracksAndViews().filter((d) => d.type === "track")];
  };
  const getTrack = (trackId) => {
    const trackInfoFound = getTracks().find((d) => d.id === trackId);
    if (!trackInfoFound) {
      console.warn(`[getTrack()] Unable to find a track using the ID (${trackId})`);
    }
    return trackInfoFound;
  };
  const getViews = () => {
    return [...getTracksAndViews().filter((d) => d.type === "view")];
  };
  const getView = (viewId) => {
    const view = getViews().find((d) => d.id === viewId);
    if (!view) {
      console.warn(`Unable to find a view with the ID of ${viewId}`);
    }
    return view;
  };
  const getCanvas = (options) => {
    var _a, _b;
    const resolution = (_a = options == null ? void 0 : options.resolution) != null ? _a : 4;
    const transparentBackground = (_b = options == null ? void 0 : options.transparentBackground) != null ? _b : false;
    const renderer = hg.pixiRenderer;
    const renderTexture = PIXI.RenderTexture.create({
      width: renderer.width / 2,
      height: renderer.height / 2,
      resolution
    });
    renderer.render(hg.pixiStage, renderTexture);
    const canvas = renderer.plugins.extract.canvas(renderTexture);
    const canvasWithBg = document.createElement("canvas");
    canvasWithBg.width = canvas.width;
    canvasWithBg.height = canvas.height;
    const ctx = canvasWithBg.getContext("2d");
    if (!transparentBackground) {
      ctx.fillStyle = theme.root.background;
      ctx.fillRect(0, 0, canvasWithBg.width, canvasWithBg.height);
    }
    ctx.drawImage(canvas, 0, 0);
    return {
      canvas: canvasWithBg,
      resolution,
      canvasWidth: canvas.width,
      canvasHeight: canvas.height
    };
  };
  return {
    subscribe,
    unsubscribe,
    zoomTo: (trackId, position, padding = 0, duration = 1e3) => {
      var _a;
      const assembly = (_a = getTrack(trackId)) == null ? void 0 : _a.spec.assembly;
      const manager = GenomicPositionHelper.fromString(position);
      const absCoordinates = manager.toAbsoluteCoordinates(assembly, padding);
      const hgViewId = getHgViewId(trackId);
      hg.api.zoomTo(hgViewId, ...absCoordinates, ...absCoordinates, duration);
    },
    zoomToExtent: (trackId, duration = 1e3) => {
      var _a;
      const assembly = (_a = getTrack(trackId)) == null ? void 0 : _a.spec.assembly;
      const [start, end] = [0, computeChromSizes(assembly).total];
      const hgViewId = getHgViewId(trackId);
      hg.api.zoomTo(hgViewId, start, end, start, end, duration);
    },
    zoomToGene: (trackId, gene, padding = 0, duration = 1e3) => {
      const hgViewId = getHgViewId(trackId);
      hg.api.zoomToGene(hgViewId, gene, padding, duration);
    },
    suggestGene: (trackId, keyword2, callback) => {
      const hgViewId = getHgViewId(trackId);
      hg.api.suggestGene(hgViewId, keyword2, callback);
    },
    getTrackIds: getTrackIds2,
    getTracksAndViews,
    getTracks,
    getTrack,
    getView,
    getViews,
    getCanvas,
    exportPng: (transparentBackground) => {
      const { canvas } = getCanvas({ resolution: 4, transparentBackground });
      canvas.toBlob((blob2) => {
        const a = document.createElement("a");
        document.body.append(a);
        a.download = "gosling-visualization";
        a.href = URL.createObjectURL(blob2);
        a.click();
        a.remove();
      }, "image/png");
    },
    exportPdf: async (transparentBackground) => {
      const { jsPDF } = await import("jspdf");
      const { canvas } = getCanvas({ resolution: 4, transparentBackground });
      const imgData = canvas.toDataURL("image/jpeg", 1);
      const pdf = new jsPDF({
        orientation: canvas.width < canvas.height ? "p" : "l",
        unit: "pt",
        format: [canvas.width, canvas.height]
      });
      pdf.addImage(imgData, "JPEG", 0, 0, canvas.width, canvas.height);
      pdf.save("gosling-visualization.pdf");
    }
  };
}
function omitDeep(spec, omitKeys) {
  return cloneDeepWith(spec, (value) => {
    if (isObject(value)) {
      omitKeys.forEach((key) => {
        delete value[key];
      });
    }
  });
}
const preverseZoomStatus = (newSpec, prevSpec) => {
  newSpec.views.forEach((view) => {
    var _a, _b, _c;
    const viewUid = view.uid;
    const isNewView = !prevSpec.views.find((v) => v.uid === viewUid);
    if (isNewView) {
      const { locksByViewUid } = newSpec.zoomLocks;
      const lockUid = locksByViewUid[viewUid];
      const linkedViewUid = (_a = Object.entries(locksByViewUid).find(([_, uid]) => _ && uid === lockUid)) == null ? void 0 : _a[0];
      const linkedViewExistedPrev = !!prevSpec.views.find((v) => v.uid === linkedViewUid);
      if (linkedViewUid && linkedViewExistedPrev) {
        view.initialXDomain = (_b = prevSpec.views.find((v) => v.uid === linkedViewUid)) == null ? void 0 : _b.initialXDomain;
        view.initialYDomain = (_c = prevSpec.views.find((v) => v.uid === linkedViewUid)) == null ? void 0 : _c.initialYDomain;
      }
    }
  });
};
const DELAY_FOR_CONTAINER_RESIZE_BEFORE_RERENDER = 300;
const GoslingComponent = forwardRef((props, ref2) => {
  var _a, _b, _c;
  const [viewConfig, setViewConfig] = useState();
  const [size, setSize] = useState({ width: 200, height: 200 });
  const wrapperSize = useRef();
  const wrapperParentSize = useRef();
  const prevSpec = useRef();
  const tracksAndViews = useRef([]);
  const idTable = useRef({});
  const hgRef = useRef(null);
  const theme = getTheme(props.theme || "light");
  const wrapperDivId = (_a = props.id) != null ? _a : uuid();
  const publishOnNewView = (currentTracksAndViews) => {
    const prevViews = tracksAndViews.current.filter((data2) => data2.type == "view");
    const currentViews = currentTracksAndViews.filter((data2) => data2.type == "view");
    const prevViewIds = new Set(prevViews.map((data2) => data2.id));
    const newViews = currentViews.filter((view) => !prevViewIds.has(view.id));
    newViews.forEach((view) => {
      publish("onNewView", { id: view.id });
    });
  };
  useImperativeHandle(
    ref2,
    () => {
      const hgApi = refAsReadonlyProxy(hgRef);
      const visUnits = refAsReadonlyProxy(tracksAndViews);
      const api = createApi(hgApi, viewConfig, visUnits, theme, idTable.current);
      return { api, hgApi };
    },
    [viewConfig, theme]
  );
  const compile$12 = useCallback(() => {
    if (props.spec) {
      const valid = validateGoslingSpec(props.spec);
      if (valid.state === "error") {
        console.warn("Gosling spec is not valid. Please refer to the console message.");
        return;
      }
      compile(
        props.spec,
        (newHiGlassSpec, newSize, newGoslingSpec, newTracksAndViews, newIdTable) => {
          var _a2, _b2;
          if (prevSpec.current && isEqual(omitDeep(prevSpec.current, ["linkingId"]), omitDeep(newGoslingSpec, ["linkingId"]))) {
            return;
          }
          (_a2 = props.compiled) == null ? void 0 : _a2.call(props, props.spec, newHiGlassSpec);
          setSize(newSize);
          const isMountedOnce = typeof viewConfig !== "undefined";
          if (((_b2 = props.experimental) == null ? void 0 : _b2.reactive) && isMountedOnce) {
            setTimeout(() => {
              var _a3, _b3;
              preverseZoomStatus(
                newHiGlassSpec,
                (_a3 = hgRef.current) == null ? void 0 : _a3.api.getViewConfig()
              );
              (_b3 = hgRef.current) == null ? void 0 : _b3.api.setViewConfig(newHiGlassSpec);
            }, DELAY_FOR_CONTAINER_RESIZE_BEFORE_RERENDER);
          } else {
            setViewConfig(newHiGlassSpec);
          }
          publishOnNewView(newTracksAndViews);
          prevSpec.current = newGoslingSpec;
          tracksAndViews.current = newTracksAndViews;
          idTable.current = newIdTable;
        },
        [...GoslingTemplates],
        // TODO: allow user definitions
        theme,
        {
          containerSize: wrapperSize.current,
          containerParentSize: wrapperParentSize.current
        },
        props.urlToFetchOptions
      );
    }
  }, [props.spec, theme]);
  useEffect(() => {
    var _a2;
    if (!((_a2 = props.spec) == null ? void 0 : _a2.responsiveSize))
      return;
    const containerElement = document.getElementById(wrapperDivId);
    if (!containerElement)
      return;
    const resizer = new ResizeSensor(containerElement, (newSize) => {
      if (!wrapperSize.current || wrapperSize.current.height !== newSize.height || wrapperSize.current.width !== newSize.width) {
        wrapperSize.current = newSize;
        compile$12();
      }
    });
    const parentElement = containerElement.parentElement;
    if (!parentElement)
      return;
    const parentResizer = new ResizeSensor(parentElement, (newSize) => {
      if (!wrapperParentSize.current || wrapperParentSize.current.height !== newSize.height || wrapperParentSize.current.width !== newSize.width) {
        wrapperParentSize.current = newSize;
        compile$12();
      }
    });
    return () => {
      resizer.detach();
      parentResizer.detach();
    };
  });
  useEffect(() => {
    compile$12();
  }, [props.spec, theme]);
  const responsiveHeight = typeof ((_b = props.spec) == null ? void 0 : _b.responsiveSize) !== "object" ? (_c = props.spec) == null ? void 0 : _c.responsiveSize : props.spec.responsiveSize.height;
  const higlassComponent = useMemo(
    () => {
      var _a2, _b2, _c2;
      return /* @__PURE__ */ React.createElement(
        HiGlassComponentWrapper,
        {
          ref: hgRef,
          viewConfig,
          size,
          id: wrapperDivId,
          className: props.className,
          options: {
            padding: props.padding,
            border: props.border,
            margin: props.margin,
            responsiveWidth: typeof ((_a2 = props.spec) == null ? void 0 : _a2.responsiveSize) !== "object" ? (_b2 = props.spec) == null ? void 0 : _b2.responsiveSize : props.spec.responsiveSize.width,
            responsiveHeight,
            background: theme.root.background,
            alt: (_c2 = props.spec) == null ? void 0 : _c2.description
          }
        }
      );
    },
    [viewConfig, size, theme, responsiveHeight]
  );
  return higlassComponent;
});
GoslingComponent.displayName = "GoslingComponent";
function refAsReadonlyProxy(ref2) {
  return new Proxy({}, {
    get(_target, prop, reciever) {
      if (!ref2.current)
        throw Error("ref is not set!");
      return Reflect.get(ref2.current, prop, reciever);
    }
  });
}
var createRoot;
var m = require$$0;
if (process.env.NODE_ENV === "production") {
  createRoot = m.createRoot;
  m.hydrateRoot;
} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(c, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}
const MAX_TRIES = 20;
const INTERVAL = 200;
const launchHiglass = (element, viewConfig, size, opts) => {
  const ref2 = React.createRef();
  const component = React.createElement(HiGlassComponentWrapper, {
    ref: ref2,
    viewConfig,
    size,
    id: opts.id,
    className: opts.className,
    options: opts
  });
  createRoot(element).render(component);
  return new Promise((resolve2, reject) => {
    let tries = 0;
    const poll = setInterval(() => {
      if (ref2 && ref2.current) {
        clearInterval(poll);
        resolve2(ref2.current);
      }
      if (tries >= MAX_TRIES) {
        reject(new Error("Failed to initialize HiGlassApi."));
      }
      tries++;
    }, INTERVAL);
  });
};
function embed(element, spec, opts = {}) {
  return new Promise((resolve2, reject) => {
    var _a, _b;
    const valid = validateGoslingSpec(spec);
    if (valid.state === "error") {
      reject(new Error("Gosling spec is not valid. Please refer to the console message."));
    }
    const theme = getTheme(opts.theme || "light");
    const options = {
      ...opts,
      background: theme.root.background,
      alt: (_b = (_a = opts.alt) != null ? _a : spec.description) != null ? _b : "Gosling visualization"
    };
    compile(
      spec,
      async (hsSpec, size, _, trackInfos, idTable) => {
        const hg = await launchHiglass(element, hsSpec, size, options);
        const api = createApi(hg, hsSpec, trackInfos, theme, idTable);
        resolve2(api);
      },
      [...GoslingTemplates],
      theme,
      {},
      // TODO: properly specify this
      opts.urlToFetchOptions
    );
  });
}
export {
  GoslingComponent,
  GoslingSchema,
  GoslingTemplates,
  theme_schema as ThemeSchema,
  compile,
  embed,
  init,
  name,
  validateGoslingSpec,
  version
};
//# sourceMappingURL=gosling.js.map
