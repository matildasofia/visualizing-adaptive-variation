var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import slugid from "slugid";
import EmptyDataFetcher from "./EmptyDataFetcher";

var TextTrack = function TextTrack(HGC) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }

  // Services
  var tileProxy = HGC.services.tileProxy;

  // Utils

  var colorToHex = HGC.utils.colorToHex;

  var TextTrackClass = function (_HGC$tracks$BedLikeTr) {
    _inherits(TextTrackClass, _HGC$tracks$BedLikeTr);

    function TextTrackClass(context, options) {
      _classCallCheck(this, TextTrackClass);

      context.dataFetcher = new EmptyDataFetcher(context.dataConfig);

      var _this = _possibleConstructorReturn(this, (TextTrackClass.__proto__ || Object.getPrototypeOf(TextTrackClass)).call(this, context, options));

      var animate = context.animate;

      _this.animate = animate;

      _this.isTrackShownVertically = context.definition.position === "left" || context.definition.position === "right";

      _this.options = options;
      _this.initOptions();
      return _this;
    }

    _createClass(TextTrackClass, [{
      key: "initTile",
      value: function initTile(tile) {}
    }, {
      key: "initOptions",
      value: function initOptions() {
        this.fontSize = +this.options.fontSize;

        this.colors = {};
        this.colors["textColor"] = colorToHex(this.options.textColor);
        this.colors["black"] = colorToHex("#000000");
        this.colors["white"] = colorToHex("#ffffff");
        this.colors["lightgrey"] = colorToHex("#ededed");

        this.text = this.options.text;

        this.textOptions = {
          fontSize: this.fontSize + "px",
          fontFamily: this.options.fontFamily,
          fontWeight: this.options.fontWeight,
          fill: this.colors["textColor"]
        };
      }
    }, {
      key: "drawTile",
      value: function drawTile() {}

      /*
       * Redraw the track because the options
       * changed
       */

    }, {
      key: "rerender",
      value: function rerender(options, force) {
        var strOptions = JSON.stringify(options);
        if (!force && strOptions === this.prevOptions) return;

        this.options = options;
        this.initOptions();

        this.prevOptions = strOptions;

        this.renderText();

        requestAnimationFrame(this.animate);
      }
    }, {
      key: "drawTile",
      value: function drawTile(tile) {}
    }, {
      key: "renderTile",
      value: function renderTile(tile) {}
    }, {
      key: "draw",
      value: function draw() {}
    }, {
      key: "renderText",
      value: function renderText() {
        this.pForeground.clear();
        this.pForeground.removeChildren();

        var text = new HGC.libraries.PIXI.Text(this.text, this.textOptions);
        text.interactive = true;
        text.anchor.x = 0;
        text.anchor.y = 0;
        text.visible = true;
        text.y = this.options.offsetY;

        var margin = 5;
        text.x = margin;

        if (!this.isTrackShownVertically) {
          if (this.options.align === "left") {
            text.anchor.x = 0;
            text.x = margin;
            this.svgAnchor = "start";
          } else if (this.options.align === "middle") {
            text.anchor.x = 0.5;
            text.x = this.dimensions[0] / 2;
            this.svgAnchor = "middle";
          } else if (this.options.align === "right") {
            text.anchor.x = 1;
            text.x = this.dimensions[0] - margin;
            this.svgAnchor = "end";
          }
        } else {
          if (this.options.align === "right") {
            text.anchor.x = 1;
            text.scale.x *= -1;
            this.svgAnchor = "end";
          } else if (this.options.align === "middle") {
            text.anchor.x = 0.5;
            text.scale.x *= -1;
            text.x = this.dimensions[0] / 2;
            this.svgAnchor = "middle";
          } else if (this.options.align === "left") {
            text.anchor.x = 0;
            text.scale.x *= -1;
            text.x = this.dimensions[0] - margin;
            this.svgAnchor = "start";
          }
        }

        this.svgX = text.x;

        this.pForeground.addChild(text);
      }
    }, {
      key: "zoomedY",
      value: function zoomedY(yPos, kMultiplier) {}
    }, {
      key: "movedY",
      value: function movedY(dY) {}

      /** cleanup */

    }, {
      key: "destroyTile",
      value: function destroyTile(tile) {
        tile.graphics.destroy();
        tile = null;
      }
    }, {
      key: "setDimensions",
      value: function setDimensions(newDimensions) {
        _get(TextTrackClass.prototype.__proto__ || Object.getPrototypeOf(TextTrackClass.prototype), "setDimensions", this).call(this, newDimensions);
        // We have to rerender here, otherwise it does not fire at all sometimes
        this.rerender(this.options, false);
      }
    }, {
      key: "getMouseOverHtml",
      value: function getMouseOverHtml(trackX, trackY) {}
    }, {
      key: "exportSVG",
      value: function exportSVG() {
        var track = null;
        var base = null;

        base = document.createElement("g");
        track = base;

        var clipPathId = slugid.nice();

        var gClipPath = document.createElement("g");
        gClipPath.setAttribute("style", "clip-path:url(#" + clipPathId + ");");

        track.appendChild(gClipPath);

        // define the clipping area as a polygon defined by the track's
        // dimensions on the canvas
        var clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
        clipPath.setAttribute("id", clipPathId);
        track.appendChild(clipPath);

        var clipPolygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        clipPath.appendChild(clipPolygon);

        clipPolygon.setAttribute("points", this.position[0] + "," + this.position[1] + " " + (this.position[0] + this.dimensions[0] + "," + this.position[1] + " ") + (this.position[0] + this.dimensions[0] + "," + (this.position[1] + this.dimensions[1]) + " ") + (this.position[0] + "," + (this.position[1] + this.dimensions[1]) + " "));

        var output = document.createElement("g");

        output.setAttribute("transform", "translate(" + this.position[0] + "," + this.position[1] + ")");

        gClipPath.appendChild(output);

        // Background
        var gBackground = document.createElement("g");
        var rBackground = document.createElement("path");
        var dBackground = "M 0 0 H " + this.dimensions[0] + " V " + this.dimensions[1] + " H 0 Z";
        rBackground.setAttribute("d", dBackground);
        rBackground.setAttribute("fill", this.options.backgroundColor);
        rBackground.setAttribute("opacity", "1");
        gBackground.appendChild(rBackground);
        output.appendChild(gBackground);

        // Text
        var gText = document.createElement("g");
        var t = document.createElement("text");
        t.setAttribute("text-anchor", this.svgAnchor);
        t.setAttribute("font-family", this.options.fontFamily);
        t.setAttribute("font-size", this.fontSize + "px");
        //t.setAttribute("alignment-baseline", "top");
        t.setAttribute("font-weight", this.options.fontWeight);

        gText.setAttribute("transform", "scale(1,1)");

        t.setAttribute("fill", this.options.textColor);
        t.innerHTML = this.options.text;

        var scalefactor = this.isTrackShownVertically ? -1 : 1;

        gText.appendChild(t);
        gText.setAttribute("transform", "translate(" + this.svgX + "," + (this.options.offsetY + this.fontSize) + ")scale(" + scalefactor + ",1)");
        output.appendChild(gText);

        return [base, base];
      }
    }]);

    return TextTrackClass;
  }(HGC.tracks.BedLikeTrack);

  return new (Function.prototype.bind.apply(TextTrackClass, [null].concat(args)))();
};

var icon = '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path fill="#fff" d="M-1-1h22v22H-1z"/><g><path stroke="#007fff" stroke-width="1.5" fill="#007fff" d="M-.667-.091h5v20.167h-5z"/><path stroke-width="1.5" stroke="#e8e500" fill="#e8e500" d="M5.667.242h5v20.167h-5z"/><path stroke-width="1.5" stroke="#ff0038" fill="#ff0038" d="M15.833.076h5v20.167h-5z"/><path stroke="green" stroke-width="1.5" fill="green" d="M10.833-.258H14.5v20.167h-3.667z"/></g></svg>';

// default
TextTrack.config = {
  type: "text",
  datatype: ["bedlike"],
  local: false,
  orientation: "1d-horizontal",
  thumbnail: new DOMParser().parseFromString(icon, "text/xml").documentElement,
  availableOptions: ["backgroundColor", "textColor", "fontSize", "fontWeight", "offsetY", "align", "text"],
  defaultOptions: {
    backgroundColor: "#ededed",
    textColor: "#333333",
    fontSize: 14,
    fontFamily: "Arial",
    fontWeight: "normal",
    align: "left",
    offsetY: 0,
    text: ""
  }
};

export default TextTrack;