"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const long_1 = __importDefault(require("long"));
const virtualOffset_1 = require("./virtualOffset");
const chunk_1 = __importDefault(require("./chunk"));
const indexFile_1 = __importDefault(require("./indexFile"));
const util_1 = require("./util");
const BAI_MAGIC = 21578050; // BAI\1
function roundDown(n, multiple) {
    return n - (n % multiple);
}
function roundUp(n, multiple) {
    return n - (n % multiple) + multiple;
}
class BAI extends indexFile_1.default {
    parsePseudoBin(bytes, offset) {
        const lineCount = (0, util_1.longToNumber)(long_1.default.fromBytesLE(Array.prototype.slice.call(bytes, offset + 16, offset + 24), true));
        return { lineCount };
    }
    lineCount(refId, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const prom = yield this.parse(opts);
            const index = prom.indices[refId];
            if (!index) {
                return -1;
            }
            const ret = index.stats || {};
            return ret.lineCount === undefined ? -1 : ret.lineCount;
        });
    }
    fetchBai(opts = {}) {
        if (!this.baiP) {
            this.baiP = this.filehandle.readFile(opts).catch(e => {
                this.baiP = undefined;
                throw e;
            });
        }
        return this.baiP;
    }
    // fetch and parse the index
    _parse() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = { bai: true, maxBlockSize: 1 << 16 };
            const bytes = yield this.fetchBai();
            // check BAI magic numbers
            if (bytes.readUInt32LE(0) !== BAI_MAGIC) {
                throw new Error('Not a BAI file');
            }
            data.refCount = bytes.readInt32LE(4);
            const depth = 5;
            const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7;
            // read the indexes for each reference sequence
            data.indices = new Array(data.refCount);
            let currOffset = 8;
            for (let i = 0; i < data.refCount; i += 1) {
                // the binning index
                const binCount = bytes.readInt32LE(currOffset);
                let stats;
                currOffset += 4;
                const binIndex = {};
                for (let j = 0; j < binCount; j += 1) {
                    const bin = bytes.readUInt32LE(currOffset);
                    currOffset += 4;
                    if (bin === binLimit + 1) {
                        currOffset += 4;
                        stats = this.parsePseudoBin(bytes, currOffset);
                        currOffset += 32;
                    }
                    else if (bin > binLimit + 1) {
                        throw new Error('bai index contains too many bins, please use CSI');
                    }
                    else {
                        const chunkCount = bytes.readInt32LE(currOffset);
                        currOffset += 4;
                        const chunks = new Array(chunkCount);
                        for (let k = 0; k < chunkCount; k += 1) {
                            const u = (0, virtualOffset_1.fromBytes)(bytes, currOffset);
                            const v = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 8);
                            currOffset += 16;
                            this._findFirstData(data, u);
                            chunks[k] = new chunk_1.default(u, v, bin);
                        }
                        binIndex[bin] = chunks;
                    }
                }
                const linearCount = bytes.readInt32LE(currOffset);
                currOffset += 4;
                // as we're going through the linear index, figure out
                // the smallest virtual offset in the indexes, which
                // tells us where the BAM header ends
                const linearIndex = new Array(linearCount);
                for (let k = 0; k < linearCount; k += 1) {
                    linearIndex[k] = (0, virtualOffset_1.fromBytes)(bytes, currOffset);
                    currOffset += 8;
                    this._findFirstData(data, linearIndex[k]);
                }
                data.indices[i] = { binIndex, linearIndex, stats };
            }
            return data;
        });
    }
    indexCov(seqId, start, end, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const v = 16384;
            const range = start !== undefined;
            const indexData = yield this.parse(opts);
            const seqIdx = indexData.indices[seqId];
            if (!seqIdx) {
                return [];
            }
            const { linearIndex = [], stats } = seqIdx;
            if (!linearIndex.length) {
                return [];
            }
            const e = end !== undefined ? roundUp(end, v) : (linearIndex.length - 1) * v;
            const s = start !== undefined ? roundDown(start, v) : 0;
            let depths;
            if (range) {
                depths = new Array((e - s) / v);
            }
            else {
                depths = new Array(linearIndex.length - 1);
            }
            const totalSize = linearIndex[linearIndex.length - 1].blockPosition;
            if (e > (linearIndex.length - 1) * v) {
                throw new Error('query outside of range of linear index');
            }
            let currentPos = linearIndex[s / v].blockPosition;
            for (let i = s / v, j = 0; i < e / v; i++, j++) {
                depths[j] = {
                    score: linearIndex[i + 1].blockPosition - currentPos,
                    start: i * v,
                    end: i * v + v,
                };
                currentPos = linearIndex[i + 1].blockPosition;
            }
            return depths.map(d => {
                return Object.assign(Object.assign({}, d), { score: (d.score * stats.lineCount) / totalSize });
            });
        });
    }
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     * @returns {Array[number]}
     */
    reg2bins(beg, end) {
        end -= 1;
        return [
            [0, 0],
            [1 + (beg >> 26), 1 + (end >> 26)],
            [9 + (beg >> 23), 9 + (end >> 23)],
            [73 + (beg >> 20), 73 + (end >> 20)],
            [585 + (beg >> 17), 585 + (end >> 17)],
            [4681 + (beg >> 14), 4681 + (end >> 14)],
        ];
    }
    blocksForRange(refId, min, max, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (min < 0) {
                min = 0;
            }
            const indexData = yield this.parse(opts);
            if (!indexData) {
                return [];
            }
            const ba = indexData.indices[refId];
            if (!ba) {
                return [];
            }
            // List of bin #s that overlap min, max
            const overlappingBins = this.reg2bins(min, max);
            const chunks = [];
            // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
            for (const [start, end] of overlappingBins) {
                for (let bin = start; bin <= end; bin++) {
                    if (ba.binIndex[bin]) {
                        const binChunks = ba.binIndex[bin];
                        for (let c = 0; c < binChunks.length; ++c) {
                            chunks.push(new chunk_1.default(binChunks[c].minv, binChunks[c].maxv, bin));
                        }
                    }
                }
            }
            // Use the linear index to find minimum file position of chunks that could
            // contain alignments in the region
            const nintv = ba.linearIndex.length;
            let lowest = null;
            const minLin = Math.min(min >> 14, nintv - 1);
            const maxLin = Math.min(max >> 14, nintv - 1);
            for (let i = minLin; i <= maxLin; ++i) {
                const vp = ba.linearIndex[i];
                if (vp) {
                    if (!lowest || vp.compareTo(lowest) < 0) {
                        lowest = vp;
                    }
                }
            }
            return (0, util_1.optimizeChunks)(chunks, lowest);
        });
    }
}
exports.default = BAI;
//# sourceMappingURL=bai.js.map